{
  "frontend-html": [
    {
      "id": "fe-1",
      "question": "Explain how the box model works in CSS.",
      "answer": [
        {
          "type": "text",
          "content": "The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model. Each box has a content area (e.g., text, an image, etc.) and optional surrounding padding, border, and margin areas."
        },
        {
          "type": "text",
          "content": "Components from inside to outside:"
        },
        {
          "type": "list",
          "items": [
            "**Content** - The actual content of the box where text and images appear",
            "**Padding** - Clears an area around the content (inside the box)",
            "**Border** - A border that goes around the padding and content",
            "**Margin** - Clears an area outside the border"
          ]
        },
        {
          "type": "text",
          "content": "The total width of an element is calculated as: width + left padding + right padding + left border + right border + left margin + right margin"
        },
        {
          "type": "text",
          "content": "In modern CSS, you can change how the box model works by setting the `box-sizing` property:"
        },
        {
          "type": "list",
          "items": [
            "`box-sizing: content-box` (default): Width and height only apply to the content area",
            "`box-sizing: border-box`: Width and height include content, padding, and border (but not margin)"
          ]
        }
      ]
    },
    {
      "id": "fe-2",
      "question": "What is the difference between 'let', 'const', and 'var' in JavaScript?",
      "answer": [
        {
          "type": "text",
          "content": "These three keywords are used for variable declarations in JavaScript but have different scoping rules and behaviors:"
        },
        {
          "type": "text",
          "content": "**var**:"
        },
        {
          "type": "list",
          "items": [
            "Function-scoped or globally-scoped, not block-scoped",
            "Can be redeclared and updated",
            "Hoisted to the top of its scope and initialized with `undefined`",
            "Can cause unexpected behavior in loops and conditional blocks"
          ]
        },
        {
          "type": "text",
          "content": "**let**:"
        },
        {
          "type": "list",
          "items": [
            "Block-scoped (available only within the block it's defined in)",
            "Can be updated but not redeclared in the same scope",
            "Hoisted but not initialized (in the \"temporal dead zone\" until declaration)",
            "Introduced in ES6 (ES2015)"
          ]
        },
        {
          "type": "text",
          "content": "**const**:"
        },
        {
          "type": "list",
          "items": [
            "Block-scoped like `let`",
            "Cannot be updated or redeclared",
            "Must be initialized at declaration",
            "For objects and arrays, the variable cannot be reassigned, but the properties/elements can be changed",
            "Hoisted but not initialized (in the \"temporal dead zone\" until declaration)",
            "Introduced in ES6 (ES2015)"
          ]
        }
      ]
    },
    {
      "id": "fe-3",
      "question": "Implement a debounce function in JavaScript.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Creates a debounced function that delays invoking the provided function\n * until after 'wait' milliseconds have elapsed since the last time it was invoked.\n * \n * @param {Function} func - The function to debounce\n * @param {number} wait - The number of milliseconds to delay\n * @return {Function} - The debounced function\n */\nfunction debounce(func, wait) {\n  let timeout;\n  \n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Example usage:\nconst handleSearch = debounce(function(event) {\n  console.log('Searching for:', event.target.value);\n  // API call or other expensive operation\n}, 500);\n\n// Attach to an input element\n// document.querySelector('input').addEventListener('input', handleSearch);"
      }
    }
  ],
  "backend": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": [
        {
          "type": "text",
          "content": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client."
        },
        {
          "type": "text",
          "content": "Key principles of RESTful API design:"
        },
        {
          "type": "list",
          "items": [
            "**Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.",
            "**Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.",
            "**Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.",
            "**Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)",
            "**Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.",
            "**Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code."
          ]
        },
        {
          "type": "text",
          "content": "RESTful APIs typically use HTTP methods explicitly:"
        },
        {
          "type": "list",
          "items": [
            "GET (retrieve a resource)",
            "POST (create a resource)",
            "PUT (update a resource)",
            "DELETE (remove a resource)",
            "PATCH (partial update)"
          ]
        },
        {
          "type": "text",
          "content": "And HTTP status codes to indicate success/failure."
        }
      ]
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": [
        {
          "type": "text",
          "content": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints."
        },
        {
          "type": "text",
          "content": "The main normal forms are:"
        },
        {
          "type": "text",
          "content": "**First Normal Form (1NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Each table cell should contain a single value",
            "Each record needs to be unique",
            "No repeating groups or arrays"
          ]
        },
        {
          "type": "text",
          "content": "**Second Normal Form (2NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 1NF",
            "All non-key attributes must depend on the entire primary key",
            "Eliminates partial dependencies"
          ]
        },
        {
          "type": "text",
          "content": "**Third Normal Form (3NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 2NF",
            "No transitive dependencies (non-key attributes depending on other non-key attributes)",
            "All fields must depend directly on the primary key"
          ]
        },
        {
          "type": "text",
          "content": "**Boyce-Codd Normal Form (BCNF)**:"
        },
        {
          "type": "list",
          "items": [
            "A stricter version of 3NF",
            "For any dependency A → B, A must be a super key",
            "Addresses certain anomalies not addressed by 3NF"
          ]
        },
        {
          "type": "text",
          "content": "**Fourth Normal Form (4NF)**:"
        },
        {
          "type": "list",
          "items": ["Must be in BCNF", "No multi-valued dependencies"]
        },
        {
          "type": "text",
          "content": "**Fifth Normal Form (5NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 4NF",
            "No join dependencies",
            "Every join dependency is implied by the candidate keys"
          ]
        },
        {
          "type": "text",
          "content": "Benefits of normalization include:"
        },
        {
          "type": "list",
          "items": [
            "Reducing data redundancy",
            "Improving data integrity",
            "Making the database more flexible",
            "Better database organization"
          ]
        },
        {
          "type": "text",
          "content": "However, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
        }
      ]
    }
  ],
  "backend-csharp": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": [
        {
          "type": "text",
          "content": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client."
        },
        {
          "type": "text",
          "content": "Key principles of RESTful API design:"
        },
        {
          "type": "list",
          "items": [
            "**Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.",
            "**Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.",
            "**Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.",
            "**Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)",
            "**Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.",
            "**Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code."
          ]
        },
        {
          "type": "text",
          "content": "RESTful APIs typically use HTTP methods explicitly:"
        },
        {
          "type": "list",
          "items": [
            "GET (retrieve a resource)",
            "POST (create a resource)",
            "PUT (update a resource)",
            "DELETE (remove a resource)",
            "PATCH (partial update)"
          ]
        },
        {
          "type": "text",
          "content": "And HTTP status codes to indicate success/failure."
        }
      ]
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": [
        {
          "type": "text",
          "content": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints."
        },
        {
          "type": "text",
          "content": "The main normal forms are:"
        },
        {
          "type": "text",
          "content": "**First Normal Form (1NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Each table cell should contain a single value",
            "Each record needs to be unique",
            "No repeating groups or arrays"
          ]
        },
        {
          "type": "text",
          "content": "**Second Normal Form (2NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 1NF",
            "All non-key attributes must depend on the entire primary key",
            "Eliminates partial dependencies"
          ]
        },
        {
          "type": "text",
          "content": "**Third Normal Form (3NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 2NF",
            "No transitive dependencies (non-key attributes depending on other non-key attributes)",
            "All fields must depend directly on the primary key"
          ]
        },
        {
          "type": "text",
          "content": "**Boyce-Codd Normal Form (BCNF)**:"
        },
        {
          "type": "list",
          "items": [
            "A stricter version of 3NF",
            "For any dependency A → B, A must be a super key",
            "Addresses certain anomalies not addressed by 3NF"
          ]
        },
        {
          "type": "text",
          "content": "**Fourth Normal Form (4NF)**:"
        },
        {
          "type": "list",
          "items": ["Must be in BCNF", "No multi-valued dependencies"]
        },
        {
          "type": "text",
          "content": "**Fifth Normal Form (5NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 4NF",
            "No join dependencies",
            "Every join dependency is implied by the candidate keys"
          ]
        },
        {
          "type": "text",
          "content": "Benefits of normalization include:"
        },
        {
          "type": "list",
          "items": [
            "Reducing data redundancy",
            "Improving data integrity",
            "Making the database more flexible",
            "Better database organization"
          ]
        },
        {
          "type": "text",
          "content": "However, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
        }
      ]
    }
  ],
  "backend-golang": [
    {
      "id": "be-3",
      "question": "How does garbage collection work in Golang compared to C#?",
      "answer": [
        {
          "type": "text",
          "content": "Garbage collection (GC) is the process of automatically reclaiming memory occupied by objects that are no longer in use. Both Golang and C# use garbage collection, but they have different approaches to it."
        },
        {
          "type": "text",
          "content": "**Garbage Collection in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses a **concurrent, non-blocking garbage collector** to minimize pause times and improve performance.",
            "It focuses on **low-latency** garbage collection to make it suitable for real-time applications.",
            "The GC runs in the background and works in **multiple small steps** to avoid stopping the entire application.",
            "It uses a **tri-color marking algorithm** that classifies objects as **white, gray, or black** to track object reachability efficiently.",
            "Since Go does not have manual memory management (like C or C++), developers rely on GC to handle memory cleanup automatically.",
            "Objects are automatically deallocated when they are no longer reachable."
          ]
        },
        {
          "type": "text",
          "content": "**Garbage Collection in C#:**"
        },
        {
          "type": "list",
          "items": [
            "C# uses a **generational garbage collector**, which divides objects into **three generations** (Gen 0, Gen 1, Gen 2).",
            "Objects that survive multiple collections move to higher generations (long-lived objects reside in Gen 2).",
            "The GC in C# is **managed by the Common Language Runtime (CLR)**, and developers can trigger collection using `GC.Collect()`, though it's usually not recommended.",
            "Uses a **mark-and-sweep algorithm** similar to Go but is optimized with generational heuristics.",
            "Supports **finalizers** (`~ClassName()`) for custom cleanup, but they should be used cautiously as they impact performance.",
            "Provides **manual memory management** via `IDisposable` and `using` statements for deterministic cleanup of resources (e.g., database connections, file streams)."
          ]
        },
        {
          "type": "text",
          "content": "**Key Differences:**"
        },
        {
          "type": "list",
          "items": [
            "Golang's GC is **designed for low-latency applications**, whereas C#'s GC is **optimized for long-running applications**.",
            "C# has a **generational garbage collector**, while Go uses a **concurrent, tri-color marking algorithm**.",
            "C# allows **manual memory management (IDisposable, `GC.Collect()`)**, while Go strictly relies on automatic GC.",
            "Golang's GC is optimized for **server-side performance**, whereas C#'s GC is highly optimized for **desktop, cloud, and enterprise applications**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, Golang focuses on minimizing pause times to improve concurrency, while C#'s generational GC optimizes memory management for different object lifetimes."
        }
      ]
    },
    {
      "id": "be-4",
      "question": "Discuss asynchronous programming in C# and Golang (async/await, goroutines).",
      "answer": [
        {
          "type": "text",
          "content": "Asynchronous programming allows tasks to run concurrently without blocking the main execution thread, improving performance and responsiveness. C# and Golang have different approaches to handling concurrency and asynchronous operations."
        },
        {
          "type": "text",
          "content": "**Asynchronous Programming in C# (async/await):**"
        },
        {
          "type": "list",
          "items": [
            "C# uses the **async/await** pattern to handle asynchronous operations.",
            "The `Task` and `Task<T>` types represent asynchronous operations that can run in the background.",
            "The `await` keyword allows code execution to pause and resume without blocking the main thread.",
            "Uses the **Thread Pool** for managing multiple tasks efficiently.",
            "Asynchronous programming in C# is useful for **I/O-bound operations** like database calls, network requests, and file operations."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main()\n    {\n        Console.WriteLine(\"Start\");\n        string result = await FetchData();\n        Console.WriteLine(result);\n        Console.WriteLine(\"End\");\n    }\n\n    static async Task<string> FetchData()\n    {\n        await Task.Delay(2000); // Simulate async work\n        return \"Data received\";\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Asynchronous Programming in Golang (Goroutines):**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses **goroutines**, which are lightweight threads managed by the Go runtime.",
            "Unlike OS threads, goroutines use less memory and allow thousands of tasks to run concurrently.",
            "The `go` keyword is used to start a new goroutine.",
            "Channels (`chan`) are used to communicate safely between goroutines.",
            "Ideal for **CPU-bound** and **network-intensive** operations."
          ]
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc fetchData(ch chan string) {\n    time.Sleep(2 * time.Second) // Simulate async work\n    ch <- \"Data received\"\n}\n\nfunc main() {\n    fmt.Println(\"Start\")\n    ch := make(chan string)\n    go fetchData(ch)\n    result := <-ch\n    fmt.Println(result)\n    fmt.Println(\"End\")\n}"
        },
        {
          "type": "text",
          "content": "**Key Differences:**"
        },
        {
          "type": "list",
          "items": [
            "C# uses **async/await with Tasks**, while Golang uses **goroutines and channels**.",
            "C#'s **Thread Pool** manages threads, whereas Golang’s **runtime scheduler** manages goroutines.",
            "Goroutines are **lighter and more efficient** than C# tasks, making them suitable for high-concurrency applications.",
            "C#'s `await` helps avoid blocking the main thread, whereas Go relies on **channels and synchronization** for communication.",
            "C# is more structured for **asynchronous I/O operations**, while Go excels at **parallel execution and concurrency control**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, C#'s async/await is designed for easier asynchronous coding in **I/O-bound** applications, while Go's goroutines provide a more **lightweight and efficient** concurrency model for **highly concurrent** systems."
        }
      ]
    },
    {
      "id": "be-6",
      "question": "What are the benefits of using Golang for backend services compared to C#? (Including memory usage and footprint comparison)",
      "answer": [
        {
          "type": "text",
          "content": "Golang and C# both offer strong backend capabilities, but they differ in terms of memory consumption, execution speed, and deployment footprint. Below is a detailed comparison."
        },
        {
          "type": "text",
          "content": "**1. Performance & Execution Speed**"
        },
        {
          "type": "list",
          "items": [
            "Golang is **compiled directly to native machine code**, making it faster at execution than C#'s **JIT (Just-In-Time) compilation** in .NET.",
            "C# runs on the **.NET runtime**, which adds some overhead but provides benefits like runtime optimizations and garbage collection."
          ]
        },
        {
          "type": "text",
          "content": "**2. Memory Usage & Garbage Collection**"
        },
        {
          "type": "list",
          "items": [
            "Golang’s **garbage collector (GC)** is optimized for **low-latency, high-throughput** applications with **short pauses**.",
            "C#'s **.NET GC** is powerful but can cause **longer pauses** in high-memory applications due to **heap compaction and generational collection**.",
            "Go’s memory model avoids **heap fragmentation**, making it more predictable in **containerized environments**."
          ]
        },
        {
          "type": "text",
          "content": "**3. Deployment & Binary Size**"
        },
        {
          "type": "list",
          "items": [
            "Golang compiles into a **single static binary** with no external dependencies, making deployment easy.",
            "A **Golang binary** typically ranges between **5-15 MB**, depending on the project.",
            "C# applications depend on **.NET runtime (CoreCLR or Mono)**, which increases the size.",
            "A self-contained **C# .NET Core application** can range from **50-100 MB+** when bundled with runtime dependencies."
          ]
        },
        {
          "type": "text",
          "content": "**4. Memory Footprint in Real-World Usage**"
        },
        {
          "type": "list",
          "items": [
            "A simple **Hello World** app in Go uses **1-2 MB RAM**, while in C# .NET, it starts at **15-30 MB RAM** due to runtime overhead.",
            "Go’s **HTTP server** consumes around **5-10 MB RAM** under load, while an equivalent ASP.NET Core service may require **50-100 MB+ RAM**.",
            "For **high-concurrency services**, Go’s lightweight **goroutines** allow handling **millions of requests** with lower memory usage compared to C#'s **ThreadPool-based tasks**."
          ]
        },
        {
          "type": "text",
          "content": "**5. Containerization & Cloud Deployment**"
        },
        {
          "type": "list",
          "items": [
            "Go's small footprint makes it ideal for **Docker and Kubernetes**, with **small container images (~10-20 MB)**.",
            "C# applications packaged in Docker often require **Alpine (~80-100 MB) or Debian (~200-300 MB)** base images to include the .NET runtime.",
            "Golang is preferred for **serverless functions** and cloud-native applications due to its **low memory consumption**."
          ]
        },
        {
          "type": "text",
          "content": "**Key Takeaways:**"
        },
        {
          "type": "list",
          "items": [
            "**Use Golang if:** You need a lightweight, fast, and highly efficient backend with **minimal memory consumption and small deployment size**.",
            "**Use C# if:** You require a feature-rich backend with **robust framework support**, even at the cost of a **larger memory footprint and dependency on .NET runtime**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, Golang is a better choice for high-performance microservices, cloud-native applications, and low-latency APIs, while C# excels in enterprise solutions where rich ecosystem support and framework capabilities matter more."
        }
      ]
    },
    {
      "id": "be-7",
      "question": "Explain Rate Limiting and how to implement it in a Golang-based microservice.",
      "answer": [
        {
          "type": "text",
          "content": "Rate limiting is a technique used to control the number of requests a client can make to a server in a given time period. It helps prevent abuse, maintain service availability, and ensure fair usage of resources."
        },
        {
          "type": "text",
          "content": "**Common Rate Limiting Strategies:**"
        },
        {
          "type": "list",
          "items": [
            "**Token Bucket**: Clients acquire tokens before making requests. Requests are denied if tokens are exhausted.",
            "**Leaky Bucket**: Requests are processed at a fixed rate, and excess requests are queued.",
            "**Fixed Window**: Limits requests within a specific time window (e.g., 100 requests per minute).",
            "**Sliding Window**: More dynamic than fixed window; calculates limits based on the recent request history."
          ]
        },
        {
          "type": "text",
          "content": "**Rate Limiting Implementation in Golang**"
        },
        {
          "type": "text",
          "content": "Below is a Golang example implementing rate limiting using the `golang.org/x/time/rate` package, which provides an efficient token bucket algorithm."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n)\n\n// RateLimiter struct for per-client rate limiting\ntype RateLimiter struct {\n\tclients map[string]*rate.Limiter\n\tmutex   sync.Mutex\n\trate  rate.Limit\n\tburst int\n}\n\n// NewRateLimiter initializes a new rate limiter\nfunc NewRateLimiter(r rate.Limit, b int) *RateLimiter {\n\treturn &RateLimiter{\n\t\tclients: make(map[string]*rate.Limiter),\n\t\trate:    r,\n\t\tburst:   b,\n\t}\n}\n\n// GetLimiter retrieves or creates a rate limiter for a client\nfunc (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {\n\trl.mutex.Lock()\n\tdefer rl.mutex.Unlock()\n\n\tif limiter, exists := rl.clients[ip]; exists {\n\t\treturn limiter\n\t}\n\n\tlimiter := rate.NewLimiter(rl.rate, rl.burst)\n\trl.clients[ip] = limiter\n\treturn limiter\n}\n\nfunc main() {\n\trl := NewRateLimiter(1, 5) // 1 request per second, burst of 5\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tip := r.RemoteAddr\n\t\tlimiter := rl.GetLimiter(ip)\n\n\t\tif !limiter.Allow() {\n\t\t\thttp.Error(w, \"429 Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprintln(w, \"Request successful\")\n\t})\n\n\tlog.Println(\"Starting server on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"
        },
        {
          "type": "text",
          "content": "**How It Works:**"
        },
        {
          "type": "list",
          "items": [
            "Each client is identified by their **IP address**.",
            "A **token bucket rate limiter** is created for each client.",
            "If the client **exceeds the request limit**, they receive a **429 Too Many Requests** response.",
            "The limit is set to **1 request per second** with a burst capacity of **5 requests**."
          ]
        },
        {
          "type": "text",
          "content": "**Alternative Implementations:**"
        },
        {
          "type": "list",
          "items": [
            "Use **Redis-based rate limiting** for distributed systems (`github.com/go-redis/redis/v8`).",
            "Use **nginx or API Gateway** for rate limiting before requests reach the backend.",
            "Implement a **Sliding Window Counter** using a database like PostgreSQL."
          ]
        },
        {
          "type": "text",
          "content": "Rate limiting is crucial for protecting microservices from abuse and ensuring fair resource usage. In high-scale systems, it's recommended to use a distributed rate limiter backed by **Redis** or an API gateway like **Kong or Envoy**."
        }
      ]
    },
    {
      "id": "be-8",
      "question": "How do you secure APIs using OAuth, JWT, or API keys?",
      "answer": [
        {
          "type": "text",
          "content": "Securing APIs is essential to prevent unauthorized access and data breaches. Common authentication and authorization mechanisms include OAuth, JWT, and API Keys."
        },
        {
          "type": "text",
          "content": "**1. OAuth 2.0**"
        },
        {
          "type": "list",
          "items": [
            "OAuth 2.0 is an open standard for access delegation, commonly used to grant third-party applications limited access to user data.",
            "It uses **Access Tokens** to authenticate API requests.",
            "OAuth supports **authorization flows** such as Authorization Code, Client Credentials, and Password Grant."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Implementing OAuth 2.0 in Golang with `oauth2` package**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"golang.org/x/oauth2\"\n)\n\nvar googleOauthConfig = &oauth2.Config{\n\tClientID:     \"your-client-id\",\n\tClientSecret: \"your-client-secret\",\n\tRedirectURL:  \"http://localhost:8080/callback\",\n\tScopes:       []string{\"profile\", \"email\"},\n\tEndpoint:     oauth2.Endpoint{\n\t\tAuthURL:  \"https://accounts.google.com/o/oauth2/auth\",\n\t\tTokenURL: \"https://oauth2.googleapis.com/token\",\n\t},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\turl := googleOauthConfig.AuthCodeURL(\"state-token\", oauth2.AccessTypeOffline)\n\thttp.Redirect(w, r, url, http.StatusFound)\n}\n\nfunc callbackHandler(w http.ResponseWriter, r *http.Request) {\n\tcode := r.URL.Query().Get(\"code\")\n\ttoken, err := googleOauthConfig.Exchange(context.Background(), code)\n\tif err != nil {\n\t\tlog.Println(\"Failed to get token:\", err)\n\t\treturn\n\t}\n\tfmt.Fprintf(w, \"Access Token: %s\", token.AccessToken)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.HandleFunc(\"/callback\", callbackHandler)\n\tlog.Println(\"Server started at :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**2. JSON Web Token (JWT)**"
        },
        {
          "type": "list",
          "items": [
            "JWT is a compact, self-contained token format that encodes user claims and authentication data.",
            "It consists of **Header, Payload, and Signature**.",
            "JWTs are signed using HMAC or RSA to ensure integrity."
          ]
        },
        {
          "type": "text",
          "content": "**Example: JWT Authentication in Golang using `github.com/golang-jwt/jwt/v4`**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar secretKey = []byte(\"your-secret-key\")\n\nfunc generateJWT() (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"user\": \"admin\",\n\t\t\"exp\":  time.Now().Add(time.Hour * 1).Unix(),\n\t})\n\treturn token.SignedString(secretKey)\n}\n\nfunc jwtMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn secretKey, nil\n\t\t})\n\t\tif err != nil || !token.Valid {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc protectedEndpoint(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Access granted to protected resource\")\n}\n\nfunc main() {\n\thttp.Handle(\"/protected\", jwtMiddleware(http.HandlerFunc(protectedEndpoint)))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**3. API Keys Authentication**"
        },
        {
          "type": "list",
          "items": [
            "API Keys are simple authentication tokens passed in HTTP headers or query parameters.",
            "They are commonly used for **service-to-service communication**.",
            "API Keys should be **revocable and scoped** to control access."
          ]
        },
        {
          "type": "text",
          "content": "**Example: API Key Middleware in Golang**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar validAPIKey = \"your-api-key\"\n\nfunc apiKeyMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tapiKey := r.Header.Get(\"X-API-Key\")\n\t\tif apiKey != validAPIKey {\n\t\t\thttp.Error(w, \"Forbidden\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc protectedHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"API Key authentication successful\")\n}\n\nfunc main() {\n\thttp.Handle(\"/secure\", apiKeyMiddleware(http.HandlerFunc(protectedHandler)))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**Choosing the Right Authentication Method:**"
        },
        {
          "type": "list",
          "items": [
            "**OAuth 2.0**: Best for user authentication in third-party integrations (e.g., Google, Facebook login).",
            "**JWT**: Ideal for securing API endpoints in microservices without needing session storage.",
            "**API Keys**: Useful for machine-to-machine authentication but should be used with caution due to security risks."
          ]
        },
        {
          "type": "text",
          "content": "A combination of these methods can be used to enhance API security, e.g., using **OAuth for user login** and **JWT for API authorization**."
        }
      ]
    },
    {
      "id": "be-9",
      "question": "How does goroutine scheduling work in Golang? How does it differ from OS threads?",
      "answer": [
        {
          "type": "text",
          "content": "Goroutines are lightweight, managed by the Go runtime, and allow concurrent execution. Unlike OS threads, goroutines have minimal memory overhead and can scale efficiently."
        },
        {
          "type": "text",
          "content": "**Goroutine Scheduling:**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses **Goroutine Scheduler** to map thousands of goroutines onto a small number of OS threads.",
            "The scheduler is **non-preemptive** but can yield execution during function calls and specific points (e.g., I/O operations).",
            "It follows a **work-stealing** strategy where idle processors (P) take work from busy ones.",
            "Each OS thread (M) is bound to a user-level scheduler (P) managing a pool of goroutines."
          ]
        },
        {
          "type": "text",
          "content": "**Differences between Goroutines and OS Threads:**"
        },
        {
          "type": "list",
          "items": [
            "**Goroutines:** Small stack (~2KB), dynamically grows; managed by Go runtime.",
            "**OS Threads:** Large stack (~1MB), fixed size; managed by the operating system.",
            "**Goroutines:** Multiplexed over OS threads, allowing millions of goroutines.",
            "**OS Threads:** Limited in number due to resource constraints."
          ]
        }
      ]
    },
    {
      "id": "be-10",
      "question": "Explain channels vs. mutexes. When would you use one over the other?",
      "answer": [
        {
          "type": "text",
          "content": "Channels and mutexes are synchronization primitives in Golang."
        },
        {
          "type": "text",
          "content": "**Channels:**"
        },
        {
          "type": "list",
          "items": [
            "Used for **message passing** between goroutines.",
            "Avoids shared memory, enabling safe concurrent programming.",
            "Synchronous (blocking) or asynchronous (buffered) communication."
          ]
        },
        {
          "type": "text",
          "content": "**Mutexes:**"
        },
        {
          "type": "list",
          "items": [
            "Used for **mutual exclusion** (locking shared data).",
            "Provides fine-grained control over shared resources.",
            "More efficient for protecting small, frequently accessed variables."
          ]
        },
        {
          "type": "text",
          "content": "**When to use which?**"
        },
        {
          "type": "list",
          "items": [
            "Use **channels** when you want to pass ownership of data instead of locking it.",
            "Use **mutexes** when multiple goroutines need to modify a shared variable safely."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Channel-based synchronization**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tch := make(chan int)\n\n\tgo func() {\n\t\tch <- 42 // Send data to channel\n\t}()\n\n\tfmt.Println(<-ch) // Receive data from channel\n}"
        },
        {
          "type": "text",
          "content": "**Example: Mutex-based synchronization**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar counter int\nvar mu sync.Mutex\n\nfunc increment(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tmu.Lock()\n\tcounter++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo increment(&wg)\n\t}\n\twg.Wait()\n\tfmt.Println(\"Final Counter:\", counter)\n}"
        }
      ]
    },
    {
      "id": "be-11",
      "question": "What are defer, panic, and recover in Golang? How do they work?",
      "answer": [
        {
          "type": "text",
          "content": "In Golang, `defer`, `panic`, and `recover` are mechanisms for handling cleanup and error recovery."
        },
        {
          "type": "text",
          "content": "**1. Defer:**"
        },
        {
          "type": "list",
          "items": [
            "Used to schedule a function to execute **after** the surrounding function returns.",
            "Useful for **resource cleanup** (closing files, unlocking mutexes, etc.)."
          ]
        },
        {
          "type": "text",
          "content": "**Example of defer:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"This will execute last\")\n\tfmt.Println(\"This executes first\")\n}"
        },
        {
          "type": "text",
          "content": "**2. Panic:**"
        },
        {
          "type": "list",
          "items": [
            "Used to **abort execution** immediately.",
            "Typically used for **critical errors** like accessing an invalid memory location."
          ]
        },
        {
          "type": "text",
          "content": "**Example of panic:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Before panic\")\n\tpanic(\"Something went wrong!\")\n\tfmt.Println(\"This will not execute\")\n}"
        },
        {
          "type": "text",
          "content": "**3. Recover:**"
        },
        {
          "type": "list",
          "items": [
            "Used inside `defer` to **catch a panic** and prevent program crash.",
            "Returns `nil` if no panic occurs."
          ]
        },
        {
          "type": "text",
          "content": "**Example of recover:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Recovered from panic:\", r)\n\t\t}\n\t}()\n\tpanic(\"Something went wrong!\")\n}"
        }
      ]
    },
    {
      "id": "be-12",
      "question": "How would you implement worker pools in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Worker pools are a pattern used to control concurrency by limiting the number of goroutines processing tasks."
        },
        {
          "type": "text",
          "content": "**Steps to implement a worker pool:**"
        },
        {
          "type": "list",
          "items": [
            "Create a buffered channel for tasks.",
            "Spawn a fixed number of worker goroutines.",
            "Each worker fetches and processes tasks from the channel.",
            "Close the channel when all tasks are dispatched."
          ]
        },
        {
          "type": "text",
          "content": "**Example of a Worker Pool in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 5)\n\tvar wg sync.WaitGroup\n\n\t// Create worker pool\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, &wg)\n\t}\n\n\t// Send jobs to channel\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n}"
        }
      ]
    },
    {
      "id": "be-13",
      "question": "Explain context package in Golang. How do you use it for request cancellation?",
      "answer": [
        {
          "type": "text",
          "content": "The `context` package in Golang provides a way to manage request deadlines, cancellations, and timeouts across API calls and goroutines."
        },
        {
          "type": "text",
          "content": "**Key Features:**"
        },
        {
          "type": "list",
          "items": [
            "Allows request **cancellation** to prevent resource leaks.",
            "Supports **timeouts** and **deadlines**.",
            "Enables **passing metadata** between function calls."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using context for request cancellation**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel() // Ensure cleanup\n\n\tgo func(ctx context.Context) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tfmt.Println(\"Request canceled\")\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Processing...\")\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}(ctx)\n\ntime.Sleep(3 * time.Second)\n}"
        }
      ]
    },
    {
      "id": "be-14",
      "question": "How do you handle race conditions in a concurrent Golang application?",
      "answer": [
        {
          "type": "text",
          "content": "Race conditions occur when multiple goroutines access shared data simultaneously, leading to unpredictable behavior."
        },
        {
          "type": "text",
          "content": "**Ways to Prevent Race Conditions:**"
        },
        {
          "type": "list",
          "items": [
            "Use **sync.Mutex** to lock shared data.",
            "Use **channels** to control access.",
            "Use **sync/atomic** for atomic operations.",
            "Use **Go's race detector** (`go run -race`)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Mutex to prevent race conditions**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar count int\nvar mu sync.Mutex\n\nfunc increment(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tmu.Lock()\n\tcount++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo increment(&wg)\n\t}\n\twg.Wait()\n\tfmt.Println(\"Final Count:\", count)\n}"
        }
      ]
    },
    {
      "id": "be-15",
      "question": "What are interface types, and how does Golang’s interface system differ from C#’s?",
      "answer": [
        {
          "type": "text",
          "content": "**Golang Interfaces:**"
        },
        {
          "type": "list",
          "items": [
            "Interfaces define **behavior** rather than **inheritance**.",
            "A type **implicitly** satisfies an interface if it implements the required methods.",
            "Interfaces allow **decoupled code** and **mocking** in tests."
          ]
        },
        {
          "type": "text",
          "content": "**Difference from C# Interfaces:**"
        },
        {
          "type": "list",
          "items": [
            "**Golang:** Implicit implementation (structs automatically satisfy interfaces).",
            "**C#:** Explicit implementation using `interface` keyword.",
            "**Golang:** No need to declare an interface in the struct.",
            "**C#:** Classes must explicitly declare they implement an interface."
          ]
        },
        {
          "type": "text",
          "content": "**Example of Golang Interface:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Animal interface {\n\tSpeak() string\n}\n\ntype Dog struct {}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof!\"\n}\n\nfunc main() {\n\tvar a Animal = Dog{}\n\tfmt.Println(a.Speak())\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "How does dependency injection work in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern where dependencies are **injected** instead of being created inside a struct."
        },
        {
          "type": "text",
          "content": "**DI Approaches in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Using **constructor functions**.",
            "Passing **interfaces instead of concrete types**.",
            "Using **third-party DI libraries** (e.g., `uber-go/fx`, `wire`)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Constructor-based DI**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Service struct {\n\tmessage string\n}\n\nfunc NewService(msg string) *Service {\n\treturn &Service{message: msg}\n}\n\nfunc main() {\n\tservice := NewService(\"Hello, DI!\")\n\tfmt.Println(service.message)\n}"
        }
      ]
    },
    {
      "id": "be-17",
      "question": "How do you design a highly available, scalable Golang microservice?",
      "answer": [
        {
          "type": "text",
          "content": "**Best Practices for Scalable Microservices:**"
        },
        {
          "type": "list",
          "items": [
            "Use **stateless** services with shared databases or caches.",
            "Implement **load balancing** (e.g., Nginx, HAProxy).",
            "Use **goroutines and channels** for concurrency.",
            "Apply **caching** (Redis, Memcached) to reduce DB load.",
            "Implement **rate limiting** to prevent abuse.",
            "Use **Docker and Kubernetes** for containerization and orchestration."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Goroutine-based request handling**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello, Microservice!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    },
    {
      "id": "be-18",
      "question": "Explain the difference between struct embedding and inheritance in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "**Golang does not support classical inheritance** like C++ or Java but uses **struct embedding** for composition."
        },
        {
          "type": "text",
          "content": "**Struct Embedding:**"
        },
        {
          "type": "list",
          "items": [
            "Allows code reuse without a strict parent-child hierarchy.",
            "Encapsulates behavior while avoiding deep inheritance chains.",
            "Methods of the embedded struct are promoted to the outer struct."
          ]
        },
        {
          "type": "text",
          "content": "**Example of Struct Embedding:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Engine struct {\n\tHorsepower int\n}\n\ntype Car struct {\n\tEngine // Embedded struct\n\tBrand string\n}\n\nfunc main() {\n\tc := Car{Engine{250}, \"Toyota\"}\n\tfmt.Println(\"Car brand:\", c.Brand, \"Horsepower:\", c.Horsepower)\n}"
        }
      ]
    },
    {
      "id": "be-13",
      "question": "What are best practices for logging and monitoring in Golang applications?",
      "answer": [
        {
          "type": "text",
          "content": "Logging and monitoring are essential for observability in Golang applications. Here are best practices:"
        },
        {
          "type": "text",
          "content": "**Best Practices for Logging:**"
        },
        {
          "type": "list",
          "items": [
            "Use structured logging with libraries like `logrus` or `zap`.",
            "Log at appropriate levels: `Debug`, `Info`, `Warning`, `Error`, and `Fatal`.",
            "Include contextual information (e.g., request ID, user ID).",
            "Write logs in JSON format for easy parsing.",
            "Avoid logging sensitive information (passwords, API keys)."
          ]
        },
        {
          "type": "text",
          "content": "**Example using logrus:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n\tlog := logrus.New()\n\tlog.SetFormatter(&logrus.JSONFormatter{})\n\tlog.Info(\"Application started\")\n}"
        },
        {
          "type": "text",
          "content": "**Best Practices for Monitoring:**"
        },
        {
          "type": "list",
          "items": [
            "Use Prometheus for metrics collection.",
            "Track key performance indicators (latency, request count, errors).",
            "Use distributed tracing (e.g., OpenTelemetry, Jaeger).",
            "Monitor logs centrally with ELK (Elasticsearch, Logstash, Kibana) or Loki."
          ]
        }
      ]
    },
    {
      "id": "be-14",
      "question": "How do you implement retry logic with exponential backoff in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Retry logic with exponential backoff helps in handling transient failures by delaying retries progressively."
        },
        {
          "type": "text",
          "content": "**Steps to implement exponential backoff:**"
        },
        {
          "type": "list",
          "items": [
            "Define maximum retries and initial delay.",
            "Double the delay after each failed attempt.",
            "Introduce jitter to avoid synchronized retries.",
            "Stop retrying after a maximum number of attempts."
          ]
        },
        {
          "type": "text",
          "content": "**Example using exponential backoff in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc retryWithBackoff(attempts int, baseDelay time.Duration) error {\n\tfor i := 0; i < attempts; i++ {\n\t\terr := makeRequest()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tjitter := time.Duration(rand.Intn(100)) * time.Millisecond\n\t\tsleepTime := baseDelay * (1 << i) + jitter\n\t\tfmt.Println(\"Retrying in\", sleepTime)\n\t\ttime.Sleep(sleepTime)\n\t}\n\treturn fmt.Errorf(\"operation failed after %d attempts\", attempts)\n}\n\nfunc makeRequest() error {\n\treturn fmt.Errorf(\"temporary error\")\n}\n\nfunc main() {\n\tretryWithBackoff(5, 500*time.Millisecond)\n}"
        }
      ]
    },
    {
      "id": "be-15",
      "question": "How does Golang handle JSON marshaling and unmarshaling?",
      "answer": [
        {
          "type": "text",
          "content": "Golang uses the `encoding/json` package to marshal (convert struct to JSON) and unmarshal (convert JSON to struct)."
        },
        {
          "type": "text",
          "content": "**Example of JSON marshaling (struct to JSON):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\tuser := User{Name: \"Alice\", Age: 25, Email: \"alice@example.com\"}\n\tjsonData, _ := json.Marshal(user)\n\tfmt.Println(string(jsonData))\n}"
        },
        {
          "type": "text",
          "content": "**Example of JSON unmarshaling (JSON to struct):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\tjsonData := `{\"name\": \"Bob\", \"age\": 30, \"email\": \"bob@example.com\"}`\n\tvar user User\n\tjson.Unmarshal([]byte(jsonData), &user)\n\tfmt.Println(user)\n}"
        },
        {
          "type": "text",
          "content": "**Handling Unknown JSON Fields:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "type Response struct {\n\tData map[string]interface{} `json:\"data\"`\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "How do you implement WebSockets in a Golang API?",
      "answer": [
        {
          "type": "text",
          "content": "WebSockets enable real-time communication between clients and a Golang server. The `github.com/gorilla/websocket` package is commonly used."
        },
        {
          "type": "text",
          "content": "**Steps to implement WebSockets:**"
        },
        {
          "type": "list",
          "items": [
            "Upgrade HTTP requests to WebSocket connections.",
            "Handle WebSocket messages in a loop.",
            "Gracefully close the connection when the client disconnects."
          ]
        },
        {
          "type": "text",
          "content": "**Example WebSocket server in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool { return true },\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error upgrading connection:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Received:\", string(msg))\n\t\tconn.WriteMessage(messageType, []byte(\"Hello from server!\"))\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", handleWebSocket)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    }
  ],
  "backend-golang-problem-solving": [
    {
      "id": "cps-1",
      "question": "Implement a thread-safe in-memory key-value store in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "A thread-safe key-value store requires synchronization mechanisms like `sync.Mutex` or `sync.RWMutex` to prevent race conditions when multiple goroutines access the store."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"sync\"\n\t\"fmt\"\n)\n\ntype Store struct {\n\tdata map[string]string\n\tmu   sync.RWMutex\n}\n\nfunc NewStore() *Store {\n\treturn &Store{data: make(map[string]string)}\n}\n\nfunc (s *Store) Set(key, value string) {\n\ts.mu.Lock()\n\ts.data[key] = value\n\ts.mu.Unlock()\n}\n\nfunc (s *Store) Get(key string) (string, bool) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tval, exists := s.data[key]\n\treturn val, exists\n}\n\nfunc main() {\n\tstore := NewStore()\n\tstore.Set(\"foo\", \"bar\")\n\tval, _ := store.Get(\"foo\")\n\tfmt.Println(\"Value:\", val)\n}"
        }
      ]
    },
    {
      "id": "cps-2",
      "question": "Write a rate limiter using Golang middleware.",
      "answer": [
        {
          "type": "text",
          "content": "Rate limiting ensures API requests are restricted to a fixed rate. We use `golang.org/x/time/rate` package to implement a token bucket rate limiter in middleware."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\t\"golang.org/x/time/rate\"\n)\n\ntype rateLimiter struct {\n\tlimiter *rate.Limiter\n}\n\nfunc (rl *rateLimiter) middleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !rl.limiter.Allow() {\n\t\t\thttp.Error(w, \"Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\trl := &rateLimiter{limiter: rate.NewLimiter(1, 5)} // 1 request per second, burst of 5\n\n\thttp.Handle(\"/\", rl.middleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    },
    {
      "id": "cps-3",
      "question": "Implement a concurrent worker pool in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "A worker pool limits the number of concurrent workers processing tasks. It distributes tasks among workers using channels."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 5)\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, &wg)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n}"
        }
      ]
    },
    {
      "id": "cps-4",
      "question": "Implement a REST API in Golang that connects to a PostgreSQL database.",
      "answer": [
        {
          "type": "text",
          "content": "This implementation uses `gorm` for database interactions and `gin` for REST API handling."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n)\n\ntype User struct {\n\tID   uint   `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nvar db *gorm.DB\n\nfunc initDB() {\n\tdsn := \"host=localhost user=postgres password=yourpassword dbname=testdb port=5432 sslmode=disable\"\n\tvar err error\n\tdb, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\tif err != nil {\n\t\tpanic(\"Failed to connect to database\")\n\t}\n\tdb.AutoMigrate(&User{})\n}\n\nfunc getUsers(c *gin.Context) {\n\tvar users []User\n\tdb.Find(&users)\n\tc.JSON(200, users)\n}\n\nfunc main() {\n\tinitDB()\n\tr := gin.Default()\n\tr.GET(\"/users\", getUsers)\n\tr.Run(\":8080\")\n}"
        }
      ]
    },
    {
      "id": "cps-5",
      "question": "Design a task scheduler in Golang where tasks run at specific intervals.",
      "answer": [
        {
          "type": "text",
          "content": "A task scheduler can be implemented using `time.Ticker` or `cron` library for periodic execution."
        },
        {
          "type": "text",
          "content": "**Example Implementation (Using time.Ticker):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc task() {\n\tfmt.Println(\"Task executed at\", time.Now())\n}\n\nfunc main() {\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\ttask()\n\t}\n}"
        }
      ]
    }
  ],
  "algorithms": [
    {
      "id": "algo-1",
      "question": "Implement a function to reverse a linked list.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for singly-linked list node\n */\nclass ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n/**\n * Reverses a singly linked list\n * Time Complexity: O(n)\n * Space Complexity: O(1)\n * \n * @param {ListNode} head - Head of the linked list\n * @return {ListNode} - Head of the reversed linked list\n */\nfunction reverseLinkedList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current !== null) {\n    // Save next node\n    const next = current.next;\n    \n    // Reverse pointer\n    current.next = prev;\n    \n    // Move pointers one step forward\n    prev = current;\n    current = next;\n  }\n  \n  // prev is the new head\n  return prev;\n}\n\n// Example usage:\n// const list = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));\n// const reversed = reverseLinkedList(list);\n// Output: 4 -> 3 -> 2 -> 1 -> null"
      }
    },
    {
      "id": "algo-2",
      "question": "Implement a function to find if a binary tree is balanced.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for a binary tree node\n */\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * Determines if a binary tree is height-balanced.\n * A height-balanced tree is a tree in which the left and right subtrees \n * of every node differ in height by no more than 1.\n * \n * Time Complexity: O(n) where n is the number of nodes in the tree\n * Space Complexity: O(h) where h is the height of the tree (due to recursion stack)\n * \n * @param {TreeNode} root - Root of the binary tree\n * @return {boolean} - Whether the tree is balanced or not\n */\nfunction isBalanced(root) {\n  // Function returns -1 if the tree is unbalanced, otherwise returns the height\n  function checkHeight(node) {\n    if (node === null) return 0;\n    \n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1; // Left subtree is unbalanced\n    \n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1; // Right subtree is unbalanced\n    \n    // Check if current node is balanced\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    \n    // Return height of current subtree\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  return checkHeight(root) !== -1;\n}\n\n// Example usage:\n// const balancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3));\n// console.log(isBalanced(balancedTree)); // true\n//\n// const unbalancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4, new TreeNode(8))), new TreeNode(3));\n// console.log(isBalanced(unbalancedTree)); // false"
      }
    }
  ],
  "system-design": [
    {
      "id": "sd-1",
      "question": "Design a URL shortening service like bit.ly.",
      "answer": [
        {
          "type": "text",
          "content": "Designing a URL shortening service involves several components and considerations:"
        },
        {
          "type": "text",
          "content": "**Functional Requirements:**"
        },
        {
          "type": "list",
          "items": [
            "URL shortening: Convert a long URL to a short URL",
            "URL redirection: Redirect short URL to original URL",
            "User accounts: Optional for analytics and URL management",
            "Analytics: Track click rates, geographic data, etc.",
            "Custom short URLs: Allow users to choose their custom short URLs"
          ]
        },
        {
          "type": "text",
          "content": "**Non-Functional Requirements:**"
        },
        {
          "type": "list",
          "items": [
            "High availability: System should be always available",
            "Minimal latency: Redirection should happen with minimal delay",
            "Scalability: System should handle high traffic",
            "Security: Prevent abuse and malicious URLs"
          ]
        },
        {
          "type": "text",
          "content": "**API Design:**"
        },
        {
          "type": "list",
          "items": [
            "`POST /api/shorten` - Create a new short URL",
            "`GET /{shortCode}` - Redirect to original URL",
            "`GET /api/analytics/{shortCode}` - Get analytics for a short URL"
          ]
        },
        {
          "type": "text",
          "content": "**Data Model:**"
        },
        {
          "type": "code",
          "language": "text",
          "content": "URL {\n  id: string (primary key)\n  shortCode: string (indexed)\n  originalUrl: string\n  userId: string (optional)\n  createdAt: timestamp\n  expiresAt: timestamp (optional)\n}\n\nClick {\n  id: string (primary key)\n  urlId: string (foreign key)\n  timestamp: timestamp\n  userAgent: string\n  ipAddress: string\n  referrer: string\n}"
        },
        {
          "type": "text",
          "content": "**URL Shortening Algorithm:**"
        },
        {
          "type": "list",
          "items": [
            "Hash-based approach: Hash the long URL and take first few characters",
            "Counter-based approach: Use an auto-incrementing counter and convert to base62",
            "Random generation: Generate random strings and check for collisions"
          ]
        },
        {
          "type": "text",
          "content": "**System Architecture:**"
        },
        {
          "type": "list",
          "items": [
            "Load Balancer: Distribute traffic across application servers",
            "Application Servers: Handle API requests and URL redirection",
            "Database: Store URLs and analytics data",
            "Cache: Store frequently accessed URLs for faster redirection"
          ]
        },
        {
          "type": "text",
          "content": "**Database Choice:**"
        },
        {
          "type": "list",
          "items": [
            "Relational DB (PostgreSQL/MySQL): For structured data and transactions",
            "NoSQL DB (DynamoDB/Cassandra): For scalability and performance"
          ]
        },
        {
          "type": "text",
          "content": "**Caching Strategy:**"
        },
        {
          "type": "list",
          "items": [
            "Use Redis/Memcached to cache URL mappings",
            "LRU (Least Recently Used) eviction policy"
          ]
        },
        {
          "type": "text",
          "content": "**Scaling Considerations:**"
        },
        {
          "type": "list",
          "items": [
            "Database sharding: Partition URLs based on shortCode hash",
            "Caching: Implement multiple cache layers",
            "CDN: Use for handling static content and reducing latency",
            "Horizontal scaling: Add more application servers as needed"
          ]
        },
        {
          "type": "text",
          "content": "**Security:**"
        },
        {
          "type": "list",
          "items": [
            "Rate limiting: Prevent abuse",
            "URL validation: Check for malicious URLs",
            "User authentication: For managing URLs",
            "HTTPS: Secure all communications"
          ]
        },
        {
          "type": "text",
          "content": "This design balances simplicity, performance, and scalability while addressing the key requirements of a URL shortening service."
        }
      ]
    }
  ]
}
