{
  "frontend-html": [
    {
      "id": "fe-1",
      "question": "Explain how the box model works in CSS.",
      "answer": "The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model. Each box has a content area (e.g., text, an image, etc.) and optional surrounding padding, border, and margin areas.\n\nComponents from inside to outside:\n\n1. Content - The actual content of the box where text and images appear\n2. Padding - Clears an area around the content (inside the box)\n3. Border - A border that goes around the padding and content\n4. Margin - Clears an area outside the border\n\nThe total width of an element is calculated as: width + left padding + right padding + left border + right border + left margin + right margin\n\nIn modern CSS, you can change how the box model works by setting the `box-sizing` property:\n\n- `box-sizing: content-box` (default): Width and height only apply to the content area\n- `box-sizing: border-box`: Width and height include content, padding, and border (but not margin)"
    },
    {
      "id": "fe-2",
      "question": "What is the difference between 'let', 'const', and 'var' in JavaScript?",
      "answer": "These three keywords are used for variable declarations in JavaScript but have different scoping rules and behaviors:\n\n**var**:\n- Function-scoped or globally-scoped, not block-scoped\n- Can be redeclared and updated\n- Hoisted to the top of its scope and initialized with `undefined`\n- Can cause unexpected behavior in loops and conditional blocks\n\n**let**:\n- Block-scoped (available only within the block it's defined in)\n- Can be updated but not redeclared in the same scope\n- Hoisted but not initialized (in the \"temporal dead zone\" until declaration)\n- Introduced in ES6 (ES2015)\n\n**const**:\n- Block-scoped like `let`\n- Cannot be updated or redeclared\n- Must be initialized at declaration\n- For objects and arrays, the variable cannot be reassigned, but the properties/elements can be changed\n- Hoisted but not initialized (in the \"temporal dead zone\" until declaration)\n- Introduced in ES6 (ES2015)"
    },
    {
      "id": "fe-3",
      "question": "Implement a debounce function in JavaScript.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Creates a debounced function that delays invoking the provided function\n * until after 'wait' milliseconds have elapsed since the last time it was invoked.\n * \n * @param {Function} func - The function to debounce\n * @param {number} wait - The number of milliseconds to delay\n * @return {Function} - The debounced function\n */\nfunction debounce(func, wait) {\n  let timeout;\n  \n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Example usage:\nconst handleSearch = debounce(function(event) {\n  console.log('Searching for:', event.target.value);\n  // API call or other expensive operation\n}, 500);\n\n// Attach to an input element\n// document.querySelector('input').addEventListener('input', handleSearch);"
      }
    }
  ],
  "backend": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client.\n\nKey principles of RESTful API design:\n\n1. **Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.\n\n2. **Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.\n\n3. **Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.\n\n4. **Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)\n\n5. **Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.\n\n6. **Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code.\n\nRESTful APIs typically use HTTP methods explicitly:\n- GET (retrieve a resource)\n- POST (create a resource)\n- PUT (update a resource)\n- DELETE (remove a resource)\n- PATCH (partial update)\n\nAnd HTTP status codes to indicate success/failure."
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints.\n\nThe main normal forms are:\n\n**First Normal Form (1NF)**:\n- Each table cell should contain a single value\n- Each record needs to be unique\n- No repeating groups or arrays\n\n**Second Normal Form (2NF)**:\n- Must be in 1NF\n- All non-key attributes must depend on the entire primary key\n- Eliminates partial dependencies\n\n**Third Normal Form (3NF)**:\n- Must be in 2NF\n- No transitive dependencies (non-key attributes depending on other non-key attributes)\n- All fields must depend directly on the primary key\n\n**Boyce-Codd Normal Form (BCNF)**:\n- A stricter version of 3NF\n- For any dependency A → B, A must be a super key\n- Addresses certain anomalies not addressed by 3NF\n\n**Fourth Normal Form (4NF)**:\n- Must be in BCNF\n- No multi-valued dependencies\n\n**Fifth Normal Form (5NF)**:\n- Must be in 4NF\n- No join dependencies\n- Every join dependency is implied by the candidate keys\n\nBenefits of normalization include:\n- Reducing data redundancy\n- Improving data integrity\n- Making the database more flexible\n- Better database organization\n\nHowever, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
    }
  ],
  "backend-csharp": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client.\n\nKey principles of RESTful API design:\n\n1. **Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.\n\n2. **Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.\n\n3. **Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.\n\n4. **Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)\n\n5. **Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.\n\n6. **Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code.\n\nRESTful APIs typically use HTTP methods explicitly:\n- GET (retrieve a resource)\n- POST (create a resource)\n- PUT (update a resource)\n- DELETE (remove a resource)\n- PATCH (partial update)\n\nAnd HTTP status codes to indicate success/failure."
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints.\n\nThe main normal forms are:\n\n**First Normal Form (1NF)**:\n- Each table cell should contain a single value\n- Each record needs to be unique\n- No repeating groups or arrays\n\n**Second Normal Form (2NF)**:\n- Must be in 1NF\n- All non-key attributes must depend on the entire primary key\n- Eliminates partial dependencies\n\n**Third Normal Form (3NF)**:\n- Must be in 2NF\n- No transitive dependencies (non-key attributes depending on other non-key attributes)\n- All fields must depend directly on the primary key\n\n**Boyce-Codd Normal Form (BCNF)**:\n- A stricter version of 3NF\n- For any dependency A → B, A must be a super key\n- Addresses certain anomalies not addressed by 3NF\n\n**Fourth Normal Form (4NF)**:\n- Must be in BCNF\n- No multi-valued dependencies\n\n**Fifth Normal Form (5NF)**:\n- Must be in 4NF\n- No join dependencies\n- Every join dependency is implied by the candidate keys\n\nBenefits of normalization include:\n- Reducing data redundancy\n- Improving data integrity\n- Making the database more flexible\n- Better database organization\n\nHowever, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
    }
  ],
  "backend-golang": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client.\n\nKey principles of RESTful API design:\n\n1. **Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.\n\n2. **Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.\n\n3. **Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.\n\n4. **Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)\n\n5. **Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.\n\n6. **Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code.\n\nRESTful APIs typically use HTTP methods explicitly:\n- GET (retrieve a resource)\n- POST (create a resource)\n- PUT (update a resource)\n- DELETE (remove a resource)\n- PATCH (partial update)\n\nAnd HTTP status codes to indicate success/failure."
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints.\n\nThe main normal forms are:\n\n**First Normal Form (1NF)**:\n- Each table cell should contain a single value\n- Each record needs to be unique\n- No repeating groups or arrays\n\n**Second Normal Form (2NF)**:\n- Must be in 1NF\n- All non-key attributes must depend on the entire primary key\n- Eliminates partial dependencies\n\n**Third Normal Form (3NF)**:\n- Must be in 2NF\n- No transitive dependencies (non-key attributes depending on other non-key attributes)\n- All fields must depend directly on the primary key\n\n**Boyce-Codd Normal Form (BCNF)**:\n- A stricter version of 3NF\n- For any dependency A → B, A must be a super key\n- Addresses certain anomalies not addressed by 3NF\n\n**Fourth Normal Form (4NF)**:\n- Must be in BCNF\n- No multi-valued dependencies\n\n**Fifth Normal Form (5NF)**:\n- Must be in 4NF\n- No join dependencies\n- Every join dependency is implied by the candidate keys\n\nBenefits of normalization include:\n- Reducing data redundancy\n- Improving data integrity\n- Making the database more flexible\n- Better database organization\n\nHowever, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
    }
  ],
  "algorithms": [
    {
      "id": "algo-1",
      "question": "Implement a function to reverse a linked list.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for singly-linked list node\n */\nclass ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n/**\n * Reverses a singly linked list\n * Time Complexity: O(n)\n * Space Complexity: O(1)\n * \n * @param {ListNode} head - Head of the linked list\n * @return {ListNode} - Head of the reversed linked list\n */\nfunction reverseLinkedList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current !== null) {\n    // Save next node\n    const next = current.next;\n    \n    // Reverse pointer\n    current.next = prev;\n    \n    // Move pointers one step forward\n    prev = current;\n    current = next;\n  }\n  \n  // prev is the new head\n  return prev;\n}\n\n// Example usage:\n// const list = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));\n// const reversed = reverseLinkedList(list);\n// Output: 4 -> 3 -> 2 -> 1 -> null"
      }
    },
    {
      "id": "algo-2",
      "question": "Implement a function to find if a binary tree is balanced.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for a binary tree node\n */\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * Determines if a binary tree is height-balanced.\n * A height-balanced tree is a tree in which the left and right subtrees \n * of every node differ in height by no more than 1.\n * \n * Time Complexity: O(n) where n is the number of nodes in the tree\n * Space Complexity: O(h) where h is the height of the tree (due to recursion stack)\n * \n * @param {TreeNode} root - Root of the binary tree\n * @return {boolean} - Whether the tree is balanced or not\n */\nfunction isBalanced(root) {\n  // Function returns -1 if the tree is unbalanced, otherwise returns the height\n  function checkHeight(node) {\n    if (node === null) return 0;\n    \n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1; // Left subtree is unbalanced\n    \n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1; // Right subtree is unbalanced\n    \n    // Check if current node is balanced\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    \n    // Return height of current subtree\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  return checkHeight(root) !== -1;\n}\n\n// Example usage:\n// const balancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3));\n// console.log(isBalanced(balancedTree)); // true\n//\n// const unbalancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4, new TreeNode(8))), new TreeNode(3));\n// console.log(isBalanced(unbalancedTree)); // false"
      }
    }
  ],
  "system-design": [
    {
      "id": "sd-1",
      "question": "Design a URL shortening service like bit.ly.",
      "answer": "Designing a URL shortening service involves several components and considerations:\n\n**Functional Requirements:**\n1. URL shortening: Convert a long URL to a short URL\n2. URL redirection: Redirect short URL to original URL\n3. User accounts: Optional for analytics and URL management\n4. Analytics: Track click rates, geographic data, etc.\n5. Custom short URLs: Allow users to choose their custom short URLs\n\n**Non-Functional Requirements:**\n1. High availability: System should be always available\n2. Minimal latency: Redirection should happen with minimal delay\n3. Scalability: System should handle high traffic\n4. Security: Prevent abuse and malicious URLs\n\n**API Design:**\n1. `POST /api/shorten` - Create a new short URL\n2. `GET /{shortCode}` - Redirect to original URL\n3. `GET /api/analytics/{shortCode}` - Get analytics for a short URL\n\n**Data Model:**\n```\nURL {\n  id: string (primary key)\n  shortCode: string (indexed)\n  originalUrl: string\n  userId: string (optional)\n  createdAt: timestamp\n  expiresAt: timestamp (optional)\n}\n\nClick {\n  id: string (primary key)\n  urlId: string (foreign key)\n  timestamp: timestamp\n  userAgent: string\n  ipAddress: string\n  referrer: string\n}\n```\n\n**URL Shortening Algorithm:**\n1. Hash-based approach: Hash the long URL and take first few characters\n2. Counter-based approach: Use an auto-incrementing counter and convert to base62\n3. Random generation: Generate random strings and check for collisions\n\n**System Architecture:**\n1. Load Balancer: Distribute traffic across application servers\n2. Application Servers: Handle API requests and URL redirection\n3. Database: Store URLs and analytics data\n4. Cache: Store frequently accessed URLs for faster redirection\n\n**Database Choice:**\n- Relational DB (PostgreSQL/MySQL): For structured data and transactions\n- NoSQL DB (DynamoDB/Cassandra): For scalability and performance\n\n**Caching Strategy:**\n- Use Redis/Memcached to cache URL mappings\n- LRU (Least Recently Used) eviction policy\n\n**Scaling Considerations:**\n1. Database sharding: Partition URLs based on shortCode hash\n2. Caching: Implement multiple cache layers\n3. CDN: Use for handling static content and reducing latency\n4. Horizontal scaling: Add more application servers as needed\n\n**Security:**\n1. Rate limiting: Prevent abuse\n2. URL validation: Check for malicious URLs\n3. User authentication: For managing URLs\n4. HTTPS: Secure all communications\n\nThis design balances simplicity, performance, and scalability while addressing the key requirements of a URL shortening service."
    }
  ]
}
