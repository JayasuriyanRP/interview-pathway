{
  "frontend-html": [
    {
      "id": "fe-1",
      "question": "Explain how the box model works in CSS.",
      "answer": [
        {
          "type": "text",
          "content": "The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model. Each box has a content area (e.g., text, an image, etc.) and optional surrounding padding, border, and margin areas."
        },
        {
          "type": "text",
          "content": "Components from inside to outside:"
        },
        {
          "type": "list",
          "items": [
            "**Content** - The actual content of the box where text and images appear",
            "**Padding** - Clears an area around the content (inside the box)",
            "**Border** - A border that goes around the padding and content",
            "**Margin** - Clears an area outside the border"
          ]
        },
        {
          "type": "text",
          "content": "The total width of an element is calculated as: width + left padding + right padding + left border + right border + left margin + right margin"
        },
        {
          "type": "text",
          "content": "In modern CSS, you can change how the box model works by setting the `box-sizing` property:"
        },
        {
          "type": "list",
          "items": [
            "`box-sizing: content-box` (default): Width and height only apply to the content area",
            "`box-sizing: border-box`: Width and height include content, padding, and border (but not margin)"
          ]
        }
      ]
    },
    {
      "id": "fe-2",
      "question": "What is the difference between 'let', 'const', and 'var' in JavaScript?",
      "answer": [
        {
          "type": "text",
          "content": "These three keywords are used for variable declarations in JavaScript but have different scoping rules and behaviors:"
        },
        {
          "type": "text",
          "content": "**var**:"
        },
        {
          "type": "list",
          "items": [
            "Function-scoped or globally-scoped, not block-scoped",
            "Can be redeclared and updated",
            "Hoisted to the top of its scope and initialized with `undefined`",
            "Can cause unexpected behavior in loops and conditional blocks"
          ]
        },
        {
          "type": "text",
          "content": "**let**:"
        },
        {
          "type": "list",
          "items": [
            "Block-scoped (available only within the block it's defined in)",
            "Can be updated but not redeclared in the same scope",
            "Hoisted but not initialized (in the \"temporal dead zone\" until declaration)",
            "Introduced in ES6 (ES2015)"
          ]
        },
        {
          "type": "text",
          "content": "**const**:"
        },
        {
          "type": "list",
          "items": [
            "Block-scoped like `let`",
            "Cannot be updated or redeclared",
            "Must be initialized at declaration",
            "For objects and arrays, the variable cannot be reassigned, but the properties/elements can be changed",
            "Hoisted but not initialized (in the \"temporal dead zone\" until declaration)",
            "Introduced in ES6 (ES2015)"
          ]
        }
      ]
    },
    {
      "id": "fe-3",
      "question": "Implement a debounce function in JavaScript.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Creates a debounced function that delays invoking the provided function\n * until after 'wait' milliseconds have elapsed since the last time it was invoked.\n * \n * @param {Function} func - The function to debounce\n * @param {number} wait - The number of milliseconds to delay\n * @return {Function} - The debounced function\n */\nfunction debounce(func, wait) {\n  let timeout;\n  \n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Example usage:\nconst handleSearch = debounce(function(event) {\n  console.log('Searching for:', event.target.value);\n  // API call or other expensive operation\n}, 500);\n\n// Attach to an input element\n// document.querySelector('input').addEventListener('input', handleSearch);"
      }
    }
  ],
  "backend": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": [
        {
          "type": "text",
          "content": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client."
        },
        {
          "type": "text",
          "content": "Key principles of RESTful API design:"
        },
        {
          "type": "list",
          "items": [
            "**Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.",
            "**Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.",
            "**Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.",
            "**Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)",
            "**Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.",
            "**Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code."
          ]
        },
        {
          "type": "text",
          "content": "RESTful APIs typically use HTTP methods explicitly:"
        },
        {
          "type": "list",
          "items": [
            "GET (retrieve a resource)",
            "POST (create a resource)",
            "PUT (update a resource)",
            "DELETE (remove a resource)",
            "PATCH (partial update)"
          ]
        },
        {
          "type": "text",
          "content": "And HTTP status codes to indicate success/failure."
        }
      ]
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": [
        {
          "type": "text",
          "content": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints."
        },
        {
          "type": "text",
          "content": "The main normal forms are:"
        },
        {
          "type": "text",
          "content": "**First Normal Form (1NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Each table cell should contain a single value",
            "Each record needs to be unique",
            "No repeating groups or arrays"
          ]
        },
        {
          "type": "text",
          "content": "**Second Normal Form (2NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 1NF",
            "All non-key attributes must depend on the entire primary key",
            "Eliminates partial dependencies"
          ]
        },
        {
          "type": "text",
          "content": "**Third Normal Form (3NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 2NF",
            "No transitive dependencies (non-key attributes depending on other non-key attributes)",
            "All fields must depend directly on the primary key"
          ]
        },
        {
          "type": "text",
          "content": "**Boyce-Codd Normal Form (BCNF)**:"
        },
        {
          "type": "list",
          "items": [
            "A stricter version of 3NF",
            "For any dependency A â†’ B, A must be a super key",
            "Addresses certain anomalies not addressed by 3NF"
          ]
        },
        {
          "type": "text",
          "content": "**Fourth Normal Form (4NF)**:"
        },
        {
          "type": "list",
          "items": ["Must be in BCNF", "No multi-valued dependencies"]
        },
        {
          "type": "text",
          "content": "**Fifth Normal Form (5NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 4NF",
            "No join dependencies",
            "Every join dependency is implied by the candidate keys"
          ]
        },
        {
          "type": "text",
          "content": "Benefits of normalization include:"
        },
        {
          "type": "list",
          "items": [
            "Reducing data redundancy",
            "Improving data integrity",
            "Making the database more flexible",
            "Better database organization"
          ]
        },
        {
          "type": "text",
          "content": "However, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
        }
      ]
    }
  ],
  "backend-csharp": [
    {
      "id": "cs-1",
      "question": "What is C# and how does it differ from other programming languages?",
      "answer": [
        {
          "type": "text",
          "content": "C# (pronounced C-Sharp) is a modern, object-oriented programming language developed by Microsoft as part of the .NET framework. It is designed to be simple, safe, and scalable for application development."
        },
        {
          "type": "list",
          "items": [
            "C# is statically typed, whereas languages like JavaScript are dynamically typed.",
            "It is compiled to Intermediate Language (IL) and runs on the .NET runtime, unlike C++ which compiles to machine code.",
            "C# provides automatic garbage collection, whereas C++ requires manual memory management.",
            "It supports both procedural and object-oriented programming paradigms, similar to Java."
          ]
        }
      ]
    },
    {
      "id": "cs-2",
      "question": "What are the key features of C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Object-Oriented**: Supports classes, inheritance, polymorphism, and encapsulation.",
            "**Automatic Memory Management**: Uses garbage collection to manage memory efficiently.",
            "**Type Safety**: Prevents operations that lead to type errors.",
            "**LINQ Support**: Provides a powerful query syntax for collections and databases.",
            "**Asynchronous Programming**: Supports async/await for handling asynchronous operations.",
            "**Cross-Platform**: With .NET Core, C# applications can run on Windows, macOS, and Linux."
          ]
        }
      ]
    },
    {
      "id": "cs-3",
      "question": "Explain the difference between value types and reference types in C#.",
      "answer": [
        {
          "type": "text",
          "content": "C# differentiates between value types and reference types based on how data is stored in memory."
        },
        {
          "type": "text",
          "content": "**Value Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in stack memory.",
            "Contain actual values.",
            "Examples: int, float, char, struct, enum."
          ]
        },
        {
          "type": "text",
          "content": "**Reference Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in heap memory.",
            "Contain references (addresses) to actual data.",
            "Examples: class, interface, delegate, array, string."
          ]
        }
      ]
    },
    {
      "id": "cs-4",
      "question": "What is the difference between var, dynamic, and object in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**var**: Statically typed, inferred at compile-time. Cannot change type after initialization.",
            "**dynamic**: Dynamically typed, resolved at runtime. Allows flexibility but reduces compile-time checks.",
            "**object**: Base type for all types in C#. Requires explicit casting for specific type operations."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "var number = 10; // int type inferred\nobject obj = \"Hello\"; // Can store any type\ndynamic dyn = 100; // Type determined at runtime"
        }
      ]
    },
    {
      "id": "cs-5",
      "question": "What are nullable types in C#? How do you declare them?",
      "answer": [
        {
          "type": "text",
          "content": "Nullable types allow value types (like int, float) to hold a null value, useful for database operations."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "int? age = null; // Nullable int\ndouble? price = 9.99; // Nullable double"
        }
      ]
    },
    {
      "id": "cs-6",
      "question": "Explain boxing and unboxing with examples.",
      "answer": [
        {
          "type": "text",
          "content": "Boxing is converting a value type to an object type. Unboxing is converting an object type back to a value type."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Boxing\nint num = 10;\nobject obj = num; // num is boxed\n\n// Unboxing\nint unboxedNum = (int)obj; // Explicit cast required"
        }
      ]
    },
    {
      "id": "cs-7",
      "question": "What is the difference between const, readonly, and static in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**const**: Value is assigned at compile-time and cannot be changed.",
            "**readonly**: Value is assigned at runtime, can be changed in the constructor.",
            "**static**: Shared across all instances of a class."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "const double PI = 3.14; // Compile-time constant\nreadonly int id; // Runtime constant\nstatic int counter; // Shared across instances"
        }
      ]
    },
    {
      "id": "cs-8",
      "question": "What are access modifiers in C#? Explain public, private, protected, and internal.",
      "answer": [
        {
          "type": "list",
          "items": [
            "**public**: Accessible from anywhere.",
            "**private**: Accessible only within the same class.",
            "**protected**: Accessible within the same class and derived classes.",
            "**internal**: Accessible within the same assembly."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Example {\n    public int publicVar;\n    private int privateVar;\n    protected int protectedVar;\n    internal int internalVar;\n}"
        }
      ]
    },
    {
      "id": "cs-9",
      "question": "Explain the concept of namespace in C#.",
      "answer": [
        {
          "type": "text",
          "content": "A namespace is a way to organize code and prevent naming conflicts in C#."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "namespace MyApp {\n    class Program {\n        static void Main() {\n            Console.WriteLine(\"Hello World\");\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-10",
      "question": "What is the difference between == and .Equals() in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**==**: Compares object references for reference types and values for value types.",
            "**.Equals()**: Can be overridden to compare contents instead of references."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "string a = \"hello\";\nstring b = \"hello\";\nConsole.WriteLine(a == b); // true (compares values)\nConsole.WriteLine(a.Equals(b)); // true (compares values)\n\nobject obj1 = new object();\nobject obj2 = new object();\nConsole.WriteLine(obj1 == obj2); // false (different references)\nConsole.WriteLine(obj1.Equals(obj2)); // false (default implementation)"
        }
      ]
    },
    {
      "id": "oop-1",
      "question": "What is object-oriented programming (OOP)?",
      "answer": [
        {
          "type": "text",
          "content": "Object-Oriented Programming (OOP) is a programming paradigm that organizes code into objects, which are instances of classes. It provides a structured way of designing programs using principles such as encapsulation, inheritance, polymorphism, and abstraction."
        },
        {
          "type": "list",
          "items": [
            "**Encapsulation**: Hides internal implementation details and only exposes necessary functionalities.",
            "**Inheritance**: Allows a class to inherit properties and methods from another class.",
            "**Polymorphism**: Enables a single interface to represent different data types.",
            "**Abstraction**: Hides complex implementation details and exposes only the necessary parts of an object."
          ]
        }
      ]
    },
    {
      "id": "oop-2",
      "question": "Explain encapsulation, inheritance, polymorphism, and abstraction in C#.",
      "answer": [
        {
          "type": "text",
          "content": "**Encapsulation**: The process of wrapping data and methods within a class and restricting direct access to some components."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Person {\n  private string name;\n  public string GetName() => name;\n  public void SetName(string newName) => name = newName;\n}"
        },
        {
          "type": "text",
          "content": "**Inheritance**: A mechanism where one class derives from another, reusing and extending its functionalities."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Animal { public void Eat() { Console.WriteLine(\"Eating\"); } }\nclass Dog : Animal { public void Bark() { Console.WriteLine(\"Barking\"); } }"
        },
        {
          "type": "text",
          "content": "**Polymorphism**: The ability of different classes to be treated as instances of the same class through a common interface."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Shape { public virtual void Draw() { Console.WriteLine(\"Drawing Shape\"); } }\nclass Circle : Shape { public override void Draw() { Console.WriteLine(\"Drawing Circle\"); } }"
        },
        {
          "type": "text",
          "content": "**Abstraction**: Hiding implementation details and exposing only essential functionalities."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "abstract class Vehicle {\n  public abstract void Move();\n}\nclass Car : Vehicle {\n  public override void Move() { Console.WriteLine(\"Car is moving\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-3",
      "question": "What is the difference between an abstract class and an interface?",
      "answer": [
        {
          "type": "text",
          "content": "An **abstract class** is a class that cannot be instantiated and may contain both abstract and non-abstract methods. An **interface** is a contract that defines only method signatures without implementation."
        },
        {
          "type": "list",
          "items": [
            "**Abstract Class**: Can have method implementations, fields, and constructors.",
            "**Interface**: Cannot have field members; only method signatures (before C# 8.0).",
            "**Abstract Class**: Used when classes share behavior.",
            "**Interface**: Used for multiple inheritance or enforcing behavior across classes."
          ]
        }
      ]
    },
    {
      "id": "oop-4",
      "question": "Can a class implement multiple interfaces in C#? Provide an example.",
      "answer": [
        {
          "type": "text",
          "content": "Yes, C# allows a class to implement multiple interfaces, enabling multiple inheritance of behavior."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "interface IA { void MethodA(); }\ninterface IB { void MethodB(); }\nclass MyClass : IA, IB {\n  public void MethodA() { Console.WriteLine(\"MethodA Implementation\"); }\n  public void MethodB() { Console.WriteLine(\"MethodB Implementation\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-5",
      "question": "What is method overloading and method overriding? Give examples.",
      "answer": [
        {
          "type": "text",
          "content": "**Method Overloading**: Defining multiple methods with the same name but different parameters."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class MathOps {\n  public int Add(int a, int b) => a + b;\n  public double Add(double a, double b) => a + b;\n}"
        },
        {
          "type": "text",
          "content": "**Method Overriding**: A derived class provides a new implementation for a method from the base class."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Base {\n  public virtual void Show() { Console.WriteLine(\"Base Show\"); }\n}\nclass Derived : Base {\n  public override void Show() { Console.WriteLine(\"Derived Show\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-6",
      "question": "What is a sealed class in C#? When would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "A **sealed class** prevents inheritance, ensuring no class can derive from it. It is used for security and performance reasons."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "sealed class Utility {\n  public void Display() { Console.WriteLine(\"Utility Class\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-7",
      "question": "How does C# support multiple inheritance?",
      "answer": [
        {
          "type": "text",
          "content": "C# does not support multiple inheritance with classes but allows multiple interface implementation."
        }
      ]
    },
    {
      "id": "oop-8",
      "question": "What is a partial class?",
      "answer": [
        {
          "type": "text",
          "content": "A **partial class** allows a class to be split across multiple files, making large class definitions easier to manage."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// File1.cs\npartial class MyClass {\n  public void Method1() { Console.WriteLine(\"Method1\"); }\n}\n// File2.cs\npartial class MyClass {\n  public void Method2() { Console.WriteLine(\"Method2\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-9",
      "question": "What is a static class in C#? When should it be used?",
      "answer": [
        {
          "type": "text",
          "content": "A **static class** cannot be instantiated and contains only static members. It is used for utility functions that do not require instance state."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "static class MathUtils {\n  public static int Square(int num) => num * num;\n}"
        }
      ]
    },
    {
      "id": "oop-10",
      "question": "What is the difference between a constructor and a destructor in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Constructor**: Initializes an object when it is created.",
            "**Destructor**: Cleans up resources when the object is destroyed.",
            "**Constructors**: Can be overloaded.",
            "**Destructors**: Cannot be overloaded."
          ]
        }
      ]
    },

    {
      "id": "cs-21",
      "question": "What are the different types of collections available in C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# provides various types of collections in the System.Collections and System.Collections.Generic namespaces."
        },
        {
          "type": "list",
          "items": [
            "**Array** - Fixed-size, type-safe collection of elements.",
            "**List<T>** - Dynamic array that grows as needed.",
            "**Dictionary<TKey, TValue>** - Key-value pair collection for fast lookups.",
            "**HashSet<T>** - Unordered collection of unique elements.",
            "**Queue<T>** - FIFO (First In, First Out) collection.",
            "**Stack<T>** - LIFO (Last In, First Out) collection.",
            "**LinkedList<T>** - Doubly linked list implementation.",
            "**SortedList<TKey, TValue>** - Sorted collection of key-value pairs.",
            "**SortedDictionary<TKey, TValue>** - A dictionary where keys are sorted.",
            "**ObservableCollection<T>** - A collection that notifies observers of changes."
          ]
        }
      ]
    },
    {
      "id": "cs-22",
      "question": "What is the difference between an Array and a List in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Array**: Fixed size, type-safe, and provides fast access to elements using indices.",
            "**List<T>**: Dynamic size, provides additional utility methods like Add, Remove, and supports LINQ operations.",
            "**Performance**: Arrays are faster due to fixed memory allocation, while Lists offer flexibility at the cost of minor performance overhead."
          ]
        }
      ]
    },
    {
      "id": "cs-23",
      "question": "Explain Stack and Queue with examples.",
      "answer": [
        {
          "type": "text",
          "content": "Stack and Queue are both linear data structures with different order of operations."
        },
        {
          "type": "text",
          "content": "**Stack (LIFO - Last In, First Out)**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Stack<int> stack = new Stack<int>();\nstack.Push(1);\nstack.Push(2);\nstack.Push(3);\nConsole.WriteLine(stack.Pop()); // Outputs: 3"
        },
        {
          "type": "text",
          "content": "**Queue (FIFO - First In, First Out)**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Queue<int> queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nqueue.Enqueue(3);\nConsole.WriteLine(queue.Dequeue()); // Outputs: 1"
        }
      ]
    },
    {
      "id": "cs-24",
      "question": "What is a Dictionary in C#? How does it differ from a List?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Dictionary<TKey, TValue>**: Stores key-value pairs and provides fast lookups by key.",
            "**List<T>**: Stores elements in an ordered manner, accessible by index.",
            "**Performance**: Dictionary lookup is faster (O(1)) compared to searching in a List (O(n) in worst case).",
            "**Use Case**: Use Dictionary for fast lookups and List for ordered collections where index-based access is required."
          ]
        }
      ]
    },
    {
      "id": "cs-25",
      "question": "What is the difference between IEnumerable<T> and IQueryable<T>?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**IEnumerable<T>**: Used for in-memory collection iteration, executes queries immediately.",
            "**IQueryable<T>**: Used for querying data from external sources (e.g., databases), supports deferred execution and optimization."
          ]
        }
      ]
    },
    {
      "id": "cs-26",
      "question": "What are hash tables and how are they implemented in C#?",
      "answer": [
        {
          "type": "text",
          "content": "A hash table is a data structure that stores key-value pairs using a hash function for fast lookups."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Hashtable hashtable = new Hashtable();\nhashtable.Add(\"key1\", \"value1\");\nhashtable.Add(\"key2\", \"value2\");\nConsole.WriteLine(hashtable[\"key1\"]); // Outputs: value1"
        }
      ]
    },
    {
      "id": "cs-27",
      "question": "What is the difference between List<T> and ArrayList?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**List<T>**: Type-safe, generic collection introduced in .NET 2.0.",
            "**ArrayList**: Non-generic, stores objects of any type (boxing/unboxing overhead).",
            "**Performance**: List<T> is faster due to type safety and no need for type conversions."
          ]
        }
      ]
    },
    {
      "id": "cs-28",
      "question": "Explain LINQ (Language Integrated Query) and its benefits.",
      "answer": [
        {
          "type": "text",
          "content": "LINQ (Language Integrated Query) allows querying collections using C# syntax."
        },
        {
          "type": "list",
          "items": [
            "Improves code readability.",
            "Reduces the need for loops and conditional statements.",
            "Supports multiple data sources (collections, XML, databases)."
          ]
        }
      ]
    },
    {
      "id": "cs-29",
      "question": "What is the difference between First() and FirstOrDefault() in LINQ?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**First()**: Returns the first element, throws an exception if no elements exist.",
            "**FirstOrDefault()**: Returns the first element or default value (null for reference types, 0 for int, etc.) if none exist."
          ]
        }
      ]
    },
    {
      "id": "cs-30",
      "question": "What is the difference between Select and SelectMany in LINQ?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Select**: Projects each element into a new form (1-to-1 mapping).",
            "**SelectMany**: Flattens nested collections into a single sequence (1-to-many mapping)."
          ]
        }
      ]
    },
    {
      "id": "cs-17",
      "question": "How does C# support multiple inheritance?",
      "answer": [
        {
          "type": "text",
          "content": "C# does not support multiple inheritance directly. Instead, it uses interfaces to achieve similar functionality."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "interface IA { void MethodA(); }\ninterface IB { void MethodB(); }\nclass C : IA, IB { public void MethodA() {} public void MethodB() {} }"
        }
      ]
    },
    {
      "id": "cs-18",
      "question": "What is a partial class?",
      "answer": [
        {
          "type": "text",
          "content": "A partial class allows splitting a class definition across multiple files for better organization."
        }
      ]
    },
    {
      "id": "cs-19",
      "question": "What is a static class in C#? When should it be used?",
      "answer": [
        {
          "type": "text",
          "content": "A static class contains only static members and cannot be instantiated. It is used for utility methods."
        }
      ]
    },
    {
      "id": "cs-20",
      "question": "What is the difference between a constructor and a destructor in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Constructor**: Initializes an object when it is created.",
            "**Destructor**: Cleans up resources before an object is garbage collected."
          ]
        }
      ]
    },

    {
      "id": "cs-31",
      "question": "What is multithreading in C#? How does it improve performance?",
      "answer": [
        {
          "type": "text",
          "content": "Multithreading in C# is a feature that allows multiple threads to run concurrently, enabling parallel execution of tasks. It improves performance by utilizing multiple cores of a CPU efficiently and ensuring responsiveness in applications."
        },
        {
          "type": "text",
          "content": "Benefits of multithreading:"
        },
        {
          "type": "list",
          "items": [
            "Improves application responsiveness (e.g., UI remains responsive while executing background tasks).",
            "Enhances CPU utilization by running multiple tasks in parallel.",
            "Reduces execution time by dividing work among threads."
          ]
        },
        {
          "type": "text",
          "content": "Example of creating and starting a thread in C#:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading;\n\nclass Program {\n    static void PrintNumbers() {\n        for (int i = 1; i <= 5; i++) {\n            Console.WriteLine(i);\n            Thread.Sleep(500); // Simulating work\n        }\n    }\n\n    static void Main() {\n        Thread thread = new Thread(PrintNumbers);\n        thread.Start();\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-32",
      "question": "Explain Thread vs Task in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Both `Thread` and `Task` are used for parallel execution in C#, but they have different use cases."
        },
        {
          "type": "text",
          "content": "Key differences:"
        },
        {
          "type": "list",
          "items": [
            "**Thread:** Lower-level construct that represents a dedicated system thread.",
            "**Task:** Higher-level abstraction from the Task Parallel Library (TPL) that manages threads internally."
          ]
        },
        {
          "type": "text",
          "content": "Example using Thread:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Thread thread = new Thread(() => Console.WriteLine(\"Running in thread\"));\nthread.Start();"
        },
        {
          "type": "text",
          "content": "Example using Task:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Task.Run(() => Console.WriteLine(\"Running in task\"));"
        }
      ]
    },
    {
      "id": "cs-33",
      "question": "What is the difference between async and await in C#?",
      "answer": [
        {
          "type": "text",
          "content": "`async` and `await` are used for asynchronous programming in C#."
        },
        {
          "type": "text",
          "content": "Key differences:"
        },
        {
          "type": "list",
          "items": [
            "**async:** Used to define an asynchronous method. It allows the method to return a `Task`.",
            "**await:** Suspends execution of the async method until the awaited task completes, preventing blocking."
          ]
        },
        {
          "type": "text",
          "content": "Example:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "async Task<int> GetDataAsync() {\n    await Task.Delay(1000); // Simulate async operation\n    return 42;\n}\n\nasync Task Main() {\n    int result = await GetDataAsync();\n    Console.WriteLine(result);\n}"
        }
      ]
    },
    {
      "id": "cs-34",
      "question": "What is deadlock, and how do you prevent it?",
      "answer": [
        {
          "type": "text",
          "content": "A deadlock occurs when two or more threads are waiting indefinitely for resources locked by each other, causing a circular wait."
        },
        {
          "type": "text",
          "content": "Ways to prevent deadlocks:"
        },
        {
          "type": "list",
          "items": [
            "Avoid nested locks.",
            "Use lock timeouts.",
            "Follow a consistent locking order.",
            "Use `Monitor.TryEnter` or `Mutex` with timeout."
          ]
        }
      ]
    },
    {
      "id": "cs-35",
      "question": "What are Task.Run() and Task.Delay() used for in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "`Task.Run()`: Executes a method asynchronously on a thread pool.",
            "`Task.Delay()`: Introduces an asynchronous delay without blocking the thread."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "await Task.Run(() => Console.WriteLine(\"Running in Task\"));\nawait Task.Delay(1000); // Wait for 1 second"
        }
      ]
    },
    {
      "id": "cs-36",
      "question": "How does the lock keyword work in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The `lock` keyword ensures that only one thread can access a critical section at a time."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "private static object locker = new object();\n\nlock (locker) {\n    // Critical section\n}"
        }
      ]
    },
    {
      "id": "cs-37",
      "question": "What are concurrent collections in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Concurrent collections are thread-safe collections provided by `System.Collections.Concurrent`."
        },
        {
          "type": "list",
          "items": [
            "`ConcurrentDictionary<TKey, TValue>`",
            "`ConcurrentQueue<T>`",
            "`ConcurrentStack<T>`",
            "`ConcurrentBag<T>`"
          ]
        }
      ]
    },
    {
      "id": "cs-38",
      "question": "Explain CancellationToken and its usage in asynchronous programming.",
      "answer": [
        {
          "type": "text",
          "content": "CancellationToken is used to cancel async operations in C#."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "CancellationTokenSource cts = new CancellationTokenSource();\nawait Task.Run(() => {\n    if (cts.Token.IsCancellationRequested) return;\n});"
        }
      ]
    },
    {
      "id": "cs-39",
      "question": "What is TPL (Task Parallel Library)?",
      "answer": [
        {
          "type": "text",
          "content": "The Task Parallel Library (TPL) is a framework in C# for parallel execution of tasks, making multithreading easier."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Task t = Task.Run(() => Console.WriteLine(\"Running task\"));"
        }
      ]
    },
    {
      "id": "cs-40",
      "question": "How does Parallel.ForEach work in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Parallel.ForEach enables parallel execution over collections."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Parallel.ForEach(Enumerable.Range(1, 10), (i) => {\n    Console.WriteLine(i);\n});"
        }
      ]
    },
    {
      "id": "cs-41",
      "question": "What is Garbage Collection (GC) in C#? How does it work?",
      "answer": [
        {
          "type": "text",
          "content": "Garbage Collection (GC) in C# is an automatic memory management feature provided by the .NET runtime. It helps in reclaiming memory occupied by objects that are no longer in use, preventing memory leaks."
        },
        {
          "type": "text",
          "content": "How it works:"
        },
        {
          "type": "list",
          "items": [
            "**Generational Garbage Collection**: Objects are divided into three generations (Gen 0, Gen 1, Gen 2) based on their lifespan.",
            "**Mark-and-Sweep Algorithm**: The GC identifies objects that are no longer reachable and removes them.",
            "**Compacting**: After collection, the memory is compacted to reduce fragmentation.",
            "**Finalization**: If an object has a finalizer, GC runs it before reclaiming memory."
          ]
        }
      ]
    },
    {
      "id": "cs-42",
      "question": "What are finalizers in C#?",
      "answer": [
        {
          "type": "text",
          "content": "A finalizer is a special method in C# that is used to perform cleanup operations before an object is garbage collected."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class MyClass\n{\n    ~MyClass()\n    {\n        // Cleanup code before object destruction\n        Console.WriteLine(\"Finalizer called\");\n    }\n}"
        },
        {
          "type": "text",
          "content": "Finalizers are non-deterministic and should be avoided unless necessary. Instead, IDisposable should be used for cleanup."
        }
      ]
    },
    {
      "id": "cs-43",
      "question": "What is the difference between Dispose() and Finalize()?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Dispose()**: Used for deterministic cleanup, part of IDisposable interface, explicitly called by the developer.",
            "**Finalize()**: Called by the Garbage Collector, used for non-managed resources cleanup, runs unpredictably."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class MyClass : IDisposable\n{\n    public void Dispose()\n    {\n        // Cleanup resources\n        GC.SuppressFinalize(this); // Prevent finalizer call\n    }\n    ~MyClass()\n    {\n        // Finalizer\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-44",
      "question": "How do you manage memory leaks in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "Use **IDisposable** for resources like database connections, files, etc.",
            "Use the **using** statement to automatically dispose objects.",
            "Avoid static references that prevent objects from being collected.",
            "Monitor memory usage using **dotMemory, PerfMon, or GC.GetTotalMemory()**.",
            "Unsubscribe from events to prevent memory leaks due to event handler references."
          ]
        }
      ]
    },
    {
      "id": "cs-45",
      "question": "What is the using statement in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The `using` statement in C# is used to ensure that objects implementing IDisposable are disposed of properly, avoiding memory leaks."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using (StreamReader reader = new StreamReader(\"file.txt\"))\n{\n    string content = reader.ReadToEnd();\n}"
        }
      ]
    },
    {
      "id": "cs-46",
      "question": "What is Dependency Injection (DI) and how is it implemented in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern that helps in managing dependencies between objects by injecting them rather than creating them within a class."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IService { void Serve(); }\npublic class MyService : IService { public void Serve() => Console.WriteLine(\"Service called\"); }\n\npublic class Client\n{\n    private readonly IService _service;\n    public Client(IService service) { _service = service; }\n    public void Start() { _service.Serve(); }\n}\n\n// Dependency Injection using .NET Core DI Container\nvar services = new ServiceCollection();\nservices.AddTransient<IService, MyService>();\nvar provider = services.BuildServiceProvider();\nvar client = provider.GetService<Client>();\nclient?.Start();"
        }
      ]
    },
    {
      "id": "cs-47",
      "question": "What is Reflection in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Reflection in C# allows runtime inspection of assemblies, modules, and types. It enables dynamic object creation and method invocation."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Type type = typeof(String);\nMethodInfo method = type.GetMethod(\"Substring\", new Type[] { typeof(int) });\nConsole.WriteLine(method.ReturnType);"
        }
      ]
    },
    {
      "id": "cs-48",
      "question": "Explain delegates and events in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Delegates are type-safe function pointers that allow methods to be passed as parameters. Events are built on delegates and provide a mechanism for publishing and subscribing to notifications."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public delegate void Notify();\npublic class Process\n{\n    public event Notify OnProcessCompleted;\n    public void Start() { OnProcessCompleted?.Invoke(); }\n}\n\n// Usage\nProcess process = new Process();\nprocess.OnProcessCompleted += () => Console.WriteLine(\"Process completed\");\nprocess.Start();"
        }
      ]
    },
    {
      "id": "cs-49",
      "question": "What is the difference between Func, Action, and Predicate in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Func<T>**: Represents a method that returns a value.",
            "**Action<T>**: Represents a method that does not return a value.",
            "**Predicate<T>**: Represents a method that returns a boolean value."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Func<int, int> square = x => x * x; // Returns value\nAction<string> print = msg => Console.WriteLine(msg); // No return value\nPredicate<int> isEven = x => x % 2 == 0; // Returns boolean"
        }
      ]
    },
    {
      "id": "cs-50",
      "question": "What is Entity Framework (EF) and how does it work with C#?",
      "answer": [
        {
          "type": "text",
          "content": "Entity Framework (EF) is an ORM (Object-Relational Mapper) for .NET that simplifies database interactions by allowing developers to work with database entities as C# objects."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class AppDbContext : DbContext\n{\n    public DbSet<Product> Products { get; set; }\n}\n\n// Usage\nusing (var context = new AppDbContext())\n{\n    context.Products.Add(new Product { Name = \"Laptop\" });\n    context.SaveChanges();\n}"
        }
      ]
    },
    {
      "id": "cs-1",
      "question": "Implement a generic repository pattern in C# using EF Core.",
      "answer": [
        {
          "type": "text",
          "content": "The generic repository pattern in C# using Entity Framework Core provides a reusable and maintainable way to interact with the database."
        },
        {
          "type": "text",
          "content": "Key benefits of using the repository pattern:"
        },
        {
          "type": "list",
          "items": [
            "Encapsulates data access logic, improving maintainability",
            "Reduces code duplication",
            "Enhances testability by providing an abstraction layer over EF Core"
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IRepository<T> where T : class\n{\n    Task<IEnumerable<T>> GetAllAsync();\n    Task<T> GetByIdAsync(int id);\n    Task AddAsync(T entity);\n    Task UpdateAsync(T entity);\n    Task DeleteAsync(int id);\n}\n\npublic class Repository<T> : IRepository<T> where T : class\n{\n    private readonly DbContext _context;\n    private readonly DbSet<T> _dbSet;\n\n    public Repository(DbContext context)\n    {\n        _context = context;\n        _dbSet = context.Set<T>();\n    }\n\n    public async Task<IEnumerable<T>> GetAllAsync() => await _dbSet.ToListAsync();\n    public async Task<T> GetByIdAsync(int id) => await _dbSet.FindAsync(id);\n    public async Task AddAsync(T entity) { await _dbSet.AddAsync(entity); await _context.SaveChangesAsync(); }\n    public async Task UpdateAsync(T entity) { _dbSet.Update(entity); await _context.SaveChangesAsync(); }\n    public async Task DeleteAsync(int id) { var entity = await GetByIdAsync(id); if (entity != null) { _dbSet.Remove(entity); await _context.SaveChangesAsync(); } }\n}"
        }
      ]
    },
    {
      "id": "cs-2",
      "question": "Write an in-memory caching mechanism in C#.",
      "answer": [
        {
          "type": "text",
          "content": "In-memory caching improves performance by reducing redundant database or API calls."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class MemoryCacheService\n{\n    private readonly IMemoryCache _cache;\n    public MemoryCacheService(IMemoryCache cache) { _cache = cache; }\n\n    public T GetOrCreate<T>(string key, Func<T> createItem, TimeSpan cacheDuration)\n    {\n        if (!_cache.TryGetValue(key, out T value))\n        {\n            value = createItem();\n            _cache.Set(key, value, cacheDuration);\n        }\n        return value;\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-3",
      "question": "Implement a distributed lock system in C# using Redis.",
      "answer": [
        {
          "type": "text",
          "content": "Distributed locking ensures that multiple instances of an application do not execute critical sections simultaneously."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public async Task<bool> AcquireLockAsync(string key, TimeSpan expiration)\n{\n    using var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var db = redis.GetDatabase();\n    return await db.StringSetAsync(key, \"locked\", expiration, When.NotExists);\n}\n\npublic async Task ReleaseLockAsync(string key)\n{\n    using var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var db = redis.GetDatabase();\n    await db.KeyDeleteAsync(key);\n}"
        }
      ]
    },
    {
      "id": "cs-4",
      "question": "Write a high-performance API in C# using ASP.NET Core.",
      "answer": [
        {
          "type": "text",
          "content": "Optimizing ASP.NET Core APIs for high performance includes techniques such as response caching, efficient database queries, and using asynchronous programming."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "[ApiController]\n[Route(\"api/[controller]\")]\npublic class PerformanceController : ControllerBase\n{\n    [HttpGet(\"data\")] \n    [ResponseCache(Duration = 60)]\n    public async Task<IActionResult> GetDataAsync()\n    {\n        var data = await GetDataFromDbAsync(); // Simulated async data fetch\n        return Ok(data);\n    }\n\n    private Task<string[]> GetDataFromDbAsync() => Task.FromResult(new[] { \"Item1\", \"Item2\" });\n}"
        }
      ]
    },
    {
      "id": "cs-5",
      "question": "Implement a message queue in C# using RabbitMQ or Azure Service Bus.",
      "answer": [
        {
          "type": "text",
          "content": "Message queues help in building scalable and decoupled applications. RabbitMQ and Azure Service Bus are popular message brokers."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public async Task SendMessageAsync(string message)\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\" };\n    using var connection = factory.CreateConnection();\n    using var channel = connection.CreateModel();\n    channel.QueueDeclare(queue: \"task_queue\", durable: true, exclusive: false, autoDelete: false, arguments: null);\n    var body = Encoding.UTF8.GetBytes(message);\n    var properties = channel.CreateBasicProperties();\n    properties.Persistent = true;\n    channel.BasicPublish(exchange: \"\", routingKey: \"task_queue\", basicProperties: properties, body: body);\n}"
        }
      ]
    },
    {
      "id": "cs-1",
      "question": "Explain the syntax and usage of Func and Action in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Func and Action are predefined delegates in C# used for encapsulating methods with different signatures."
        },
        {
          "type": "text",
          "content": "**Func<T, TResult>**:"
        },
        {
          "type": "list",
          "items": [
            "Func is a generic delegate that represents a method that returns a value.",
            "It can take up to 16 input parameters.",
            "The last generic parameter is always the return type."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Func<int, int, int> add = (a, b) => a + b;\nint result = add(5, 10); // Output: 15"
        },
        {
          "type": "text",
          "content": "**Action<T>**:"
        },
        {
          "type": "list",
          "items": [
            "Action is a generic delegate that represents a method with parameters but no return value.",
            "It can take up to 16 input parameters."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Action<string> greet = name => Console.WriteLine($\"Hello, {name}!\");\ngreet(\"Alice\"); // Output: Hello, Alice!"
        }
      ]
    },
    {
      "id": "cs-2",
      "question": "Explain the syntax and usage of delegates and events in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Delegates are type-safe pointers to methods, and events are a special kind of delegate used for notifications."
        },
        {
          "type": "text",
          "content": "**Delegate Syntax:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Define a delegate\ndelegate void Notify(string message);\n\n// Use the delegate\nclass Program {\n    static void DisplayMessage(string msg) {\n        Console.WriteLine(msg);\n    }\n    static void Main() {\n        Notify notifier = DisplayMessage;\n        notifier(\"Hello, Delegates!\"); // Output: Hello, Delegates!\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Event Syntax:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Publisher {\n    public event Action<string> OnNotify;\n    \n    public void TriggerEvent() {\n        OnNotify?.Invoke(\"Event triggered!\");\n    }\n}\n\nclass Subscriber {\n    static void Main() {\n        Publisher pub = new Publisher();\n        pub.OnNotify += msg => Console.WriteLine(msg);\n        pub.TriggerEvent(); // Output: Event triggered!\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-3",
      "question": "Explain the syntax and usage of generics in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Generics allow defining classes, interfaces, and methods with a placeholder for data types, providing type safety and code reusability."
        },
        {
          "type": "text",
          "content": "**Generic Class Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class GenericBox<T> {\n    private T value;\n    public void SetValue(T val) {\n        value = val;\n    }\n    public T GetValue() {\n        return value;\n    }\n}\n\nclass Program {\n    static void Main() {\n        GenericBox<int> intBox = new GenericBox<int>();\n        intBox.SetValue(42);\n        Console.WriteLine(intBox.GetValue()); // Output: 42\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Generic Method Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Program {\n    static void Swap<T>(ref T a, ref T b) {\n        T temp = a;\n        a = b;\n        b = temp;\n    }\n    static void Main() {\n        int x = 5, y = 10;\n        Swap(ref x, ref y);\n        Console.WriteLine($\"x: {x}, y: {y}\"); // Output: x: 10, y: 5\n    }\n}"
        }
      ]
    }
  ],
  "backend-dotnet": [
    {
      "id": "dotnet-1",
      "question": "Why should I use .NET Core, and what are its best features?",
      "answer": [
        {
          "type": "text",
          "content": ".NET Core (now evolved into .NET 6+ as part of unified .NET) is a modern, open-source, cross-platform framework developed by Microsoft. It is designed for building high-performance, scalable, and cloud-ready applications."
        },
        {
          "type": "text",
          "content": "Here are the key reasons why you should use .NET Core:"
        },
        {
          "type": "list",
          "items": [
            "**Cross-Platform**: .NET Core runs on Windows, Linux, and macOS, making it ideal for cloud and container-based deployments.",
            "**High Performance**: It is one of the fastest frameworks for web applications, optimized for high throughput and low memory usage.",
            "**Microservices Architecture**: .NET Core supports the development of microservices-based applications using Docker and Kubernetes.",
            "**Modern Development Support**: It includes support for asynchronous programming, dependency injection, and modern APIs.",
            "**Open Source and Community-Driven**: Unlike the older .NET Framework, .NET Core is open-source and constantly evolving with contributions from the community.",
            "**Unified Platform**: .NET Core supports multiple application types, including web apps (ASP.NET Core), desktop apps (via .NET 6+), IoT, and gaming (Unity).",
            "**Better Security and Maintainability**: It receives frequent updates and security patches due to its open-source nature and Microsoftâ€™s long-term support.",
            "**Cloud-Ready**: Designed to work seamlessly with cloud services like Azure, AWS, and Google Cloud."
          ]
        },
        {
          "type": "text",
          "content": "Example: A simple ASP.NET Core Web API"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class HelloWorldController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get()\n    {\n        return Ok(\"Hello, .NET Core World!\");\n    }\n}"
        },
        {
          "type": "text",
          "content": "This example demonstrates how easy it is to create a minimal Web API using .NET Core with built-in dependency injection and routing."
        }
      ]
    },
    {
      "id": "dotnet-1",
      "question": "How does .NET compile code and generate executables?",
      "answer": [
        {
          "type": "text",
          "content": ".NET follows a multi-step compilation process to generate executable files. The compilation process involves the following steps:"
        },
        {
          "type": "list",
          "items": [
            "**Source Code Compilation**: The .NET compiler (like `csc` for C#) compiles source code into an intermediate representation called CIL (Common Intermediate Language).",
            "**Assembly Generation**: The compiled CIL is stored in assemblies (`.exe` or `.dll` files) along with metadata about types and methods.",
            "**JIT Compilation**: At runtime, the .NET Just-In-Time (JIT) compiler converts CIL into native machine code for execution.",
            "**Execution by the CLR**: The Common Language Runtime (CLR) executes the native code, manages memory, garbage collection, and enforces security."
          ]
        },
        {
          "type": "text",
          "content": "### Example: Compilation and Execution"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Sample C# Program\nusing System;\n\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Hello, .NET!\");\n    }\n}"
        },
        {
          "type": "text",
          "content": "#### Step 1: Compile the code"
        },
        {
          "type": "code",
          "language": "bash",
          "content": "csc Program.cs  # Compiles to Program.exe"
        },
        {
          "type": "text",
          "content": "This generates a `Program.exe` file containing CIL."
        },
        {
          "type": "text",
          "content": "#### Step 2: Inspect the CIL (Intermediate Language)"
        },
        {
          "type": "code",
          "language": "bash",
          "content": "ildasm Program.exe  # Opens IL disassembler to view CIL"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": ".method private hidebysig static void Main() cil managed {\n    .entrypoint\n    IL_0000: ldstr \"Hello, .NET!\"\n    IL_0005: call void [System.Console]::WriteLine(string)\n    IL_000a: ret\n}"
        },
        {
          "type": "text",
          "content": "#### Step 3: Run the Executable"
        },
        {
          "type": "code",
          "language": "bash",
          "content": "./Program.exe  # Outputs 'Hello, .NET!'"
        },
        {
          "type": "text",
          "content": "### Summary\n- C# source code â†’ compiled into CIL (.exe/.dll)\n- CIL is Just-In-Time compiled to native code\n- CLR manages execution, memory, and security"
        }
      ]
    },
    {
      "id": "dotnet-1",
      "question": "Explain the difference between value types and reference types in C#.",
      "answer": [
        {
          "type": "text",
          "content": "In C#, data types are categorized as value types and reference types based on how they are stored in memory."
        },
        {
          "type": "text",
          "content": "**Value Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in the stack",
            "Hold actual data",
            "Assignment creates a copy",
            "Examples: `int`, `float`, `double`, `char`, `bool`, `struct`"
          ]
        },
        {
          "type": "text",
          "content": "**Reference Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in the heap (reference stored in the stack)",
            "Hold a reference to the actual object",
            "Assignment copies the reference, not the actual data",
            "Examples: `class`, `string`, `array`, `interface`, `delegate`"
          ]
        },
        {
          "type": "text",
          "content": "**Example demonstrating value vs. reference types:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\n\nclass Program\n{\n    struct ValueTypeExample {\n        public int Number;\n    }\n    class ReferenceTypeExample {\n        public int Number;\n    }\n\n    static void Main() {\n        ValueTypeExample val1 = new ValueTypeExample { Number = 10 };\n        ValueTypeExample val2 = val1; // Copy of data\n        val2.Number = 20;\n        Console.WriteLine(val1.Number); // Output: 10 (Unchanged)\n        \n        ReferenceTypeExample ref1 = new ReferenceTypeExample { Number = 10 };\n        ReferenceTypeExample ref2 = ref1; // Reference to the same object\n        ref2.Number = 20;\n        Console.WriteLine(ref1.Number); // Output: 20 (Changed)\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-2",
      "question": "What is Dependency Injection (DI) in .NET Core and how does it work?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern that enables better modularity and testability by injecting dependencies instead of hardcoding them inside a class."
        },
        {
          "type": "text",
          "content": "**Types of Dependency Injection:**"
        },
        {
          "type": "list",
          "items": [
            "Constructor Injection (Most commonly used)",
            "Method Injection",
            "Property Injection"
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Dependency Injection in .NET Core**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.Extensions.DependencyInjection;\nusing System;\n\npublic interface IService {\n    void PrintMessage();\n}\npublic class MyService : IService {\n    public void PrintMessage() => Console.WriteLine(\"Hello from MyService\");\n}\n\nclass Program {\n    static void Main() {\n        var services = new ServiceCollection();\n        services.AddTransient<IService, MyService>(); // Register DI\n        var provider = services.BuildServiceProvider();\n        var service = provider.GetService<IService>();\n        service.PrintMessage(); // Output: Hello from MyService\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-3",
      "question": "What is async/await in C#? How does it improve performance?",
      "answer": [
        {
          "type": "text",
          "content": "Async/Await is used in C# to perform asynchronous programming, allowing non-blocking execution of I/O-bound or long-running operations."
        },
        {
          "type": "text",
          "content": "**Benefits of async/await:**"
        },
        {
          "type": "list",
          "items": [
            "Prevents blocking the main thread",
            "Allows handling of multiple tasks concurrently",
            "Improves responsiveness of applications"
          ]
        },
        {
          "type": "text",
          "content": "**Example of async/await in C#:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program {\n    static async Task Main() {\n        Console.WriteLine(\"Fetching data...\");\n        string result = await GetDataAsync();\n        Console.WriteLine(result);\n    }\n\n    static async Task<string> GetDataAsync() {\n        await Task.Delay(3000); // Simulating delay\n        return \"Data retrieved successfully!\";\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-4",
      "question": "What is the difference between `IEnumerable`, `IQueryable`, `ICollection`, and `List` in C#?",
      "answer": [
        {
          "type": "text",
          "content": "**IEnumerable<T>:**\n- Used for in-memory and LINQ-to-Objects queries.\n- Supports forward-only iteration.\n- Lazy loading is not supported."
        },
        {
          "type": "text",
          "content": "**IQueryable<T>:**\n- Used for querying remote data sources like databases (Entity Framework).\n- Executes queries at the database level."
        },
        {
          "type": "text",
          "content": "**ICollection<T>:**\n- Supports adding/removing elements.\n- Inherits from `IEnumerable<T>`."
        },
        {
          "type": "text",
          "content": "**List<T>:**\n- Implements `ICollection<T>` and `IEnumerable<T>`.\n- Provides random access via indexing."
        }
      ]
    },
    {
      "id": "dotnet-5",
      "question": "Explain Middleware in ASP.NET Core. How does the request pipeline work?",
      "answer": [
        {
          "type": "text",
          "content": "Middleware in ASP.NET Core is a sequence of components that handle HTTP requests and responses."
        },
        {
          "type": "text",
          "content": "**Example of Custom Middleware in .NET Core:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\nusing System.Threading.Tasks;\n\npublic class CustomMiddleware {\n    private readonly RequestDelegate _next;\n\n    public CustomMiddleware(RequestDelegate next) {\n        _next = next;\n    }\n\n    public async Task Invoke(HttpContext context) {\n        Console.WriteLine(\"Request: \" + context.Request.Path);\n        await _next(context);\n        Console.WriteLine(\"Response: \" + context.Response.StatusCode);\n    }\n}\n\npublic static class MiddlewareExtensions {\n    public static IApplicationBuilder UseCustomMiddleware(this IApplicationBuilder builder) {\n        return builder.UseMiddleware<CustomMiddleware>();\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-6",
      "question": "What are best practices for dependency injection in .NET Core?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a fundamental pattern in .NET Core for managing dependencies in a loosely coupled manner."
        },
        {
          "type": "text",
          "content": "**Best Practices:**"
        },
        {
          "type": "list",
          "items": [
            "Use Constructor Injection instead of Property Injection.",
            "Use the built-in .NET Core DI container unless a third-party container is necessary.",
            "Register services with the appropriate lifetimes (Transient, Scoped, Singleton).",
            "Avoid direct instantiation of dependencies using `new` inside classes.",
            "Use interfaces to abstract dependencies."
          ]
        },
        {
          "type": "text",
          "content": "**Example of DI in .NET Core:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IRepository {\n    void GetData();\n}\npublic class Repository : IRepository {\n    public void GetData() => Console.WriteLine(\"Fetching Data...\");\n}\npublic class Service {\n    private readonly IRepository _repository;\n    public Service(IRepository repository) {\n        _repository = repository;\n    }\n    public void Process() {\n        _repository.GetData();\n    }\n}\nvar services = new ServiceCollection();\nservices.AddTransient<IRepository, Repository>();\nvar provider = services.BuildServiceProvider();\nvar service = provider.GetService<Service>();\nservice?.Process();"
        }
      ]
    },
    {
      "id": "dotnet-7",
      "question": "How does async/await work internally in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The async/await mechanism in C# allows for asynchronous programming without blocking threads. It internally utilizes the `Task`-based asynchronous pattern (TAP) and the state machine concept."
        },
        {
          "type": "text",
          "content": "**Key concepts:**"
        },
        {
          "type": "list",
          "items": [
            "`async` keyword marks a method as asynchronous.",
            "`await` keyword suspends execution until the awaited task completes.",
            "The compiler rewrites `async` methods into a state machine that executes callbacks on completion.",
            "If `ConfigureAwait(false)` is used, the continuation does not return to the original context."
          ]
        },
        {
          "type": "text",
          "content": "**Example of async/await usage:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program {\n    static async Task Main() {\n        Console.WriteLine(\"Start fetching data...\");\n        string data = await GetDataAsync();\n        Console.WriteLine(data);\n    }\n\n    static async Task<string> GetDataAsync() {\n        await Task.Delay(3000);\n        return \"Data fetched successfully!\";\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-8",
      "question": "Explain IQueryable vs. IEnumerable â€“ when would you use each?",
      "answer": [
        {
          "type": "text",
          "content": "**IEnumerable<T>:**"
        },
        {
          "type": "list",
          "items": [
            "Executes queries in-memory.",
            "Does not support query translation into SQL.",
            "Best for working with in-memory collections."
          ]
        },
        {
          "type": "text",
          "content": "**IQueryable<T>:**"
        },
        {
          "type": "list",
          "items": [
            "Executes queries at the database level (deferred execution).",
            "Supports query translation into SQL.",
            "Best for performance when querying databases using Entity Framework."
          ]
        },
        {
          "type": "text",
          "content": "**Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "var data = dbContext.Users.AsEnumerable(); // Executed in-memory\nvar data = dbContext.Users.AsQueryable();  // Executed as SQL query in DB"
        }
      ]
    },
    {
      "id": "dotnet-9",
      "question": "How do you implement a background worker service in .NET Core?",
      "answer": [
        {
          "type": "text",
          "content": "In .NET Core, background worker services are implemented using `IHostedService` or by extending `BackgroundService`."
        },
        {
          "type": "text",
          "content": "**Example of a Background Service:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class MyBackgroundService : BackgroundService {\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {\n        while (!stoppingToken.IsCancellationRequested) {\n            Console.WriteLine(\"Background task running...\");\n            await Task.Delay(5000, stoppingToken);\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-10",
      "question": "How would you optimize EF Core queries to improve performance?",
      "answer": [
        {
          "type": "text",
          "content": "To optimize EF Core queries, consider the following best practices:"
        },
        {
          "type": "list",
          "items": [
            "Use `.AsNoTracking()` for read-only queries to avoid unnecessary tracking.",
            "Use `.Select()` to fetch only necessary columns instead of full entities.",
            "Apply pagination with `Skip()` and `Take()` to avoid fetching large data sets.",
            "Use compiled queries for frequently used queries.",
            "Avoid lazy loading when unnecessary and prefer eager loading (`Include()`).",
            "Use raw SQL queries (`FromSqlRaw`) for complex queries."
          ]
        },
        {
          "type": "text",
          "content": "**Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "var users = dbContext.Users.AsNoTracking()\n                          .Where(u => u.Age > 30)\n                          .Select(u => new { u.Name, u.Email })\n                          .ToList();"
        }
      ]
    },
    {
      "id": "dotnet-11",
      "question": "What is SignalR, and when would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "SignalR is a real-time communication library in ASP.NET Core that enables bi-directional communication between servers and clients."
        },
        {
          "type": "text",
          "content": "**Use Cases:**"
        },
        {
          "type": "list",
          "items": [
            "Chat applications",
            "Live dashboards and notifications",
            "Collaborative applications (e.g., Google Docs-like features)",
            "Real-time stock market updates"
          ]
        },
        {
          "type": "text",
          "content": "**Example of SignalR implementation:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class ChatHub : Hub {\n    public async Task SendMessage(string user, string message) {\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-4",
      "question": "What are the SOLID principles, and how have you applied them in C# projects?",
      "answer": [
        {
          "type": "text",
          "content": "SOLID is a set of five design principles that improve maintainability and scalability in object-oriented design."
        },
        {
          "type": "list",
          "items": [
            "**S - Single Responsibility Principle (SRP):** A class should have only one reason to change.",
            "**O - Open/Closed Principle (OCP):** Software entities should be open for extension but closed for modification.",
            "**L - Liskov Substitution Principle (LSP):** Derived classes must be substitutable for their base classes.",
            "**I - Interface Segregation Principle (ISP):** Clients should not be forced to depend on interfaces they do not use.",
            "**D - Dependency Inversion Principle (DIP):** High-level modules should not depend on low-level modules. Both should depend on abstractions."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Applying SOLID in C#**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IEmailService {\n    void SendEmail(string to, string message);\n}\n\npublic class EmailService : IEmailService {\n    public void SendEmail(string to, string message) {\n        Console.WriteLine($\"Sending Email to {to}: {message}\");\n    }\n}\n\npublic class NotificationService {\n    private readonly IEmailService _emailService;\n    public NotificationService(IEmailService emailService) {\n        _emailService = emailService;\n    }\n    public void NotifyUser(string user, string message) {\n        _emailService.SendEmail(user, message);\n    }\n}\n"
        }
      ]
    },
    {
      "id": "dotnet-5",
      "question": "How do you implement event-driven architecture in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Event-driven architecture (EDA) is a design pattern in which system components communicate via events rather than direct method calls."
        },
        {
          "type": "text",
          "content": "**Ways to implement Event-Driven Architecture:**"
        },
        {
          "type": "list",
          "items": [
            "Using C# Events & Delegates",
            "Message Queues (RabbitMQ, Kafka, Azure Service Bus)",
            "Event Bus (MediatR pattern in .NET)"
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using C# Events & Delegates for Event-Driven Architecture**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class EventPublisher {\n    public delegate void Notify(string message);\n    public event Notify OnNotification;\n    public void SendNotification(string message) {\n        OnNotification?.Invoke(message);\n    }\n}\n\nclass Program {\n    static void Main() {\n        EventPublisher publisher = new EventPublisher();\n        publisher.OnNotification += msg => Console.WriteLine($\"Received: {msg}\");\n        publisher.SendNotification(\"Event-Driven Architecture in Action!\");\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-6",
      "question": "What are MemoryCache and DistributedCache, and when would you use them?",
      "answer": [
        {
          "type": "text",
          "content": "**MemoryCache (In-Memory Cache):**\n- Stores cache in the application's memory.\n- Works well for small to medium-scale applications.\n- Data is lost when the application restarts.\n- Suitable for single-instance applications."
        },
        {
          "type": "text",
          "content": "**DistributedCache (External Cache like Redis, SQL Server Cache):**\n- Stores cache externally (Redis, SQL Server, etc.).\n- Can be shared across multiple instances.\n- Suitable for cloud-based and microservices applications."
        },
        {
          "type": "text",
          "content": "**Example: Using MemoryCache in .NET Core**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.Extensions.Caching.Memory;\nusing System;\n\nclass Program {\n    static void Main() {\n        var cache = new MemoryCache(new MemoryCacheOptions());\n        cache.Set(\"key\", \"Cached Data\", TimeSpan.FromMinutes(10));\n        Console.WriteLine(cache.Get(\"key\")); // Output: Cached Data\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-7",
      "question": "What are Records in C#? How do they differ from Classes?",
      "answer": [
        {
          "type": "text",
          "content": "Records are reference types introduced in C# 9 that provide **immutable data** structures with built-in value equality."
        },
        {
          "type": "list",
          "items": [
            "**Records vs. Classes:**",
            "- **Records** use value-based equality (compare content).",
            "- **Classes** use reference-based equality (compare memory references).",
            "- Records are immutable by default."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Records vs. Classes**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public record PersonRecord(string Name, int Age);\npublic class PersonClass {\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nclass Program {\n    static void Main() {\n        var person1 = new PersonRecord(\"John\", 30);\n        var person2 = new PersonRecord(\"John\", 30);\n        Console.WriteLine(person1 == person2); // Output: True (Value-based equality)\n\n        var class1 = new PersonClass { Name = \"John\", Age = 30 };\n        var class2 = new PersonClass { Name = \"John\", Age = 30 };\n        Console.WriteLine(class1 == class2); // Output: False (Reference-based equality)\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-1",
      "question": "How do you implement a background worker service in .NET Core?",
      "answer": [
        {
          "type": "text",
          "content": ".NET Core provides the `BackgroundService` class to implement background worker services. You can use it for tasks such as message queue processing, scheduled jobs, or long-running background operations."
        },
        {
          "type": "text",
          "content": "Hereâ€™s how to implement a background worker service:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class MyBackgroundService : BackgroundService\n{\n    private readonly ILogger<MyBackgroundService> _logger;\n\n    public MyBackgroundService(ILogger<MyBackgroundService> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            _logger.LogInformation(\"Background task running at: {time}\", DateTimeOffset.Now);\n            await Task.Delay(5000, stoppingToken); // Runs every 5 seconds\n        }\n    }\n}\n\n// Register the background service in Program.cs\nbuilder.Services.AddHostedService<MyBackgroundService>();"
        }
      ]
    },
    {
      "id": "dotnet-2",
      "question": "Explain how the Actor Model works in Orleans or Akka.NET.",
      "answer": [
        {
          "type": "text",
          "content": "The Actor Model is a concurrency framework where actors are isolated entities that communicate via messages. They do not share state directly, reducing race conditions and complexity in distributed systems."
        },
        {
          "type": "text",
          "content": "### Orleans:\n- Implements the Virtual Actor Model.\n- Manages actor lifecycles automatically (no need to explicitly create/destroy them).\n- Useful for scalable, stateful applications (e.g., IoT, real-time apps)."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IMyActor : IGrainWithStringKey\n{\n    Task<string> SayHello(string name);\n}\n\npublic class MyActor : Grain, IMyActor\n{\n    public Task<string> SayHello(string name) => Task.FromResult($\"Hello, {name}!\");\n}"
        },
        {
          "type": "text",
          "content": "### Akka.NET:\n- More traditional actor model with explicit actor creation and supervision.\n- Uses a hierarchical approach where actors can spawn child actors."
        }
      ]
    },
    {
      "id": "dotnet-3",
      "question": "How do you implement CQRS in a .NET Core application?",
      "answer": [
        {
          "type": "text",
          "content": "CQRS (Command Query Responsibility Segregation) separates read and write operations to optimize performance and scalability."
        },
        {
          "type": "text",
          "content": "### Implementation Steps:"
        },
        {
          "type": "list",
          "items": [
            "Commands modify data (write operations).",
            "Queries fetch data (read operations).",
            "Use MediatR to handle commands and queries.",
            "Separate databases for reads/writes in some cases."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Command Handler using MediatR\npublic record CreateUserCommand(string Name) : IRequest<int>;\n\npublic class CreateUserHandler : IRequestHandler<CreateUserCommand, int>\n{\n    private readonly AppDbContext _context;\n    \n    public CreateUserHandler(AppDbContext context)\n    {\n        _context = context;\n    }\n    \n    public async Task<int> Handle(CreateUserCommand request, CancellationToken cancellationToken)\n    {\n        var user = new User { Name = request.Name };\n        _context.Users.Add(user);\n        await _context.SaveChangesAsync();\n        return user.Id;\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-4",
      "question": "What are gRPC services in .NET, and how do they compare to REST APIs?",
      "answer": [
        {
          "type": "text",
          "content": "gRPC (Google Remote Procedure Call) is a high-performance RPC framework used for inter-service communication in microservices."
        },
        {
          "type": "list",
          "items": [
            "Uses HTTP/2 for improved performance.",
            "Binary serialization with Protocol Buffers (Protobuf).",
            "Supports bi-directional streaming.",
            "Better for internal microservices compared to REST."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "syntax = \"proto3\";\npackage mygrpc;\n\nservice MyService {\n  rpc SayHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloResponse {\n  string message = 1;\n}"
        }
      ]
    },
    {
      "id": "dotnet-5",
      "question": "How would you optimize EF Core queries to improve performance?",
      "answer": [
        {
          "type": "list",
          "items": [
            "Use `.AsNoTracking()` for read-only queries.",
            "Use projections (`Select`) instead of fetching full entities.",
            "Optimize indexes in the database.",
            "Use compiled queries for frequently executed queries.",
            "Implement caching for repeated queries."
          ]
        }
      ]
    },
    {
      "id": "dotnet-6",
      "question": "How do you implement distributed tracing in a .NET Core microservice?",
      "answer": [
        {
          "type": "text",
          "content": "Distributed tracing helps track requests across microservices using tools like OpenTelemetry and Application Insights."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "builder.Services.AddOpenTelemetryTracing(builder =>\n{\n    builder.AddAspNetCoreInstrumentation()\n           .AddHttpClientInstrumentation()\n           .AddConsoleExporter();\n});"
        }
      ]
    },
    {
      "id": "dotnet-7",
      "question": "What is SignalR, and when would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "SignalR is a real-time communication library in .NET Core used for live chat, notifications, and live dashboards."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class ChatHub : Hub\n{\n    public async Task SendMessage(string user, string message)\n    {\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-8",
      "question": "How does Kestrel work, and why is it used as the default web server in .NET?",
      "answer": [
        {
          "type": "list",
          "items": [
            "Kestrel is a cross-platform, high-performance web server built on libuv.",
            "It is the default server in ASP.NET Core applications.",
            "Supports asynchronous I/O operations for scalability.",
            "Used behind Nginx/IIS in production for additional features like security."
          ]
        }
      ]
    }
  ],
  "backend-golang": [
    {
      "id": "gb-1",
      "question": "What are the basic data types in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Golang has several basic data types categorized into numeric, string, and boolean types."
        },
        {
          "type": "text",
          "content": "**1. Numeric Types:**"
        },
        {
          "type": "list",
          "items": [
            "Integers: `int`, `int8`, `int16`, `int32`, `int64`",
            "Unsigned Integers: `uint`, `uint8`, `uint16`, `uint32`, `uint64`",
            "Floating Points: `float32`, `float64`",
            "Complex Numbers: `complex64`, `complex128`"
          ]
        },
        {
          "type": "text",
          "content": "**2. Other Basic Types:**"
        },
        {
          "type": "list",
          "items": [
            "Boolean: `bool` (true/false)",
            "Strings: `string` (UTF-8 encoded text)",
            "Byte & Rune: `byte` (alias for `uint8`), `rune` (alias for `int32`, used for Unicode characters)"
          ]
        },
        {
          "type": "text",
          "content": "**Example of using different data types:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a int = 10\n\tvar b float64 = 3.14\n\tvar c string = \"Hello\"\n\tvar d bool = true\n\tfmt.Println(a, b, c, d)\n}"
        }
      ]
    },
    {
      "id": "gb-2",
      "question": "What are pointers in Golang? How do they work?",
      "answer": [
        {
          "type": "text",
          "content": "Pointers in Golang store memory addresses of variables. They help in efficient memory manipulation and function parameter passing."
        },
        {
          "type": "text",
          "content": "**Pointer Syntax:**"
        },
        {
          "type": "list",
          "items": [
            "`*T` â†’ Defines a pointer to a type `T`.",
            "`&` â†’ Returns the memory address of a variable.",
            "`*p` â†’ Dereferences a pointer (accesses the value at the memory address)."
          ]
        },
        {
          "type": "text",
          "content": "**Example of using pointers:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnum := 10\n\tptr := &num // Pointer to num\n\tfmt.Println(\"Memory Address:\", ptr)\n\tfmt.Println(\"Value:\", *ptr) // Dereferencing\n}"
        }
      ]
    },
    {
      "id": "gb-3",
      "question": "What is the difference between arrays and slices in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "**Arrays:** Fixed-size collections of elements of the same type."
        },
        {
          "type": "list",
          "items": [
            "Declared using `[size]Type{values}`",
            "Size is part of the type, so cannot be resized",
            "Stored sequentially in memory"
          ]
        },
        {
          "type": "text",
          "content": "**Slices:** Dynamic, flexible views into arrays."
        },
        {
          "type": "list",
          "items": [
            "Declared using `[]Type{values}` or `make([]Type, length, capacity)`",
            "Can grow dynamically using `append()`",
            "Stores reference to underlying array"
          ]
        },
        {
          "type": "text",
          "content": "**Example:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tarr := [3]int{1, 2, 3} // Array\n\tslice := []int{1, 2, 3} // Slice\n\tslice = append(slice, 4) // Append to slice\n\n\tfmt.Println(arr, slice)\n}"
        }
      ]
    },
    {
      "id": "gb-4",
      "question": "What are structs in Golang? How do you define and use them?",
      "answer": [
        {
          "type": "text",
          "content": "A struct is a collection of fields (data members) used to define a custom data type."
        },
        {
          "type": "text",
          "content": "**Defining and Using Structs:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 25}\n\tfmt.Println(p.Name, p.Age)\n}"
        }
      ]
    },
    {
      "id": "gb-5",
      "question": "What are interfaces in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Interfaces define method signatures that types must implement. They enable polymorphism."
        },
        {
          "type": "text",
          "content": "**Example of an Interface:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Speaker interface {\n\tSpeak() string\n}\n\ntype Dog struct{}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof!\"\n}\n\nfunc main() {\n\tvar s Speaker = Dog{}\n\tfmt.Println(s.Speak())\n}"
        }
      ]
    },
    {
      "id": "gb-6",
      "question": "What is the difference between pass-by-value and pass-by-reference in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "**Pass-by-Value:** A copy of the variable is passed to a function."
        },
        {
          "type": "text",
          "content": "**Pass-by-Reference:** A pointer to the original variable is passed, allowing modifications."
        },
        {
          "type": "text",
          "content": "**Example of pass-by-value:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc modify(x int) {\n\tx = 100\n}\n\nfunc main() {\n\tn := 10\n\tmodify(n)\n\tfmt.Println(n) // Output: 10 (unchanged)\n}"
        }
      ]
    },
    {
      "id": "gb-7",
      "question": "What are maps in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Maps are key-value data structures similar to hash tables."
        },
        {
          "type": "text",
          "content": "**Example of using a map:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := map[string]int{\"Alice\": 25, \"Bob\": 30}\n\tfmt.Println(m[\"Alice\"])\n}"
        }
      ]
    },
    {
      "id": "gc-1",
      "question": "Explain mutable and immutable types in Golang. Are strings and other types mutable? Provide examples.",
      "answer": [
        {
          "type": "text",
          "content": "Mutable types can be modified after creation, whereas immutable types cannot be changed once assigned."
        },
        {
          "type": "text",
          "content": "**Immutable Types in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Strings (`string`) - Once created, their value cannot be modified.",
            "Numbers (`int`, `float`, `complex`) - These are copied when assigned."
          ]
        },
        {
          "type": "text",
          "content": "**Mutable Types in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Slices (`[]T`) - Can be resized and modified.",
            "Maps (`map[T]T`) - Can add/remove/update key-value pairs.",
            "Pointers (`*T`) - Allow modification of referenced data.",
            "Structs (`struct`) - Fields can be modified (except when using pointers to them)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Strings are immutable in Golang**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := \"hello\"\n\t// s[0] = 'H' // This will cause an error as strings are immutable\n\ts = \"Hello\" // This is allowed (creates a new string)\n\tfmt.Println(s)\n}"
        }
      ]
    },
    {
      "id": "gc-2",
      "question": "Explain call by value and call by reference with examples in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "**Call by Value:** A copy of the argument is passed to the function, meaning changes inside the function do not affect the original variable."
        },
        {
          "type": "text",
          "content": "**Example of Call by Value:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc modify(x int) {\n\tx = 100 // This modifies a copy, not the original variable\n}\n\nfunc main() {\n\tn := 10\n\tmodify(n)\n\tfmt.Println(n) // Output: 10 (unchanged)\n}"
        }
      ]
    },
    {
      "id": "gc-3",
      "question": "Explain call by reference with an example.",
      "answer": [
        {
          "type": "text",
          "content": "**Call by Reference:** A pointer to the argument is passed to the function, allowing modification of the original variable."
        },
        {
          "type": "text",
          "content": "**Example of Call by Reference:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc modifyPointer(x *int) {\n\t*x = 100 // Modifies the original variable\n}\n\nfunc main() {\n\tn := 10\n\tmodifyPointer(&n) // Passing memory address\n\tfmt.Println(n) // Output: 100 (modified)\n}"
        }
      ]
    },
    {
      "id": "be-3",
      "question": "How does garbage collection work in Golang compared to C#?",
      "answer": [
        {
          "type": "text",
          "content": "Garbage collection (GC) is the process of automatically reclaiming memory occupied by objects that are no longer in use. Both Golang and C# use garbage collection, but they have different approaches to it."
        },
        {
          "type": "text",
          "content": "**Garbage Collection in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses a **concurrent, non-blocking garbage collector** to minimize pause times and improve performance.",
            "It focuses on **low-latency** garbage collection to make it suitable for real-time applications.",
            "The GC runs in the background and works in **multiple small steps** to avoid stopping the entire application.",
            "It uses a **tri-color marking algorithm** that classifies objects as **white, gray, or black** to track object reachability efficiently.",
            "Since Go does not have manual memory management (like C or C++), developers rely on GC to handle memory cleanup automatically.",
            "Objects are automatically deallocated when they are no longer reachable."
          ]
        },
        {
          "type": "text",
          "content": "**Garbage Collection in C#:**"
        },
        {
          "type": "list",
          "items": [
            "C# uses a **generational garbage collector**, which divides objects into **three generations** (Gen 0, Gen 1, Gen 2).",
            "Objects that survive multiple collections move to higher generations (long-lived objects reside in Gen 2).",
            "The GC in C# is **managed by the Common Language Runtime (CLR)**, and developers can trigger collection using `GC.Collect()`, though it's usually not recommended.",
            "Uses a **mark-and-sweep algorithm** similar to Go but is optimized with generational heuristics.",
            "Supports **finalizers** (`~ClassName()`) for custom cleanup, but they should be used cautiously as they impact performance.",
            "Provides **manual memory management** via `IDisposable` and `using` statements for deterministic cleanup of resources (e.g., database connections, file streams)."
          ]
        },
        {
          "type": "text",
          "content": "**Key Differences:**"
        },
        {
          "type": "list",
          "items": [
            "Golang's GC is **designed for low-latency applications**, whereas C#'s GC is **optimized for long-running applications**.",
            "C# has a **generational garbage collector**, while Go uses a **concurrent, tri-color marking algorithm**.",
            "C# allows **manual memory management (IDisposable, `GC.Collect()`)**, while Go strictly relies on automatic GC.",
            "Golang's GC is optimized for **server-side performance**, whereas C#'s GC is highly optimized for **desktop, cloud, and enterprise applications**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, Golang focuses on minimizing pause times to improve concurrency, while C#'s generational GC optimizes memory management for different object lifetimes."
        }
      ]
    },
    {
      "id": "be-4",
      "question": "Discuss asynchronous programming in C# and Golang (async/await, goroutines).",
      "answer": [
        {
          "type": "text",
          "content": "Asynchronous programming allows tasks to run concurrently without blocking the main execution thread, improving performance and responsiveness. C# and Golang have different approaches to handling concurrency and asynchronous operations."
        },
        {
          "type": "text",
          "content": "**Asynchronous Programming in C# (async/await):**"
        },
        {
          "type": "list",
          "items": [
            "C# uses the **async/await** pattern to handle asynchronous operations.",
            "The `Task` and `Task<T>` types represent asynchronous operations that can run in the background.",
            "The `await` keyword allows code execution to pause and resume without blocking the main thread.",
            "Uses the **Thread Pool** for managing multiple tasks efficiently.",
            "Asynchronous programming in C# is useful for **I/O-bound operations** like database calls, network requests, and file operations."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main()\n    {\n        Console.WriteLine(\"Start\");\n        string result = await FetchData();\n        Console.WriteLine(result);\n        Console.WriteLine(\"End\");\n    }\n\n    static async Task<string> FetchData()\n    {\n        await Task.Delay(2000); // Simulate async work\n        return \"Data received\";\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Asynchronous Programming in Golang (Goroutines):**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses **goroutines**, which are lightweight threads managed by the Go runtime.",
            "Unlike OS threads, goroutines use less memory and allow thousands of tasks to run concurrently.",
            "The `go` keyword is used to start a new goroutine.",
            "Channels (`chan`) are used to communicate safely between goroutines.",
            "Ideal for **CPU-bound** and **network-intensive** operations."
          ]
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc fetchData(ch chan string) {\n    time.Sleep(2 * time.Second) // Simulate async work\n    ch <- \"Data received\"\n}\n\nfunc main() {\n    fmt.Println(\"Start\")\n    ch := make(chan string)\n    go fetchData(ch)\n    result := <-ch\n    fmt.Println(result)\n    fmt.Println(\"End\")\n}"
        },
        {
          "type": "text",
          "content": "**Key Differences:**"
        },
        {
          "type": "list",
          "items": [
            "C# uses **async/await with Tasks**, while Golang uses **goroutines and channels**.",
            "C#'s **Thread Pool** manages threads, whereas Golangâ€™s **runtime scheduler** manages goroutines.",
            "Goroutines are **lighter and more efficient** than C# tasks, making them suitable for high-concurrency applications.",
            "C#'s `await` helps avoid blocking the main thread, whereas Go relies on **channels and synchronization** for communication.",
            "C# is more structured for **asynchronous I/O operations**, while Go excels at **parallel execution and concurrency control**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, C#'s async/await is designed for easier asynchronous coding in **I/O-bound** applications, while Go's goroutines provide a more **lightweight and efficient** concurrency model for **highly concurrent** systems."
        }
      ]
    },
    {
      "id": "be-6",
      "question": "What are the benefits of using Golang for backend services compared to C#? (Including memory usage and footprint comparison)",
      "answer": [
        {
          "type": "text",
          "content": "Golang and C# both offer strong backend capabilities, but they differ in terms of memory consumption, execution speed, and deployment footprint. Below is a detailed comparison."
        },
        {
          "type": "text",
          "content": "**1. Performance & Execution Speed**"
        },
        {
          "type": "list",
          "items": [
            "Golang is **compiled directly to native machine code**, making it faster at execution than C#'s **JIT (Just-In-Time) compilation** in .NET.",
            "C# runs on the **.NET runtime**, which adds some overhead but provides benefits like runtime optimizations and garbage collection."
          ]
        },
        {
          "type": "text",
          "content": "**2. Memory Usage & Garbage Collection**"
        },
        {
          "type": "list",
          "items": [
            "Golangâ€™s **garbage collector (GC)** is optimized for **low-latency, high-throughput** applications with **short pauses**.",
            "C#'s **.NET GC** is powerful but can cause **longer pauses** in high-memory applications due to **heap compaction and generational collection**.",
            "Goâ€™s memory model avoids **heap fragmentation**, making it more predictable in **containerized environments**."
          ]
        },
        {
          "type": "text",
          "content": "**3. Deployment & Binary Size**"
        },
        {
          "type": "list",
          "items": [
            "Golang compiles into a **single static binary** with no external dependencies, making deployment easy.",
            "A **Golang binary** typically ranges between **5-15 MB**, depending on the project.",
            "C# applications depend on **.NET runtime (CoreCLR or Mono)**, which increases the size.",
            "A self-contained **C# .NET Core application** can range from **50-100 MB+** when bundled with runtime dependencies."
          ]
        },
        {
          "type": "text",
          "content": "**4. Memory Footprint in Real-World Usage**"
        },
        {
          "type": "list",
          "items": [
            "A simple **Hello World** app in Go uses **1-2 MB RAM**, while in C# .NET, it starts at **15-30 MB RAM** due to runtime overhead.",
            "Goâ€™s **HTTP server** consumes around **5-10 MB RAM** under load, while an equivalent ASP.NET Core service may require **50-100 MB+ RAM**.",
            "For **high-concurrency services**, Goâ€™s lightweight **goroutines** allow handling **millions of requests** with lower memory usage compared to C#'s **ThreadPool-based tasks**."
          ]
        },
        {
          "type": "text",
          "content": "**5. Containerization & Cloud Deployment**"
        },
        {
          "type": "list",
          "items": [
            "Go's small footprint makes it ideal for **Docker and Kubernetes**, with **small container images (~10-20 MB)**.",
            "C# applications packaged in Docker often require **Alpine (~80-100 MB) or Debian (~200-300 MB)** base images to include the .NET runtime.",
            "Golang is preferred for **serverless functions** and cloud-native applications due to its **low memory consumption**."
          ]
        },
        {
          "type": "text",
          "content": "**Key Takeaways:**"
        },
        {
          "type": "list",
          "items": [
            "**Use Golang if:** You need a lightweight, fast, and highly efficient backend with **minimal memory consumption and small deployment size**.",
            "**Use C# if:** You require a feature-rich backend with **robust framework support**, even at the cost of a **larger memory footprint and dependency on .NET runtime**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, Golang is a better choice for high-performance microservices, cloud-native applications, and low-latency APIs, while C# excels in enterprise solutions where rich ecosystem support and framework capabilities matter more."
        }
      ]
    },
    {
      "id": "be-7",
      "question": "Explain Rate Limiting and how to implement it in a Golang-based microservice.",
      "answer": [
        {
          "type": "text",
          "content": "Rate limiting is a technique used to control the number of requests a client can make to a server in a given time period. It helps prevent abuse, maintain service availability, and ensure fair usage of resources."
        },
        {
          "type": "text",
          "content": "**Common Rate Limiting Strategies:**"
        },
        {
          "type": "list",
          "items": [
            "**Token Bucket**: Clients acquire tokens before making requests. Requests are denied if tokens are exhausted.",
            "**Leaky Bucket**: Requests are processed at a fixed rate, and excess requests are queued.",
            "**Fixed Window**: Limits requests within a specific time window (e.g., 100 requests per minute).",
            "**Sliding Window**: More dynamic than fixed window; calculates limits based on the recent request history."
          ]
        },
        {
          "type": "text",
          "content": "**Rate Limiting Implementation in Golang**"
        },
        {
          "type": "text",
          "content": "Below is a Golang example implementing rate limiting using the `golang.org/x/time/rate` package, which provides an efficient token bucket algorithm."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n)\n\n// RateLimiter struct for per-client rate limiting\ntype RateLimiter struct {\n\tclients map[string]*rate.Limiter\n\tmutex   sync.Mutex\n\trate  rate.Limit\n\tburst int\n}\n\n// NewRateLimiter initializes a new rate limiter\nfunc NewRateLimiter(r rate.Limit, b int) *RateLimiter {\n\treturn &RateLimiter{\n\t\tclients: make(map[string]*rate.Limiter),\n\t\trate:    r,\n\t\tburst:   b,\n\t}\n}\n\n// GetLimiter retrieves or creates a rate limiter for a client\nfunc (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {\n\trl.mutex.Lock()\n\tdefer rl.mutex.Unlock()\n\n\tif limiter, exists := rl.clients[ip]; exists {\n\t\treturn limiter\n\t}\n\n\tlimiter := rate.NewLimiter(rl.rate, rl.burst)\n\trl.clients[ip] = limiter\n\treturn limiter\n}\n\nfunc main() {\n\trl := NewRateLimiter(1, 5) // 1 request per second, burst of 5\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tip := r.RemoteAddr\n\t\tlimiter := rl.GetLimiter(ip)\n\n\t\tif !limiter.Allow() {\n\t\t\thttp.Error(w, \"429 Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprintln(w, \"Request successful\")\n\t})\n\n\tlog.Println(\"Starting server on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"
        },
        {
          "type": "text",
          "content": "**How It Works:**"
        },
        {
          "type": "list",
          "items": [
            "Each client is identified by their **IP address**.",
            "A **token bucket rate limiter** is created for each client.",
            "If the client **exceeds the request limit**, they receive a **429 Too Many Requests** response.",
            "The limit is set to **1 request per second** with a burst capacity of **5 requests**."
          ]
        },
        {
          "type": "text",
          "content": "**Alternative Implementations:**"
        },
        {
          "type": "list",
          "items": [
            "Use **Redis-based rate limiting** for distributed systems (`github.com/go-redis/redis/v8`).",
            "Use **nginx or API Gateway** for rate limiting before requests reach the backend.",
            "Implement a **Sliding Window Counter** using a database like PostgreSQL."
          ]
        },
        {
          "type": "text",
          "content": "Rate limiting is crucial for protecting microservices from abuse and ensuring fair resource usage. In high-scale systems, it's recommended to use a distributed rate limiter backed by **Redis** or an API gateway like **Kong or Envoy**."
        }
      ]
    },
    {
      "id": "be-8",
      "question": "How do you secure APIs using OAuth, JWT, or API keys?",
      "answer": [
        {
          "type": "text",
          "content": "Securing APIs is essential to prevent unauthorized access and data breaches. Common authentication and authorization mechanisms include OAuth, JWT, and API Keys."
        },
        {
          "type": "text",
          "content": "**1. OAuth 2.0**"
        },
        {
          "type": "list",
          "items": [
            "OAuth 2.0 is an open standard for access delegation, commonly used to grant third-party applications limited access to user data.",
            "It uses **Access Tokens** to authenticate API requests.",
            "OAuth supports **authorization flows** such as Authorization Code, Client Credentials, and Password Grant."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Implementing OAuth 2.0 in Golang with `oauth2` package**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"golang.org/x/oauth2\"\n)\n\nvar googleOauthConfig = &oauth2.Config{\n\tClientID:     \"your-client-id\",\n\tClientSecret: \"your-client-secret\",\n\tRedirectURL:  \"http://localhost:8080/callback\",\n\tScopes:       []string{\"profile\", \"email\"},\n\tEndpoint:     oauth2.Endpoint{\n\t\tAuthURL:  \"https://accounts.google.com/o/oauth2/auth\",\n\t\tTokenURL: \"https://oauth2.googleapis.com/token\",\n\t},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\turl := googleOauthConfig.AuthCodeURL(\"state-token\", oauth2.AccessTypeOffline)\n\thttp.Redirect(w, r, url, http.StatusFound)\n}\n\nfunc callbackHandler(w http.ResponseWriter, r *http.Request) {\n\tcode := r.URL.Query().Get(\"code\")\n\ttoken, err := googleOauthConfig.Exchange(context.Background(), code)\n\tif err != nil {\n\t\tlog.Println(\"Failed to get token:\", err)\n\t\treturn\n\t}\n\tfmt.Fprintf(w, \"Access Token: %s\", token.AccessToken)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.HandleFunc(\"/callback\", callbackHandler)\n\tlog.Println(\"Server started at :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**2. JSON Web Token (JWT)**"
        },
        {
          "type": "list",
          "items": [
            "JWT is a compact, self-contained token format that encodes user claims and authentication data.",
            "It consists of **Header, Payload, and Signature**.",
            "JWTs are signed using HMAC or RSA to ensure integrity."
          ]
        },
        {
          "type": "text",
          "content": "**Example: JWT Authentication in Golang using `github.com/golang-jwt/jwt/v4`**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar secretKey = []byte(\"your-secret-key\")\n\nfunc generateJWT() (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"user\": \"admin\",\n\t\t\"exp\":  time.Now().Add(time.Hour * 1).Unix(),\n\t})\n\treturn token.SignedString(secretKey)\n}\n\nfunc jwtMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn secretKey, nil\n\t\t})\n\t\tif err != nil || !token.Valid {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc protectedEndpoint(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Access granted to protected resource\")\n}\n\nfunc main() {\n\thttp.Handle(\"/protected\", jwtMiddleware(http.HandlerFunc(protectedEndpoint)))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**3. API Keys Authentication**"
        },
        {
          "type": "list",
          "items": [
            "API Keys are simple authentication tokens passed in HTTP headers or query parameters.",
            "They are commonly used for **service-to-service communication**.",
            "API Keys should be **revocable and scoped** to control access."
          ]
        },
        {
          "type": "text",
          "content": "**Example: API Key Middleware in Golang**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar validAPIKey = \"your-api-key\"\n\nfunc apiKeyMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tapiKey := r.Header.Get(\"X-API-Key\")\n\t\tif apiKey != validAPIKey {\n\t\t\thttp.Error(w, \"Forbidden\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc protectedHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"API Key authentication successful\")\n}\n\nfunc main() {\n\thttp.Handle(\"/secure\", apiKeyMiddleware(http.HandlerFunc(protectedHandler)))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**Choosing the Right Authentication Method:**"
        },
        {
          "type": "list",
          "items": [
            "**OAuth 2.0**: Best for user authentication in third-party integrations (e.g., Google, Facebook login).",
            "**JWT**: Ideal for securing API endpoints in microservices without needing session storage.",
            "**API Keys**: Useful for machine-to-machine authentication but should be used with caution due to security risks."
          ]
        },
        {
          "type": "text",
          "content": "A combination of these methods can be used to enhance API security, e.g., using **OAuth for user login** and **JWT for API authorization**."
        }
      ]
    },
    {
      "id": "be-9",
      "question": "How does goroutine scheduling work in Golang? How does it differ from OS threads?",
      "answer": [
        {
          "type": "text",
          "content": "Goroutines are lightweight, managed by the Go runtime, and allow concurrent execution. Unlike OS threads, goroutines have minimal memory overhead and can scale efficiently."
        },
        {
          "type": "text",
          "content": "**Goroutine Scheduling:**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses **Goroutine Scheduler** to map thousands of goroutines onto a small number of OS threads.",
            "The scheduler is **non-preemptive** but can yield execution during function calls and specific points (e.g., I/O operations).",
            "It follows a **work-stealing** strategy where idle processors (P) take work from busy ones.",
            "Each OS thread (M) is bound to a user-level scheduler (P) managing a pool of goroutines."
          ]
        },
        {
          "type": "text",
          "content": "**Differences between Goroutines and OS Threads:**"
        },
        {
          "type": "list",
          "items": [
            "**Goroutines:** Small stack (~2KB), dynamically grows; managed by Go runtime.",
            "**OS Threads:** Large stack (~1MB), fixed size; managed by the operating system.",
            "**Goroutines:** Multiplexed over OS threads, allowing millions of goroutines.",
            "**OS Threads:** Limited in number due to resource constraints."
          ]
        }
      ]
    },
    {
      "id": "be-10",
      "question": "Explain channels vs. mutexes. When would you use one over the other?",
      "answer": [
        {
          "type": "text",
          "content": "Channels and mutexes are synchronization primitives in Golang."
        },
        {
          "type": "text",
          "content": "**Channels:**"
        },
        {
          "type": "list",
          "items": [
            "Used for **message passing** between goroutines.",
            "Avoids shared memory, enabling safe concurrent programming.",
            "Synchronous (blocking) or asynchronous (buffered) communication."
          ]
        },
        {
          "type": "text",
          "content": "**Mutexes:**"
        },
        {
          "type": "list",
          "items": [
            "Used for **mutual exclusion** (locking shared data).",
            "Provides fine-grained control over shared resources.",
            "More efficient for protecting small, frequently accessed variables."
          ]
        },
        {
          "type": "text",
          "content": "**When to use which?**"
        },
        {
          "type": "list",
          "items": [
            "Use **channels** when you want to pass ownership of data instead of locking it.",
            "Use **mutexes** when multiple goroutines need to modify a shared variable safely."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Channel-based synchronization**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tch := make(chan int)\n\n\tgo func() {\n\t\tch <- 42 // Send data to channel\n\t}()\n\n\tfmt.Println(<-ch) // Receive data from channel\n}"
        },
        {
          "type": "text",
          "content": "**Example: Mutex-based synchronization**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar counter int\nvar mu sync.Mutex\n\nfunc increment(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tmu.Lock()\n\tcounter++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo increment(&wg)\n\t}\n\twg.Wait()\n\tfmt.Println(\"Final Counter:\", counter)\n}"
        }
      ]
    },
    {
      "id": "be-11",
      "question": "What are defer, panic, and recover in Golang? How do they work?",
      "answer": [
        {
          "type": "text",
          "content": "In Golang, `defer`, `panic`, and `recover` are mechanisms for handling cleanup and error recovery."
        },
        {
          "type": "text",
          "content": "**1. Defer:**"
        },
        {
          "type": "list",
          "items": [
            "Used to schedule a function to execute **after** the surrounding function returns.",
            "Useful for **resource cleanup** (closing files, unlocking mutexes, etc.)."
          ]
        },
        {
          "type": "text",
          "content": "**Example of defer:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"This will execute last\")\n\tfmt.Println(\"This executes first\")\n}"
        },
        {
          "type": "text",
          "content": "**2. Panic:**"
        },
        {
          "type": "list",
          "items": [
            "Used to **abort execution** immediately.",
            "Typically used for **critical errors** like accessing an invalid memory location."
          ]
        },
        {
          "type": "text",
          "content": "**Example of panic:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Before panic\")\n\tpanic(\"Something went wrong!\")\n\tfmt.Println(\"This will not execute\")\n}"
        },
        {
          "type": "text",
          "content": "**3. Recover:**"
        },
        {
          "type": "list",
          "items": [
            "Used inside `defer` to **catch a panic** and prevent program crash.",
            "Returns `nil` if no panic occurs."
          ]
        },
        {
          "type": "text",
          "content": "**Example of recover:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Recovered from panic:\", r)\n\t\t}\n\t}()\n\tpanic(\"Something went wrong!\")\n}"
        }
      ]
    },
    {
      "id": "be-12",
      "question": "How would you implement worker pools in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Worker pools are a pattern used to control concurrency by limiting the number of goroutines processing tasks."
        },
        {
          "type": "text",
          "content": "**Steps to implement a worker pool:**"
        },
        {
          "type": "list",
          "items": [
            "Create a buffered channel for tasks.",
            "Spawn a fixed number of worker goroutines.",
            "Each worker fetches and processes tasks from the channel.",
            "Close the channel when all tasks are dispatched."
          ]
        },
        {
          "type": "text",
          "content": "**Example of a Worker Pool in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 5)\n\tvar wg sync.WaitGroup\n\n\t// Create worker pool\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, &wg)\n\t}\n\n\t// Send jobs to channel\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n}"
        }
      ]
    },
    {
      "id": "be-13",
      "question": "Explain context package in Golang. How do you use it for request cancellation?",
      "answer": [
        {
          "type": "text",
          "content": "The `context` package in Golang provides a way to manage request deadlines, cancellations, and timeouts across API calls and goroutines."
        },
        {
          "type": "text",
          "content": "**Key Features:**"
        },
        {
          "type": "list",
          "items": [
            "Allows request **cancellation** to prevent resource leaks.",
            "Supports **timeouts** and **deadlines**.",
            "Enables **passing metadata** between function calls."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using context for request cancellation**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel() // Ensure cleanup\n\n\tgo func(ctx context.Context) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tfmt.Println(\"Request canceled\")\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Processing...\")\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}(ctx)\n\ntime.Sleep(3 * time.Second)\n}"
        }
      ]
    },
    {
      "id": "be-14",
      "question": "How do you handle race conditions in a concurrent Golang application?",
      "answer": [
        {
          "type": "text",
          "content": "Race conditions occur when multiple goroutines access shared data simultaneously, leading to unpredictable behavior."
        },
        {
          "type": "text",
          "content": "**Ways to Prevent Race Conditions:**"
        },
        {
          "type": "list",
          "items": [
            "Use **sync.Mutex** to lock shared data.",
            "Use **channels** to control access.",
            "Use **sync/atomic** for atomic operations.",
            "Use **Go's race detector** (`go run -race`)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Mutex to prevent race conditions**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar count int\nvar mu sync.Mutex\n\nfunc increment(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tmu.Lock()\n\tcount++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo increment(&wg)\n\t}\n\twg.Wait()\n\tfmt.Println(\"Final Count:\", count)\n}"
        }
      ]
    },
    {
      "id": "be-15",
      "question": "What are interface types, and how does Golangâ€™s interface system differ from C#â€™s?",
      "answer": [
        {
          "type": "text",
          "content": "**Golang Interfaces:**"
        },
        {
          "type": "list",
          "items": [
            "Interfaces define **behavior** rather than **inheritance**.",
            "A type **implicitly** satisfies an interface if it implements the required methods.",
            "Interfaces allow **decoupled code** and **mocking** in tests."
          ]
        },
        {
          "type": "text",
          "content": "**Difference from C# Interfaces:**"
        },
        {
          "type": "list",
          "items": [
            "**Golang:** Implicit implementation (structs automatically satisfy interfaces).",
            "**C#:** Explicit implementation using `interface` keyword.",
            "**Golang:** No need to declare an interface in the struct.",
            "**C#:** Classes must explicitly declare they implement an interface."
          ]
        },
        {
          "type": "text",
          "content": "**Example of Golang Interface:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Animal interface {\n\tSpeak() string\n}\n\ntype Dog struct {}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof!\"\n}\n\nfunc main() {\n\tvar a Animal = Dog{}\n\tfmt.Println(a.Speak())\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "How does dependency injection work in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern where dependencies are **injected** instead of being created inside a struct."
        },
        {
          "type": "text",
          "content": "**DI Approaches in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Using **constructor functions**.",
            "Passing **interfaces instead of concrete types**.",
            "Using **third-party DI libraries** (e.g., `uber-go/fx`, `wire`)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Constructor-based DI**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Service struct {\n\tmessage string\n}\n\nfunc NewService(msg string) *Service {\n\treturn &Service{message: msg}\n}\n\nfunc main() {\n\tservice := NewService(\"Hello, DI!\")\n\tfmt.Println(service.message)\n}"
        }
      ]
    },
    {
      "id": "be-17",
      "question": "How do you design a highly available, scalable Golang microservice?",
      "answer": [
        {
          "type": "text",
          "content": "**Best Practices for Scalable Microservices:**"
        },
        {
          "type": "list",
          "items": [
            "Use **stateless** services with shared databases or caches.",
            "Implement **load balancing** (e.g., Nginx, HAProxy).",
            "Use **goroutines and channels** for concurrency.",
            "Apply **caching** (Redis, Memcached) to reduce DB load.",
            "Implement **rate limiting** to prevent abuse.",
            "Use **Docker and Kubernetes** for containerization and orchestration."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Goroutine-based request handling**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello, Microservice!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    },
    {
      "id": "be-18",
      "question": "Explain the difference between struct embedding and inheritance in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "**Golang does not support classical inheritance** like C++ or Java but uses **struct embedding** for composition."
        },
        {
          "type": "text",
          "content": "**Struct Embedding:**"
        },
        {
          "type": "list",
          "items": [
            "Allows code reuse without a strict parent-child hierarchy.",
            "Encapsulates behavior while avoiding deep inheritance chains.",
            "Methods of the embedded struct are promoted to the outer struct."
          ]
        },
        {
          "type": "text",
          "content": "**Example of Struct Embedding:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Engine struct {\n\tHorsepower int\n}\n\ntype Car struct {\n\tEngine // Embedded struct\n\tBrand string\n}\n\nfunc main() {\n\tc := Car{Engine{250}, \"Toyota\"}\n\tfmt.Println(\"Car brand:\", c.Brand, \"Horsepower:\", c.Horsepower)\n}"
        }
      ]
    },
    {
      "id": "be-13",
      "question": "What are best practices for logging and monitoring in Golang applications?",
      "answer": [
        {
          "type": "text",
          "content": "Logging and monitoring are essential for observability in Golang applications. Here are best practices:"
        },
        {
          "type": "text",
          "content": "**Best Practices for Logging:**"
        },
        {
          "type": "list",
          "items": [
            "Use structured logging with libraries like `logrus` or `zap`.",
            "Log at appropriate levels: `Debug`, `Info`, `Warning`, `Error`, and `Fatal`.",
            "Include contextual information (e.g., request ID, user ID).",
            "Write logs in JSON format for easy parsing.",
            "Avoid logging sensitive information (passwords, API keys)."
          ]
        },
        {
          "type": "text",
          "content": "**Example using logrus:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n\tlog := logrus.New()\n\tlog.SetFormatter(&logrus.JSONFormatter{})\n\tlog.Info(\"Application started\")\n}"
        },
        {
          "type": "text",
          "content": "**Best Practices for Monitoring:**"
        },
        {
          "type": "list",
          "items": [
            "Use Prometheus for metrics collection.",
            "Track key performance indicators (latency, request count, errors).",
            "Use distributed tracing (e.g., OpenTelemetry, Jaeger).",
            "Monitor logs centrally with ELK (Elasticsearch, Logstash, Kibana) or Loki."
          ]
        }
      ]
    },
    {
      "id": "be-14",
      "question": "How do you implement retry logic with exponential backoff in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Retry logic with exponential backoff helps in handling transient failures by delaying retries progressively."
        },
        {
          "type": "text",
          "content": "**Steps to implement exponential backoff:**"
        },
        {
          "type": "list",
          "items": [
            "Define maximum retries and initial delay.",
            "Double the delay after each failed attempt.",
            "Introduce jitter to avoid synchronized retries.",
            "Stop retrying after a maximum number of attempts."
          ]
        },
        {
          "type": "text",
          "content": "**Example using exponential backoff in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc retryWithBackoff(attempts int, baseDelay time.Duration) error {\n\tfor i := 0; i < attempts; i++ {\n\t\terr := makeRequest()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tjitter := time.Duration(rand.Intn(100)) * time.Millisecond\n\t\tsleepTime := baseDelay * (1 << i) + jitter\n\t\tfmt.Println(\"Retrying in\", sleepTime)\n\t\ttime.Sleep(sleepTime)\n\t}\n\treturn fmt.Errorf(\"operation failed after %d attempts\", attempts)\n}\n\nfunc makeRequest() error {\n\treturn fmt.Errorf(\"temporary error\")\n}\n\nfunc main() {\n\tretryWithBackoff(5, 500*time.Millisecond)\n}"
        }
      ]
    },
    {
      "id": "be-15",
      "question": "How does Golang handle JSON marshaling and unmarshaling?",
      "answer": [
        {
          "type": "text",
          "content": "Golang uses the `encoding/json` package to marshal (convert struct to JSON) and unmarshal (convert JSON to struct)."
        },
        {
          "type": "text",
          "content": "**Example of JSON marshaling (struct to JSON):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\tuser := User{Name: \"Alice\", Age: 25, Email: \"alice@example.com\"}\n\tjsonData, _ := json.Marshal(user)\n\tfmt.Println(string(jsonData))\n}"
        },
        {
          "type": "text",
          "content": "**Example of JSON unmarshaling (JSON to struct):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\tjsonData := `{\"name\": \"Bob\", \"age\": 30, \"email\": \"bob@example.com\"}`\n\tvar user User\n\tjson.Unmarshal([]byte(jsonData), &user)\n\tfmt.Println(user)\n}"
        },
        {
          "type": "text",
          "content": "**Handling Unknown JSON Fields:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "type Response struct {\n\tData map[string]interface{} `json:\"data\"`\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "How do you implement WebSockets in a Golang API?",
      "answer": [
        {
          "type": "text",
          "content": "WebSockets enable real-time communication between clients and a Golang server. The `github.com/gorilla/websocket` package is commonly used."
        },
        {
          "type": "text",
          "content": "**Steps to implement WebSockets:**"
        },
        {
          "type": "list",
          "items": [
            "Upgrade HTTP requests to WebSocket connections.",
            "Handle WebSocket messages in a loop.",
            "Gracefully close the connection when the client disconnects."
          ]
        },
        {
          "type": "text",
          "content": "**Example WebSocket server in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool { return true },\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error upgrading connection:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Received:\", string(msg))\n\t\tconn.WriteMessage(messageType, []byte(\"Hello from server!\"))\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", handleWebSocket)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    }
  ],
  "backend-golang-problem-solving": [
    {
      "id": "cps-1",
      "question": "Implement a thread-safe in-memory key-value store in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "A thread-safe key-value store requires synchronization mechanisms like `sync.Mutex` or `sync.RWMutex` to prevent race conditions when multiple goroutines access the store."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"sync\"\n\t\"fmt\"\n)\n\ntype Store struct {\n\tdata map[string]string\n\tmu   sync.RWMutex\n}\n\nfunc NewStore() *Store {\n\treturn &Store{data: make(map[string]string)}\n}\n\nfunc (s *Store) Set(key, value string) {\n\ts.mu.Lock()\n\ts.data[key] = value\n\ts.mu.Unlock()\n}\n\nfunc (s *Store) Get(key string) (string, bool) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tval, exists := s.data[key]\n\treturn val, exists\n}\n\nfunc main() {\n\tstore := NewStore()\n\tstore.Set(\"foo\", \"bar\")\n\tval, _ := store.Get(\"foo\")\n\tfmt.Println(\"Value:\", val)\n}"
        }
      ]
    },
    {
      "id": "cps-2",
      "question": "Write a rate limiter using Golang middleware.",
      "answer": [
        {
          "type": "text",
          "content": "Rate limiting ensures API requests are restricted to a fixed rate. We use `golang.org/x/time/rate` package to implement a token bucket rate limiter in middleware."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\t\"golang.org/x/time/rate\"\n)\n\ntype rateLimiter struct {\n\tlimiter *rate.Limiter\n}\n\nfunc (rl *rateLimiter) middleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !rl.limiter.Allow() {\n\t\t\thttp.Error(w, \"Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\trl := &rateLimiter{limiter: rate.NewLimiter(1, 5)} // 1 request per second, burst of 5\n\n\thttp.Handle(\"/\", rl.middleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    },
    {
      "id": "cps-3",
      "question": "Implement a concurrent worker pool in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "A worker pool limits the number of concurrent workers processing tasks. It distributes tasks among workers using channels."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 5)\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, &wg)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n}"
        }
      ]
    },
    {
      "id": "cps-4",
      "question": "Implement a REST API in Golang that connects to a PostgreSQL database.",
      "answer": [
        {
          "type": "text",
          "content": "This implementation uses `gorm` for database interactions and `gin` for REST API handling."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n)\n\ntype User struct {\n\tID   uint   `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nvar db *gorm.DB\n\nfunc initDB() {\n\tdsn := \"host=localhost user=postgres password=yourpassword dbname=testdb port=5432 sslmode=disable\"\n\tvar err error\n\tdb, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\tif err != nil {\n\t\tpanic(\"Failed to connect to database\")\n\t}\n\tdb.AutoMigrate(&User{})\n}\n\nfunc getUsers(c *gin.Context) {\n\tvar users []User\n\tdb.Find(&users)\n\tc.JSON(200, users)\n}\n\nfunc main() {\n\tinitDB()\n\tr := gin.Default()\n\tr.GET(\"/users\", getUsers)\n\tr.Run(\":8080\")\n}"
        }
      ]
    },
    {
      "id": "cps-5",
      "question": "Design a task scheduler in Golang where tasks run at specific intervals.",
      "answer": [
        {
          "type": "text",
          "content": "A task scheduler can be implemented using `time.Ticker` or `cron` library for periodic execution."
        },
        {
          "type": "text",
          "content": "**Example Implementation (Using time.Ticker):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc task() {\n\tfmt.Println(\"Task executed at\", time.Now())\n}\n\nfunc main() {\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\ttask()\n\t}\n}"
        }
      ]
    }
  ],
  "algorithms": [
    {
      "id": "algo-1",
      "question": "Implement a function to reverse a linked list.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for singly-linked list node\n */\nclass ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n/**\n * Reverses a singly linked list\n * Time Complexity: O(n)\n * Space Complexity: O(1)\n * \n * @param {ListNode} head - Head of the linked list\n * @return {ListNode} - Head of the reversed linked list\n */\nfunction reverseLinkedList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current !== null) {\n    // Save next node\n    const next = current.next;\n    \n    // Reverse pointer\n    current.next = prev;\n    \n    // Move pointers one step forward\n    prev = current;\n    current = next;\n  }\n  \n  // prev is the new head\n  return prev;\n}\n\n// Example usage:\n// const list = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));\n// const reversed = reverseLinkedList(list);\n// Output: 4 -> 3 -> 2 -> 1 -> null"
      }
    },
    {
      "id": "algo-2",
      "question": "Implement a function to find if a binary tree is balanced.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for a binary tree node\n */\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * Determines if a binary tree is height-balanced.\n * A height-balanced tree is a tree in which the left and right subtrees \n * of every node differ in height by no more than 1.\n * \n * Time Complexity: O(n) where n is the number of nodes in the tree\n * Space Complexity: O(h) where h is the height of the tree (due to recursion stack)\n * \n * @param {TreeNode} root - Root of the binary tree\n * @return {boolean} - Whether the tree is balanced or not\n */\nfunction isBalanced(root) {\n  // Function returns -1 if the tree is unbalanced, otherwise returns the height\n  function checkHeight(node) {\n    if (node === null) return 0;\n    \n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1; // Left subtree is unbalanced\n    \n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1; // Right subtree is unbalanced\n    \n    // Check if current node is balanced\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    \n    // Return height of current subtree\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  return checkHeight(root) !== -1;\n}\n\n// Example usage:\n// const balancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3));\n// console.log(isBalanced(balancedTree)); // true\n//\n// const unbalancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4, new TreeNode(8))), new TreeNode(3));\n// console.log(isBalanced(unbalancedTree)); // false"
      }
    }
  ],
  "system-design": [
    {
      "id": "sd-1",
      "question": "Design a URL shortening service like bit.ly.",
      "answer": [
        {
          "type": "text",
          "content": "Designing a URL shortening service involves several components and considerations:"
        },
        {
          "type": "text",
          "content": "**Functional Requirements:**"
        },
        {
          "type": "list",
          "items": [
            "URL shortening: Convert a long URL to a short URL",
            "URL redirection: Redirect short URL to original URL",
            "User accounts: Optional for analytics and URL management",
            "Analytics: Track click rates, geographic data, etc.",
            "Custom short URLs: Allow users to choose their custom short URLs"
          ]
        },
        {
          "type": "text",
          "content": "**Non-Functional Requirements:**"
        },
        {
          "type": "list",
          "items": [
            "High availability: System should be always available",
            "Minimal latency: Redirection should happen with minimal delay",
            "Scalability: System should handle high traffic",
            "Security: Prevent abuse and malicious URLs"
          ]
        },
        {
          "type": "text",
          "content": "**API Design:**"
        },
        {
          "type": "list",
          "items": [
            "`POST /api/shorten` - Create a new short URL",
            "`GET /{shortCode}` - Redirect to original URL",
            "`GET /api/analytics/{shortCode}` - Get analytics for a short URL"
          ]
        },
        {
          "type": "text",
          "content": "**Data Model:**"
        },
        {
          "type": "code",
          "language": "text",
          "content": "URL {\n  id: string (primary key)\n  shortCode: string (indexed)\n  originalUrl: string\n  userId: string (optional)\n  createdAt: timestamp\n  expiresAt: timestamp (optional)\n}\n\nClick {\n  id: string (primary key)\n  urlId: string (foreign key)\n  timestamp: timestamp\n  userAgent: string\n  ipAddress: string\n  referrer: string\n}"
        },
        {
          "type": "text",
          "content": "**URL Shortening Algorithm:**"
        },
        {
          "type": "list",
          "items": [
            "Hash-based approach: Hash the long URL and take first few characters",
            "Counter-based approach: Use an auto-incrementing counter and convert to base62",
            "Random generation: Generate random strings and check for collisions"
          ]
        },
        {
          "type": "text",
          "content": "**System Architecture:**"
        },
        {
          "type": "list",
          "items": [
            "Load Balancer: Distribute traffic across application servers",
            "Application Servers: Handle API requests and URL redirection",
            "Database: Store URLs and analytics data",
            "Cache: Store frequently accessed URLs for faster redirection"
          ]
        },
        {
          "type": "text",
          "content": "**Database Choice:**"
        },
        {
          "type": "list",
          "items": [
            "Relational DB (PostgreSQL/MySQL): For structured data and transactions",
            "NoSQL DB (DynamoDB/Cassandra): For scalability and performance"
          ]
        },
        {
          "type": "text",
          "content": "**Caching Strategy:**"
        },
        {
          "type": "list",
          "items": [
            "Use Redis/Memcached to cache URL mappings",
            "LRU (Least Recently Used) eviction policy"
          ]
        },
        {
          "type": "text",
          "content": "**Scaling Considerations:**"
        },
        {
          "type": "list",
          "items": [
            "Database sharding: Partition URLs based on shortCode hash",
            "Caching: Implement multiple cache layers",
            "CDN: Use for handling static content and reducing latency",
            "Horizontal scaling: Add more application servers as needed"
          ]
        },
        {
          "type": "text",
          "content": "**Security:**"
        },
        {
          "type": "list",
          "items": [
            "Rate limiting: Prevent abuse",
            "URL validation: Check for malicious URLs",
            "User authentication: For managing URLs",
            "HTTPS: Secure all communications"
          ]
        },
        {
          "type": "text",
          "content": "This design balances simplicity, performance, and scalability while addressing the key requirements of a URL shortening service."
        }
      ]
    }
  ]
}
