{
  "frontend-html": [
    {
      "id": "fe-1",
      "question": "Explain how the box model works in CSS.",
      "answer": [
        {
          "type": "text",
          "content": "The CSS box model describes the rectangular boxes that are generated for elements in the document tree and laid out according to the visual formatting model. Each box has a content area (e.g., text, an image, etc.) and optional surrounding padding, border, and margin areas."
        },
        {
          "type": "text",
          "content": "Components from inside to outside:"
        },
        {
          "type": "list",
          "items": [
            "**Content** - The actual content of the box where text and images appear",
            "**Padding** - Clears an area around the content (inside the box)",
            "**Border** - A border that goes around the padding and content",
            "**Margin** - Clears an area outside the border"
          ]
        },
        {
          "type": "text",
          "content": "The total width of an element is calculated as: width + left padding + right padding + left border + right border + left margin + right margin"
        },
        {
          "type": "text",
          "content": "In modern CSS, you can change how the box model works by setting the `box-sizing` property:"
        },
        {
          "type": "list",
          "items": [
            "`box-sizing: content-box` (default): Width and height only apply to the content area",
            "`box-sizing: border-box`: Width and height include content, padding, and border (but not margin)"
          ]
        }
      ]
    },
    {
      "id": "fe-2",
      "question": "What is the difference between 'let', 'const', and 'var' in JavaScript?",
      "answer": [
        {
          "type": "text",
          "content": "These three keywords are used for variable declarations in JavaScript but have different scoping rules and behaviors:"
        },
        {
          "type": "text",
          "content": "**var**:"
        },
        {
          "type": "list",
          "items": [
            "Function-scoped or globally-scoped, not block-scoped",
            "Can be redeclared and updated",
            "Hoisted to the top of its scope and initialized with `undefined`",
            "Can cause unexpected behavior in loops and conditional blocks"
          ]
        },
        {
          "type": "text",
          "content": "**let**:"
        },
        {
          "type": "list",
          "items": [
            "Block-scoped (available only within the block it's defined in)",
            "Can be updated but not redeclared in the same scope",
            "Hoisted but not initialized (in the \"temporal dead zone\" until declaration)",
            "Introduced in ES6 (ES2015)"
          ]
        },
        {
          "type": "text",
          "content": "**const**:"
        },
        {
          "type": "list",
          "items": [
            "Block-scoped like `let`",
            "Cannot be updated or redeclared",
            "Must be initialized at declaration",
            "For objects and arrays, the variable cannot be reassigned, but the properties/elements can be changed",
            "Hoisted but not initialized (in the \"temporal dead zone\" until declaration)",
            "Introduced in ES6 (ES2015)"
          ]
        }
      ]
    },
    {
      "id": "fe-3",
      "question": "Implement a debounce function in JavaScript.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Creates a debounced function that delays invoking the provided function\n * until after 'wait' milliseconds have elapsed since the last time it was invoked.\n * \n * @param {Function} func - The function to debounce\n * @param {number} wait - The number of milliseconds to delay\n * @return {Function} - The debounced function\n */\nfunction debounce(func, wait) {\n  let timeout;\n  \n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    \n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\n// Example usage:\nconst handleSearch = debounce(function(event) {\n  console.log('Searching for:', event.target.value);\n  // API call or other expensive operation\n}, 500);\n\n// Attach to an input element\n// document.querySelector('input').addEventListener('input', handleSearch);"
      }
    }
  ],
  "backend": [
    {
      "id": "be-1",
      "question": "What is REST and what are the key principles of RESTful API design?",
      "answer": [
        {
          "type": "text",
          "content": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs are designed around resources, which are any kind of object, data, or service that can be accessed by the client."
        },
        {
          "type": "text",
          "content": "Key principles of RESTful API design:"
        },
        {
          "type": "list",
          "items": [
            "**Client-Server Architecture**: Separation of concerns between client and server improves portability and scalability.",
            "**Statelessness**: Each request from client to server must contain all the information needed to understand and process the request. The server cannot store session state across requests.",
            "**Cacheability**: Responses must define themselves as cacheable or non-cacheable to prevent clients from reusing stale data.",
            "**Uniform Interface**: A uniform way of interacting with a given server regardless of device or application type. This includes:\n   - Resource identification in requests\n   - Resource manipulation through representations\n   - Self-descriptive messages\n   - Hypermedia as the engine of application state (HATEOAS)",
            "**Layered System**: A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way.",
            "**Code on Demand (optional)**: Servers can temporarily extend client functionality by transferring executable code."
          ]
        },
        {
          "type": "text",
          "content": "RESTful APIs typically use HTTP methods explicitly:"
        },
        {
          "type": "list",
          "items": [
            "GET (retrieve a resource)",
            "POST (create a resource)",
            "PUT (update a resource)",
            "DELETE (remove a resource)",
            "PATCH (partial update)"
          ]
        },
        {
          "type": "text",
          "content": "And HTTP status codes to indicate success/failure."
        }
      ]
    },
    {
      "id": "be-2",
      "question": "Explain the concept of database normalization and its normal forms.",
      "answer": [
        {
          "type": "text",
          "content": "Database normalization is the process of structuring a relational database to reduce data redundancy and improve data integrity. It involves organizing fields and tables to ensure that their dependencies are properly enforced by database integrity constraints."
        },
        {
          "type": "text",
          "content": "The main normal forms are:"
        },
        {
          "type": "text",
          "content": "**First Normal Form (1NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Each table cell should contain a single value",
            "Each record needs to be unique",
            "No repeating groups or arrays"
          ]
        },
        {
          "type": "text",
          "content": "**Second Normal Form (2NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 1NF",
            "All non-key attributes must depend on the entire primary key",
            "Eliminates partial dependencies"
          ]
        },
        {
          "type": "text",
          "content": "**Third Normal Form (3NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 2NF",
            "No transitive dependencies (non-key attributes depending on other non-key attributes)",
            "All fields must depend directly on the primary key"
          ]
        },
        {
          "type": "text",
          "content": "**Boyce-Codd Normal Form (BCNF)**:"
        },
        {
          "type": "list",
          "items": [
            "A stricter version of 3NF",
            "For any dependency A â†’ B, A must be a super key",
            "Addresses certain anomalies not addressed by 3NF"
          ]
        },
        {
          "type": "text",
          "content": "**Fourth Normal Form (4NF)**:"
        },
        {
          "type": "list",
          "items": ["Must be in BCNF", "No multi-valued dependencies"]
        },
        {
          "type": "text",
          "content": "**Fifth Normal Form (5NF)**:"
        },
        {
          "type": "list",
          "items": [
            "Must be in 4NF",
            "No join dependencies",
            "Every join dependency is implied by the candidate keys"
          ]
        },
        {
          "type": "text",
          "content": "Benefits of normalization include:"
        },
        {
          "type": "list",
          "items": [
            "Reducing data redundancy",
            "Improving data integrity",
            "Making the database more flexible",
            "Better database organization"
          ]
        },
        {
          "type": "text",
          "content": "However, excessive normalization can lead to performance issues due to the need for many JOIN operations. In practical applications, denormalization might be applied strategically for performance optimization."
        }
      ]
    }
  ],
  "backend-csharp": [
    {
      "id": "cs-1",
      "question": "What is C# and how does it differ from other programming languages?",
      "answer": [
        {
          "type": "text",
          "content": "C# (pronounced C-Sharp) is a modern, object-oriented programming language developed by Microsoft as part of the .NET framework. It is designed to be simple, safe, and scalable for application development."
        },
        {
          "type": "list",
          "items": [
            "C# is statically typed, whereas languages like JavaScript are dynamically typed.",
            "It is compiled to Intermediate Language (IL) and runs on the .NET runtime, unlike C++ which compiles to machine code.",
            "C# provides automatic garbage collection, whereas C++ requires manual memory management.",
            "It supports both procedural and object-oriented programming paradigms, similar to Java."
          ]
        }
      ]
    },
    {
      "id": "be-4",
      "question": "What are the basic syntax rules and features of C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# is an object-oriented, statically-typed language developed by Microsoft for the .NET platform. It provides strong typing, garbage collection, and high-level abstraction."
        },
        {
          "type": "text",
          "content": "Here are the fundamental syntax rules and features of C#:"
        },
        {
          "type": "list",
          "items": [
            "**Namespace and Classes**: Code is organized using `namespace`, and functionality is encapsulated in `class`.",
            "**Main Method**: Every C# program has a `Main` method as the entry point.",
            "**Data Types**: Includes built-in types like `int`, `float`, `string`, `bool`, `object`, and user-defined types.",
            "**Variables and Constants**: Declared using `var`, `int`, `string`, or `const`.",
            "**Control Flow**: Uses `if-else`, `switch`, `for`, `while`, `foreach`, `try-catch` for exception handling.",
            "**Methods**: Functions are defined using `returnType MethodName(parameters) {}`.",
            "**Object-Oriented Programming (OOP)**: Supports classes, inheritance, polymorphism, and interfaces.",
            "**Asynchronous Programming**: Uses `async` and `await` keywords for non-blocking execution."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\n\nnamespace HelloWorld\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello, C#!\");\n\n            // Variable declaration\n            int x = 10;\n            var y = 20; // Implicit typing\n\n            // Conditional statement\n            if (y > x)\n            {\n                Console.WriteLine(\"y is greater than x\");\n            }\n\n            // Loop\n            for (int i = 0; i < 5; i++)\n            {\n                Console.WriteLine(i);\n            }\n\n            // Function call\n            int sum = Add(5, 3);\n            Console.WriteLine(\"Sum: \" + sum);\n        }\n\n        // Function definition\n        static int Add(int a, int b)\n        {\n            return a + b;\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-2",
      "question": "What are the key features of C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Object-Oriented**: Supports classes, inheritance, polymorphism, and encapsulation.",
            "**Automatic Memory Management**: Uses garbage collection to manage memory efficiently.",
            "**Type Safety**: Prevents operations that lead to type errors.",
            "**LINQ Support**: Provides a powerful query syntax for collections and databases.",
            "**Asynchronous Programming**: Supports async/await for handling asynchronous operations.",
            "**Cross-Platform**: With .NET Core, C# applications can run on Windows, macOS, and Linux."
          ]
        }
      ]
    },
    {
      "id": "cs-3",
      "question": "Explain the difference between value types and reference types in C#.",
      "answer": [
        {
          "type": "text",
          "content": "C# differentiates between value types and reference types based on how data is stored in memory."
        },
        {
          "type": "text",
          "content": "**Value Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in stack memory.",
            "Contain actual values.",
            "Examples: int, float, char, struct, enum."
          ]
        },
        {
          "type": "text",
          "content": "**Reference Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in heap memory.",
            "Contain references (addresses) to actual data.",
            "Examples: class, interface, delegate, array, string."
          ]
        }
      ]
    },
    {
      "id": "cs-4",
      "question": "What is the difference between var, dynamic, and object in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**var**: Statically typed, inferred at compile-time. Cannot change type after initialization.",
            "**dynamic**: Dynamically typed, resolved at runtime. Allows flexibility but reduces compile-time checks.",
            "**object**: Base type for all types in C#. Requires explicit casting for specific type operations."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "var number = 10; // int type inferred\nobject obj = \"Hello\"; // Can store any type\ndynamic dyn = 100; // Type determined at runtime"
        }
      ]
    },
    {
      "id": "cs-5",
      "question": "What are nullable types in C#? How do you declare them?",
      "answer": [
        {
          "type": "text",
          "content": "Nullable types allow value types (like int, float) to hold a null value, useful for database operations."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "int? age = null; // Nullable int\ndouble? price = 9.99; // Nullable double"
        }
      ]
    },
    {
      "id": "cs-6",
      "question": "Explain boxing and unboxing with examples.",
      "answer": [
        {
          "type": "text",
          "content": "Boxing is converting a value type to an object type. Unboxing is converting an object type back to a value type."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Boxing\nint num = 10;\nobject obj = num; // num is boxed\n\n// Unboxing\nint unboxedNum = (int)obj; // Explicit cast required"
        }
      ]
    },
    {
      "id": "cs-7",
      "question": "What is the difference between const, readonly, and static in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**const**: Value is assigned at compile-time and cannot be changed.",
            "**readonly**: Value is assigned at runtime, can be changed in the constructor.",
            "**static**: Shared across all instances of a class."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "const double PI = 3.14; // Compile-time constant\nreadonly int id; // Runtime constant\nstatic int counter; // Shared across instances"
        }
      ]
    },
    {
      "id": "cs-8",
      "question": "What are access modifiers in C#? Explain public, private, protected, and internal.",
      "answer": [
        {
          "type": "list",
          "items": [
            "**public**: Accessible from anywhere.",
            "**private**: Accessible only within the same class.",
            "**protected**: Accessible within the same class and derived classes.",
            "**internal**: Accessible within the same assembly."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Example {\n    public int publicVar;\n    private int privateVar;\n    protected int protectedVar;\n    internal int internalVar;\n}"
        }
      ]
    },
    {
      "id": "cs-9",
      "question": "Explain the concept of namespace in C#.",
      "answer": [
        {
          "type": "text",
          "content": "A namespace is a way to organize code and prevent naming conflicts in C#."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "namespace MyApp {\n    class Program {\n        static void Main() {\n            Console.WriteLine(\"Hello World\");\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-10",
      "question": "What is the difference between == and .Equals() in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**==**: Compares object references for reference types and values for value types.",
            "**.Equals()**: Can be overridden to compare contents instead of references."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "string a = \"hello\";\nstring b = \"hello\";\nConsole.WriteLine(a == b); // true (compares values)\nConsole.WriteLine(a.Equals(b)); // true (compares values)\n\nobject obj1 = new object();\nobject obj2 = new object();\nConsole.WriteLine(obj1 == obj2); // false (different references)\nConsole.WriteLine(obj1.Equals(obj2)); // false (default implementation)"
        }
      ]
    },
    {
      "id": "oop-1",
      "question": "What is object-oriented programming (OOP)?",
      "answer": [
        {
          "type": "text",
          "content": "Object-Oriented Programming (OOP) is a programming paradigm that organizes code into objects, which are instances of classes. It provides a structured way of designing programs using principles such as encapsulation, inheritance, polymorphism, and abstraction."
        },
        {
          "type": "list",
          "items": [
            "**Encapsulation**: Hides internal implementation details and only exposes necessary functionalities.",
            "**Inheritance**: Allows a class to inherit properties and methods from another class.",
            "**Polymorphism**: Enables a single interface to represent different data types.",
            "**Abstraction**: Hides complex implementation details and exposes only the necessary parts of an object."
          ]
        }
      ]
    },
    {
      "id": "oop-2",
      "question": "Explain encapsulation, inheritance, polymorphism, and abstraction in C#.",
      "answer": [
        {
          "type": "text",
          "content": "**Encapsulation**: The process of wrapping data and methods within a class and restricting direct access to some components."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Person {\n  private string name;\n  public string GetName() => name;\n  public void SetName(string newName) => name = newName;\n}"
        },
        {
          "type": "text",
          "content": "**Inheritance**: A mechanism where one class derives from another, reusing and extending its functionalities."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Animal { public void Eat() { Console.WriteLine(\"Eating\"); } }\nclass Dog : Animal { public void Bark() { Console.WriteLine(\"Barking\"); } }"
        },
        {
          "type": "text",
          "content": "**Polymorphism**: The ability of different classes to be treated as instances of the same class through a common interface."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Shape { public virtual void Draw() { Console.WriteLine(\"Drawing Shape\"); } }\nclass Circle : Shape { public override void Draw() { Console.WriteLine(\"Drawing Circle\"); } }"
        },
        {
          "type": "text",
          "content": "**Abstraction**: Hiding implementation details and exposing only essential functionalities."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "abstract class Vehicle {\n  public abstract void Move();\n}\nclass Car : Vehicle {\n  public override void Move() { Console.WriteLine(\"Car is moving\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-3",
      "question": "What is the difference between an abstract class and an interface?",
      "answer": [
        {
          "type": "text",
          "content": "An **abstract class** is a class that cannot be instantiated and may contain both abstract and non-abstract methods. An **interface** is a contract that defines only method signatures without implementation."
        },
        {
          "type": "list",
          "items": [
            "**Abstract Class**: Can have method implementations, fields, and constructors.",
            "**Interface**: Cannot have field members; only method signatures (before C# 8.0).",
            "**Abstract Class**: Used when classes share behavior.",
            "**Interface**: Used for multiple inheritance or enforcing behavior across classes."
          ]
        }
      ]
    },
    {
      "id": "oop-4",
      "question": "Can a class implement multiple interfaces in C#? Provide an example.",
      "answer": [
        {
          "type": "text",
          "content": "Yes, C# allows a class to implement multiple interfaces, enabling multiple inheritance of behavior."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "interface IA { void MethodA(); }\ninterface IB { void MethodB(); }\nclass MyClass : IA, IB {\n  public void MethodA() { Console.WriteLine(\"MethodA Implementation\"); }\n  public void MethodB() { Console.WriteLine(\"MethodB Implementation\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-5",
      "question": "What is method overloading and method overriding? Give examples.",
      "answer": [
        {
          "type": "text",
          "content": "**Method Overloading**: Defining multiple methods with the same name but different parameters."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class MathOps {\n  public int Add(int a, int b) => a + b;\n  public double Add(double a, double b) => a + b;\n}"
        },
        {
          "type": "text",
          "content": "**Method Overriding**: A derived class provides a new implementation for a method from the base class."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Base {\n  public virtual void Show() { Console.WriteLine(\"Base Show\"); }\n}\nclass Derived : Base {\n  public override void Show() { Console.WriteLine(\"Derived Show\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-6",
      "question": "What is a sealed class in C#? When would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "A **sealed class** prevents inheritance, ensuring no class can derive from it. It is used for security and performance reasons."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "sealed class Utility {\n  public void Display() { Console.WriteLine(\"Utility Class\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-7",
      "question": "How does C# support multiple inheritance?",
      "answer": [
        {
          "type": "text",
          "content": "C# does not support multiple inheritance with classes but allows multiple interface implementation."
        }
      ]
    },
    {
      "id": "oop-8",
      "question": "What is a partial class?",
      "answer": [
        {
          "type": "text",
          "content": "A **partial class** allows a class to be split across multiple files, making large class definitions easier to manage."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// File1.cs\npartial class MyClass {\n  public void Method1() { Console.WriteLine(\"Method1\"); }\n}\n// File2.cs\npartial class MyClass {\n  public void Method2() { Console.WriteLine(\"Method2\"); }\n}"
        }
      ]
    },
    {
      "id": "oop-9",
      "question": "What is a static class in C#? When should it be used?",
      "answer": [
        {
          "type": "text",
          "content": "A **static class** cannot be instantiated and contains only static members. It is used for utility functions that do not require instance state."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "static class MathUtils {\n  public static int Square(int num) => num * num;\n}"
        }
      ]
    },
    {
      "id": "oop-10",
      "question": "What is the difference between a constructor and a destructor in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Constructor**: Initializes an object when it is created.",
            "**Destructor**: Cleans up resources when the object is destroyed.",
            "**Constructors**: Can be overloaded.",
            "**Destructors**: Cannot be overloaded."
          ]
        }
      ]
    },

    {
      "id": "cs-21",
      "question": "What are the different types of collections available in C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# provides various types of collections in the System.Collections and System.Collections.Generic namespaces."
        },
        {
          "type": "list",
          "items": [
            "**Array** - Fixed-size, type-safe collection of elements.",
            "**List<T>** - Dynamic array that grows as needed.",
            "**Dictionary<TKey, TValue>** - Key-value pair collection for fast lookups.",
            "**HashSet<T>** - Unordered collection of unique elements.",
            "**Queue<T>** - FIFO (First In, First Out) collection.",
            "**Stack<T>** - LIFO (Last In, First Out) collection.",
            "**LinkedList<T>** - Doubly linked list implementation.",
            "**SortedList<TKey, TValue>** - Sorted collection of key-value pairs.",
            "**SortedDictionary<TKey, TValue>** - A dictionary where keys are sorted.",
            "**ObservableCollection<T>** - A collection that notifies observers of changes."
          ]
        }
      ]
    },
    {
      "id": "cs-22",
      "question": "What is the difference between an Array and a List in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Array**: Fixed size, type-safe, and provides fast access to elements using indices.",
            "**List<T>**: Dynamic size, provides additional utility methods like Add, Remove, and supports LINQ operations.",
            "**Performance**: Arrays are faster due to fixed memory allocation, while Lists offer flexibility at the cost of minor performance overhead."
          ]
        }
      ]
    },
    {
      "id": "cs-23",
      "question": "Explain Stack and Queue with examples.",
      "answer": [
        {
          "type": "text",
          "content": "Stack and Queue are both linear data structures with different order of operations."
        },
        {
          "type": "text",
          "content": "**Stack (LIFO - Last In, First Out)**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Stack<int> stack = new Stack<int>();\nstack.Push(1);\nstack.Push(2);\nstack.Push(3);\nConsole.WriteLine(stack.Pop()); // Outputs: 3"
        },
        {
          "type": "text",
          "content": "**Queue (FIFO - First In, First Out)**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Queue<int> queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nqueue.Enqueue(3);\nConsole.WriteLine(queue.Dequeue()); // Outputs: 1"
        }
      ]
    },
    {
      "id": "cs-24",
      "question": "What is a Dictionary in C#? How does it differ from a List?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Dictionary<TKey, TValue>**: Stores key-value pairs and provides fast lookups by key.",
            "**List<T>**: Stores elements in an ordered manner, accessible by index.",
            "**Performance**: Dictionary lookup is faster (O(1)) compared to searching in a List (O(n) in worst case).",
            "**Use Case**: Use Dictionary for fast lookups and List for ordered collections where index-based access is required."
          ]
        }
      ]
    },
    {
      "id": "cs-25",
      "question": "What is the difference between IEnumerable<T> and IQueryable<T>?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**IEnumerable<T>**: Used for in-memory collection iteration, executes queries immediately.",
            "**IQueryable<T>**: Used for querying data from external sources (e.g., databases), supports deferred execution and optimization."
          ]
        }
      ]
    },
    {
      "id": "cs-26",
      "question": "What are hash tables and how are they implemented in C#?",
      "answer": [
        {
          "type": "text",
          "content": "A hash table is a data structure that stores key-value pairs using a hash function for fast lookups."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Hashtable hashtable = new Hashtable();\nhashtable.Add(\"key1\", \"value1\");\nhashtable.Add(\"key2\", \"value2\");\nConsole.WriteLine(hashtable[\"key1\"]); // Outputs: value1"
        }
      ]
    },
    {
      "id": "cs-27",
      "question": "What is the difference between List<T> and ArrayList?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**List<T>**: Type-safe, generic collection introduced in .NET 2.0.",
            "**ArrayList**: Non-generic, stores objects of any type (boxing/unboxing overhead).",
            "**Performance**: List<T> is faster due to type safety and no need for type conversions."
          ]
        }
      ]
    },
    {
      "id": "cs-28",
      "question": "Explain LINQ (Language Integrated Query) and its benefits.",
      "answer": [
        {
          "type": "text",
          "content": "LINQ (Language Integrated Query) allows querying collections using C# syntax."
        },
        {
          "type": "list",
          "items": [
            "Improves code readability.",
            "Reduces the need for loops and conditional statements.",
            "Supports multiple data sources (collections, XML, databases)."
          ]
        }
      ]
    },
    {
      "id": "cs-29",
      "question": "What is the difference between First() and FirstOrDefault() in LINQ?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**First()**: Returns the first element, throws an exception if no elements exist.",
            "**FirstOrDefault()**: Returns the first element or default value (null for reference types, 0 for int, etc.) if none exist."
          ]
        }
      ]
    },
    {
      "id": "cs-30",
      "question": "What is the difference between Select and SelectMany in LINQ?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Select**: Projects each element into a new form (1-to-1 mapping).",
            "**SelectMany**: Flattens nested collections into a single sequence (1-to-many mapping)."
          ]
        }
      ]
    },
    {
      "id": "cs-17",
      "question": "How does C# support multiple inheritance?",
      "answer": [
        {
          "type": "text",
          "content": "C# does not support multiple inheritance directly. Instead, it uses interfaces to achieve similar functionality."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "interface IA { void MethodA(); }\ninterface IB { void MethodB(); }\nclass C : IA, IB { public void MethodA() {} public void MethodB() {} }"
        }
      ]
    },
    {
      "id": "cs-18",
      "question": "What is a partial class?",
      "answer": [
        {
          "type": "text",
          "content": "A partial class allows splitting a class definition across multiple files for better organization."
        }
      ]
    },
    {
      "id": "cs-19",
      "question": "What is a static class in C#? When should it be used?",
      "answer": [
        {
          "type": "text",
          "content": "A static class contains only static members and cannot be instantiated. It is used for utility methods."
        }
      ]
    },
    {
      "id": "cs-20",
      "question": "What is the difference between a constructor and a destructor in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Constructor**: Initializes an object when it is created.",
            "**Destructor**: Cleans up resources before an object is garbage collected."
          ]
        }
      ]
    },

    {
      "id": "cs-31",
      "question": "What is multithreading in C#? How does it improve performance?",
      "answer": [
        {
          "type": "text",
          "content": "Multithreading in C# is a feature that allows multiple threads to run concurrently, enabling parallel execution of tasks. It improves performance by utilizing multiple cores of a CPU efficiently and ensuring responsiveness in applications."
        },
        {
          "type": "text",
          "content": "Benefits of multithreading:"
        },
        {
          "type": "list",
          "items": [
            "Improves application responsiveness (e.g., UI remains responsive while executing background tasks).",
            "Enhances CPU utilization by running multiple tasks in parallel.",
            "Reduces execution time by dividing work among threads."
          ]
        },
        {
          "type": "text",
          "content": "Example of creating and starting a thread in C#:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading;\n\nclass Program {\n    static void PrintNumbers() {\n        for (int i = 1; i <= 5; i++) {\n            Console.WriteLine(i);\n            Thread.Sleep(500); // Simulating work\n        }\n    }\n\n    static void Main() {\n        Thread thread = new Thread(PrintNumbers);\n        thread.Start();\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-32",
      "question": "Explain Thread vs Task in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Both `Thread` and `Task` are used for parallel execution in C#, but they have different use cases."
        },
        {
          "type": "text",
          "content": "Key differences:"
        },
        {
          "type": "list",
          "items": [
            "**Thread:** Lower-level construct that represents a dedicated system thread.",
            "**Task:** Higher-level abstraction from the Task Parallel Library (TPL) that manages threads internally."
          ]
        },
        {
          "type": "text",
          "content": "Example using Thread:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Thread thread = new Thread(() => Console.WriteLine(\"Running in thread\"));\nthread.Start();"
        },
        {
          "type": "text",
          "content": "Example using Task:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Task.Run(() => Console.WriteLine(\"Running in task\"));"
        }
      ]
    },
    {
      "id": "cs-33",
      "question": "What is the difference between async and await in C#?",
      "answer": [
        {
          "type": "text",
          "content": "`async` and `await` are used for asynchronous programming in C#."
        },
        {
          "type": "text",
          "content": "Key differences:"
        },
        {
          "type": "list",
          "items": [
            "**async:** Used to define an asynchronous method. It allows the method to return a `Task`.",
            "**await:** Suspends execution of the async method until the awaited task completes, preventing blocking."
          ]
        },
        {
          "type": "text",
          "content": "Example:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "async Task<int> GetDataAsync() {\n    await Task.Delay(1000); // Simulate async operation\n    return 42;\n}\n\nasync Task Main() {\n    int result = await GetDataAsync();\n    Console.WriteLine(result);\n}"
        }
      ]
    },
    {
      "id": "cs-34",
      "question": "What is deadlock, and how do you prevent it?",
      "answer": [
        {
          "type": "text",
          "content": "A deadlock occurs when two or more threads are waiting indefinitely for resources locked by each other, causing a circular wait."
        },
        {
          "type": "text",
          "content": "Ways to prevent deadlocks:"
        },
        {
          "type": "list",
          "items": [
            "Avoid nested locks.",
            "Use lock timeouts.",
            "Follow a consistent locking order.",
            "Use `Monitor.TryEnter` or `Mutex` with timeout."
          ]
        }
      ]
    },
    {
      "id": "cs-35",
      "question": "What are Task.Run() and Task.Delay() used for in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "`Task.Run()`: Executes a method asynchronously on a thread pool.",
            "`Task.Delay()`: Introduces an asynchronous delay without blocking the thread."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "await Task.Run(() => Console.WriteLine(\"Running in Task\"));\nawait Task.Delay(1000); // Wait for 1 second"
        }
      ]
    },
    {
      "id": "cs-36",
      "question": "How does the lock keyword work in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The `lock` keyword ensures that only one thread can access a critical section at a time."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "private static object locker = new object();\n\nlock (locker) {\n    // Critical section\n}"
        }
      ]
    },
    {
      "id": "cs-37",
      "question": "What are concurrent collections in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Concurrent collections are thread-safe collections provided by `System.Collections.Concurrent`."
        },
        {
          "type": "list",
          "items": [
            "`ConcurrentDictionary<TKey, TValue>`",
            "`ConcurrentQueue<T>`",
            "`ConcurrentStack<T>`",
            "`ConcurrentBag<T>`"
          ]
        }
      ]
    },
    {
      "id": "cs-38",
      "question": "Explain CancellationToken and its usage in asynchronous programming.",
      "answer": [
        {
          "type": "text",
          "content": "CancellationToken is used to cancel async operations in C#."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "CancellationTokenSource cts = new CancellationTokenSource();\nawait Task.Run(() => {\n    if (cts.Token.IsCancellationRequested) return;\n});"
        }
      ]
    },
    {
      "id": "cs-39",
      "question": "What is TPL (Task Parallel Library)?",
      "answer": [
        {
          "type": "text",
          "content": "The Task Parallel Library (TPL) is a framework in C# for parallel execution of tasks, making multithreading easier."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Task t = Task.Run(() => Console.WriteLine(\"Running task\"));"
        }
      ]
    },
    {
      "id": "cs-40",
      "question": "How does Parallel.ForEach work in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Parallel.ForEach enables parallel execution over collections."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Parallel.ForEach(Enumerable.Range(1, 10), (i) => {\n    Console.WriteLine(i);\n});"
        }
      ]
    },
    {
      "id": "cs-41",
      "question": "What is Garbage Collection (GC) in C#? How does it work?",
      "answer": [
        {
          "type": "text",
          "content": "Garbage Collection (GC) in C# is an automatic memory management feature provided by the .NET runtime. It helps in reclaiming memory occupied by objects that are no longer in use, preventing memory leaks."
        },
        {
          "type": "text",
          "content": "How it works:"
        },
        {
          "type": "list",
          "items": [
            "**Generational Garbage Collection**: Objects are divided into three generations (Gen 0, Gen 1, Gen 2) based on their lifespan.",
            "**Mark-and-Sweep Algorithm**: The GC identifies objects that are no longer reachable and removes them.",
            "**Compacting**: After collection, the memory is compacted to reduce fragmentation.",
            "**Finalization**: If an object has a finalizer, GC runs it before reclaiming memory."
          ]
        }
      ]
    },
    {
      "id": "cs-42",
      "question": "What are finalizers in C#?",
      "answer": [
        {
          "type": "text",
          "content": "A finalizer is a special method in C# that is used to perform cleanup operations before an object is garbage collected."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class MyClass\n{\n    ~MyClass()\n    {\n        // Cleanup code before object destruction\n        Console.WriteLine(\"Finalizer called\");\n    }\n}"
        },
        {
          "type": "text",
          "content": "Finalizers are non-deterministic and should be avoided unless necessary. Instead, IDisposable should be used for cleanup."
        }
      ]
    },
    {
      "id": "cs-43",
      "question": "What is the difference between Dispose() and Finalize()?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Dispose()**: Used for deterministic cleanup, part of IDisposable interface, explicitly called by the developer.",
            "**Finalize()**: Called by the Garbage Collector, used for non-managed resources cleanup, runs unpredictably."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class MyClass : IDisposable\n{\n    public void Dispose()\n    {\n        // Cleanup resources\n        GC.SuppressFinalize(this); // Prevent finalizer call\n    }\n    ~MyClass()\n    {\n        // Finalizer\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-44",
      "question": "How do you manage memory leaks in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "Use **IDisposable** for resources like database connections, files, etc.",
            "Use the **using** statement to automatically dispose objects.",
            "Avoid static references that prevent objects from being collected.",
            "Monitor memory usage using **dotMemory, PerfMon, or GC.GetTotalMemory()**.",
            "Unsubscribe from events to prevent memory leaks due to event handler references."
          ]
        }
      ]
    },
    {
      "id": "cs-45",
      "question": "What is the using statement in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The `using` statement in C# is used to ensure that objects implementing IDisposable are disposed of properly, avoiding memory leaks."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using (StreamReader reader = new StreamReader(\"file.txt\"))\n{\n    string content = reader.ReadToEnd();\n}"
        }
      ]
    },
    {
      "id": "cs-46",
      "question": "What is Dependency Injection (DI) and how is it implemented in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern that helps in managing dependencies between objects by injecting them rather than creating them within a class."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IService { void Serve(); }\npublic class MyService : IService { public void Serve() => Console.WriteLine(\"Service called\"); }\n\npublic class Client\n{\n    private readonly IService _service;\n    public Client(IService service) { _service = service; }\n    public void Start() { _service.Serve(); }\n}\n\n// Dependency Injection using .NET Core DI Container\nvar services = new ServiceCollection();\nservices.AddTransient<IService, MyService>();\nvar provider = services.BuildServiceProvider();\nvar client = provider.GetService<Client>();\nclient?.Start();"
        }
      ]
    },
    {
      "id": "cs-47",
      "question": "What is Reflection in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Reflection in C# allows runtime inspection of assemblies, modules, and types. It enables dynamic object creation and method invocation."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Type type = typeof(String);\nMethodInfo method = type.GetMethod(\"Substring\", new Type[] { typeof(int) });\nConsole.WriteLine(method.ReturnType);"
        }
      ]
    },
    {
      "id": "cs-48",
      "question": "Explain delegates and events in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Delegates are type-safe function pointers that allow methods to be passed as parameters. Events are built on delegates and provide a mechanism for publishing and subscribing to notifications."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public delegate void Notify();\npublic class Process\n{\n    public event Notify OnProcessCompleted;\n    public void Start() { OnProcessCompleted?.Invoke(); }\n}\n\n// Usage\nProcess process = new Process();\nprocess.OnProcessCompleted += () => Console.WriteLine(\"Process completed\");\nprocess.Start();"
        }
      ]
    },
    {
      "id": "cs-49",
      "question": "What is the difference between Func, Action, and Predicate in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Func<T>**: Represents a method that returns a value.",
            "**Action<T>**: Represents a method that does not return a value.",
            "**Predicate<T>**: Represents a method that returns a boolean value."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Func<int, int> square = x => x * x; // Returns value\nAction<string> print = msg => Console.WriteLine(msg); // No return value\nPredicate<int> isEven = x => x % 2 == 0; // Returns boolean"
        }
      ]
    },
    {
      "id": "cs-50",
      "question": "What is Entity Framework (EF) and how does it work with C#?",
      "answer": [
        {
          "type": "text",
          "content": "Entity Framework (EF) is an ORM (Object-Relational Mapper) for .NET that simplifies database interactions by allowing developers to work with database entities as C# objects."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\npublic class AppDbContext : DbContext\n{\n    public DbSet<Product> Products { get; set; }\n}\n\n// Usage\nusing (var context = new AppDbContext())\n{\n    context.Products.Add(new Product { Name = \"Laptop\" });\n    context.SaveChanges();\n}"
        }
      ]
    },
    {
      "id": "cs-1",
      "question": "Implement a generic repository pattern in C# using EF Core.",
      "answer": [
        {
          "type": "text",
          "content": "The generic repository pattern in C# using Entity Framework Core provides a reusable and maintainable way to interact with the database."
        },
        {
          "type": "text",
          "content": "Key benefits of using the repository pattern:"
        },
        {
          "type": "list",
          "items": [
            "Encapsulates data access logic, improving maintainability",
            "Reduces code duplication",
            "Enhances testability by providing an abstraction layer over EF Core"
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IRepository<T> where T : class\n{\n    Task<IEnumerable<T>> GetAllAsync();\n    Task<T> GetByIdAsync(int id);\n    Task AddAsync(T entity);\n    Task UpdateAsync(T entity);\n    Task DeleteAsync(int id);\n}\n\npublic class Repository<T> : IRepository<T> where T : class\n{\n    private readonly DbContext _context;\n    private readonly DbSet<T> _dbSet;\n\n    public Repository(DbContext context)\n    {\n        _context = context;\n        _dbSet = context.Set<T>();\n    }\n\n    public async Task<IEnumerable<T>> GetAllAsync() => await _dbSet.ToListAsync();\n    public async Task<T> GetByIdAsync(int id) => await _dbSet.FindAsync(id);\n    public async Task AddAsync(T entity) { await _dbSet.AddAsync(entity); await _context.SaveChangesAsync(); }\n    public async Task UpdateAsync(T entity) { _dbSet.Update(entity); await _context.SaveChangesAsync(); }\n    public async Task DeleteAsync(int id) { var entity = await GetByIdAsync(id); if (entity != null) { _dbSet.Remove(entity); await _context.SaveChangesAsync(); } }\n}"
        }
      ]
    },
    {
      "id": "cs-2",
      "question": "Write an in-memory caching mechanism in C#.",
      "answer": [
        {
          "type": "text",
          "content": "In-memory caching improves performance by reducing redundant database or API calls."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class MemoryCacheService\n{\n    private readonly IMemoryCache _cache;\n    public MemoryCacheService(IMemoryCache cache) { _cache = cache; }\n\n    public T GetOrCreate<T>(string key, Func<T> createItem, TimeSpan cacheDuration)\n    {\n        if (!_cache.TryGetValue(key, out T value))\n        {\n            value = createItem();\n            _cache.Set(key, value, cacheDuration);\n        }\n        return value;\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-3",
      "question": "Implement a distributed lock system in C# using Redis.",
      "answer": [
        {
          "type": "text",
          "content": "Distributed locking ensures that multiple instances of an application do not execute critical sections simultaneously."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public async Task<bool> AcquireLockAsync(string key, TimeSpan expiration)\n{\n    using var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var db = redis.GetDatabase();\n    return await db.StringSetAsync(key, \"locked\", expiration, When.NotExists);\n}\n\npublic async Task ReleaseLockAsync(string key)\n{\n    using var redis = ConnectionMultiplexer.Connect(\"localhost\");\n    var db = redis.GetDatabase();\n    await db.KeyDeleteAsync(key);\n}"
        }
      ]
    },
    {
      "id": "cs-4",
      "question": "Write a high-performance API in C# using ASP.NET Core.",
      "answer": [
        {
          "type": "text",
          "content": "Optimizing ASP.NET Core APIs for high performance includes techniques such as response caching, efficient database queries, and using asynchronous programming."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "[ApiController]\n[Route(\"api/[controller]\")]\npublic class PerformanceController : ControllerBase\n{\n    [HttpGet(\"data\")] \n    [ResponseCache(Duration = 60)]\n    public async Task<IActionResult> GetDataAsync()\n    {\n        var data = await GetDataFromDbAsync(); // Simulated async data fetch\n        return Ok(data);\n    }\n\n    private Task<string[]> GetDataFromDbAsync() => Task.FromResult(new[] { \"Item1\", \"Item2\" });\n}"
        }
      ]
    },
    {
      "id": "cs-5",
      "question": "Implement a message queue in C# using RabbitMQ or Azure Service Bus.",
      "answer": [
        {
          "type": "text",
          "content": "Message queues help in building scalable and decoupled applications. RabbitMQ and Azure Service Bus are popular message brokers."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public async Task SendMessageAsync(string message)\n{\n    var factory = new ConnectionFactory() { HostName = \"localhost\" };\n    using var connection = factory.CreateConnection();\n    using var channel = connection.CreateModel();\n    channel.QueueDeclare(queue: \"task_queue\", durable: true, exclusive: false, autoDelete: false, arguments: null);\n    var body = Encoding.UTF8.GetBytes(message);\n    var properties = channel.CreateBasicProperties();\n    properties.Persistent = true;\n    channel.BasicPublish(exchange: \"\", routingKey: \"task_queue\", basicProperties: properties, body: body);\n}"
        }
      ]
    },
    {
      "id": "cs-1",
      "question": "Explain the syntax and usage of Func and Action in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Func and Action are predefined delegates in C# used for encapsulating methods with different signatures."
        },
        {
          "type": "text",
          "content": "**Func<T, TResult>**:"
        },
        {
          "type": "list",
          "items": [
            "Func is a generic delegate that represents a method that returns a value.",
            "It can take up to 16 input parameters.",
            "The last generic parameter is always the return type."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Func<int, int, int> add = (a, b) => a + b;\nint result = add(5, 10); // Output: 15"
        },
        {
          "type": "text",
          "content": "**Action<T>**:"
        },
        {
          "type": "list",
          "items": [
            "Action is a generic delegate that represents a method with parameters but no return value.",
            "It can take up to 16 input parameters."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Action<string> greet = name => Console.WriteLine($\"Hello, {name}!\");\ngreet(\"Alice\"); // Output: Hello, Alice!"
        }
      ]
    },
    {
      "id": "cs-2",
      "question": "Explain the syntax and usage of delegates and events in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Delegates are type-safe pointers to methods, and events are a special kind of delegate used for notifications."
        },
        {
          "type": "text",
          "content": "**Delegate Syntax:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Define a delegate\ndelegate void Notify(string message);\n\n// Use the delegate\nclass Program {\n    static void DisplayMessage(string msg) {\n        Console.WriteLine(msg);\n    }\n    static void Main() {\n        Notify notifier = DisplayMessage;\n        notifier(\"Hello, Delegates!\"); // Output: Hello, Delegates!\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Event Syntax:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Publisher {\n    public event Action<string> OnNotify;\n    \n    public void TriggerEvent() {\n        OnNotify?.Invoke(\"Event triggered!\");\n    }\n}\n\nclass Subscriber {\n    static void Main() {\n        Publisher pub = new Publisher();\n        pub.OnNotify += msg => Console.WriteLine(msg);\n        pub.TriggerEvent(); // Output: Event triggered!\n    }\n}"
        }
      ]
    },
    {
      "id": "cs-3",
      "question": "Explain the syntax and usage of generics in C#.",
      "answer": [
        {
          "type": "text",
          "content": "Generics allow defining classes, interfaces, and methods with a placeholder for data types, providing type safety and code reusability."
        },
        {
          "type": "text",
          "content": "**Generic Class Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class GenericBox<T> {\n    private T value;\n    public void SetValue(T val) {\n        value = val;\n    }\n    public T GetValue() {\n        return value;\n    }\n}\n\nclass Program {\n    static void Main() {\n        GenericBox<int> intBox = new GenericBox<int>();\n        intBox.SetValue(42);\n        Console.WriteLine(intBox.GetValue()); // Output: 42\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Generic Method Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Program {\n    static void Swap<T>(ref T a, ref T b) {\n        T temp = a;\n        a = b;\n        b = temp;\n    }\n    static void Main() {\n        int x = 5, y = 10;\n        Swap(ref x, ref y);\n        Console.WriteLine($\"x: {x}, y: {y}\"); // Output: x: 10, y: 5\n    }\n}"
        }
      ]
    }
  ],
  "backend-csharp-basic": [
    {
      "id": "be-5",
      "question": "What are the data types and variable declarations in C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# is a strongly typed language that provides various data types categorized into Value Types and Reference Types."
        },
        {
          "type": "list",
          "items": [
            "**Value Types**: `int`, `double`, `float`, `bool`, `char`, `struct`, `enum` - Stored directly in memory.",
            "**Reference Types**: `string`, `object`, `dynamic`, `class`, `interface`, `delegate` - Stored as references.",
            "**Nullable Types**: `int?`, `double?`, etc. - Allows value types to hold `null` values.",
            "**Implicit Typing**: `var` - Compiler infers type at compile-time.",
            "**Dynamic Typing**: `dynamic` - Type is resolved at runtime."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "int age = 30;\ndouble price = 99.99;\nvar name = \"Alice\"; // Compiler infers string type\ndynamic value = 10; // Can change type dynamically\nvalue = \"Hello\"; // Now it's a string"
        }
      ]
    },
    {
      "id": "be-6",
      "question": "What are the control flow keywords in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Control flow statements determine the execution order of statements in a program."
        },
        {
          "type": "list",
          "items": [
            "**Conditional Statements**: `if`, `else`, `switch`, `case`",
            "**Looping Statements**: `for`, `while`, `do-while`, `foreach`",
            "**Jump Statements**: `break`, `continue`, `return`, `goto`"
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "for (int i = 0; i < 5; i++)\n{\n    if (i == 3) continue; // Skips iteration\n    Console.WriteLine(i);\n}"
        }
      ]
    },
    {
      "id": "be-7",
      "question": "How does exception handling work in C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# provides structured exception handling using `try`, `catch`, `finally`, and `throw` to handle errors gracefully."
        },
        {
          "type": "list",
          "items": [
            "`try` - Defines a block of code to test for exceptions.",
            "`catch` - Handles exceptions.",
            "`finally` - Executes regardless of exception occurrence.",
            "`throw` - Used to throw an exception."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    int num = int.Parse(\"abc\"); // Throws FormatException\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Invalid format: \" + ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Execution completed.\");\n}"
        }
      ]
    },
    {
      "id": "be-8",
      "question": "What are the key Object-Oriented Programming (OOP) keywords in C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# is an object-oriented language and follows OOP principles like encapsulation, inheritance, and polymorphism."
        },
        {
          "type": "list",
          "items": [
            "**Class & Object Keywords**: `class`, `struct`, `new`",
            "**Inheritance Keywords**: `base`, `this`, `virtual`, `override`, `abstract`, `sealed`",
            "**Encapsulation Keywords**: `private`, `protected`, `public`, `internal`"
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Animal\n{\n    public virtual void Speak() => Console.WriteLine(\"Animal speaks\");\n}\nclass Dog : Animal\n{\n    public override void Speak() => Console.WriteLine(\"Dog barks\");\n}"
        }
      ]
    },
    {
      "id": "be-9",
      "question": "What are access modifiers in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Access modifiers define the scope and accessibility of classes, methods, and properties."
        },
        {
          "type": "list",
          "items": [
            "`public` - Accessible everywhere.",
            "`private` - Accessible only within the class.",
            "`protected` - Accessible within the class and derived classes.",
            "`internal` - Accessible within the same assembly.",
            "`protected internal` - Combination of `protected` and `internal`.",
            "`private protected` - Accessible within the same class and derived classes in the same assembly."
          ]
        }
      ]
    },
    {
      "id": "be-10",
      "question": "What are properties and indexers in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Properties encapsulate class fields, providing controlled access. Indexers allow objects to be accessed like arrays."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "class Person\n{\n    private string _name;\n    public string Name { get => _name; set => _name = value; }\n}"
        }
      ]
    },
    {
      "id": "be-11",
      "question": "What are delegates, events, and lambda expressions in C#?",
      "answer": [
        {
          "type": "list",
          "items": [
            "`delegate` - Defines a function pointer.",
            "`event` - Defines an event mechanism.",
            "`=>` (Lambda) - Used for anonymous functions."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "delegate void PrintMessage(string message);\nclass Program\n{\n    static void Main()\n    {\n        PrintMessage print = msg => Console.WriteLine(msg);\n        print(\"Hello, C#\");\n    }\n}"
        }
      ]
    },
    {
      "id": "be-12",
      "question": "How does asynchronous programming work in C#?",
      "answer": [
        {
          "type": "text",
          "content": "C# supports asynchronous programming using `async` and `await` to improve performance."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "async Task<int> FetchData()\n{\n    await Task.Delay(2000);\n    return 42;\n}\n\nasync void CallAsync()\n{\n    int result = await FetchData();\n    Console.WriteLine(result);\n}"
        }
      ]
    }
  ],
  "backend-csharp-errorhandling": [
    {
      "id": "be-13",
      "question": "Can we have a try block without a catch block in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Yes, a `try` block can exist without a `catch` block as long as it has a `finally` block."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    Console.WriteLine(\"Inside try block\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block executes regardless of exception.\");\n}"
        },
        {
          "type": "text",
          "content": "This is useful when we want to **ensure cleanup code runs** (like closing database connections) **without handling exceptions** explicitly."
        }
      ]
    },
    {
      "id": "be-14",
      "question": "What happens if an exception is thrown in a finally block?",
      "answer": [
        {
          "type": "text",
          "content": "If an exception is thrown in a `finally` block, it will **override any previous exception** thrown in the `try` block."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    throw new Exception(\"Try block exception\");\n}\nfinally\n{\n    throw new Exception(\"Finally block exception\"); // This overrides the original exception\n}"
        },
        {
          "type": "text",
          "content": "This can cause unintended behavior, so it's recommended to avoid throwing exceptions inside `finally`."
        }
      ]
    },
    {
      "id": "be-15",
      "question": "What is the difference between throw and throw ex in C#?",
      "answer": [
        {
          "type": "text",
          "content": "`throw` preserves the original stack trace, whereas `throw ex` resets the stack trace, making debugging harder."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    throw new Exception(\"Original Exception\");\n}\ncatch (Exception ex)\n{\n    throw; // Preserves original stack trace\n    // throw ex; // Resets stack trace, making debugging difficult\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "What happens if a return statement is inside a finally block?",
      "answer": [
        {
          "type": "text",
          "content": "If a `finally` block contains a `return` statement, it **overrides any return value from the try or catch block**."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "static int Test()\n{\n    try { return 1; }\n    finally { return 2; } // This overrides the try block return\n}\n\nConsole.WriteLine(Test()); // Output: 2"
        }
      ]
    },
    {
      "id": "be-17",
      "question": "Can we catch multiple exceptions in a single catch block?",
      "answer": [
        {
          "type": "text",
          "content": "Yes, from C# 7.0 onwards, multiple exceptions can be caught using the `when` filter or a single catch block with pattern matching."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    throw new ArgumentException(\"Invalid argument\");\n}\ncatch (Exception ex) when (ex is ArgumentException || ex is NullReferenceException)\n{\n    Console.WriteLine(\"Caught ArgumentException or NullReferenceException\");\n}"
        }
      ]
    },
    {
      "id": "be-18",
      "question": "Can we use an empty catch block? What are the consequences?",
      "answer": [
        {
          "type": "text",
          "content": "Yes, but using an empty catch block **swallows exceptions**, making debugging difficult and potentially leading to hidden errors."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    int result = 10 / 0;\n}\ncatch { } // Bad practice: Exception is silently ignored"
        },
        {
          "type": "text",
          "content": "Instead, log the exception properly:\n\n```csharp\ncatch (Exception ex)\n{\n    Console.WriteLine(ex.Message);\n}\n```"
        }
      ]
    },
    {
      "id": "be-19",
      "question": "What is the difference between checked and unchecked in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The `checked` keyword enables **overflow checking**, while `unchecked` ignores it (default behavior for non-constant expressions)."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "int x = int.MaxValue;\n\n// Checked will throw OverflowException\nint y = checked(x + 1);"
        }
      ]
    },
    {
      "id": "be-20",
      "question": "How does exception handling work with asynchronous methods?",
      "answer": [
        {
          "type": "text",
          "content": "In async methods, exceptions must be caught using `try-catch` inside the `await` block. Otherwise, they are wrapped in an `AggregateException`."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "async Task TestAsync()\n{\n    try\n    {\n        await Task.Run(() => throw new Exception(\"Async Error\"));\n    }\n    catch (Exception ex)\n    {\n        Console.WriteLine(\"Caught: \" + ex.Message);\n    }\n}"
        }
      ]
    },
    {
      "id": "be-23",
      "question": "What happens if an exception is thrown from within a 'catch' block?",
      "answer": [
        {
          "type": "text",
          "content": "If an exception is thrown within a 'catch' block, it will propagate up the call stack, potentially overriding the original exception if not handled properly. This can lead to loss of information about the initial exception."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "try\n{\n    // Some code that throws an exception\n}\ncatch (Exception ex)\n{\n    // Handling the first exception\n    try\n    {\n        // Some code that throws another exception\n    }\n    catch (Exception innerEx)\n    {\n        // This exception can override the original one\n        throw innerEx;\n    }\n}"
        }
      ]
    },
    {
      "id": "be-25",
      "question": "What is the effect of an unhandled exception in a Task run by Task.Run()?",
      "answer": [
        {
          "type": "text",
          "content": "An unhandled exception in a Task run by Task.Run() will cause the Task to transition to the Faulted state. If the exception is not observed (e.g., by awaiting the Task or accessing its Exception property), it can lead to the application terminating due to an unobserved task exception."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "Task.Run(() =>\n{\n    throw new InvalidOperationException(\"Something went wrong\");\n});\n\n// If the Task is not awaited or its Exception property is not accessed,\n// the exception may go unobserved, potentially terminating the application."
        }
      ]
    }
  ],
  "backend-csharp-design-patterns": [
    {
      "id": "dp-1",
      "question": "What is the Singleton pattern and how do you implement it with thread safety?",
      "answer": [
        {
          "type": "text",
          "content": "The Singleton pattern ensures that a class has only one instance and provides a global access point to it."
        },
        {
          "type": "text",
          "content": "**Thread-Safe Singleton with Lock:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public sealed class Singleton\n{\n    private static Singleton _instance;\n    private static readonly object _lock = new object();\n    private Singleton() { }\n    public static Singleton Instance\n    {\n        get\n        {\n            lock (_lock)\n            {\n                if (_instance == null)\n                    _instance = new Singleton();\n            }\n            return _instance;\n        }\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Best Singleton Implementation using Lazy<T>:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public sealed class Singleton\n{\n    private static readonly Lazy<Singleton> _instance = new Lazy<Singleton>(() => new Singleton());\n    private Singleton() { }\n    public static Singleton Instance => _instance.Value;\n}"
        }
      ]
    },
    {
      "id": "dp-2",
      "question": "What is the Builder pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Builder pattern is used to construct complex objects step by step."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Creating objects with multiple optional parameters\n- Separating object creation from representation"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Car\n{\n    public string Engine { get; set; }\n    public int Wheels { get; set; }\n    public override string ToString() => $\"Car with {Engine} engine and {Wheels} wheels\";\n}\n\npublic class CarBuilder\n{\n    private Car _car = new Car();\n    public CarBuilder SetEngine(string engine) { _car.Engine = engine; return this; }\n    public CarBuilder SetWheels(int wheels) { _car.Wheels = wheels; return this; }\n    public Car Build() => _car;\n}\n"
        }
      ]
    },
    {
      "id": "dp-3",
      "question": "What is the Prototype pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Prototype pattern is used to create object copies without making their class-dependent."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Cloning objects without affecting the original\n- Reducing the overhead of object creation"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Prototype : ICloneable\n{\n    public string Name { get; set; }\n    public object Clone() => this.MemberwiseClone();\n}"
        }
      ]
    },
    {
      "id": "dp-4",
      "question": "What is the Adapter pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Adapter pattern allows incompatible interfaces to work together by converting the interface of a class into one that the client expects."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Integrating with third-party libraries\n- Legacy code modernization"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface ITarget\n{\n    void Request();\n}\n\npublic class Adaptee\n{\n    public void SpecificRequest() => Console.WriteLine(\"Specific request called\");\n}\n\npublic class Adapter : ITarget\n{\n    private readonly Adaptee _adaptee = new();\n    public void Request() => _adaptee.SpecificRequest();\n}"
        }
      ]
    },
    {
      "id": "dp-5",
      "question": "What is the Command pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Command pattern encapsulates a request as an object, allowing parameterization of clients with different requests."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Implementing undo/redo functionality\n- Queuing requests and executing them later"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface ICommand { void Execute(); }\n\npublic class LightOnCommand : ICommand\n{\n    private readonly Light _light;\n    public LightOnCommand(Light light) { _light = light; }\n    public void Execute() => _light.TurnOn();\n}\n\npublic class Light\n{\n    public void TurnOn() => Console.WriteLine(\"Light is On\");\n}\n\npublic class RemoteControl\n{\n    private ICommand _command;\n    public void SetCommand(ICommand command) => _command = command;\n    public void PressButton() => _command.Execute();\n}"
        }
      ]
    },
    {
      "id": "dp-6",
      "question": "What is the Mediator pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Mediator pattern reduces dependencies between communicating objects by introducing a mediator object."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Implementing chat systems\n- Managing relationships between UI components"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Mediator\n{\n    private List<Colleague> _colleagues = new();\n    public void Register(Colleague colleague) => _colleagues.Add(colleague);\n    public void SendMessage(string message, Colleague sender)\n    {\n        foreach (var colleague in _colleagues)\n            if (colleague != sender) colleague.Receive(message);\n    }\n}\n\npublic class Colleague\n{\n    private Mediator _mediator;\n    public Colleague(Mediator mediator) { _mediator = mediator; mediator.Register(this); }\n    public void Send(string message) => _mediator.SendMessage(message, this);\n    public void Receive(string message) => Console.WriteLine($\"Received: {message}\");\n}"
        }
      ]
    },
    {
      "id": "dp-7",
      "question": "How would you create a Singleton class with double-check locking?",
      "answer": [
        {
          "type": "text",
          "content": "Double-check locking ensures thread safety while avoiding performance bottlenecks."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public sealed class Singleton\n{\n    private static Singleton _instance;\n    private static readonly object _lock = new();\n    private Singleton() { }\n    public static Singleton Instance\n    {\n        get\n        {\n            if (_instance == null)\n            {\n                lock (_lock)\n                {\n                    if (_instance == null)\n                        _instance = new Singleton();\n                }\n            }\n            return _instance;\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "dp-1",
      "question": "What is the Singleton pattern and how do you implement it in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The Singleton pattern ensures that a class has only one instance and provides a global access point to it."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Managing database connections\n- Logging mechanisms\n- Configuration settings"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public sealed class Singleton\n{\n    private static readonly Singleton _instance = new Singleton();\n    private Singleton() { }\n    public static Singleton Instance => _instance;\n}"
        }
      ]
    },
    {
      "id": "dp-2",
      "question": "What is the Factory Method pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Factory Method pattern defines an interface for creating an object but allows subclasses to alter the type of objects that will be created."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- When exact object creation logic is unknown until runtime\n- To centralize object creation"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public abstract class Product { }\npublic class ConcreteProductA : Product { }\npublic class ConcreteProductB : Product { }\n\npublic abstract class Creator\n{\n    public abstract Product FactoryMethod();\n}\n\npublic class ConcreteCreatorA : Creator\n{\n    public override Product FactoryMethod() => new ConcreteProductA();\n}\n"
        }
      ]
    },
    {
      "id": "dp-3",
      "question": "What is the Observer pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Observer pattern defines a dependency between objects so that when one object changes state, all its dependents are notified automatically."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Event handling systems\n- Publish-subscribe mechanisms"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Subject\n{\n    private readonly List<IObserver> _observers = new();\n    public void Attach(IObserver observer) => _observers.Add(observer);\n    public void Notify() => _observers.ForEach(o => o.Update());\n}\n\npublic interface IObserver { void Update(); }\npublic class ConcreteObserver : IObserver\n{\n    public void Update() => Console.WriteLine(\"Observer updated\");\n}\n"
        }
      ]
    },
    {
      "id": "dp-4",
      "question": "What is the Strategy pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Dynamic selection of algorithms\n- Implementing different behaviors at runtime"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IStrategy { void Execute(); }\npublic class ConcreteStrategyA : IStrategy\n{\n    public void Execute() => Console.WriteLine(\"Strategy A\");\n}\npublic class Context\n{\n    private IStrategy _strategy;\n    public void SetStrategy(IStrategy strategy) => _strategy = strategy;\n    public void ExecuteStrategy() => _strategy.Execute();\n}\n"
        }
      ]
    },
    {
      "id": "dp-5",
      "question": "What is the Decorator pattern?",
      "answer": [
        {
          "type": "text",
          "content": "The Decorator pattern allows behavior to be added to an object dynamically without modifying its structure."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Adding features to UI components dynamically\n- Extending functionalities of existing objects"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IComponent { void Operation(); }\npublic class ConcreteComponent : IComponent\n{\n    public void Operation() => Console.WriteLine(\"Concrete Component\");\n}\npublic class Decorator : IComponent\n{\n    private readonly IComponent _component;\n    public Decorator(IComponent component) { _component = component; }\n    public void Operation()\n    {\n        Console.WriteLine(\"Decorator Start\");\n        _component.Operation();\n        Console.WriteLine(\"Decorator End\");\n    }\n}\n"
        }
      ]
    },
    {
      "id": "dp-6",
      "question": "What is the Dependency Injection (DI) pattern?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a technique where an object receives its dependencies instead of creating them itself."
        },
        {
          "type": "text",
          "content": "**Use Cases:**\n- Reducing tight coupling between objects\n- Enhancing testability of applications"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IService { void Serve(); }\npublic class Service : IService { public void Serve() => Console.WriteLine(\"Service Called\"); }\npublic class Client\n{\n    private readonly IService _service;\n    public Client(IService service) { _service = service; }\n    public void Start() => _service.Serve();\n}\n"
        }
      ]
    }
  ],
  "backend-dotnet": [
    {
      "id": "dotnet-1",
      "question": "Why should I use .NET Core, and what are its best features?",
      "answer": [
        {
          "type": "text",
          "content": ".NET Core (now evolved into .NET 6+ as part of unified .NET) is a modern, open-source, cross-platform framework developed by Microsoft. It is designed for building high-performance, scalable, and cloud-ready applications."
        },
        {
          "type": "text",
          "content": "Here are the key reasons why you should use .NET Core:"
        },
        {
          "type": "list",
          "items": [
            "**Cross-Platform**: .NET Core runs on Windows, Linux, and macOS, making it ideal for cloud and container-based deployments.",
            "**High Performance**: It is one of the fastest frameworks for web applications, optimized for high throughput and low memory usage.",
            "**Microservices Architecture**: .NET Core supports the development of microservices-based applications using Docker and Kubernetes.",
            "**Modern Development Support**: It includes support for asynchronous programming, dependency injection, and modern APIs.",
            "**Open Source and Community-Driven**: Unlike the older .NET Framework, .NET Core is open-source and constantly evolving with contributions from the community.",
            "**Unified Platform**: .NET Core supports multiple application types, including web apps (ASP.NET Core), desktop apps (via .NET 6+), IoT, and gaming (Unity).",
            "**Better Security and Maintainability**: It receives frequent updates and security patches due to its open-source nature and Microsoftâ€™s long-term support.",
            "**Cloud-Ready**: Designed to work seamlessly with cloud services like Azure, AWS, and Google Cloud."
          ]
        },
        {
          "type": "text",
          "content": "Example: A simple ASP.NET Core Web API"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class HelloWorldController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get()\n    {\n        return Ok(\"Hello, .NET Core World!\");\n    }\n}"
        },
        {
          "type": "text",
          "content": "This example demonstrates how easy it is to create a minimal Web API using .NET Core with built-in dependency injection and routing."
        }
      ]
    },
    {
      "id": "dotnet-1",
      "question": "How does .NET compile code and generate executables?",
      "answer": [
        {
          "type": "text",
          "content": ".NET follows a multi-step compilation process to generate executable files. The compilation process involves the following steps:"
        },
        {
          "type": "list",
          "items": [
            "**Source Code Compilation**: The .NET compiler (like `csc` for C#) compiles source code into an intermediate representation called CIL (Common Intermediate Language).",
            "**Assembly Generation**: The compiled CIL is stored in assemblies (`.exe` or `.dll` files) along with metadata about types and methods.",
            "**JIT Compilation**: At runtime, the .NET Just-In-Time (JIT) compiler converts CIL into native machine code for execution.",
            "**Execution by the CLR**: The Common Language Runtime (CLR) executes the native code, manages memory, garbage collection, and enforces security."
          ]
        },
        {
          "type": "text",
          "content": "### Example: Compilation and Execution"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Sample C# Program\nusing System;\n\nclass Program {\n    static void Main() {\n        Console.WriteLine(\"Hello, .NET!\");\n    }\n}"
        },
        {
          "type": "text",
          "content": "#### Step 1: Compile the code"
        },
        {
          "type": "code",
          "language": "bash",
          "content": "csc Program.cs  # Compiles to Program.exe"
        },
        {
          "type": "text",
          "content": "This generates a `Program.exe` file containing CIL."
        },
        {
          "type": "text",
          "content": "#### Step 2: Inspect the CIL (Intermediate Language)"
        },
        {
          "type": "code",
          "language": "bash",
          "content": "ildasm Program.exe  # Opens IL disassembler to view CIL"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": ".method private hidebysig static void Main() cil managed {\n    .entrypoint\n    IL_0000: ldstr \"Hello, .NET!\"\n    IL_0005: call void [System.Console]::WriteLine(string)\n    IL_000a: ret\n}"
        },
        {
          "type": "text",
          "content": "#### Step 3: Run the Executable"
        },
        {
          "type": "code",
          "language": "bash",
          "content": "./Program.exe  # Outputs 'Hello, .NET!'"
        },
        {
          "type": "text",
          "content": "### Summary\n- C# source code â†’ compiled into CIL (.exe/.dll)\n- CIL is Just-In-Time compiled to native code\n- CLR manages execution, memory, and security"
        }
      ]
    },
    {
      "id": "dotnet-1",
      "question": "Explain the difference between value types and reference types in C#.",
      "answer": [
        {
          "type": "text",
          "content": "In C#, data types are categorized as value types and reference types based on how they are stored in memory."
        },
        {
          "type": "text",
          "content": "**Value Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in the stack",
            "Hold actual data",
            "Assignment creates a copy",
            "Examples: `int`, `float`, `double`, `char`, `bool`, `struct`"
          ]
        },
        {
          "type": "text",
          "content": "**Reference Types:**"
        },
        {
          "type": "list",
          "items": [
            "Stored in the heap (reference stored in the stack)",
            "Hold a reference to the actual object",
            "Assignment copies the reference, not the actual data",
            "Examples: `class`, `string`, `array`, `interface`, `delegate`"
          ]
        },
        {
          "type": "text",
          "content": "**Example demonstrating value vs. reference types:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\n\nclass Program\n{\n    struct ValueTypeExample {\n        public int Number;\n    }\n    class ReferenceTypeExample {\n        public int Number;\n    }\n\n    static void Main() {\n        ValueTypeExample val1 = new ValueTypeExample { Number = 10 };\n        ValueTypeExample val2 = val1; // Copy of data\n        val2.Number = 20;\n        Console.WriteLine(val1.Number); // Output: 10 (Unchanged)\n        \n        ReferenceTypeExample ref1 = new ReferenceTypeExample { Number = 10 };\n        ReferenceTypeExample ref2 = ref1; // Reference to the same object\n        ref2.Number = 20;\n        Console.WriteLine(ref1.Number); // Output: 20 (Changed)\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-2",
      "question": "What is Dependency Injection (DI) in .NET Core and how does it work?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern that enables better modularity and testability by injecting dependencies instead of hardcoding them inside a class."
        },
        {
          "type": "text",
          "content": "**Types of Dependency Injection:**"
        },
        {
          "type": "list",
          "items": [
            "Constructor Injection (Most commonly used)",
            "Method Injection",
            "Property Injection"
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Dependency Injection in .NET Core**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.Extensions.DependencyInjection;\nusing System;\n\npublic interface IService {\n    void PrintMessage();\n}\npublic class MyService : IService {\n    public void PrintMessage() => Console.WriteLine(\"Hello from MyService\");\n}\n\nclass Program {\n    static void Main() {\n        var services = new ServiceCollection();\n        services.AddTransient<IService, MyService>(); // Register DI\n        var provider = services.BuildServiceProvider();\n        var service = provider.GetService<IService>();\n        service.PrintMessage(); // Output: Hello from MyService\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-3",
      "question": "What is async/await in C#? How does it improve performance?",
      "answer": [
        {
          "type": "text",
          "content": "Async/Await is used in C# to perform asynchronous programming, allowing non-blocking execution of I/O-bound or long-running operations."
        },
        {
          "type": "text",
          "content": "**Benefits of async/await:**"
        },
        {
          "type": "list",
          "items": [
            "Prevents blocking the main thread",
            "Allows handling of multiple tasks concurrently",
            "Improves responsiveness of applications"
          ]
        },
        {
          "type": "text",
          "content": "**Example of async/await in C#:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program {\n    static async Task Main() {\n        Console.WriteLine(\"Fetching data...\");\n        string result = await GetDataAsync();\n        Console.WriteLine(result);\n    }\n\n    static async Task<string> GetDataAsync() {\n        await Task.Delay(3000); // Simulating delay\n        return \"Data retrieved successfully!\";\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-4",
      "question": "What is the difference between `IEnumerable`, `IQueryable`, `ICollection`, and `List` in C#?",
      "answer": [
        {
          "type": "text",
          "content": "**IEnumerable<T>:**\n- Used for in-memory and LINQ-to-Objects queries.\n- Supports forward-only iteration.\n- Lazy loading is not supported."
        },
        {
          "type": "text",
          "content": "**IQueryable<T>:**\n- Used for querying remote data sources like databases (Entity Framework).\n- Executes queries at the database level."
        },
        {
          "type": "text",
          "content": "**ICollection<T>:**\n- Supports adding/removing elements.\n- Inherits from `IEnumerable<T>`."
        },
        {
          "type": "text",
          "content": "**List<T>:**\n- Implements `ICollection<T>` and `IEnumerable<T>`.\n- Provides random access via indexing."
        }
      ]
    },
    {
      "id": "dotnet-5",
      "question": "Explain Middleware in ASP.NET Core. How does the request pipeline work?",
      "answer": [
        {
          "type": "text",
          "content": "Middleware in ASP.NET Core is a sequence of components that handle HTTP requests and responses."
        },
        {
          "type": "text",
          "content": "**Example of Custom Middleware in .NET Core:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Http;\nusing System.Threading.Tasks;\n\npublic class CustomMiddleware {\n    private readonly RequestDelegate _next;\n\n    public CustomMiddleware(RequestDelegate next) {\n        _next = next;\n    }\n\n    public async Task Invoke(HttpContext context) {\n        Console.WriteLine(\"Request: \" + context.Request.Path);\n        await _next(context);\n        Console.WriteLine(\"Response: \" + context.Response.StatusCode);\n    }\n}\n\npublic static class MiddlewareExtensions {\n    public static IApplicationBuilder UseCustomMiddleware(this IApplicationBuilder builder) {\n        return builder.UseMiddleware<CustomMiddleware>();\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-6",
      "question": "What are best practices for dependency injection in .NET Core?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a fundamental pattern in .NET Core for managing dependencies in a loosely coupled manner."
        },
        {
          "type": "text",
          "content": "**Best Practices:**"
        },
        {
          "type": "list",
          "items": [
            "Use Constructor Injection instead of Property Injection.",
            "Use the built-in .NET Core DI container unless a third-party container is necessary.",
            "Register services with the appropriate lifetimes (Transient, Scoped, Singleton).",
            "Avoid direct instantiation of dependencies using `new` inside classes.",
            "Use interfaces to abstract dependencies."
          ]
        },
        {
          "type": "text",
          "content": "**Example of DI in .NET Core:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IRepository {\n    void GetData();\n}\npublic class Repository : IRepository {\n    public void GetData() => Console.WriteLine(\"Fetching Data...\");\n}\npublic class Service {\n    private readonly IRepository _repository;\n    public Service(IRepository repository) {\n        _repository = repository;\n    }\n    public void Process() {\n        _repository.GetData();\n    }\n}\nvar services = new ServiceCollection();\nservices.AddTransient<IRepository, Repository>();\nvar provider = services.BuildServiceProvider();\nvar service = provider.GetService<Service>();\nservice?.Process();"
        }
      ]
    },
    {
      "id": "dotnet-7",
      "question": "How does async/await work internally in C#?",
      "answer": [
        {
          "type": "text",
          "content": "The async/await mechanism in C# allows for asynchronous programming without blocking threads. It internally utilizes the `Task`-based asynchronous pattern (TAP) and the state machine concept."
        },
        {
          "type": "text",
          "content": "**Key concepts:**"
        },
        {
          "type": "list",
          "items": [
            "`async` keyword marks a method as asynchronous.",
            "`await` keyword suspends execution until the awaited task completes.",
            "The compiler rewrites `async` methods into a state machine that executes callbacks on completion.",
            "If `ConfigureAwait(false)` is used, the continuation does not return to the original context."
          ]
        },
        {
          "type": "text",
          "content": "**Example of async/await usage:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program {\n    static async Task Main() {\n        Console.WriteLine(\"Start fetching data...\");\n        string data = await GetDataAsync();\n        Console.WriteLine(data);\n    }\n\n    static async Task<string> GetDataAsync() {\n        await Task.Delay(3000);\n        return \"Data fetched successfully!\";\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-8",
      "question": "Explain IQueryable vs. IEnumerable â€“ when would you use each?",
      "answer": [
        {
          "type": "text",
          "content": "**IEnumerable<T>:**"
        },
        {
          "type": "list",
          "items": [
            "Executes queries in-memory.",
            "Does not support query translation into SQL.",
            "Best for working with in-memory collections."
          ]
        },
        {
          "type": "text",
          "content": "**IQueryable<T>:**"
        },
        {
          "type": "list",
          "items": [
            "Executes queries at the database level (deferred execution).",
            "Supports query translation into SQL.",
            "Best for performance when querying databases using Entity Framework."
          ]
        },
        {
          "type": "text",
          "content": "**Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "var data = dbContext.Users.AsEnumerable(); // Executed in-memory\nvar data = dbContext.Users.AsQueryable();  // Executed as SQL query in DB"
        }
      ]
    },
    {
      "id": "dotnet-9",
      "question": "How do you implement a background worker service in .NET Core?",
      "answer": [
        {
          "type": "text",
          "content": "In .NET Core, background worker services are implemented using `IHostedService` or by extending `BackgroundService`."
        },
        {
          "type": "text",
          "content": "**Example of a Background Service:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class MyBackgroundService : BackgroundService {\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken) {\n        while (!stoppingToken.IsCancellationRequested) {\n            Console.WriteLine(\"Background task running...\");\n            await Task.Delay(5000, stoppingToken);\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-10",
      "question": "How would you optimize EF Core queries to improve performance?",
      "answer": [
        {
          "type": "text",
          "content": "To optimize EF Core queries, consider the following best practices:"
        },
        {
          "type": "list",
          "items": [
            "Use `.AsNoTracking()` for read-only queries to avoid unnecessary tracking.",
            "Use `.Select()` to fetch only necessary columns instead of full entities.",
            "Apply pagination with `Skip()` and `Take()` to avoid fetching large data sets.",
            "Use compiled queries for frequently used queries.",
            "Avoid lazy loading when unnecessary and prefer eager loading (`Include()`).",
            "Use raw SQL queries (`FromSqlRaw`) for complex queries."
          ]
        },
        {
          "type": "text",
          "content": "**Example:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "var users = dbContext.Users.AsNoTracking()\n                          .Where(u => u.Age > 30)\n                          .Select(u => new { u.Name, u.Email })\n                          .ToList();"
        }
      ]
    },
    {
      "id": "dotnet-11",
      "question": "What is SignalR, and when would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "SignalR is a real-time communication library in ASP.NET Core that enables bi-directional communication between servers and clients."
        },
        {
          "type": "text",
          "content": "**Use Cases:**"
        },
        {
          "type": "list",
          "items": [
            "Chat applications",
            "Live dashboards and notifications",
            "Collaborative applications (e.g., Google Docs-like features)",
            "Real-time stock market updates"
          ]
        },
        {
          "type": "text",
          "content": "**Example of SignalR implementation:**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class ChatHub : Hub {\n    public async Task SendMessage(string user, string message) {\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-4",
      "question": "What are the SOLID principles, and how have you applied them in C# projects?",
      "answer": [
        {
          "type": "text",
          "content": "SOLID is a set of five design principles that improve maintainability and scalability in object-oriented design."
        },
        {
          "type": "list",
          "items": [
            "**S - Single Responsibility Principle (SRP):** A class should have only one reason to change.",
            "**O - Open/Closed Principle (OCP):** Software entities should be open for extension but closed for modification.",
            "**L - Liskov Substitution Principle (LSP):** Derived classes must be substitutable for their base classes.",
            "**I - Interface Segregation Principle (ISP):** Clients should not be forced to depend on interfaces they do not use.",
            "**D - Dependency Inversion Principle (DIP):** High-level modules should not depend on low-level modules. Both should depend on abstractions."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Applying SOLID in C#**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IEmailService {\n    void SendEmail(string to, string message);\n}\n\npublic class EmailService : IEmailService {\n    public void SendEmail(string to, string message) {\n        Console.WriteLine($\"Sending Email to {to}: {message}\");\n    }\n}\n\npublic class NotificationService {\n    private readonly IEmailService _emailService;\n    public NotificationService(IEmailService emailService) {\n        _emailService = emailService;\n    }\n    public void NotifyUser(string user, string message) {\n        _emailService.SendEmail(user, message);\n    }\n}\n"
        }
      ]
    },
    {
      "id": "dotnet-5",
      "question": "How do you implement event-driven architecture in C#?",
      "answer": [
        {
          "type": "text",
          "content": "Event-driven architecture (EDA) is a design pattern in which system components communicate via events rather than direct method calls."
        },
        {
          "type": "text",
          "content": "**Ways to implement Event-Driven Architecture:**"
        },
        {
          "type": "list",
          "items": [
            "Using C# Events & Delegates",
            "Message Queues (RabbitMQ, Kafka, Azure Service Bus)",
            "Event Bus (MediatR pattern in .NET)"
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using C# Events & Delegates for Event-Driven Architecture**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class EventPublisher {\n    public delegate void Notify(string message);\n    public event Notify OnNotification;\n    public void SendNotification(string message) {\n        OnNotification?.Invoke(message);\n    }\n}\n\nclass Program {\n    static void Main() {\n        EventPublisher publisher = new EventPublisher();\n        publisher.OnNotification += msg => Console.WriteLine($\"Received: {msg}\");\n        publisher.SendNotification(\"Event-Driven Architecture in Action!\");\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-6",
      "question": "What are MemoryCache and DistributedCache, and when would you use them?",
      "answer": [
        {
          "type": "text",
          "content": "**MemoryCache (In-Memory Cache):**\n- Stores cache in the application's memory.\n- Works well for small to medium-scale applications.\n- Data is lost when the application restarts.\n- Suitable for single-instance applications."
        },
        {
          "type": "text",
          "content": "**DistributedCache (External Cache like Redis, SQL Server Cache):**\n- Stores cache externally (Redis, SQL Server, etc.).\n- Can be shared across multiple instances.\n- Suitable for cloud-based and microservices applications."
        },
        {
          "type": "text",
          "content": "**Example: Using MemoryCache in .NET Core**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using Microsoft.Extensions.Caching.Memory;\nusing System;\n\nclass Program {\n    static void Main() {\n        var cache = new MemoryCache(new MemoryCacheOptions());\n        cache.Set(\"key\", \"Cached Data\", TimeSpan.FromMinutes(10));\n        Console.WriteLine(cache.Get(\"key\")); // Output: Cached Data\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-7",
      "question": "What are Records in C#? How do they differ from Classes?",
      "answer": [
        {
          "type": "text",
          "content": "Records are reference types introduced in C# 9 that provide **immutable data** structures with built-in value equality."
        },
        {
          "type": "list",
          "items": [
            "**Records vs. Classes:**",
            "- **Records** use value-based equality (compare content).",
            "- **Classes** use reference-based equality (compare memory references).",
            "- Records are immutable by default."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Records vs. Classes**"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public record PersonRecord(string Name, int Age);\npublic class PersonClass {\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\nclass Program {\n    static void Main() {\n        var person1 = new PersonRecord(\"John\", 30);\n        var person2 = new PersonRecord(\"John\", 30);\n        Console.WriteLine(person1 == person2); // Output: True (Value-based equality)\n\n        var class1 = new PersonClass { Name = \"John\", Age = 30 };\n        var class2 = new PersonClass { Name = \"John\", Age = 30 };\n        Console.WriteLine(class1 == class2); // Output: False (Reference-based equality)\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-1",
      "question": "How do you implement a background worker service in .NET Core?",
      "answer": [
        {
          "type": "text",
          "content": ".NET Core provides the `BackgroundService` class to implement background worker services. You can use it for tasks such as message queue processing, scheduled jobs, or long-running background operations."
        },
        {
          "type": "text",
          "content": "Hereâ€™s how to implement a background worker service:"
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class MyBackgroundService : BackgroundService\n{\n    private readonly ILogger<MyBackgroundService> _logger;\n\n    public MyBackgroundService(ILogger<MyBackgroundService> logger)\n    {\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            _logger.LogInformation(\"Background task running at: {time}\", DateTimeOffset.Now);\n            await Task.Delay(5000, stoppingToken); // Runs every 5 seconds\n        }\n    }\n}\n\n// Register the background service in Program.cs\nbuilder.Services.AddHostedService<MyBackgroundService>();"
        }
      ]
    },
    {
      "id": "dotnet-2",
      "question": "Explain how the Actor Model works in Orleans or Akka.NET.",
      "answer": [
        {
          "type": "text",
          "content": "The Actor Model is a concurrency framework where actors are isolated entities that communicate via messages. They do not share state directly, reducing race conditions and complexity in distributed systems."
        },
        {
          "type": "text",
          "content": "### Orleans:\n- Implements the Virtual Actor Model.\n- Manages actor lifecycles automatically (no need to explicitly create/destroy them).\n- Useful for scalable, stateful applications (e.g., IoT, real-time apps)."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IMyActor : IGrainWithStringKey\n{\n    Task<string> SayHello(string name);\n}\n\npublic class MyActor : Grain, IMyActor\n{\n    public Task<string> SayHello(string name) => Task.FromResult($\"Hello, {name}!\");\n}"
        },
        {
          "type": "text",
          "content": "### Akka.NET:\n- More traditional actor model with explicit actor creation and supervision.\n- Uses a hierarchical approach where actors can spawn child actors."
        }
      ]
    },
    {
      "id": "dotnet-3",
      "question": "How do you implement CQRS in a .NET Core application?",
      "answer": [
        {
          "type": "text",
          "content": "CQRS (Command Query Responsibility Segregation) separates read and write operations to optimize performance and scalability."
        },
        {
          "type": "text",
          "content": "### Implementation Steps:"
        },
        {
          "type": "list",
          "items": [
            "Commands modify data (write operations).",
            "Queries fetch data (read operations).",
            "Use MediatR to handle commands and queries.",
            "Separate databases for reads/writes in some cases."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "// Command Handler using MediatR\npublic record CreateUserCommand(string Name) : IRequest<int>;\n\npublic class CreateUserHandler : IRequestHandler<CreateUserCommand, int>\n{\n    private readonly AppDbContext _context;\n    \n    public CreateUserHandler(AppDbContext context)\n    {\n        _context = context;\n    }\n    \n    public async Task<int> Handle(CreateUserCommand request, CancellationToken cancellationToken)\n    {\n        var user = new User { Name = request.Name };\n        _context.Users.Add(user);\n        await _context.SaveChangesAsync();\n        return user.Id;\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-4",
      "question": "What are gRPC services in .NET, and how do they compare to REST APIs?",
      "answer": [
        {
          "type": "text",
          "content": "gRPC (Google Remote Procedure Call) is a high-performance RPC framework used for inter-service communication in microservices."
        },
        {
          "type": "list",
          "items": [
            "Uses HTTP/2 for improved performance.",
            "Binary serialization with Protocol Buffers (Protobuf).",
            "Supports bi-directional streaming.",
            "Better for internal microservices compared to REST."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "syntax = \"proto3\";\npackage mygrpc;\n\nservice MyService {\n  rpc SayHello (HelloRequest) returns (HelloResponse);\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloResponse {\n  string message = 1;\n}"
        }
      ]
    },
    {
      "id": "dotnet-5",
      "question": "How would you optimize EF Core queries to improve performance?",
      "answer": [
        {
          "type": "list",
          "items": [
            "Use `.AsNoTracking()` for read-only queries.",
            "Use projections (`Select`) instead of fetching full entities.",
            "Optimize indexes in the database.",
            "Use compiled queries for frequently executed queries.",
            "Implement caching for repeated queries."
          ]
        }
      ]
    },
    {
      "id": "dotnet-6",
      "question": "How do you implement distributed tracing in a .NET Core microservice?",
      "answer": [
        {
          "type": "text",
          "content": "Distributed tracing helps track requests across microservices using tools like OpenTelemetry and Application Insights."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "builder.Services.AddOpenTelemetryTracing(builder =>\n{\n    builder.AddAspNetCoreInstrumentation()\n           .AddHttpClientInstrumentation()\n           .AddConsoleExporter();\n});"
        }
      ]
    },
    {
      "id": "dotnet-7",
      "question": "What is SignalR, and when would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "SignalR is a real-time communication library in .NET Core used for live chat, notifications, and live dashboards."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class ChatHub : Hub\n{\n    public async Task SendMessage(string user, string message)\n    {\n        await Clients.All.SendAsync(\"ReceiveMessage\", user, message);\n    }\n}"
        }
      ]
    },
    {
      "id": "dotnet-8",
      "question": "How does Kestrel work, and why is it used as the default web server in .NET?",
      "answer": [
        {
          "type": "list",
          "items": [
            "Kestrel is a cross-platform, high-performance web server built on libuv.",
            "It is the default server in ASP.NET Core applications.",
            "Supports asynchronous I/O operations for scalability.",
            "Used behind Nginx/IIS in production for additional features like security."
          ]
        }
      ]
    }
  ],
  "backend-solid": [
    {
      "id": "solid-1",
      "question": "What are the SOLID principles?",
      "answer": [
        {
          "type": "text",
          "content": "SOLID is an acronym for five design principles that improve the maintainability, scalability, and flexibility of software systems."
        },
        {
          "type": "list",
          "items": [
            "**S: Single Responsibility Principle (SRP)** - A class should have only one reason to change.",
            "**O: Open/Closed Principle (OCP)** - Software entities should be open for extension but closed for modification.",
            "**L: Liskov Substitution Principle (LSP)** - Subtypes must be substitutable for their base types.",
            "**I: Interface Segregation Principle (ISP)** - Clients should not be forced to depend on interfaces they donâ€™t use.",
            "**D: Dependency Inversion Principle (DIP)** - High-level modules should not depend on low-level modules."
          ]
        }
      ]
    },
    {
      "id": "solid-2",
      "question": "Why do we need SOLID principles?",
      "answer": [
        {
          "type": "text",
          "content": "SOLID principles help in designing maintainable, scalable, and testable software. They reduce dependencies, improve code readability, and allow easy modifications without affecting the entire system."
        }
      ]
    },
    {
      "id": "solid-3",
      "question": "Explain the Single Responsibility Principle (SRP) with analogy and example.",
      "answer": [
        {
          "type": "text",
          "content": "SRP states that a class should only have one reason to change. This keeps code modular and easy to maintain."
        },
        {
          "type": "text",
          "content": "Analogy: Imagine a chef in a restaurant. If the chef is responsible for cooking, taking orders, and serving food, it's chaotic. Instead, different staff handle different tasks (chef cooks, waiter serves, cashier manages bills)."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class ReportGenerator \n{\n    public string GenerateReport() \n    {\n        return \"Report content\";\n    }\n}\n\npublic class ReportSaver \n{\n    public void SaveToFile(string report) \n    {\n        File.WriteAllText(\"report.txt\", report);\n    }\n}\n\n// Each class has a single responsibility, adhering to SRP."
        }
      ]
    },
    {
      "id": "solid-4",
      "question": "Explain the Open/Closed Principle (OCP) with analogy and example.",
      "answer": [
        {
          "type": "text",
          "content": "OCP states that a class should be open for extension but closed for modification."
        },
        {
          "type": "text",
          "content": "Analogy: Imagine a power strip with multiple sockets. Instead of modifying the strip when a new device needs to be plugged in, we simply use an adapter, extending its functionality without changing its core design."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Notifier interface {\n    Notify() string\n}\n\ntype EmailNotifier struct{}\nfunc (e EmailNotifier) Notify() string { return \"Sending Email\" }\n\ntype SMSNotifier struct{}\nfunc (s SMSNotifier) Notify() string { return \"Sending SMS\" }\n\nfunc SendNotification(n Notifier) {\n    fmt.Println(n.Notify())\n}\n\nfunc main() {\n    email := EmailNotifier{}\n    sms := SMSNotifier{}\n    SendNotification(email)\n    SendNotification(sms)\n}"
        }
      ]
    },
    {
      "id": "solid-5",
      "question": "Explain the Liskov Substitution Principle (LSP) with analogy and example.",
      "answer": [
        {
          "type": "text",
          "content": "LSP states that subclasses should be replaceable by their parent class without altering correctness."
        },
        {
          "type": "text",
          "content": "Analogy: If a car rental company allows you to rent a regular car, an electric car, or a luxury car, they all should work the same way (drive, accelerate, brake). If a luxury car suddenly required a special kind of fuel that regular cars don't, it would violate LSP."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public class Bird \n{\n    public virtual void Fly() { Console.WriteLine(\"Bird is flying\"); }\n}\n\npublic class Sparrow : Bird {}\n\npublic class Ostrich : Bird \n{\n    public override void Fly() { throw new NotSupportedException(\"Ostriches can't fly\"); }\n}\n\n// Ostrich breaks LSP because it cannot substitute Bird in all cases."
        }
      ]
    },
    {
      "id": "solid-6",
      "question": "Explain Interface Segregation Principle (ISP) with analogy and example.",
      "answer": [
        {
          "type": "text",
          "content": "ISP states that clients should not be forced to depend on interfaces they do not use."
        },
        {
          "type": "text",
          "content": "Analogy: Imagine a remote control that controls both TV and Air Conditioner. If you only use it for the TV, then having Air Conditioner buttons is unnecessary. A better approach is to have separate remotes for each device."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Printer interface { Print() }\ntype Scanner interface { Scan() }\n\ntype AllInOnePrinter struct{}\nfunc (a AllInOnePrinter) Print() { fmt.Println(\"Printing...\") }\nfunc (a AllInOnePrinter) Scan() { fmt.Println(\"Scanning...\") }\n\nfunc main() {\n    var p Printer = AllInOnePrinter{}\n    p.Print()\n}"
        }
      ]
    },
    {
      "id": "solid-7",
      "question": "Explain Dependency Inversion Principle (DIP) with analogy and example.",
      "answer": [
        {
          "type": "text",
          "content": "DIP states that high-level modules should not depend on low-level modules. Both should depend on abstractions."
        },
        {
          "type": "text",
          "content": "Analogy: A universal phone charger can charge different brands of phones by using a common standard (USB). The charger does not need to know the internal design of each phone; it just uses an interface (USB port)."
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "public interface IPaymentProcessor \n{\n    void ProcessPayment();\n}\n\npublic class CreditCardPayment : IPaymentProcessor \n{\n    public void ProcessPayment() { Console.WriteLine(\"Processing credit card payment...\"); }\n}\n\npublic class PayPalPayment : IPaymentProcessor \n{\n    public void ProcessPayment() { Console.WriteLine(\"Processing PayPal payment...\"); }\n}\n\npublic class PaymentService \n{\n    private readonly IPaymentProcessor _paymentProcessor;\n    public PaymentService(IPaymentProcessor paymentProcessor) { _paymentProcessor = paymentProcessor; }\n    public void MakePayment() { _paymentProcessor.ProcessPayment(); }\n}\n\n// Now PaymentService can work with any payment method without modification."
        }
      ]
    }
  ],
  "backend-golang": [
    {
      "id": "gb-1",
      "question": "What are the basic data types in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Golang has several basic data types categorized into numeric, string, and boolean types."
        },
        {
          "type": "text",
          "content": "**1. Numeric Types:**"
        },
        {
          "type": "list",
          "items": [
            "Integers: `int`, `int8`, `int16`, `int32`, `int64`",
            "Unsigned Integers: `uint`, `uint8`, `uint16`, `uint32`, `uint64`",
            "Floating Points: `float32`, `float64`",
            "Complex Numbers: `complex64`, `complex128`"
          ]
        },
        {
          "type": "text",
          "content": "**2. Other Basic Types:**"
        },
        {
          "type": "list",
          "items": [
            "Boolean: `bool` (true/false)",
            "Strings: `string` (UTF-8 encoded text)",
            "Byte & Rune: `byte` (alias for `uint8`), `rune` (alias for `int32`, used for Unicode characters)"
          ]
        },
        {
          "type": "text",
          "content": "**Example of using different data types:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar a int = 10\n\tvar b float64 = 3.14\n\tvar c string = \"Hello\"\n\tvar d bool = true\n\tfmt.Println(a, b, c, d)\n}"
        }
      ]
    },
    {
      "id": "gb-2",
      "question": "What are pointers in Golang? How do they work?",
      "answer": [
        {
          "type": "text",
          "content": "Pointers in Golang store memory addresses of variables. They help in efficient memory manipulation and function parameter passing."
        },
        {
          "type": "text",
          "content": "**Pointer Syntax:**"
        },
        {
          "type": "list",
          "items": [
            "`*T` â†’ Defines a pointer to a type `T`.",
            "`&` â†’ Returns the memory address of a variable.",
            "`*p` â†’ Dereferences a pointer (accesses the value at the memory address)."
          ]
        },
        {
          "type": "text",
          "content": "**Example of using pointers:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tnum := 10\n\tptr := &num // Pointer to num\n\tfmt.Println(\"Memory Address:\", ptr)\n\tfmt.Println(\"Value:\", *ptr) // Dereferencing\n}"
        }
      ]
    },
    {
      "id": "be-3",
      "question": "What are the basic syntax rules and features of Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Golang (Go) is a statically typed, compiled language designed for simplicity, efficiency, and concurrency. It follows C-like syntax but removes complexities like header files and manual memory management."
        },
        {
          "type": "text",
          "content": "Here are the fundamental syntax rules and features of Go:"
        },
        {
          "type": "list",
          "items": [
            "**Package Declaration**: Every Go program starts with a `package` declaration.",
            "**Import Statements**: Uses `import` to include standard or custom packages.",
            "**Functions**: Functions are defined using the `func` keyword.",
            "**Variables**: Declared using `var`, `:=` (short assignment), or constants using `const`.",
            "**Data Types**: Includes basic types like `int`, `float64`, `string`, `bool`, and composite types like `array`, `slice`, `map`, `struct`, `interface`.",
            "**Control Structures**: Uses `if`, `for`, and `switch` for flow control.",
            "**Concurrency**: Supports goroutines (`go func() {}`) and channels for concurrent execution.",
            "**Error Handling**: Uses explicit error handling with `error` return values."
          ]
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(\"Hello, Go!\")\n\n    // Variable declaration\n    var x int = 10\n    y := 20 // Short assignment\n\n    // Conditional statement\n    if y > x {\n        fmt.Println(\"y is greater than x\")\n    }\n\n    // Loop\n    for i := 0; i < 5; i++ {\n        fmt.Println(i)\n    }\n\n    // Function call\n    sum := add(5, 3)\n    fmt.Println(\"Sum:\", sum)\n}\n\n// Function definition\nfunc add(a int, b int) int {\n    return a + b\n}"
        }
      ]
    },
    {
      "id": "gb-3",
      "question": "What is the difference between arrays and slices in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "**Arrays:** Fixed-size collections of elements of the same type."
        },
        {
          "type": "list",
          "items": [
            "Declared using `[size]Type{values}`",
            "Size is part of the type, so cannot be resized",
            "Stored sequentially in memory"
          ]
        },
        {
          "type": "text",
          "content": "**Slices:** Dynamic, flexible views into arrays."
        },
        {
          "type": "list",
          "items": [
            "Declared using `[]Type{values}` or `make([]Type, length, capacity)`",
            "Can grow dynamically using `append()`",
            "Stores reference to underlying array"
          ]
        },
        {
          "type": "text",
          "content": "**Example:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tarr := [3]int{1, 2, 3} // Array\n\tslice := []int{1, 2, 3} // Slice\n\tslice = append(slice, 4) // Append to slice\n\n\tfmt.Println(arr, slice)\n}"
        }
      ]
    },
    {
      "id": "gb-4",
      "question": "What are structs in Golang? How do you define and use them?",
      "answer": [
        {
          "type": "text",
          "content": "A struct is a collection of fields (data members) used to define a custom data type."
        },
        {
          "type": "text",
          "content": "**Defining and Using Structs:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc main() {\n\tp := Person{Name: \"Alice\", Age: 25}\n\tfmt.Println(p.Name, p.Age)\n}"
        }
      ]
    },
    {
      "id": "gb-5",
      "question": "What are interfaces in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Interfaces define method signatures that types must implement. They enable polymorphism."
        },
        {
          "type": "text",
          "content": "**Example of an Interface:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Speaker interface {\n\tSpeak() string\n}\n\ntype Dog struct{}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof!\"\n}\n\nfunc main() {\n\tvar s Speaker = Dog{}\n\tfmt.Println(s.Speak())\n}"
        }
      ]
    },
    {
      "id": "gb-6",
      "question": "What is the difference between pass-by-value and pass-by-reference in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "**Pass-by-Value:** A copy of the variable is passed to a function."
        },
        {
          "type": "text",
          "content": "**Pass-by-Reference:** A pointer to the original variable is passed, allowing modifications."
        },
        {
          "type": "text",
          "content": "**Example of pass-by-value:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc modify(x int) {\n\tx = 100\n}\n\nfunc main() {\n\tn := 10\n\tmodify(n)\n\tfmt.Println(n) // Output: 10 (unchanged)\n}"
        }
      ]
    },
    {
      "id": "gb-7",
      "question": "What are maps in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Maps are key-value data structures similar to hash tables."
        },
        {
          "type": "text",
          "content": "**Example of using a map:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tm := map[string]int{\"Alice\": 25, \"Bob\": 30}\n\tfmt.Println(m[\"Alice\"])\n}"
        }
      ]
    },
    {
      "id": "gc-1",
      "question": "Explain mutable and immutable types in Golang. Are strings and other types mutable? Provide examples.",
      "answer": [
        {
          "type": "text",
          "content": "Mutable types can be modified after creation, whereas immutable types cannot be changed once assigned."
        },
        {
          "type": "text",
          "content": "**Immutable Types in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Strings (`string`) - Once created, their value cannot be modified.",
            "Numbers (`int`, `float`, `complex`) - These are copied when assigned."
          ]
        },
        {
          "type": "text",
          "content": "**Mutable Types in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Slices (`[]T`) - Can be resized and modified.",
            "Maps (`map[T]T`) - Can add/remove/update key-value pairs.",
            "Pointers (`*T`) - Allow modification of referenced data.",
            "Structs (`struct`) - Fields can be modified (except when using pointers to them)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Strings are immutable in Golang**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ts := \"hello\"\n\t// s[0] = 'H' // This will cause an error as strings are immutable\n\ts = \"Hello\" // This is allowed (creates a new string)\n\tfmt.Println(s)\n}"
        }
      ]
    },
    {
      "id": "gc-2",
      "question": "Explain call by value and call by reference with examples in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "**Call by Value:** A copy of the argument is passed to the function, meaning changes inside the function do not affect the original variable."
        },
        {
          "type": "text",
          "content": "**Example of Call by Value:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc modify(x int) {\n\tx = 100 // This modifies a copy, not the original variable\n}\n\nfunc main() {\n\tn := 10\n\tmodify(n)\n\tfmt.Println(n) // Output: 10 (unchanged)\n}"
        }
      ]
    },
    {
      "id": "gc-3",
      "question": "Explain call by reference with an example.",
      "answer": [
        {
          "type": "text",
          "content": "**Call by Reference:** A pointer to the argument is passed to the function, allowing modification of the original variable."
        },
        {
          "type": "text",
          "content": "**Example of Call by Reference:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc modifyPointer(x *int) {\n\t*x = 100 // Modifies the original variable\n}\n\nfunc main() {\n\tn := 10\n\tmodifyPointer(&n) // Passing memory address\n\tfmt.Println(n) // Output: 100 (modified)\n}"
        }
      ]
    },
    {
      "id": "be-3",
      "question": "How does garbage collection work in Golang compared to C#?",
      "answer": [
        {
          "type": "text",
          "content": "Garbage collection (GC) is the process of automatically reclaiming memory occupied by objects that are no longer in use. Both Golang and C# use garbage collection, but they have different approaches to it."
        },
        {
          "type": "text",
          "content": "**Garbage Collection in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses a **concurrent, non-blocking garbage collector** to minimize pause times and improve performance.",
            "It focuses on **low-latency** garbage collection to make it suitable for real-time applications.",
            "The GC runs in the background and works in **multiple small steps** to avoid stopping the entire application.",
            "It uses a **tri-color marking algorithm** that classifies objects as **white, gray, or black** to track object reachability efficiently.",
            "Since Go does not have manual memory management (like C or C++), developers rely on GC to handle memory cleanup automatically.",
            "Objects are automatically deallocated when they are no longer reachable."
          ]
        },
        {
          "type": "text",
          "content": "**Garbage Collection in C#:**"
        },
        {
          "type": "list",
          "items": [
            "C# uses a **generational garbage collector**, which divides objects into **three generations** (Gen 0, Gen 1, Gen 2).",
            "Objects that survive multiple collections move to higher generations (long-lived objects reside in Gen 2).",
            "The GC in C# is **managed by the Common Language Runtime (CLR)**, and developers can trigger collection using `GC.Collect()`, though it's usually not recommended.",
            "Uses a **mark-and-sweep algorithm** similar to Go but is optimized with generational heuristics.",
            "Supports **finalizers** (`~ClassName()`) for custom cleanup, but they should be used cautiously as they impact performance.",
            "Provides **manual memory management** via `IDisposable` and `using` statements for deterministic cleanup of resources (e.g., database connections, file streams)."
          ]
        },
        {
          "type": "text",
          "content": "**Key Differences:**"
        },
        {
          "type": "list",
          "items": [
            "Golang's GC is **designed for low-latency applications**, whereas C#'s GC is **optimized for long-running applications**.",
            "C# has a **generational garbage collector**, while Go uses a **concurrent, tri-color marking algorithm**.",
            "C# allows **manual memory management (IDisposable, `GC.Collect()`)**, while Go strictly relies on automatic GC.",
            "Golang's GC is optimized for **server-side performance**, whereas C#'s GC is highly optimized for **desktop, cloud, and enterprise applications**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, Golang focuses on minimizing pause times to improve concurrency, while C#'s generational GC optimizes memory management for different object lifetimes."
        }
      ]
    },
    {
      "id": "be-4",
      "question": "Discuss asynchronous programming in C# and Golang (async/await, goroutines).",
      "answer": [
        {
          "type": "text",
          "content": "Asynchronous programming allows tasks to run concurrently without blocking the main execution thread, improving performance and responsiveness. C# and Golang have different approaches to handling concurrency and asynchronous operations."
        },
        {
          "type": "text",
          "content": "**Asynchronous Programming in C# (async/await):**"
        },
        {
          "type": "list",
          "items": [
            "C# uses the **async/await** pattern to handle asynchronous operations.",
            "The `Task` and `Task<T>` types represent asynchronous operations that can run in the background.",
            "The `await` keyword allows code execution to pause and resume without blocking the main thread.",
            "Uses the **Thread Pool** for managing multiple tasks efficiently.",
            "Asynchronous programming in C# is useful for **I/O-bound operations** like database calls, network requests, and file operations."
          ]
        },
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main()\n    {\n        Console.WriteLine(\"Start\");\n        string result = await FetchData();\n        Console.WriteLine(result);\n        Console.WriteLine(\"End\");\n    }\n\n    static async Task<string> FetchData()\n    {\n        await Task.Delay(2000); // Simulate async work\n        return \"Data received\";\n    }\n}"
        },
        {
          "type": "text",
          "content": "**Asynchronous Programming in Golang (Goroutines):**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses **goroutines**, which are lightweight threads managed by the Go runtime.",
            "Unlike OS threads, goroutines use less memory and allow thousands of tasks to run concurrently.",
            "The `go` keyword is used to start a new goroutine.",
            "Channels (`chan`) are used to communicate safely between goroutines.",
            "Ideal for **CPU-bound** and **network-intensive** operations."
          ]
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc fetchData(ch chan string) {\n    time.Sleep(2 * time.Second) // Simulate async work\n    ch <- \"Data received\"\n}\n\nfunc main() {\n    fmt.Println(\"Start\")\n    ch := make(chan string)\n    go fetchData(ch)\n    result := <-ch\n    fmt.Println(result)\n    fmt.Println(\"End\")\n}"
        },
        {
          "type": "text",
          "content": "**Key Differences:**"
        },
        {
          "type": "list",
          "items": [
            "C# uses **async/await with Tasks**, while Golang uses **goroutines and channels**.",
            "C#'s **Thread Pool** manages threads, whereas Golangâ€™s **runtime scheduler** manages goroutines.",
            "Goroutines are **lighter and more efficient** than C# tasks, making them suitable for high-concurrency applications.",
            "C#'s `await` helps avoid blocking the main thread, whereas Go relies on **channels and synchronization** for communication.",
            "C# is more structured for **asynchronous I/O operations**, while Go excels at **parallel execution and concurrency control**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, C#'s async/await is designed for easier asynchronous coding in **I/O-bound** applications, while Go's goroutines provide a more **lightweight and efficient** concurrency model for **highly concurrent** systems."
        }
      ]
    },
    {
      "id": "be-6",
      "question": "What are the benefits of using Golang for backend services compared to C#? (Including memory usage and footprint comparison)",
      "answer": [
        {
          "type": "text",
          "content": "Golang and C# both offer strong backend capabilities, but they differ in terms of memory consumption, execution speed, and deployment footprint. Below is a detailed comparison."
        },
        {
          "type": "text",
          "content": "**1. Performance & Execution Speed**"
        },
        {
          "type": "list",
          "items": [
            "Golang is **compiled directly to native machine code**, making it faster at execution than C#'s **JIT (Just-In-Time) compilation** in .NET.",
            "C# runs on the **.NET runtime**, which adds some overhead but provides benefits like runtime optimizations and garbage collection."
          ]
        },
        {
          "type": "text",
          "content": "**2. Memory Usage & Garbage Collection**"
        },
        {
          "type": "list",
          "items": [
            "Golangâ€™s **garbage collector (GC)** is optimized for **low-latency, high-throughput** applications with **short pauses**.",
            "C#'s **.NET GC** is powerful but can cause **longer pauses** in high-memory applications due to **heap compaction and generational collection**.",
            "Goâ€™s memory model avoids **heap fragmentation**, making it more predictable in **containerized environments**."
          ]
        },
        {
          "type": "text",
          "content": "**3. Deployment & Binary Size**"
        },
        {
          "type": "list",
          "items": [
            "Golang compiles into a **single static binary** with no external dependencies, making deployment easy.",
            "A **Golang binary** typically ranges between **5-15 MB**, depending on the project.",
            "C# applications depend on **.NET runtime (CoreCLR or Mono)**, which increases the size.",
            "A self-contained **C# .NET Core application** can range from **50-100 MB+** when bundled with runtime dependencies."
          ]
        },
        {
          "type": "text",
          "content": "**4. Memory Footprint in Real-World Usage**"
        },
        {
          "type": "list",
          "items": [
            "A simple **Hello World** app in Go uses **1-2 MB RAM**, while in C# .NET, it starts at **15-30 MB RAM** due to runtime overhead.",
            "Goâ€™s **HTTP server** consumes around **5-10 MB RAM** under load, while an equivalent ASP.NET Core service may require **50-100 MB+ RAM**.",
            "For **high-concurrency services**, Goâ€™s lightweight **goroutines** allow handling **millions of requests** with lower memory usage compared to C#'s **ThreadPool-based tasks**."
          ]
        },
        {
          "type": "text",
          "content": "**5. Containerization & Cloud Deployment**"
        },
        {
          "type": "list",
          "items": [
            "Go's small footprint makes it ideal for **Docker and Kubernetes**, with **small container images (~10-20 MB)**.",
            "C# applications packaged in Docker often require **Alpine (~80-100 MB) or Debian (~200-300 MB)** base images to include the .NET runtime.",
            "Golang is preferred for **serverless functions** and cloud-native applications due to its **low memory consumption**."
          ]
        },
        {
          "type": "text",
          "content": "**Key Takeaways:**"
        },
        {
          "type": "list",
          "items": [
            "**Use Golang if:** You need a lightweight, fast, and highly efficient backend with **minimal memory consumption and small deployment size**.",
            "**Use C# if:** You require a feature-rich backend with **robust framework support**, even at the cost of a **larger memory footprint and dependency on .NET runtime**."
          ]
        },
        {
          "type": "text",
          "content": "In summary, Golang is a better choice for high-performance microservices, cloud-native applications, and low-latency APIs, while C# excels in enterprise solutions where rich ecosystem support and framework capabilities matter more."
        }
      ]
    },
    {
      "id": "be-7",
      "question": "Explain Rate Limiting and how to implement it in a Golang-based microservice.",
      "answer": [
        {
          "type": "text",
          "content": "Rate limiting is a technique used to control the number of requests a client can make to a server in a given time period. It helps prevent abuse, maintain service availability, and ensure fair usage of resources."
        },
        {
          "type": "text",
          "content": "**Common Rate Limiting Strategies:**"
        },
        {
          "type": "list",
          "items": [
            "**Token Bucket**: Clients acquire tokens before making requests. Requests are denied if tokens are exhausted.",
            "**Leaky Bucket**: Requests are processed at a fixed rate, and excess requests are queued.",
            "**Fixed Window**: Limits requests within a specific time window (e.g., 100 requests per minute).",
            "**Sliding Window**: More dynamic than fixed window; calculates limits based on the recent request history."
          ]
        },
        {
          "type": "text",
          "content": "**Rate Limiting Implementation in Golang**"
        },
        {
          "type": "text",
          "content": "Below is a Golang example implementing rate limiting using the `golang.org/x/time/rate` package, which provides an efficient token bucket algorithm."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"golang.org/x/time/rate\"\n)\n\n// RateLimiter struct for per-client rate limiting\ntype RateLimiter struct {\n\tclients map[string]*rate.Limiter\n\tmutex   sync.Mutex\n\trate  rate.Limit\n\tburst int\n}\n\n// NewRateLimiter initializes a new rate limiter\nfunc NewRateLimiter(r rate.Limit, b int) *RateLimiter {\n\treturn &RateLimiter{\n\t\tclients: make(map[string]*rate.Limiter),\n\t\trate:    r,\n\t\tburst:   b,\n\t}\n}\n\n// GetLimiter retrieves or creates a rate limiter for a client\nfunc (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {\n\trl.mutex.Lock()\n\tdefer rl.mutex.Unlock()\n\n\tif limiter, exists := rl.clients[ip]; exists {\n\t\treturn limiter\n\t}\n\n\tlimiter := rate.NewLimiter(rl.rate, rl.burst)\n\trl.clients[ip] = limiter\n\treturn limiter\n}\n\nfunc main() {\n\trl := NewRateLimiter(1, 5) // 1 request per second, burst of 5\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tip := r.RemoteAddr\n\t\tlimiter := rl.GetLimiter(ip)\n\n\t\tif !limiter.Allow() {\n\t\t\thttp.Error(w, \"429 Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\n\t\tfmt.Fprintln(w, \"Request successful\")\n\t})\n\n\tlog.Println(\"Starting server on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}"
        },
        {
          "type": "text",
          "content": "**How It Works:**"
        },
        {
          "type": "list",
          "items": [
            "Each client is identified by their **IP address**.",
            "A **token bucket rate limiter** is created for each client.",
            "If the client **exceeds the request limit**, they receive a **429 Too Many Requests** response.",
            "The limit is set to **1 request per second** with a burst capacity of **5 requests**."
          ]
        },
        {
          "type": "text",
          "content": "**Alternative Implementations:**"
        },
        {
          "type": "list",
          "items": [
            "Use **Redis-based rate limiting** for distributed systems (`github.com/go-redis/redis/v8`).",
            "Use **nginx or API Gateway** for rate limiting before requests reach the backend.",
            "Implement a **Sliding Window Counter** using a database like PostgreSQL."
          ]
        },
        {
          "type": "text",
          "content": "Rate limiting is crucial for protecting microservices from abuse and ensuring fair resource usage. In high-scale systems, it's recommended to use a distributed rate limiter backed by **Redis** or an API gateway like **Kong or Envoy**."
        }
      ]
    },
    {
      "id": "be-8",
      "question": "How do you secure APIs using OAuth, JWT, or API keys?",
      "answer": [
        {
          "type": "text",
          "content": "Securing APIs is essential to prevent unauthorized access and data breaches. Common authentication and authorization mechanisms include OAuth, JWT, and API Keys."
        },
        {
          "type": "text",
          "content": "**1. OAuth 2.0**"
        },
        {
          "type": "list",
          "items": [
            "OAuth 2.0 is an open standard for access delegation, commonly used to grant third-party applications limited access to user data.",
            "It uses **Access Tokens** to authenticate API requests.",
            "OAuth supports **authorization flows** such as Authorization Code, Client Credentials, and Password Grant."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Implementing OAuth 2.0 in Golang with `oauth2` package**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"golang.org/x/oauth2\"\n)\n\nvar googleOauthConfig = &oauth2.Config{\n\tClientID:     \"your-client-id\",\n\tClientSecret: \"your-client-secret\",\n\tRedirectURL:  \"http://localhost:8080/callback\",\n\tScopes:       []string{\"profile\", \"email\"},\n\tEndpoint:     oauth2.Endpoint{\n\t\tAuthURL:  \"https://accounts.google.com/o/oauth2/auth\",\n\t\tTokenURL: \"https://oauth2.googleapis.com/token\",\n\t},\n}\n\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\turl := googleOauthConfig.AuthCodeURL(\"state-token\", oauth2.AccessTypeOffline)\n\thttp.Redirect(w, r, url, http.StatusFound)\n}\n\nfunc callbackHandler(w http.ResponseWriter, r *http.Request) {\n\tcode := r.URL.Query().Get(\"code\")\n\ttoken, err := googleOauthConfig.Exchange(context.Background(), code)\n\tif err != nil {\n\t\tlog.Println(\"Failed to get token:\", err)\n\t\treturn\n\t}\n\tfmt.Fprintf(w, \"Access Token: %s\", token.AccessToken)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/login\", loginHandler)\n\thttp.HandleFunc(\"/callback\", callbackHandler)\n\tlog.Println(\"Server started at :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**2. JSON Web Token (JWT)**"
        },
        {
          "type": "list",
          "items": [
            "JWT is a compact, self-contained token format that encodes user claims and authentication data.",
            "It consists of **Header, Payload, and Signature**.",
            "JWTs are signed using HMAC or RSA to ensure integrity."
          ]
        },
        {
          "type": "text",
          "content": "**Example: JWT Authentication in Golang using `github.com/golang-jwt/jwt/v4`**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar secretKey = []byte(\"your-secret-key\")\n\nfunc generateJWT() (string, error) {\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{\n\t\t\"user\": \"admin\",\n\t\t\"exp\":  time.Now().Add(time.Hour * 1).Unix(),\n\t})\n\treturn token.SignedString(secretKey)\n}\n\nfunc jwtMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttokenString := r.Header.Get(\"Authorization\")\n\t\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\t\treturn secretKey, nil\n\t\t})\n\t\tif err != nil || !token.Valid {\n\t\t\thttp.Error(w, \"Unauthorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc protectedEndpoint(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"Access granted to protected resource\")\n}\n\nfunc main() {\n\thttp.Handle(\"/protected\", jwtMiddleware(http.HandlerFunc(protectedEndpoint)))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**3. API Keys Authentication**"
        },
        {
          "type": "list",
          "items": [
            "API Keys are simple authentication tokens passed in HTTP headers or query parameters.",
            "They are commonly used for **service-to-service communication**.",
            "API Keys should be **revocable and scoped** to control access."
          ]
        },
        {
          "type": "text",
          "content": "**Example: API Key Middleware in Golang**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nvar validAPIKey = \"your-api-key\"\n\nfunc apiKeyMiddleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tapiKey := r.Header.Get(\"X-API-Key\")\n\t\tif apiKey != validAPIKey {\n\t\t\thttp.Error(w, \"Forbidden\", http.StatusForbidden)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc protectedHandler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"API Key authentication successful\")\n}\n\nfunc main() {\n\thttp.Handle(\"/secure\", apiKeyMiddleware(http.HandlerFunc(protectedHandler)))\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        },
        {
          "type": "text",
          "content": "**Choosing the Right Authentication Method:**"
        },
        {
          "type": "list",
          "items": [
            "**OAuth 2.0**: Best for user authentication in third-party integrations (e.g., Google, Facebook login).",
            "**JWT**: Ideal for securing API endpoints in microservices without needing session storage.",
            "**API Keys**: Useful for machine-to-machine authentication but should be used with caution due to security risks."
          ]
        },
        {
          "type": "text",
          "content": "A combination of these methods can be used to enhance API security, e.g., using **OAuth for user login** and **JWT for API authorization**."
        }
      ]
    },
    {
      "id": "be-9",
      "question": "How does goroutine scheduling work in Golang? How does it differ from OS threads?",
      "answer": [
        {
          "type": "text",
          "content": "Goroutines are lightweight, managed by the Go runtime, and allow concurrent execution. Unlike OS threads, goroutines have minimal memory overhead and can scale efficiently."
        },
        {
          "type": "text",
          "content": "**Goroutine Scheduling:**"
        },
        {
          "type": "list",
          "items": [
            "Golang uses **Goroutine Scheduler** to map thousands of goroutines onto a small number of OS threads.",
            "The scheduler is **non-preemptive** but can yield execution during function calls and specific points (e.g., I/O operations).",
            "It follows a **work-stealing** strategy where idle processors (P) take work from busy ones.",
            "Each OS thread (M) is bound to a user-level scheduler (P) managing a pool of goroutines."
          ]
        },
        {
          "type": "text",
          "content": "**Differences between Goroutines and OS Threads:**"
        },
        {
          "type": "list",
          "items": [
            "**Goroutines:** Small stack (~2KB), dynamically grows; managed by Go runtime.",
            "**OS Threads:** Large stack (~1MB), fixed size; managed by the operating system.",
            "**Goroutines:** Multiplexed over OS threads, allowing millions of goroutines.",
            "**OS Threads:** Limited in number due to resource constraints."
          ]
        }
      ]
    },
    {
      "id": "be-10",
      "question": "Explain channels vs. mutexes. When would you use one over the other?",
      "answer": [
        {
          "type": "text",
          "content": "Channels and mutexes are synchronization primitives in Golang."
        },
        {
          "type": "text",
          "content": "**Channels:**"
        },
        {
          "type": "list",
          "items": [
            "Used for **message passing** between goroutines.",
            "Avoids shared memory, enabling safe concurrent programming.",
            "Synchronous (blocking) or asynchronous (buffered) communication."
          ]
        },
        {
          "type": "text",
          "content": "**Mutexes:**"
        },
        {
          "type": "list",
          "items": [
            "Used for **mutual exclusion** (locking shared data).",
            "Provides fine-grained control over shared resources.",
            "More efficient for protecting small, frequently accessed variables."
          ]
        },
        {
          "type": "text",
          "content": "**When to use which?**"
        },
        {
          "type": "list",
          "items": [
            "Use **channels** when you want to pass ownership of data instead of locking it.",
            "Use **mutexes** when multiple goroutines need to modify a shared variable safely."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Channel-based synchronization**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nfunc main() {\n\tch := make(chan int)\n\n\tgo func() {\n\t\tch <- 42 // Send data to channel\n\t}()\n\n\tfmt.Println(<-ch) // Receive data from channel\n}"
        },
        {
          "type": "text",
          "content": "**Example: Mutex-based synchronization**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar counter int\nvar mu sync.Mutex\n\nfunc increment(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tmu.Lock()\n\tcounter++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo increment(&wg)\n\t}\n\twg.Wait()\n\tfmt.Println(\"Final Counter:\", counter)\n}"
        }
      ]
    },
    {
      "id": "be-11",
      "question": "What are defer, panic, and recover in Golang? How do they work?",
      "answer": [
        {
          "type": "text",
          "content": "In Golang, `defer`, `panic`, and `recover` are mechanisms for handling cleanup and error recovery."
        },
        {
          "type": "text",
          "content": "**1. Defer:**"
        },
        {
          "type": "list",
          "items": [
            "Used to schedule a function to execute **after** the surrounding function returns.",
            "Useful for **resource cleanup** (closing files, unlocking mutexes, etc.)."
          ]
        },
        {
          "type": "text",
          "content": "**Example of defer:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"This will execute last\")\n\tfmt.Println(\"This executes first\")\n}"
        },
        {
          "type": "text",
          "content": "**2. Panic:**"
        },
        {
          "type": "list",
          "items": [
            "Used to **abort execution** immediately.",
            "Typically used for **critical errors** like accessing an invalid memory location."
          ]
        },
        {
          "type": "text",
          "content": "**Example of panic:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Before panic\")\n\tpanic(\"Something went wrong!\")\n\tfmt.Println(\"This will not execute\")\n}"
        },
        {
          "type": "text",
          "content": "**3. Recover:**"
        },
        {
          "type": "list",
          "items": [
            "Used inside `defer` to **catch a panic** and prevent program crash.",
            "Returns `nil` if no panic occurs."
          ]
        },
        {
          "type": "text",
          "content": "**Example of recover:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tfmt.Println(\"Recovered from panic:\", r)\n\t\t}\n\t}()\n\tpanic(\"Something went wrong!\")\n}"
        }
      ]
    },
    {
      "id": "be-12",
      "question": "How would you implement worker pools in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Worker pools are a pattern used to control concurrency by limiting the number of goroutines processing tasks."
        },
        {
          "type": "text",
          "content": "**Steps to implement a worker pool:**"
        },
        {
          "type": "list",
          "items": [
            "Create a buffered channel for tasks.",
            "Spawn a fixed number of worker goroutines.",
            "Each worker fetches and processes tasks from the channel.",
            "Close the channel when all tasks are dispatched."
          ]
        },
        {
          "type": "text",
          "content": "**Example of a Worker Pool in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 5)\n\tvar wg sync.WaitGroup\n\n\t// Create worker pool\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, &wg)\n\t}\n\n\t// Send jobs to channel\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n}"
        }
      ]
    },
    {
      "id": "be-13",
      "question": "Explain context package in Golang. How do you use it for request cancellation?",
      "answer": [
        {
          "type": "text",
          "content": "The `context` package in Golang provides a way to manage request deadlines, cancellations, and timeouts across API calls and goroutines."
        },
        {
          "type": "text",
          "content": "**Key Features:**"
        },
        {
          "type": "list",
          "items": [
            "Allows request **cancellation** to prevent resource leaks.",
            "Supports **timeouts** and **deadlines**.",
            "Enables **passing metadata** between function calls."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using context for request cancellation**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n\tdefer cancel() // Ensure cleanup\n\n\tgo func(ctx context.Context) {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tfmt.Println(\"Request canceled\")\n\t\t\t\treturn\n\t\t\tdefault:\n\t\t\t\tfmt.Println(\"Processing...\")\n\t\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\t}\n\t\t}\n\t}(ctx)\n\ntime.Sleep(3 * time.Second)\n}"
        }
      ]
    },
    {
      "id": "be-14",
      "question": "How do you handle race conditions in a concurrent Golang application?",
      "answer": [
        {
          "type": "text",
          "content": "Race conditions occur when multiple goroutines access shared data simultaneously, leading to unpredictable behavior."
        },
        {
          "type": "text",
          "content": "**Ways to Prevent Race Conditions:**"
        },
        {
          "type": "list",
          "items": [
            "Use **sync.Mutex** to lock shared data.",
            "Use **channels** to control access.",
            "Use **sync/atomic** for atomic operations.",
            "Use **Go's race detector** (`go run -race`)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Using Mutex to prevent race conditions**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\nvar count int\nvar mu sync.Mutex\n\nfunc increment(wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tmu.Lock()\n\tcount++\n\tmu.Unlock()\n}\n\nfunc main() {\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < 10; i++ {\n\t\twg.Add(1)\n\t\tgo increment(&wg)\n\t}\n\twg.Wait()\n\tfmt.Println(\"Final Count:\", count)\n}"
        }
      ]
    },
    {
      "id": "be-15",
      "question": "What are interface types, and how does Golangâ€™s interface system differ from C#â€™s?",
      "answer": [
        {
          "type": "text",
          "content": "**Golang Interfaces:**"
        },
        {
          "type": "list",
          "items": [
            "Interfaces define **behavior** rather than **inheritance**.",
            "A type **implicitly** satisfies an interface if it implements the required methods.",
            "Interfaces allow **decoupled code** and **mocking** in tests."
          ]
        },
        {
          "type": "text",
          "content": "**Difference from C# Interfaces:**"
        },
        {
          "type": "list",
          "items": [
            "**Golang:** Implicit implementation (structs automatically satisfy interfaces).",
            "**C#:** Explicit implementation using `interface` keyword.",
            "**Golang:** No need to declare an interface in the struct.",
            "**C#:** Classes must explicitly declare they implement an interface."
          ]
        },
        {
          "type": "text",
          "content": "**Example of Golang Interface:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Animal interface {\n\tSpeak() string\n}\n\ntype Dog struct {}\n\nfunc (d Dog) Speak() string {\n\treturn \"Woof!\"\n}\n\nfunc main() {\n\tvar a Animal = Dog{}\n\tfmt.Println(a.Speak())\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "How does dependency injection work in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Dependency Injection (DI) is a design pattern where dependencies are **injected** instead of being created inside a struct."
        },
        {
          "type": "text",
          "content": "**DI Approaches in Golang:**"
        },
        {
          "type": "list",
          "items": [
            "Using **constructor functions**.",
            "Passing **interfaces instead of concrete types**.",
            "Using **third-party DI libraries** (e.g., `uber-go/fx`, `wire`)."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Constructor-based DI**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Service struct {\n\tmessage string\n}\n\nfunc NewService(msg string) *Service {\n\treturn &Service{message: msg}\n}\n\nfunc main() {\n\tservice := NewService(\"Hello, DI!\")\n\tfmt.Println(service.message)\n}"
        }
      ]
    },
    {
      "id": "be-17",
      "question": "How do you design a highly available, scalable Golang microservice?",
      "answer": [
        {
          "type": "text",
          "content": "**Best Practices for Scalable Microservices:**"
        },
        {
          "type": "list",
          "items": [
            "Use **stateless** services with shared databases or caches.",
            "Implement **load balancing** (e.g., Nginx, HAProxy).",
            "Use **goroutines and channels** for concurrency.",
            "Apply **caching** (Redis, Memcached) to reduce DB load.",
            "Implement **rate limiting** to prevent abuse.",
            "Use **Docker and Kubernetes** for containerization and orchestration."
          ]
        },
        {
          "type": "text",
          "content": "**Example: Goroutine-based request handling**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, \"Hello, Microservice!\")\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    },
    {
      "id": "be-18",
      "question": "Explain the difference between struct embedding and inheritance in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "**Golang does not support classical inheritance** like C++ or Java but uses **struct embedding** for composition."
        },
        {
          "type": "text",
          "content": "**Struct Embedding:**"
        },
        {
          "type": "list",
          "items": [
            "Allows code reuse without a strict parent-child hierarchy.",
            "Encapsulates behavior while avoiding deep inheritance chains.",
            "Methods of the embedded struct are promoted to the outer struct."
          ]
        },
        {
          "type": "text",
          "content": "**Example of Struct Embedding:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport \"fmt\"\n\ntype Engine struct {\n\tHorsepower int\n}\n\ntype Car struct {\n\tEngine // Embedded struct\n\tBrand string\n}\n\nfunc main() {\n\tc := Car{Engine{250}, \"Toyota\"}\n\tfmt.Println(\"Car brand:\", c.Brand, \"Horsepower:\", c.Horsepower)\n}"
        }
      ]
    },
    {
      "id": "be-13",
      "question": "What are best practices for logging and monitoring in Golang applications?",
      "answer": [
        {
          "type": "text",
          "content": "Logging and monitoring are essential for observability in Golang applications. Here are best practices:"
        },
        {
          "type": "text",
          "content": "**Best Practices for Logging:**"
        },
        {
          "type": "list",
          "items": [
            "Use structured logging with libraries like `logrus` or `zap`.",
            "Log at appropriate levels: `Debug`, `Info`, `Warning`, `Error`, and `Fatal`.",
            "Include contextual information (e.g., request ID, user ID).",
            "Write logs in JSON format for easy parsing.",
            "Avoid logging sensitive information (passwords, API keys)."
          ]
        },
        {
          "type": "text",
          "content": "**Example using logrus:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"github.com/sirupsen/logrus\"\n)\n\nfunc main() {\n\tlog := logrus.New()\n\tlog.SetFormatter(&logrus.JSONFormatter{})\n\tlog.Info(\"Application started\")\n}"
        },
        {
          "type": "text",
          "content": "**Best Practices for Monitoring:**"
        },
        {
          "type": "list",
          "items": [
            "Use Prometheus for metrics collection.",
            "Track key performance indicators (latency, request count, errors).",
            "Use distributed tracing (e.g., OpenTelemetry, Jaeger).",
            "Monitor logs centrally with ELK (Elasticsearch, Logstash, Kibana) or Loki."
          ]
        }
      ]
    },
    {
      "id": "be-14",
      "question": "How do you implement retry logic with exponential backoff in Golang?",
      "answer": [
        {
          "type": "text",
          "content": "Retry logic with exponential backoff helps in handling transient failures by delaying retries progressively."
        },
        {
          "type": "text",
          "content": "**Steps to implement exponential backoff:**"
        },
        {
          "type": "list",
          "items": [
            "Define maximum retries and initial delay.",
            "Double the delay after each failed attempt.",
            "Introduce jitter to avoid synchronized retries.",
            "Stop retrying after a maximum number of attempts."
          ]
        },
        {
          "type": "text",
          "content": "**Example using exponential backoff in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc retryWithBackoff(attempts int, baseDelay time.Duration) error {\n\tfor i := 0; i < attempts; i++ {\n\t\terr := makeRequest()\n\t\tif err == nil {\n\t\t\treturn nil\n\t\t}\n\t\tjitter := time.Duration(rand.Intn(100)) * time.Millisecond\n\t\tsleepTime := baseDelay * (1 << i) + jitter\n\t\tfmt.Println(\"Retrying in\", sleepTime)\n\t\ttime.Sleep(sleepTime)\n\t}\n\treturn fmt.Errorf(\"operation failed after %d attempts\", attempts)\n}\n\nfunc makeRequest() error {\n\treturn fmt.Errorf(\"temporary error\")\n}\n\nfunc main() {\n\tretryWithBackoff(5, 500*time.Millisecond)\n}"
        }
      ]
    },
    {
      "id": "be-15",
      "question": "How does Golang handle JSON marshaling and unmarshaling?",
      "answer": [
        {
          "type": "text",
          "content": "Golang uses the `encoding/json` package to marshal (convert struct to JSON) and unmarshal (convert JSON to struct)."
        },
        {
          "type": "text",
          "content": "**Example of JSON marshaling (struct to JSON):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\tuser := User{Name: \"Alice\", Age: 25, Email: \"alice@example.com\"}\n\tjsonData, _ := json.Marshal(user)\n\tfmt.Println(string(jsonData))\n}"
        },
        {
          "type": "text",
          "content": "**Example of JSON unmarshaling (JSON to struct):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\ntype User struct {\n\tName  string `json:\"name\"`\n\tAge   int    `json:\"age\"`\n\tEmail string `json:\"email\"`\n}\n\nfunc main() {\n\tjsonData := `{\"name\": \"Bob\", \"age\": 30, \"email\": \"bob@example.com\"}`\n\tvar user User\n\tjson.Unmarshal([]byte(jsonData), &user)\n\tfmt.Println(user)\n}"
        },
        {
          "type": "text",
          "content": "**Handling Unknown JSON Fields:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "type Response struct {\n\tData map[string]interface{} `json:\"data\"`\n}"
        }
      ]
    },
    {
      "id": "be-16",
      "question": "How do you implement WebSockets in a Golang API?",
      "answer": [
        {
          "type": "text",
          "content": "WebSockets enable real-time communication between clients and a Golang server. The `github.com/gorilla/websocket` package is commonly used."
        },
        {
          "type": "text",
          "content": "**Steps to implement WebSockets:**"
        },
        {
          "type": "list",
          "items": [
            "Upgrade HTTP requests to WebSocket connections.",
            "Handle WebSocket messages in a loop.",
            "Gracefully close the connection when the client disconnects."
          ]
        },
        {
          "type": "text",
          "content": "**Example WebSocket server in Golang:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool { return true },\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tfmt.Println(\"Error upgrading connection:\", err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tfor {\n\t\tmessageType, msg, err := conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading message:\", err)\n\t\t\tbreak\n\t\t}\n\t\tfmt.Println(\"Received:\", string(msg))\n\t\tconn.WriteMessage(messageType, []byte(\"Hello from server!\"))\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", handleWebSocket)\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    }
  ],
  "backend-golang-problem-solving": [
    {
      "id": "cps-1",
      "question": "Implement a thread-safe in-memory key-value store in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "A thread-safe key-value store requires synchronization mechanisms like `sync.Mutex` or `sync.RWMutex` to prevent race conditions when multiple goroutines access the store."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"sync\"\n\t\"fmt\"\n)\n\ntype Store struct {\n\tdata map[string]string\n\tmu   sync.RWMutex\n}\n\nfunc NewStore() *Store {\n\treturn &Store{data: make(map[string]string)}\n}\n\nfunc (s *Store) Set(key, value string) {\n\ts.mu.Lock()\n\ts.data[key] = value\n\ts.mu.Unlock()\n}\n\nfunc (s *Store) Get(key string) (string, bool) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tval, exists := s.data[key]\n\treturn val, exists\n}\n\nfunc main() {\n\tstore := NewStore()\n\tstore.Set(\"foo\", \"bar\")\n\tval, _ := store.Get(\"foo\")\n\tfmt.Println(\"Value:\", val)\n}"
        }
      ]
    },
    {
      "id": "cps-2",
      "question": "Write a rate limiter using Golang middleware.",
      "answer": [
        {
          "type": "text",
          "content": "Rate limiting ensures API requests are restricted to a fixed rate. We use `golang.org/x/time/rate` package to implement a token bucket rate limiter in middleware."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\t\"golang.org/x/time/rate\"\n)\n\ntype rateLimiter struct {\n\tlimiter *rate.Limiter\n}\n\nfunc (rl *rateLimiter) middleware(next http.Handler) http.Handler {\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tif !rl.limiter.Allow() {\n\t\t\thttp.Error(w, \"Too Many Requests\", http.StatusTooManyRequests)\n\t\t\treturn\n\t\t}\n\t\tnext.ServeHTTP(w, r)\n\t})\n}\n\nfunc main() {\n\trl := &rateLimiter{limiter: rate.NewLimiter(1, 5)} // 1 request per second, burst of 5\n\n\thttp.Handle(\"/\", rl.middleware(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tfmt.Fprintln(w, \"Hello, World!\")\n\t})))\n\n\thttp.ListenAndServe(\":8080\", nil)\n}"
        }
      ]
    },
    {
      "id": "cps-3",
      "question": "Implement a concurrent worker pool in Golang.",
      "answer": [
        {
          "type": "text",
          "content": "A worker pool limits the number of concurrent workers processing tasks. It distributes tasks among workers using channels."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc worker(id int, jobs <-chan int, wg *sync.WaitGroup) {\n\tdefer wg.Done()\n\tfor job := range jobs {\n\t\tfmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc main() {\n\tjobs := make(chan int, 5)\n\tvar wg sync.WaitGroup\n\n\tfor i := 1; i <= 3; i++ {\n\t\twg.Add(1)\n\t\tgo worker(i, jobs, &wg)\n\t}\n\n\tfor j := 1; j <= 5; j++ {\n\t\tjobs <- j\n\t}\n\tclose(jobs)\n\n\twg.Wait()\n}"
        }
      ]
    },
    {
      "id": "cps-4",
      "question": "Implement a REST API in Golang that connects to a PostgreSQL database.",
      "answer": [
        {
          "type": "text",
          "content": "This implementation uses `gorm` for database interactions and `gin` for REST API handling."
        },
        {
          "type": "text",
          "content": "**Example Implementation:**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"gorm.io/driver/postgres\"\n\t\"gorm.io/gorm\"\n)\n\ntype User struct {\n\tID   uint   `json:\"id\"`\n\tName string `json:\"name\"`\n}\n\nvar db *gorm.DB\n\nfunc initDB() {\n\tdsn := \"host=localhost user=postgres password=yourpassword dbname=testdb port=5432 sslmode=disable\"\n\tvar err error\n\tdb, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n\tif err != nil {\n\t\tpanic(\"Failed to connect to database\")\n\t}\n\tdb.AutoMigrate(&User{})\n}\n\nfunc getUsers(c *gin.Context) {\n\tvar users []User\n\tdb.Find(&users)\n\tc.JSON(200, users)\n}\n\nfunc main() {\n\tinitDB()\n\tr := gin.Default()\n\tr.GET(\"/users\", getUsers)\n\tr.Run(\":8080\")\n}"
        }
      ]
    },
    {
      "id": "cps-5",
      "question": "Design a task scheduler in Golang where tasks run at specific intervals.",
      "answer": [
        {
          "type": "text",
          "content": "A task scheduler can be implemented using `time.Ticker` or `cron` library for periodic execution."
        },
        {
          "type": "text",
          "content": "**Example Implementation (Using time.Ticker):**"
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc task() {\n\tfmt.Println(\"Task executed at\", time.Now())\n}\n\nfunc main() {\n\tticker := time.NewTicker(5 * time.Second)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\ttask()\n\t}\n}"
        }
      ]
    }
  ],
  "algorithms": [
    {
      "id": "algo-1",
      "question": "Implement a function to reverse a linked list.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for singly-linked list node\n */\nclass ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n/**\n * Reverses a singly linked list\n * Time Complexity: O(n)\n * Space Complexity: O(1)\n * \n * @param {ListNode} head - Head of the linked list\n * @return {ListNode} - Head of the reversed linked list\n */\nfunction reverseLinkedList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current !== null) {\n    // Save next node\n    const next = current.next;\n    \n    // Reverse pointer\n    current.next = prev;\n    \n    // Move pointers one step forward\n    prev = current;\n    current = next;\n  }\n  \n  // prev is the new head\n  return prev;\n}\n\n// Example usage:\n// const list = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));\n// const reversed = reverseLinkedList(list);\n// Output: 4 -> 3 -> 2 -> 1 -> null"
      }
    },
    {
      "id": "algo-2",
      "question": "Implement a function to find if a binary tree is balanced.",
      "answer": {
        "type": "code",
        "language": "javascript",
        "content": "/**\n * Definition for a binary tree node\n */\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * Determines if a binary tree is height-balanced.\n * A height-balanced tree is a tree in which the left and right subtrees \n * of every node differ in height by no more than 1.\n * \n * Time Complexity: O(n) where n is the number of nodes in the tree\n * Space Complexity: O(h) where h is the height of the tree (due to recursion stack)\n * \n * @param {TreeNode} root - Root of the binary tree\n * @return {boolean} - Whether the tree is balanced or not\n */\nfunction isBalanced(root) {\n  // Function returns -1 if the tree is unbalanced, otherwise returns the height\n  function checkHeight(node) {\n    if (node === null) return 0;\n    \n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1; // Left subtree is unbalanced\n    \n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1; // Right subtree is unbalanced\n    \n    // Check if current node is balanced\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    \n    // Return height of current subtree\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  return checkHeight(root) !== -1;\n}\n\n// Example usage:\n// const balancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3));\n// console.log(isBalanced(balancedTree)); // true\n//\n// const unbalancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4, new TreeNode(8))), new TreeNode(3));\n// console.log(isBalanced(unbalancedTree)); // false"
      }
    }
  ],
  "system-design": [
    {
      "id": "sd-1",
      "question": "Design a URL shortening service like bit.ly.",
      "answer": [
        {
          "type": "text",
          "content": "Designing a URL shortening service involves several components and considerations:"
        },
        {
          "type": "text",
          "content": "**Functional Requirements:**"
        },
        {
          "type": "list",
          "items": [
            "URL shortening: Convert a long URL to a short URL",
            "URL redirection: Redirect short URL to original URL",
            "User accounts: Optional for analytics and URL management",
            "Analytics: Track click rates, geographic data, etc.",
            "Custom short URLs: Allow users to choose their custom short URLs"
          ]
        },
        {
          "type": "text",
          "content": "**Non-Functional Requirements:**"
        },
        {
          "type": "list",
          "items": [
            "High availability: System should be always available",
            "Minimal latency: Redirection should happen with minimal delay",
            "Scalability: System should handle high traffic",
            "Security: Prevent abuse and malicious URLs"
          ]
        },
        {
          "type": "text",
          "content": "**API Design:**"
        },
        {
          "type": "list",
          "items": [
            "`POST /api/shorten` - Create a new short URL",
            "`GET /{shortCode}` - Redirect to original URL",
            "`GET /api/analytics/{shortCode}` - Get analytics for a short URL"
          ]
        },
        {
          "type": "text",
          "content": "**Data Model:**"
        },
        {
          "type": "code",
          "language": "text",
          "content": "URL {\n  id: string (primary key)\n  shortCode: string (indexed)\n  originalUrl: string\n  userId: string (optional)\n  createdAt: timestamp\n  expiresAt: timestamp (optional)\n}\n\nClick {\n  id: string (primary key)\n  urlId: string (foreign key)\n  timestamp: timestamp\n  userAgent: string\n  ipAddress: string\n  referrer: string\n}"
        },
        {
          "type": "text",
          "content": "**URL Shortening Algorithm:**"
        },
        {
          "type": "list",
          "items": [
            "Hash-based approach: Hash the long URL and take first few characters",
            "Counter-based approach: Use an auto-incrementing counter and convert to base62",
            "Random generation: Generate random strings and check for collisions"
          ]
        },
        {
          "type": "text",
          "content": "**System Architecture:**"
        },
        {
          "type": "list",
          "items": [
            "Load Balancer: Distribute traffic across application servers",
            "Application Servers: Handle API requests and URL redirection",
            "Database: Store URLs and analytics data",
            "Cache: Store frequently accessed URLs for faster redirection"
          ]
        },
        {
          "type": "text",
          "content": "**Database Choice:**"
        },
        {
          "type": "list",
          "items": [
            "Relational DB (PostgreSQL/MySQL): For structured data and transactions",
            "NoSQL DB (DynamoDB/Cassandra): For scalability and performance"
          ]
        },
        {
          "type": "text",
          "content": "**Caching Strategy:**"
        },
        {
          "type": "list",
          "items": [
            "Use Redis/Memcached to cache URL mappings",
            "LRU (Least Recently Used) eviction policy"
          ]
        },
        {
          "type": "text",
          "content": "**Scaling Considerations:**"
        },
        {
          "type": "list",
          "items": [
            "Database sharding: Partition URLs based on shortCode hash",
            "Caching: Implement multiple cache layers",
            "CDN: Use for handling static content and reducing latency",
            "Horizontal scaling: Add more application servers as needed"
          ]
        },
        {
          "type": "text",
          "content": "**Security:**"
        },
        {
          "type": "list",
          "items": [
            "Rate limiting: Prevent abuse",
            "URL validation: Check for malicious URLs",
            "User authentication: For managing URLs",
            "HTTPS: Secure all communications"
          ]
        },
        {
          "type": "text",
          "content": "This design balances simplicity, performance, and scalability while addressing the key requirements of a URL shortening service."
        }
      ]
    }
  ],
  "system-design-microservices": [
    {
      "id": "be-7",
      "question": "Can you provide a simple microservice implementation in Go?",
      "answer": [
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n    \"github.com/gin-gonic/gin\"\n    \"gorm.io/driver/postgres\"\n    \"gorm.io/gorm\"\n    \"net/http\"\n)\n\n// User model\ntype User struct {\n    ID    uint   `json:\"id\" gorm:\"primaryKey\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nvar db *gorm.DB\n\nfunc init() {\n    var err error\n    dsn := \"host=localhost user=postgres password=yourpassword dbname=microservice port=5432 sslmode=disable\"\n    db, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})\n    if err != nil {\n        panic(\"Failed to connect to database\")\n    }\n    db.AutoMigrate(&User{})\n}\n\nfunc main() {\n    r := gin.Default()\n    r.GET(\"/users\", getUsers)\n    r.POST(\"/users\", createUser)\n    r.Run(\":8080\")\n}\n\n// Get all users\nfunc getUsers(c *gin.Context) {\n    var users []User\n    db.Find(&users)\n    c.JSON(http.StatusOK, users)\n}\n\n// Create a new user\nfunc createUser(c *gin.Context) {\n    var user User\n    if err := c.ShouldBindJSON(&user); err != nil {\n        c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n        return\n    }\n    db.Create(&user)\n    c.JSON(http.StatusCreated, user)\n}"
        }
      ]
    },
    {
      "id": "ms-1",
      "question": "What is Microservice Architecture?",
      "answer": [
        {
          "type": "text",
          "content": "Microservice Architecture is an architectural style where an application is developed as a collection of small, independent services that communicate over a network. Each service is responsible for a specific functionality and can be deployed, scaled, and updated independently."
        },
        {
          "type": "list",
          "items": [
            "**Independence**: Each microservice runs in its own process.",
            "**Modularity**: Services are designed around business capabilities.",
            "**Decentralized Data Management**: Each service manages its own database.",
            "**Scalability**: Services can be scaled independently based on demand.",
            "**Resilience**: Failure in one service does not impact the entire system."
          ]
        }
      ]
    },
    {
      "id": "ms-2",
      "question": "How does Microservices differ from Monolithic Architecture?",
      "answer": [
        {
          "type": "text",
          "content": "Microservices and Monolithic architectures differ in terms of structure, scalability, and deployment."
        },
        {
          "type": "list",
          "items": [
            "**Monolithic Architecture**:",
            "- Single codebase with all features in one application.",
            "- Difficult to scale specific parts of the application.",
            "- Tight coupling between components.",
            "- Deployment requires redeploying the entire application.",
            "**Microservices Architecture**:",
            "- Composed of independent, loosely coupled services.",
            "- Each service can be scaled individually.",
            "- Allows for a diverse technology stack.",
            "- Services can be deployed independently."
          ]
        }
      ]
    },
    {
      "id": "ms-3",
      "question": "What are the key advantages of Microservices?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Scalability**: Individual services can be scaled as needed.",
            "**Flexibility**: Different services can use different programming languages and databases.",
            "**Resilience**: Failures in one service do not affect others.",
            "**Faster Development**: Multiple teams can work on different services independently.",
            "**Continuous Deployment**: Easier to deploy updates without affecting the entire application."
          ]
        }
      ]
    },
    {
      "id": "ms-4",
      "question": "What are the main challenges of Microservices?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Increased Complexity**: More services mean more points of failure.",
            "**Data Management**: Handling distributed databases requires strategies like Saga Pattern.",
            "**Service Discovery**: Managing inter-service communication dynamically.",
            "**Security Concerns**: More exposed APIs increase security risks.",
            "**Latency**: Network calls between microservices introduce delays."
          ]
        }
      ]
    },
    {
      "id": "ms-5",
      "question": "What is the difference between REST and gRPC?",
      "answer": [
        {
          "type": "text",
          "content": "REST and gRPC are both communication protocols used in microservices, but they have key differences."
        },
        {
          "type": "list",
          "items": [
            "**REST**:",
            "- Uses HTTP with JSON for data exchange.",
            "- Human-readable but has higher latency.",
            "- Stateless communication.",
            "**gRPC**:",
            "- Uses HTTP/2 and Protocol Buffers for serialization.",
            "- More efficient and faster than REST.",
            "- Supports bi-directional streaming."
          ]
        }
      ]
    },
    {
      "id": "ms-6",
      "question": "How does inter-service communication work in Microservices?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Synchronous Communication**: Services call each other directly using REST or gRPC.",
            "**Asynchronous Communication**: Services use message brokers like Kafka or RabbitMQ.",
            "**Event-Driven Communication**: Services publish and subscribe to events to exchange information."
          ]
        }
      ]
    },
    {
      "id": "ms-7",
      "question": "What is API Gateway, and why is it used?",
      "answer": [
        {
          "type": "text",
          "content": "An API Gateway is a single entry point for managing requests between clients and microservices."
        },
        {
          "type": "list",
          "items": [
            "**Routing**: Directs requests to the appropriate microservice.",
            "**Authentication**: Manages security (OAuth, JWT).",
            "**Load Balancing**: Distributes traffic across multiple instances.",
            "**Rate Limiting**: Prevents abuse and ensures fair usage."
          ]
        }
      ]
    },
    {
      "id": "ms-8",
      "question": "What is Service Discovery in Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "Service Discovery is a mechanism that helps microservices dynamically find and communicate with each other."
        },
        {
          "type": "list",
          "items": [
            "**Client-Side Discovery**: The client looks up the service location from a registry (e.g., Consul, Eureka).",
            "**Server-Side Discovery**: The API Gateway handles service lookup and routing.",
            "**Service Registry**: Stores available service instances and updates dynamically."
          ]
        }
      ]
    },
    {
      "id": "ms-9",
      "question": "Explain the concept of database per service in Microservices.",
      "answer": [
        {
          "type": "text",
          "content": "Each microservice has its own dedicated database to ensure loose coupling."
        },
        {
          "type": "list",
          "items": [
            "**Benefits**:",
            "- Independent scaling of services.",
            "- Avoids data conflicts across services.",
            "- Allows for different database technologies (Polyglot Persistence).",
            "**Challenges**:",
            "- Managing distributed transactions.",
            "- Maintaining consistency between services."
          ]
        }
      ]
    },
    {
      "id": "ms-10",
      "question": "What is Polyglot Persistence?",
      "answer": [
        {
          "type": "text",
          "content": "Polyglot Persistence is the practice of using different databases for different microservices based on their requirements."
        },
        {
          "type": "list",
          "items": [
            "**Example Usage**:",
            "- **SQL (PostgreSQL, MySQL)** for transactional data.",
            "- **NoSQL (MongoDB, Cassandra)** for flexible document storage.",
            "- **Redis** for caching.",
            "**Advantages**:",
            "- Optimized performance for each service.",
            "- Flexibility in choosing the best data storage model.",
            "**Challenges**:",
            "- Increased complexity in data management.",
            "- Requires expertise in multiple database technologies."
          ]
        }
      ]
    },
    {
      "id": "ms-11",
      "question": "How do you handle transactions across multiple Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "Handling transactions in microservices requires ensuring data consistency across services, since a traditional database transaction (ACID) is not feasible."
        },
        {
          "type": "list",
          "items": [
            "**Saga Pattern**: Manages distributed transactions using either choreography (event-driven) or orchestration (centralized controller).",
            "**Two-Phase Commit (2PC)**: Ensures atomicity but introduces blocking and is not commonly used in modern microservices.",
            "**Eventual Consistency**: Uses asynchronous messaging and retries to achieve consistency over time.",
            "**Outbox Pattern**: Ensures messages are stored and reliably published along with the main database operation.",
            "**Compensating Transactions**: In case of failure, performs actions to undo changes made by previous steps."
          ]
        }
      ]
    },
    {
      "id": "ms-12",
      "question": "What is the Saga Pattern, and when would you use it?",
      "answer": [
        {
          "type": "text",
          "content": "The Saga Pattern is a way to manage distributed transactions in microservices by breaking them into smaller, independent steps."
        },
        {
          "type": "list",
          "items": [
            "**Choreography-Based Saga**: Each service listens for events and triggers the next step without a central coordinator.",
            "**Orchestration-Based Saga**: A central orchestrator service manages and directs the transaction flow."
          ]
        },
        {
          "type": "text",
          "content": "Used when multiple services need to update data while maintaining consistency and rollback mechanisms."
        }
      ]
    },
    {
      "id": "ms-13",
      "question": "Explain Circuit Breaker Pattern and its importance.",
      "answer": [
        {
          "type": "text",
          "content": "The Circuit Breaker Pattern is used to prevent repeated failures by stopping calls to a failing service and providing fallback responses."
        },
        {
          "type": "list",
          "items": [
            "**Closed State**: Requests are passed through normally.",
            "**Open State**: After failures exceed a threshold, requests are blocked temporarily.",
            "**Half-Open State**: Some requests are allowed to test if the service has recovered."
          ]
        },
        {
          "type": "text",
          "content": "It improves system resilience and prevents cascading failures in microservices."
        }
      ]
    },
    {
      "id": "ms-14",
      "question": "How do you ensure security in a Microservices architecture?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Authentication & Authorization**: Use OAuth2, JWT, or API Gateway authentication.",
            "**Secure Communication**: Encrypt data in transit using TLS.",
            "**API Gateway Security**: Centralized authentication and rate limiting.",
            "**Service-to-Service Security**: Mutual TLS (mTLS) and API keys.",
            "**Logging & Monitoring**: Detect security threats using SIEM tools."
          ]
        }
      ]
    },
    {
      "id": "ms-15",
      "question": "What are the different ways of implementing Service Discovery?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Client-Side Discovery**: Services query a registry (e.g., Consul, Eureka) to find instances.",
            "**Server-Side Discovery**: API Gateway or Load Balancer routes requests dynamically.",
            "**DNS-Based Discovery**: Services resolve addresses via DNS (e.g., Kubernetes DNS)."
          ]
        }
      ]
    },
    {
      "id": "ms-16",
      "question": "What is eventual consistency in Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "Eventual consistency ensures that after a period of time, all services have consistent data, even if updates happen asynchronously."
        },
        {
          "type": "list",
          "items": [
            "**Event-Driven Architecture**: Services publish events to synchronize state.",
            "**Retries & Idempotency**: Ensures operations can be repeated without causing errors.",
            "**Compensating Transactions**: Rolls back incomplete operations to maintain consistency."
          ]
        }
      ]
    },
    {
      "id": "ms-17",
      "question": "How do you monitor Microservices?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Logging**: Use centralized logging (ELK Stack, Loki).",
            "**Metrics Collection**: Monitor system performance (Prometheus, Grafana).",
            "**Tracing**: Use distributed tracing (Jaeger, Zipkin) to track request flows.",
            "**Health Checks**: Implement endpoint checks (/health, /metrics) to detect failures."
          ]
        }
      ]
    },
    {
      "id": "ms-18",
      "question": "What are Distributed Tracing Tools, and why are they important?",
      "answer": [
        {
          "type": "text",
          "content": "Distributed tracing tools help track requests as they pass through multiple microservices."
        },
        {
          "type": "list",
          "items": [
            "**Jaeger**: Open-source tool for request tracing and latency monitoring.",
            "**Zipkin**: Traces requests across microservices and identifies performance bottlenecks.",
            "**OpenTelemetry**: Standardized instrumentation for tracing and metrics."
          ]
        },
        {
          "type": "text",
          "content": "They help diagnose slow response times and system failures."
        }
      ]
    },
    {
      "id": "ms-19",
      "question": "What is the CAP theorem, and how does it apply to Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "The CAP theorem states that in a distributed system, it is impossible to achieve **Consistency (C), Availability (A), and Partition Tolerance (P) simultaneously.**"
        },
        {
          "type": "list",
          "items": [
            "**CP (Consistency & Partition Tolerance)**: Prioritizes data correctness but may sacrifice availability.",
            "**AP (Availability & Partition Tolerance)**: Ensures uptime but may have stale data.",
            "**CA (Consistency & Availability)**: Only feasible without network partitions (not practical for microservices)."
          ]
        },
        {
          "type": "text",
          "content": "Microservices typically choose AP (Eventual Consistency) or CP (Strong Consistency) based on business needs."
        }
      ]
    },
    {
      "id": "ms-20",
      "question": "What are some best practices for deploying Microservices?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Use CI/CD Pipelines**: Automate deployments using Jenkins, GitHub Actions, or GitLab CI.",
            "**Containerization**: Deploy services using Docker and manage with Kubernetes.",
            "**Service Mesh**: Use Istio or Linkerd for traffic management and observability.",
            "**API Gateway**: Centralized request routing, authentication, and rate limiting.",
            "**Rolling Updates & Canary Deployments**: Minimize downtime and test changes safely."
          ]
        }
      ]
    },
    {
      "id": "ms-21",
      "question": "How do you scale Microservices in production?",
      "answer": [
        {
          "type": "text",
          "content": "Scaling microservices in production involves various strategies to ensure performance, reliability, and availability."
        },
        {
          "type": "list",
          "items": [
            "**Horizontal Scaling**: Deploy multiple instances of a microservice and distribute traffic using a load balancer.",
            "**Container Orchestration**: Use Kubernetes or Docker Swarm to manage containerized microservices efficiently.",
            "**Auto-scaling**: Automatically scale up or down based on CPU/memory usage (Kubernetes HPA, AWS Auto Scaling).",
            "**Load Balancing**: Use API Gateway or a dedicated load balancer (Nginx, Envoy) to distribute requests across instances.",
            "**Database Sharding**: Split databases into smaller parts for better performance.",
            "**Caching**: Use Redis, Memcached, or CDN to reduce database load and improve response time."
          ]
        }
      ]
    },
    {
      "id": "ms-22",
      "question": "How do you handle versioning in Microservices APIs?",
      "answer": [
        {
          "type": "text",
          "content": "API versioning ensures backward compatibility while introducing new features."
        },
        {
          "type": "list",
          "items": [
            "**URI Versioning**: Include version in the URL (e.g., `/api/v1/users`).",
            "**Header Versioning**: Pass API version in HTTP headers (e.g., `Accept: application/vnd.company.v1+json`).",
            "**Query Parameter Versioning**: Pass version as a query parameter (`/users?version=1`).",
            "**Content Negotiation**: Clients request specific versions via `Accept` headers.",
            "**Feature Toggles**: Gradually enable new features instead of strict versioning."
          ]
        }
      ]
    },
    {
      "id": "ms-23",
      "question": "What is Kubernetes, and why is it used in Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "Kubernetes is an open-source container orchestration platform used to automate deployment, scaling, and management of containerized applications."
        },
        {
          "type": "list",
          "items": [
            "**Automated Deployment and Scaling**: Kubernetes manages replicas of microservices and scales them based on demand.",
            "**Self-healing**: Restarts failed containers and reschedules them if necessary.",
            "**Service Discovery and Load Balancing**: Automatically distributes traffic between microservice instances.",
            "**Rolling Updates**: Allows seamless updates without downtime.",
            "**Resource Management**: Efficiently allocates CPU and memory to containers."
          ]
        }
      ]
    },
    {
      "id": "ms-24",
      "question": "Explain Event-Driven Microservices and their benefits.",
      "answer": [
        {
          "type": "text",
          "content": "Event-driven microservices communicate asynchronously by emitting and responding to events, rather than making direct API calls."
        },
        {
          "type": "list",
          "items": [
            "**Decoupling**: Services are independent and do not need to know about each other.",
            "**Scalability**: Improves performance by processing events asynchronously.",
            "**Fault Tolerance**: A failed service does not block the entire system.",
            "**Better Performance**: Reduces request-response latency in real-time applications.",
            "**Common Tools**: Kafka, RabbitMQ, AWS SNS/SQS for event-driven architecture."
          ]
        }
      ]
    },
    {
      "id": "ms-25",
      "question": "What is gRPC, and how is it different from REST?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**gRPC**: A high-performance, RPC-based protocol using HTTP/2 and Protocol Buffers.",
            "**REST**: A resource-based architecture using HTTP and JSON/XML."
          ]
        },
        {
          "type": "text",
          "content": "Key differences:"
        },
        {
          "type": "list",
          "items": [
            "gRPC uses **binary serialization (Protocol Buffers)** for efficient data transfer, whereas REST uses **text-based JSON**.",
            "gRPC supports **bidirectional streaming**, unlike REST, which follows a request-response model.",
            "gRPC is more efficient over low-bandwidth connections due to its binary format."
          ]
        }
      ]
    },
    {
      "id": "ms-26",
      "question": "How do you handle logging and debugging in a distributed Microservices system?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Centralized Logging**: Use ELK Stack (Elasticsearch, Logstash, Kibana) or Fluentd for aggregating logs.",
            "**Distributed Tracing**: Use tools like Jaeger, Zipkin to trace request flow across services.",
            "**Structured Logging**: Use JSON-based logs for easier parsing.",
            "**Error Monitoring**: Implement tools like Sentry or Prometheus to detect failures in real-time."
          ]
        }
      ]
    },
    {
      "id": "ms-27",
      "question": "Explain CQRS (Command Query Responsibility Segregation) in Microservices.",
      "answer": [
        {
          "type": "text",
          "content": "CQRS separates read and write operations into different models to optimize performance and scalability."
        },
        {
          "type": "list",
          "items": [
            "**Command Model**: Handles write operations (Create, Update, Delete).",
            "**Query Model**: Handles read operations separately.",
            "**Benefits**: Improves performance, allows separate scaling, and enhances security by restricting write access."
          ]
        }
      ]
    },
    {
      "id": "ms-28",
      "question": "What is Sidecar Pattern in Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "The Sidecar pattern runs an auxiliary process alongside the main microservice to handle cross-cutting concerns such as logging, monitoring, and security."
        },
        {
          "type": "list",
          "items": [
            "**Use Cases**: Service mesh (Istio), logging agents (Fluentd), security proxies.",
            "**Benefits**: Enhances modularity, isolates responsibilities from the main service."
          ]
        }
      ]
    },
    {
      "id": "ms-29",
      "question": "What is a Strangler Pattern in Microservices?",
      "answer": [
        {
          "type": "text",
          "content": "The Strangler Pattern gradually replaces a monolithic system by incrementally migrating functionalities to microservices."
        },
        {
          "type": "list",
          "items": [
            "**Incremental Migration**: New features are implemented as microservices while old components are phased out.",
            "**Reduces Risk**: Avoids full rewrites by enabling a step-by-step transition."
          ]
        }
      ]
    },
    {
      "id": "ms-30",
      "question": "How do you test Microservices? (Unit, Integration, Contract Testing)",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Unit Testing**: Testing individual service components using frameworks like JUnit (Java) or Goâ€™s testing package.",
            "**Integration Testing**: Ensuring services work together correctly using tools like Postman, REST-assured.",
            "**Contract Testing**: Verifying API contracts between services using Pact.",
            "**End-to-End Testing**: Simulating real-world scenarios using Selenium, Cypress.",
            "**Performance Testing**: Load testing services using JMeter or k6."
          ]
        }
      ]
    }
  ],
  "message-broker-basics": [
    {
      "id": "mq-1",
      "question": "What is RabbitMQ, and how does it work?",
      "answer": [
        {
          "type": "text",
          "content": "RabbitMQ is an open-source message broker that enables asynchronous communication between services by sending messages via queues."
        },
        {
          "type": "list",
          "items": [
            "**Producer**: Sends messages to an exchange.",
            "**Exchange**: Routes messages to the appropriate queue based on bindings.",
            "**Queue**: Stores messages until they are consumed.",
            "**Consumer**: Receives and processes messages from the queue."
          ]
        }
      ]
    },
    {
      "id": "mq-2",
      "question": "What are the types of exchanges in RabbitMQ?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Direct Exchange**: Routes messages based on an exact match of the routing key.",
            "**Fanout Exchange**: Broadcasts messages to all bound queues, ignoring routing keys.",
            "**Topic Exchange**: Uses pattern-based routing (e.g., `logs.*` for all log messages).",
            "**Headers Exchange**: Routes messages based on header attributes instead of routing keys."
          ]
        }
      ]
    },
    {
      "id": "mq-3",
      "question": "How do you implement a basic producer and consumer in RabbitMQ using Python?",
      "answer": [
        {
          "type": "code",
          "language": "python",
          "content": "import pika\n\n# Establish connection\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\n\n# Declare a queue\nchannel.queue_declare(queue='hello')\n\n# Publish message\nchannel.basic_publish(exchange='', routing_key='hello', body='Hello RabbitMQ!')\nprint(\" [x] Sent 'Hello RabbitMQ!'\")\nconnection.close()"
        },
        {
          "type": "code",
          "language": "python",
          "content": "import pika\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\n\n# Declare queue\nchannel.queue_declare(queue='hello')\n\n# Callback function\ndef callback(ch, method, properties, body):\n    print(f\" [x] Received {body.decode()}\")\n\n# Start consuming\nchannel.basic_consume(queue='hello', on_message_callback=callback, auto_ack=True)\nprint(' [*] Waiting for messages. To exit, press CTRL+C')\nchannel.start_consuming()"
        }
      ]
    },
    {
      "id": "mq-4",
      "question": "What are some real-world use cases for RabbitMQ?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Event-Driven Architecture**: Decouple microservices by using RabbitMQ for event-based communication.",
            "**Task Queueing**: Distribute background jobs to multiple workers (e.g., processing images, sending emails).",
            "**Log Aggregation**: Collect logs from multiple services and route them to the appropriate storage or monitoring tools.",
            "**Rate Limiting**: Control API request rates by enqueueing requests and processing them at a controlled rate.",
            "**IoT Communication**: Send and receive messages from IoT devices in a scalable way."
          ]
        }
      ]
    }
  ],
  "message-broker-rabbitmq": [
    {
      "id": "cps-2",
      "question": "How to send JWT tokens along with messages in RabbitMQ and validate them in the consumer?",
      "answer": [
        {
          "type": "text",
          "content": "To send JWT tokens along with messages in RabbitMQ, include the token in the message headers. The consumer extracts and validates the token before processing the message."
        },
        {
          "type": "text",
          "content": "**Producer Implementation:** Send JWT in message headers."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"github.com/streadway/amqp\"\n)\n\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\t// Example JWT token\n\ttoken := \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\"user_task_queue\", true, false, false, false, nil)\n\tfailOnError(err, \"Failed to declare queue\")\n\n\tbody := \"Process user data\"\n\terr = ch.Publish(\n\t\t\"\",\n\t\tq.Name,\n\t\tfalse,\n\t\tfalse,\n\t\tamqp.Publishing{\n\t\t\tContentType: \"text/plain\",\n\t\t\tBody: []byte(body),\n\t\t\tHeaders: amqp.Table{\"Authorization\": token},\n\t\t},\n\t)\n\tfailOnError(err, \"Failed to publish message\")\n\n\tfmt.Printf(\" [x] Sent: %s with JWT\\n\", body)\n}"
        },
        {
          "type": "text",
          "content": "**Consumer Implementation:** Extract and validate JWT before processing."
        },
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/streadway/amqp\"\n)\n\nvar secretKey = []byte(\"your-secret-key\")\n\nfunc verifyJWT(tokenString string) (bool, error) {\n\ttoken, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {\n\t\treturn secretKey, nil\n\t})\n\tif err != nil || !token.Valid {\n\t\treturn false, fmt.Errorf(\"invalid token\")\n\t}\n\treturn true, nil\n}\n\nfunc failOnError(err error, msg string) {\n\tif err != nil {\n\t\tlog.Fatalf(\"%s: %s\", msg, err)\n\t}\n}\n\nfunc main() {\n\tconn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n\tfailOnError(err, \"Failed to connect to RabbitMQ\")\n\tdefer conn.Close()\n\n\tch, err := conn.Channel()\n\tfailOnError(err, \"Failed to open a channel\")\n\tdefer ch.Close()\n\n\tq, err := ch.QueueDeclare(\"user_task_queue\", true, false, false, false, nil)\n\tfailOnError(err, \"Failed to declare queue\")\n\n\tmsgs, err := ch.Consume(q.Name, \"\", true, false, false, false, nil)\n\tfailOnError(err, \"Failed to register consumer\")\n\n\tfmt.Println(\" [*] Waiting for messages...\")\n\n\tfor msg := range msgs {\n\t\ttoken, ok := msg.Headers[\"Authorization\"].(string)\n\t\tif !ok {\n\t\t\tfmt.Println(\" [x] No valid JWT token found\")\n\t\t\tcontinue\n\t\t}\n\n\t\tvalid, err := verifyJWT(token)\n\t\tif !valid {\n\t\t\tfmt.Printf(\" [x] Invalid JWT: %s\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tfmt.Printf(\" [âœ“] Valid JWT. Processing message: %s\\n\", msg.Body)\n\t}\n}"
        },
        {
          "type": "list",
          "content": [
            "**Security Enhancements:**",
            "Use HS256 or RS256 encryption for JWT.",
            "Set an expiration time (`exp`) on the JWT to prevent misuse.",
            "Secure RabbitMQ connections with authentication.",
            "Use message TTL (`x-message-ttl`) to auto-expire sensitive messages."
          ]
        }
      ]
    },
    {
      "id": "mb-1",
      "question": "What is a Message Broker, and why is it used?",
      "answer": [
        {
          "type": "text",
          "content": "A message broker is a middleware component that facilitates communication between services by translating and routing messages between them."
        },
        {
          "type": "list",
          "items": [
            "**Decoupling**: Enables asynchronous communication between microservices.",
            "**Scalability**: Allows services to scale independently without direct coupling.",
            "**Reliability**: Ensures message persistence and delivery guarantees.",
            "**Flexibility**: Supports various messaging patterns like Pub/Sub and Queue-based communication."
          ]
        }
      ]
    },
    {
      "id": "mb-2",
      "question": "What is the difference between a Message Queue and Publish-Subscribe model?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Message Queue**: Messages are sent to a queue where a single consumer processes each message.",
            "**Publish-Subscribe**: Messages are published to a topic where multiple subscribers can receive the message."
          ]
        }
      ]
    },
    {
      "id": "mb-3",
      "question": "How does RabbitMQ handle message persistence?",
      "answer": [
        {
          "type": "text",
          "content": "RabbitMQ allows message persistence by marking queues and messages as 'durable' so they are not lost in case of a broker restart."
        },
        {
          "type": "list",
          "items": [
            "Queues must be declared as **durable**.",
            "Messages must be marked as **persistent**.",
            "RabbitMQ writes messages to disk to ensure durability."
          ]
        },
        {
          "type": "code",
          "language": "python",
          "content": "channel.queue_declare(queue='task_queue', durable=True)\nchannel.basic_publish(exchange='', routing_key='task_queue', body=message, properties=pika.BasicProperties(delivery_mode=2))"
        }
      ]
    },
    {
      "id": "mb-4",
      "question": "What are partitions in Apache Kafka, and how do they help in scalability?",
      "answer": [
        {
          "type": "text",
          "content": "Kafka partitions allow a topic to be divided into smaller segments stored across multiple brokers, enabling parallel processing and higher throughput."
        },
        {
          "type": "list",
          "items": [
            "**Parallel Processing**: Each partition is consumed by a separate consumer in a consumer group.",
            "**Fault Tolerance**: Partitions can be replicated across brokers for redundancy.",
            "**Load Balancing**: Kafka distributes partitions among brokers, preventing overload."
          ]
        }
      ]
    },
    {
      "id": "mb-5",
      "question": "Write a simple producer and consumer using Kafka in Golang.",
      "answer": [
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"github.com/confluentinc/confluent-kafka-go/kafka\"\n)\n\nfunc main() {\n\t// Producer\n\tproducer, err := kafka.NewProducer(&kafka.ConfigMap{\"bootstrap.servers\": \"localhost:9092\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tproducer.Produce(&kafka.Message{TopicPartition: kafka.TopicPartition{Topic: &\"my-topic\", Partition: kafka.PartitionAny}, Value: []byte(\"Hello Kafka\")}, nil)\n\tproducer.Flush(1000)\n\tproducer.Close()\n\n\t// Consumer\n\tconsumer, err := kafka.NewConsumer(&kafka.ConfigMap{\n\t\t\"bootstrap.servers\": \"localhost:9092\",\n\t\t\"group.id\": \"my-group\",\n\t\t\"auto.offset.reset\": \"earliest\",\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tconsumer.Subscribe(\"my-topic\", nil)\n\tfor {\n\t\tmsg, err := consumer.ReadMessage(-1)\n\t\tif err == nil {\n\t\t\tfmt.Printf(\"Received: %s\\n\", string(msg.Value))\n\t\t}\n\t}\n\tconsumer.Close()\n}"
        }
      ]
    },
    {
      "id": "mb-6",
      "question": "What are some key differences between RabbitMQ and Apache Kafka?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**RabbitMQ**: Uses a queue-based system with message acknowledgments for transactional messaging.",
            "**Kafka**: Uses a distributed log-based architecture optimized for high-throughput event streaming.",
            "**Message Durability**: Kafka stores messages for a configured retention period, whereas RabbitMQ deletes messages after they are consumed unless set to be persistent.",
            "**Use Cases**: RabbitMQ is used for traditional message queues, while Kafka is ideal for real-time data streams and event-driven architectures."
          ]
        }
      ]
    },
    {
      "id": "mb-7",
      "question": "What is message retention in Kafka, and how does it work?",
      "answer": [
        {
          "type": "text",
          "content": "Kafka retains messages for a specified time period, allowing consumers to reprocess data if needed."
        },
        {
          "type": "list",
          "items": [
            "Retention period is defined using `log.retention.hours` in the Kafka configuration.",
            "Messages are stored in partitions and remain available even after consumption.",
            "Kafka provides 'offsets' to track consumer progress."
          ]
        },
        {
          "type": "code",
          "language": "properties",
          "content": "log.retention.hours=168  # Retain messages for 7 days"
        }
      ]
    }
  ],
  "message-broker-advanced": [
    {
      "id": "mq-5",
      "question": "What are advanced RabbitMQ messaging patterns?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Work Queues**: Distribute workload across multiple workers to ensure load balancing.",
            "**Publish/Subscribe (Fanout Exchange)**: Broadcast messages to multiple consumers simultaneously.",
            "**RPC (Remote Procedure Call) with RabbitMQ**: Implement request-response patterns for microservices.",
            "**Dead-Letter Queues (DLQ)**: Capture failed messages for analysis and retry mechanisms.",
            "**Delayed Messages**: Schedule message delivery using RabbitMQ plugins.",
            "**High Availability (HA) Queues**: Ensure resilience by mirroring queues across multiple nodes in a RabbitMQ cluster."
          ]
        }
      ]
    },
    {
      "id": "mq-6",
      "question": "How do you publish a message to RabbitMQ in Golang?",
      "answer": [
        {
          "type": "code",
          "language": "go",
          "content": "package main\n\nimport (\n    \"log\"\n    \"github.com/streadway/amqp\"\n)\n\nfunc main() {\n    conn, err := amqp.Dial(\"amqp://guest:guest@localhost:5672/\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer conn.Close()\n\n    ch, err := conn.Channel()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer ch.Close()\n\n    q, err := ch.QueueDeclare(\"task_queue\", true, false, false, false, nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    body := \"Hello RabbitMQ!\"\n    err = ch.Publish(\"\", q.Name, false, false, \n        amqp.Publishing{\n            DeliveryMode: amqp.Persistent,\n            ContentType:  \"text/plain\",\n            Body:         []byte(body),\n        })\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(\"Message sent!\")\n}"
        }
      ]
    },
    {
      "id": "mq-7",
      "question": "How do you consume messages from RabbitMQ in C#?",
      "answer": [
        {
          "type": "code",
          "language": "csharp",
          "content": "using System;\nusing RabbitMQ.Client;\nusing RabbitMQ.Client.Events;\nusing System.Text;\n\nclass Receive {\n    public static void Main() {\n        var factory = new ConnectionFactory() { HostName = \"localhost\" };\n        using var connection = factory.CreateConnection();\n        using var channel = connection.CreateModel();\n        \n        channel.QueueDeclare(queue: \"task_queue\", durable: true, exclusive: false, autoDelete: false, arguments: null);\n\n        var consumer = new EventingBasicConsumer(channel);\n        consumer.Received += (model, ea) => {\n            var body = ea.Body.ToArray();\n            var message = Encoding.UTF8.GetString(body);\n            Console.WriteLine(\"Received {0}\", message);\n        };\n\n        channel.BasicConsume(queue: \"task_queue\", autoAck: true, consumer: consumer);\n        Console.WriteLine(\"Waiting for messages...\");\n        Console.ReadLine();\n    }\n}"
        }
      ]
    },
    {
      "id": "mq-8",
      "question": "What are Dead-Letter Queues (DLQ) in RabbitMQ, and why are they useful?",
      "answer": [
        {
          "type": "text",
          "content": "A Dead-Letter Queue (DLQ) is a queue where messages that cannot be processed successfully are moved instead of being lost."
        },
        {
          "type": "list",
          "items": [
            "**Use Cases:**",
            "Messages that exceed retry limits can be stored for debugging.",
            "Unroutable messages that do not match any binding keys.",
            "Handling expired messages that exceed their TTL (Time-to-Live)."
          ]
        },
        {
          "type": "code",
          "language": "go",
          "content": "args := amqp.Table{\"x-dead-letter-exchange\": \"dlx-exchange\"}\nch.QueueDeclare(\"task_queue\", true, false, false, false, args)"
        }
      ]
    },
    {
      "id": "mq-9",
      "question": "How can you scale RabbitMQ consumers in Golang?",
      "answer": [
        {
          "type": "list",
          "items": [
            "**Multiple Consumers**: Run multiple instances of the consumer application.",
            "**Prefetch Count (QoS settings)**: Limit the number of unacknowledged messages per consumer to prevent overload.",
            "**Load Balancing**: RabbitMQ automatically distributes messages across consumers.",
            "**Clustered Deployment**: Deploy RabbitMQ nodes in a cluster to distribute queues across multiple servers."
          ]
        },
        {
          "type": "code",
          "language": "go",
          "content": "ch.Qos(1, 0, false) // Prefetch count of 1 for fair load balancing"
        }
      ]
    },

    {
      "id": "mq-01",
      "question": "What is QueueDeclare in RabbitMQ?",
      "answer": [
        {
          "type": "text",
          "content": "QueueDeclare is a function that creates a queue if it does not exist. It ensures that messages can be sent and received reliably."
        },
        {
          "type": "code",
          "content": "q, err := ch.QueueDeclare(\n    \"task_queue\", true, false, false, false, nil\n)",
          "language": "go"
        }
      ]
    },
    {
      "id": "mq-02",
      "question": "What are the QueueDeclare parameters and their impact?",
      "answer": [
        {
          "type": "table",
          "columns": ["Parameter", "Type", "Description"],
          "rows": [
            [
              "name",
              "String",
              "Queue name (if empty, RabbitMQ assigns a random name)."
            ],
            [
              "durable",
              "Bool",
              "If true, the queue persists after a RabbitMQ restart."
            ],
            [
              "autoDelete",
              "Bool",
              "If true, queue is deleted when the last consumer disconnects."
            ],
            [
              "exclusive",
              "Bool",
              "If true, the queue is only for the current connection."
            ],
            [
              "noWait",
              "Bool",
              "If true, does not wait for a response from RabbitMQ."
            ],
            [
              "arguments",
              "Map",
              "Custom queue settings like TTL, DLQ, priority."
            ]
          ]
        }
      ]
    },
    {
      "id": "mq-03",
      "question": "How do you configure a Dead-Letter Queue (DLQ) in RabbitMQ?",
      "answer": [
        {
          "type": "text",
          "content": "Dead-Letter Queues (DLQs) store messages that cannot be processed successfully."
        },
        {
          "type": "code",
          "content": "args := amqp.Table{\n    \"x-dead-letter-exchange\": \"dlx-exchange\",\n}\nq, err := ch.QueueDeclare(\"task_queue\", true, false, false, false, args)",
          "language": "go"
        }
      ]
    }
  ]
}
