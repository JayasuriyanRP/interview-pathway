{
    "questions": [
        {
            "id": "3d2d36f3-f178-4c9f-8d43-0a16d7bd6343",
            "question": "What is the purpose of the JavaScript spread operator (...)?",
            "answer": "```markdown\nThe JavaScript spread operator (`...`) is used to expand elements of an iterable (like an array, string, or object) into individual elements. It allows for more concise and flexible handling of data structures. Here are some common purposes of the spread operator:\n\n1. **Copying Arrays or Objects**:\n   The spread operator can create shallow copies of arrays or objects without modifying the original data.\n   ```javascript\n   const arr1 = [1, 2, 3];\n   const arr2 = [...arr1]; // Copy of arr1\n   console.log(arr2); // [1, 2, 3]\n   ```\n\n2. **Merging Arrays or Objects**:\n   It can merge multiple arrays or objects into one.\n   ```javascript\n   const arr1 = [1, 2];\n   const arr2 = [3, 4];\n   const mergedArray = [...arr1, ...arr2];\n   console.log(mergedArray); // [1, 2, 3, 4]\n   ```\n\n   ```javascript\n   const obj1 = { a: 1, b: 2 };\n   const obj2 = { c: 3, d: 4 };\n   const mergedObject = { ...obj1, ...obj2 };\n   console.log(mergedObject); // { a: 1, b: 2, c: 3, d: 4 }\n   ```\n\n3. **Passing Arguments to Functions**:\n   The spread operator can expand an array into individual arguments for a function.\n   ```javascript\n   const numbers = [1, 2, 3];\n   const sum = (a, b, c) => a + b + c;\n   console.log(sum(...numbers)); // 6\n   ```\n\n4. **Converting Iterables to Arrays**:\n   It can convert iterable objects (like strings or NodeLists) into arrays.\n   ```javascript\n   const str = \"hello\";\n   const chars = [...str];\n   console.log(chars); // ['h', 'e', 'l', 'l', 'o']\n   ```\n\n5. **Adding or Updating Properties in Objects**:\n   The spread operator can be used to add or update properties in objects immutably.\n   ```javascript\n   const obj = { a: 1, b: 2 };\n   const updatedObj = { ...obj, b: 3, c: 4 };\n   console.log(updatedObj); // { a: 1, b: 3, c: 4 }\n   ```\n\nThe spread operator is a powerful feature in JavaScript that simplifies working with arrays, objects, and other iterable data structures.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553237Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "949254bb-8a39-4422-81a0-e754a795ddc0",
            "question": "What is JavaScript and how is it different from Java?",
            "answer": "```markdown\nJavaScript is a lightweight, interpreted programming language primarily used to create dynamic and interactive content on websites. It is a client-side scripting language that runs in the browser and is widely used for tasks such as form validation, animations, and handling user interactions.\n\nJavaScript is different from Java in several ways:\n\n1. **Purpose**: Java is a general-purpose, object-oriented programming language used for building standalone applications, server-side applications, and mobile apps. JavaScript, on the other hand, is mainly used for enhancing the interactivity of web pages.\n\n2. **Execution Environment**: Java code is compiled into bytecode and runs on the Java Virtual Machine (JVM), making it platform-independent. JavaScript is interpreted and executed directly in the browser (or on the server using environments like Node.js).\n\n3. **Syntax and Complexity**: While both share some syntax similarities (like C-style syntax), Java is a statically-typed language requiring explicit declaration of data types, whereas JavaScript is dynamically-typed and more flexible.\n\n4. **Use Cases**: Java is used for enterprise-level applications, Android development, and backend systems. JavaScript is primarily used for front-end development, though it can also be used on the backend with frameworks like Node.js.\n\nDespite the similarity in their names, Java and JavaScript are distinct languages with different purposes and capabilities.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553035Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "3c14c8da-7ed3-4a0a-b8ed-260bfac7297f",
            "question": "What are the different data types in JavaScript?",
            "answer": "```markdown\nJavaScript has the following data types:\n\n### 1. Primitive Data Types:\n   - **String**: Represents textual data. Example: `\"Hello, World!\"`\n   - **Number**: Represents numeric values (both integers and floating-point numbers). Example: `42`, `3.14`\n   - **BigInt**: Represents integers with arbitrary precision. Example: `123456789012345678901234567890n`\n   - **Boolean**: Represents logical values: `true` or `false`.\n   - **Undefined**: Represents a variable that has been declared but not assigned a value. Example: `let x;`\n   - **Null**: Represents an intentional absence of any object value. Example: `let y = null;`\n   - **Symbol**: Represents a unique and immutable value, often used as object property keys. Example: `Symbol('description')`\n\n### 2. Non-Primitive (Reference) Data Type:\n   - **Object**: Represents collections of key-value pairs or more complex entities. Example:\n     ```javascript\n     let person = {\n       name: \"John\",\n       age: 30\n     };\n     ```\n\n### Special Notes:\n- Arrays, functions, and dates are technically objects in JavaScript.\n- JavaScript is dynamically typed, meaning variables can hold values of any data type and can change types during execution.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553063Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "6213cfbe-bc19-4777-b73d-f3bbc500761c",
            "question": "What is the difference between var, let, and const in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `var`, `let`, and `const` are used to declare variables, but they have significant differences in terms of scope, hoisting, and mutability:\n\n1. **`var`**:\n   - **Scope**: `var` is function-scoped, meaning it is accessible within the function where it is declared. If declared outside a function, it becomes globally scoped.\n   - **Hoisting**: Variables declared with `var` are hoisted to the top of their scope and initialized with `undefined`. This means you can use the variable before its declaration, but its value will be `undefined` until the assignment.\n   - **Re-declaration**: You can re-declare a `var` variable in the same scope without errors.\n   - **Example**:\n     ```javascript\n     console.log(x); // undefined (hoisted)\n     var x = 10;\n     console.log(x); // 10\n     ```\n\n2. **`let`**:\n   - **Scope**: `let` is block-scoped, meaning it is only accessible within the block (enclosed by `{}`) where it is declared.\n   - **Hoisting**: Variables declared with `let` are hoisted but are not initialized. Accessing them before declaration results in a `ReferenceError`.\n   - **Re-declaration**: You cannot re-declare a `let` variable in the same scope.\n   - **Example**:\n     ```javascript\n     {\n       let y = 20;\n       console.log(y); // 20\n     }\n     // console.log(y); // ReferenceError: y is not defined\n     ```\n\n3. **`const`**:\n   - **Scope**: Like `let`, `const` is block-scoped.\n   - **Hoisting**: Variables declared with `const` are hoisted but are not initialized. Accessing them before declaration results in a `ReferenceError`.\n   - **Mutability**: A `const` variable must be initialized at the time of declaration and cannot be reassigned. However, if the variable holds an object or array, the contents of the object or array can be modified.\n   - **Re-declaration**: You cannot re-declare a `const` variable in the same scope.\n   - **Example**:\n     ```javascript\n     const z = 30;\n     // z = 40; // TypeError: Assignment to constant variable\n     const arr = [1, 2, 3];\n     arr.push(4); // Allowed\n     console.log(arr); // [1, 2, 3, 4]\n     ```\n\n**Summary**:\n- Use `var` sparingly due to its function scope and potential for bugs.\n- Use `let` for variables that will be reassigned.\n- Use `const` for variables that should not be reassigned, ensuring immutability for primitive values.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553073Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "61668223-26a7-40e5-bbe6-9873d0a54425",
            "question": "What is the purpose of the 'use strict' directive in JavaScript?",
            "answer": "```markdown\nThe `'use strict'` directive in JavaScript is used to enable strict mode, which enforces a stricter set of rules for writing JavaScript code. It helps developers write cleaner and more secure code by catching common coding mistakes and preventing the use of certain unsafe features. Strict mode can be applied globally or to individual functions.\n\n### Key purposes of `'use strict'`:\n1. **Eliminates silent errors**: Converts silent errors into exceptions, making them easier to detect and debug.\n2. **Prevents accidental global variables**: Variables must be explicitly declared using `var`, `let`, or `const`. Assigning a value to an undeclared variable throws an error.\n3. **Disallows duplicate parameter names**: Function parameters cannot have duplicate names, which avoids ambiguity.\n4. **Restricts use of `this`**: In strict mode, `this` in a function defaults to `undefined` instead of the global object, reducing unintended behavior.\n5. **Prohibits certain syntax**: Some features, like `with` statements, are disallowed in strict mode as they can lead to unpredictable behavior.\n\n### Example:\n```javascript\n'use strict';\n\nfunction example() {\n  undeclaredVariable = 10; // Throws an error because the variable is not declared\n}\n\nexample();\n```\n\nUsing `'use strict'` is a good practice, especially in modern JavaScript development, as it promotes better coding standards and helps avoid potential bugs.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553086Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "34977d20-1b00-48d4-afc2-df38c814bf70",
            "question": "What are JavaScript closures and how do they work?",
            "answer": "```markdown\n### What are JavaScript Closures and How Do They Work?\n\nA **closure** in JavaScript is a feature where an inner function has access to the variables and scope of its outer function, even after the outer function has finished executing. Closures allow functions to \"remember\" the environment in which they were created.\n\n#### How Closures Work:\n1. **Scope Chain**: When a function is defined, it retains access to the variables in its outer scope. This is because of the lexical scoping rules in JavaScript.\n2. **Preservation of Variables**: Even if the outer function has returned, the inner function still holds a reference to the variables in the outer function's scope.\n3. **Encapsulation**: Closures can be used to create private variables and methods, as they are not directly accessible from outside the function.\n\n#### Example:\n```javascript\nfunction outerFunction(outerVariable) {\n  return function innerFunction(innerVariable) {\n    console.log(`Outer Variable: ${outerVariable}`);\n    console.log(`Inner Variable: ${innerVariable}`);\n  };\n}\n\nconst newFunction = outerFunction(\"outside\");\nnewFunction(\"inside\");\n// Output:\n// Outer Variable: outside\n// Inner Variable: inside\n```\n\nIn this example:\n- `outerFunction` creates a variable `outerVariable` and returns `innerFunction`.\n- `innerFunction` is a closure because it \"remembers\" the `outerVariable` from its parent scope, even after `outerFunction` has executed.\n\n#### Use Cases of Closures:\n1. **Data Privacy**: Create private variables that cannot be accessed directly.\n   ```javascript\n   function counter() {\n     let count = 0;\n     return function() {\n       count++;\n       return count;\n     };\n   }\n\n   const increment = counter();\n   console.log(increment()); // 1\n   console.log(increment()); // 2\n   ```\n2. **Partial Application**: Pre-configure a function with some arguments.\n   ```javascript\n   function multiply(a) {\n     return function(b) {\n       return a * b;\n     };\n   }\n\n   const double = multiply(2);\n   console.log(double(5)); // 10\n   ```\n3. **Event Handlers**: Maintain state in asynchronous callbacks.\n\nClosures are a powerful concept in JavaScript, enabling flexibility and control over function behavior and variable scope.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553096Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "08d0bded-aa1d-45a0-b8d7-c89f8c030f77",
            "question": "What is the difference between == and === in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `==` and `===` are comparison operators, but they work differently:\n\n1. **`==` (Equality Operator)**:\n   - Compares two values for equality after performing type conversion if necessary.\n   - If the values are of different types, JavaScript attempts to convert them to the same type before comparing.\n   - Example:\n     ```javascript\n     console.log(5 == '5'); // true (type coercion happens)\n     ```\n\n2. **`===` (Strict Equality Operator)**:\n   - Compares two values for equality without performing type conversion.\n   - Both the value and the type must be the same for it to return `true`.\n   - Example:\n     ```javascript\n     console.log(5 === '5'); // false (no type coercion, types are different)\n     ```\n\n**Key Difference**: `==` allows type coercion, while `===` does not. It is generally recommended to use `===` to avoid unexpected behavior caused by type conversion.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553107Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "886fca09-5847-4022-a99e-957a0a6a19b6",
            "question": "What is the event loop in JavaScript and how does it work?",
            "answer": "```markdown\n### What is the Event Loop in JavaScript and How Does It Work?\n\nThe **event loop** is a fundamental concept in JavaScript that enables asynchronous programming. It is responsible for handling and coordinating the execution of multiple pieces of code, such as callbacks, promises, and other asynchronous operations, while ensuring that JavaScript's single-threaded nature is maintained.\n\n#### How the Event Loop Works:\n\n1. **Call Stack**:\n   - JavaScript uses a call stack to manage the execution of functions. When a function is invoked, it is pushed onto the call stack. Once the function execution is complete, it is popped off the stack.\n   - The call stack operates on a \"last in, first out\" (LIFO) principle.\n\n2. **Web APIs / Background Tasks**:\n   - When an asynchronous operation (e.g., `setTimeout`, HTTP request, or DOM event listener) is initiated, it is delegated to the browser's Web APIs or Node.js's background thread.\n   - These APIs handle the operation independently of the main thread.\n\n3. **Callback Queue (or Task Queue)**:\n   - Once an asynchronous operation is completed, its associated callback function is placed in the callback queue (or task queue).\n   - Examples of tasks in the callback queue include `setTimeout` callbacks, DOM events, and other asynchronous tasks.\n\n4. **Microtask Queue**:\n   - In addition to the callback queue, there is a microtask queue, which has higher priority than the callback queue.\n   - Microtasks include callbacks from Promises (e.g., `.then()` or `catch()`), `MutationObserver`, and `queueMicrotask()`.\n\n5. **Event Loop**:\n   - The event loop continuously checks the call stack to see if it is empty.\n   - If the call stack is empty, the event loop processes tasks from the microtask queue first. Once the microtask queue is empty, it moves on to the callback queue.\n   - This ensures that microtasks are executed before any other tasks in the callback queue.\n\n#### Key Points:\n- JavaScript is single-threaded, meaning it can execute only one task at a time.\n- The event loop ensures that asynchronous operations do not block the main thread and are executed in the correct order.\n- Microtasks have higher priority than tasks in the callback queue, which is why `Promise` callbacks are executed before `setTimeout` callbacks, even if both are queued at the same time.\n\n#### Example:\n\n```javascript\nconsole.log('Start');\n\nsetTimeout(() => {\n  console.log('Timeout callback');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Promise callback');\n});\n\nconsole.log('End');\n```\n\n**Output**:\n```\nStart\nEnd\nPromise callback\nTimeout callback\n```\n\n**Explanation**:\n1. `console.log('Start')` and `console.log('End')` are executed synchronously and logged immediately.\n2. The `setTimeout` callback is added to the callback queue.\n3. The `Promise` callback is added to the microtask queue.\n4. The event loop processes the microtask queue first, so the `Promise` callback is executed before the `setTimeout` callback.\n\nThe event loop is what makes JavaScript capable of handling asynchronous operations efficiently while maintaining its single-threaded nature.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553117Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "d45a2295-0d0f-4062-8a43-76049ff3b19b",
            "question": "What is the difference between synchronous and asynchronous programming in JavaScript?",
            "answer": "```markdown\nIn JavaScript, the difference between synchronous and asynchronous programming lies in how tasks are executed and handled:\n\n### Synchronous Programming\n- **Definition**: In synchronous programming, tasks are executed sequentially, one after the other. Each task must complete before the next one begins.\n- **Blocking**: A synchronous task blocks the execution of subsequent tasks until it finishes.\n- **Example**:\n  ```javascript\n  console.log(\"Task 1\");\n  console.log(\"Task 2\");\n  console.log(\"Task 3\");\n  ```\n  Output:\n  ```\n  Task 1\n  Task 2\n  Task 3\n  ```\n\n### Asynchronous Programming\n- **Definition**: In asynchronous programming, tasks can be executed independently of the main program flow. The program does not wait for a task to complete before moving on to the next one.\n- **Non-blocking**: Asynchronous tasks do not block the execution of other tasks. Instead, they are executed in the background, and their results are handled via callbacks, promises, or `async/await`.\n- **Example**:\n  ```javascript\n  console.log(\"Task 1\");\n  setTimeout(() => {\n    console.log(\"Task 2\");\n  }, 1000);\n  console.log(\"Task 3\");\n  ```\n  Output:\n  ```\n  Task 1\n  Task 3\n  Task 2\n  ```\n\n### Key Differences\n| Feature               | Synchronous                     | Asynchronous                     |\n|-----------------------|----------------------------------|-----------------------------------|\n| **Execution**         | Sequential                      | Non-sequential                   |\n| **Blocking**          | Blocks subsequent tasks         | Does not block subsequent tasks  |\n| **Use Case**          | Simple, dependent operations    | Time-consuming or I/O operations |\n| **Examples**          | Loops, arithmetic operations    | API calls, file reading          |\n\nAsynchronous programming is particularly useful in JavaScript for handling tasks like fetching data from a server or reading files, where waiting for the task to complete would otherwise block the execution of other code.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553126Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "91a524e0-06ef-42e4-b225-21c31a086079",
            "question": "What are JavaScript promises and how are they used?",
            "answer": "```markdown\n### JavaScript Promises\n\nA **JavaScript Promise** is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises are used to handle asynchronous operations in a more readable and manageable way compared to traditional callback functions.\n\nA Promise can be in one of three states:\n1. **Pending**: The initial state, neither fulfilled nor rejected.\n2. **Fulfilled**: The operation was completed successfully, and the promise has a resulting value.\n3. **Rejected**: The operation failed, and the promise has a reason for the failure (usually an error).\n\n#### Creating a Promise\nA Promise is created using the `Promise` constructor, which takes a function (executor) with two parameters: `resolve` and `reject`.\n\n```javascript\nconst myPromise = new Promise((resolve, reject) => {\n  const success = true; // Simulate success or failure\n\n  if (success) {\n    resolve(\"Operation was successful!\");\n  } else {\n    reject(\"Operation failed.\");\n  }\n});\n```\n\n#### Using Promises\nPromises are consumed using the `.then()`, `.catch()`, and `.finally()` methods:\n\n1. **`.then()`**: Executes when the promise is fulfilled and receives the resolved value.\n2. **`.catch()`**: Executes when the promise is rejected and receives the error reason.\n3. **`.finally()`**: Executes after the promise is settled (fulfilled or rejected), regardless of the outcome.\n\n```javascript\nmyPromise\n  .then((result) => {\n    console.log(result); // Logs: \"Operation was successful!\"\n  })\n  .catch((error) => {\n    console.error(error); // Logs: \"Operation failed.\" if rejected\n  })\n  .finally(() => {\n    console.log(\"Promise has been settled.\"); // Always runs\n  });\n```\n\n#### Chaining Promises\nPromises can be chained to handle multiple asynchronous operations in sequence. Each `.then()` returns a new promise, allowing further chaining.\n\n```javascript\nconst fetchData = new Promise((resolve, reject) => {\n  setTimeout(() => resolve(\"Data fetched\"), 1000);\n});\n\nfetchData\n  .then((data) => {\n    console.log(data); // Logs: \"Data fetched\"\n    return \"Processing data\";\n  })\n  .then((processedData) => {\n    console.log(processedData); // Logs: \"Processing data\"\n  })\n  .catch((error) => {\n    console.error(error);\n  });\n```\n\n#### Benefits of Promises\n- Avoids \"callback hell\" by providing a cleaner and more structured way to handle asynchronous code.\n- Makes error handling easier with `.catch()`.\n- Supports chaining for sequential asynchronous operations.\n\nPromises are a core feature of modern JavaScript and are widely used in APIs like `fetch` for handling HTTP requests.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553136Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "45e47c0c-3093-4703-b6c1-7489c37677ce",
            "question": "What is the purpose of the async/await syntax in JavaScript?",
            "answer": "```markdown\nThe `async/await` syntax in JavaScript is used to handle asynchronous operations in a more readable and synchronous-like manner. It is built on top of Promises and provides a cleaner way to work with asynchronous code compared to using `.then()` and `.catch()` chains.\n\n### Key Points:\n1. **`async` Function**: Declaring a function as `async` ensures that it always returns a Promise. Inside an `async` function, you can use the `await` keyword to pause the execution until a Promise is resolved or rejected.\n   \n2. **`await` Keyword**: The `await` keyword is used to wait for a Promise to resolve. It allows you to write asynchronous code that looks and behaves like synchronous code, making it easier to read and debug.\n\n3. **Error Handling**: You can use `try...catch` blocks with `async/await` to handle errors in a more straightforward way compared to chaining `.catch()` with Promises.\n\n### Example:\n```javascript\n// Example of async/await\nasync function fetchData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\n\nfetchData();\n```\n\n### Benefits:\n- Improves code readability and maintainability.\n- Reduces the complexity of chaining multiple `.then()` calls.\n- Makes asynchronous code easier to debug and reason about.\n\nIn summary, `async/await` simplifies working with asynchronous operations by providing a more intuitive and cleaner syntax.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553145Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "b36e1943-bb5b-44bc-8b87-1ef85add3d83",
            "question": "What is the DOM (Document Object Model) in JavaScript?",
            "answer": "```markdown\nThe **DOM (Document Object Model)** is a programming interface for web documents. It represents the structure of an HTML or XML document as a tree of objects, where each node corresponds to a part of the document (such as elements, attributes, or text).\n\nIn JavaScript, the DOM allows developers to interact with and manipulate the content, structure, and style of a webpage dynamically. For example, you can use the DOM to:\n\n- Access elements (e.g., `document.getElementById()` or `document.querySelector()`).\n- Modify content or attributes (e.g., `element.textContent` or `element.setAttribute()`).\n- Add or remove elements (e.g., `document.createElement()` or `element.remove()`).\n- Handle events (e.g., `element.addEventListener()`).\n\nThe DOM provides a way for JavaScript to make webpages interactive and responsive to user actions.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553154Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "f934a862-1ccc-4d58-9e62-840e02a9fa91",
            "question": "What is the difference between null and undefined in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `null` and `undefined` are both used to represent the absence of a value, but they are different in their usage and meaning:\n\n1. **`undefined`**:\n   - It means a variable has been declared but has not been assigned a value yet.\n   - It is the default value for uninitialized variables.\n   - Example:\n     ```javascript\n     let x;\n     console.log(x); // Output: undefined\n     ```\n\n2. **`null`**:\n   - It is an intentional absence of any object value.\n   - It is explicitly assigned to a variable to indicate that it has no value.\n   - Example:\n     ```javascript\n     let y = null;\n     console.log(y); // Output: null\n     ```\n\n**Key Differences**:\n- `undefined` is a type itself (`undefined`), while `null` is an object.\n- `undefined` often indicates a variable that has not been initialized, whereas `null` is explicitly set to signify \"no value.\"\n\n**Type Checking**:\n```javascript\nconsole.log(typeof undefined); // Output: \"undefined\"\nconsole.log(typeof null);      // Output: \"object\"\n```\n\nIn summary, `undefined` is used by JavaScript to indicate missing values, while `null` is used by developers to explicitly indicate an empty or non-existent value.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553165Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "0db8050e-e8e9-479c-abfb-d860205a7b9c",
            "question": "What is hoisting in JavaScript and how does it work?",
            "answer": "```markdown\n### What is Hoisting in JavaScript and How Does it Work?\n\nHoisting in JavaScript is a behavior where variable and function declarations are moved to the top of their containing scope during the compilation phase, before the code is executed. This means that you can use variables and functions in your code before they are declared, without causing a runtime error.\n\nHowever, it's important to note that **only the declarations are hoisted, not the initializations**. For variables declared with `var`, the declaration is hoisted, but the value assignment remains in place. Variables declared with `let` and `const` are also hoisted, but they are placed in a \"temporal dead zone\" from the start of the block until the declaration is encountered, meaning they cannot be accessed before their declaration.\n\n#### Example of Hoisting with `var`:\n```javascript\nconsole.log(a); // Output: undefined (declaration is hoisted, but not the initialization)\nvar a = 5;\nconsole.log(a); // Output: 5\n```\n\n#### Example of Hoisting with `let` and `const`:\n```javascript\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\nlet b = 10;\n\nconsole.log(c); // ReferenceError: Cannot access 'c' before initialization\nconst c = 15;\n```\n\n#### Function Hoisting:\nFunction declarations are fully hoisted, meaning you can call the function before it is defined in the code:\n```javascript\ngreet(); // Output: \"Hello, World!\"\n\nfunction greet() {\n  console.log(\"Hello, World!\");\n}\n```\n\nHowever, function expressions (both regular and arrow functions) are not fully hoisted. Only the variable declaration is hoisted, not the function definition:\n```javascript\nsayHello(); // TypeError: sayHello is not a function\nvar sayHello = function() {\n  console.log(\"Hello!\");\n};\n```\n\n#### Key Points:\n1. Hoisting applies to variable and function declarations, not initializations.\n2. Variables declared with `var` are hoisted and initialized with `undefined`.\n3. Variables declared with `let` and `const` are hoisted but remain in the \"temporal dead zone\" until their declaration is encountered.\n4. Function declarations are fully hoisted, but function expressions are not.\n\nUnderstanding hoisting helps avoid unexpected behavior and write cleaner, more predictable code.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553174Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "5e9d8550-f9f6-4c87-a317-cd1cc790b788",
            "question": "What are JavaScript arrow functions and how do they differ from regular functions?",
            "answer": "```markdown\n### JavaScript Arrow Functions and How They Differ from Regular Functions\n\nArrow functions are a more concise syntax for writing functions in JavaScript, introduced in ES6. They are particularly useful for writing shorter function expressions and are often used in functional programming patterns.\n\n#### Syntax of Arrow Functions\nAn arrow function is defined using the `=>` (arrow) syntax. For example:\n\n```javascript\n// Regular function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst add = (a, b) => a + b;\n```\n\n#### Key Differences Between Arrow Functions and Regular Functions\n\n1. **Syntax**:\n   - Arrow functions provide a shorter and cleaner syntax, especially for simple one-liner functions.\n   - Regular functions require the `function` keyword and curly braces for the function body.\n\n2. **`this` Binding**:\n   - Arrow functions do not have their own `this`. Instead, they inherit `this` from the surrounding lexical scope. This makes them particularly useful in scenarios where you want to preserve the context of `this`, such as in callbacks.\n   - Regular functions have their own `this`, which is determined by how the function is called (e.g., as a method, as a constructor, etc.).\n\n   Example:\n   ```javascript\n   function RegularFunction() {\n     this.value = 10;\n     setTimeout(function() {\n       console.log(this.value); // undefined, because `this` refers to the global object\n     }, 1000);\n   }\n\n   function ArrowFunction() {\n     this.value = 10;\n     setTimeout(() => {\n       console.log(this.value); // 10, because `this` is inherited from the enclosing scope\n     }, 1000);\n   }\n\n   new RegularFunction();\n   new ArrowFunction();\n   ```\n\n3. **Usage as Constructors**:\n   - Arrow functions cannot be used as constructors and will throw an error if used with the `new` keyword.\n   - Regular functions can be used as constructors to create objects.\n\n4. **`arguments` Object**:\n   - Arrow functions do not have their own `arguments` object. If you need to access the `arguments` of an arrow function, you must use the rest parameter syntax (`...args`).\n   - Regular functions have their own `arguments` object, which contains all the arguments passed to the function.\n\n   Example:\n   ```javascript\n   function regularFunction() {\n     console.log(arguments); // Logs the arguments object\n   }\n\n   const arrowFunction = (...args) => {\n     console.log(args); // Logs an array of arguments\n   };\n\n   regularFunction(1, 2, 3);\n   arrowFunction(1, 2, 3);\n   ```\n\n5. **Implicit Return**:\n   - Arrow functions allow for implicit return if the function body consists of a single expression. The value of that expression is automatically returned.\n   - Regular functions require the use of the `return` keyword to return a value.\n\n   Example:\n   ```javascript\n   const multiply = (a, b) => a * b; // Implicit return\n   const multiplyRegular = function(a, b) {\n     return a * b; // Explicit return\n   };\n   ```\n\n#### Conclusion\nArrow functions are a powerful addition to JavaScript, offering a more concise syntax and predictable behavior for `this`. However, they are not a replacement for regular functions in all cases, especially when you need features like the `arguments` object or the ability to use the function as a constructor.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553183Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "afcdbbb2-c2ed-41d0-96a0-fd583f367e98",
            "question": "What is the purpose of the JavaScript 'this' keyword?",
            "answer": "```markdown\nThe `this` keyword in JavaScript refers to the object that is currently executing the code. Its value depends on the context in which it is used:\n\n1. **Global Context**: In the global execution context (outside of any function), `this` refers to the global object (`window` in browsers or `global` in Node.js).\n\n2. **Inside a Function**:\n   - In a regular function, `this` refers to the global object in non-strict mode, or `undefined` in strict mode.\n   - In an object method, `this` refers to the object that owns the method.\n\n3. **Arrow Functions**: Arrow functions do not have their own `this`. Instead, they inherit `this` from the surrounding lexical scope.\n\n4. **Event Handlers**: In event handlers, `this` typically refers to the element that triggered the event.\n\n5. **Explicit Binding**: The value of `this` can be explicitly set using methods like `call()`, `apply()`, or `bind()`.\n\n6. **Constructor Functions and Classes**: When using a constructor function or a class, `this` refers to the newly created object.\n\nThe `this` keyword is essential for dynamic context binding and allows methods to operate on the object they belong to.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553192Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "67fcb060-ee52-4761-89d7-f1b7047262f0",
            "question": "What are JavaScript prototypes and how are they used?",
            "answer": "```markdown\n### JavaScript Prototypes\n\nIn JavaScript, every object has an internal property called `[[Prototype]]`, which refers to another object. This is the foundation of JavaScript's prototype-based inheritance. The prototype is essentially a blueprint from which objects can inherit properties and methods.\n\n#### Key Concepts of Prototypes:\n1. **Prototype Chain**: If a property or method is not found on an object, JavaScript looks up the `[[Prototype]]` chain to find it. This chain continues until it reaches `null`, which is the end of the chain.\n2. **Object.prototype**: The base object in JavaScript is `Object.prototype`. All objects ultimately inherit from it unless explicitly created otherwise.\n3. **Prototype Property**: Functions in JavaScript have a `prototype` property, which is used to define properties and methods that will be inherited by objects created using that function as a constructor.\n\n#### How Prototypes Are Used:\n1. **Inheritance**: Prototypes allow objects to share methods and properties, enabling inheritance. For example:\n   ```javascript\n   function Person(name) {\n       this.name = name;\n   }\n\n   Person.prototype.greet = function() {\n       console.log(`Hello, my name is ${this.name}`);\n   };\n\n   const john = new Person('John');\n   john.greet(); // Output: Hello, my name is John\n   ```\n\n2. **Extending Objects**: Prototypes can be used to extend the functionality of existing objects.\n   ```javascript\n   Array.prototype.sum = function() {\n       return this.reduce((acc, val) => acc + val, 0);\n   };\n\n   const numbers = [1, 2, 3];\n   console.log(numbers.sum()); // Output: 6\n   ```\n\n3. **Dynamic Behavior**: Prototypes allow dynamic addition of properties or methods to objects even after they are created.\n\n4. **Custom Objects**: Developers can create custom objects with shared behavior using prototypes.\n\n#### Important Notes:\n- Modifying the prototype of an object after it has been created can lead to performance issues and is generally discouraged.\n- The `Object.create()` method allows creating a new object with a specified prototype.\n   ```javascript\n   const proto = {\n       greet() {\n           console.log('Hello from prototype!');\n       }\n   };\n\n   const obj = Object.create(proto);\n   obj.greet(); // Output: Hello from prototype!\n   ```\n\n- The `__proto__` property (deprecated but still widely used) and `Object.getPrototypeOf()` can be used to access an object's prototype.\n\n#### Summary:\nPrototypes are a core feature of JavaScript that enable inheritance and code reuse. By leveraging prototypes, developers can create efficient and maintainable code, sharing behavior across objects without duplicating functionality.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553201Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "d8ae9a4e-b54f-4c52-bc23-f84022a4bb59",
            "question": "What is the difference between function declarations and function expressions in JavaScript?",
            "answer": "```markdown\nIn JavaScript, the difference between function declarations and function expressions lies in how they are defined and their behavior in the code:\n\n### Function Declaration\n- A function declaration defines a named function using the `function` keyword.\n- It is hoisted to the top of its scope, meaning you can call the function before it is defined in the code.\n- Syntax:\n  ```javascript\n  function greet() {\n    console.log(\"Hello!\");\n  }\n  ```\n\n### Function Expression\n- A function expression defines a function as part of an expression. It can be named or anonymous.\n- It is not hoisted, so you cannot call the function before the expression is defined.\n- Syntax:\n  ```javascript\n  const greet = function() {\n    console.log(\"Hello!\");\n  };\n  ```\n\n### Key Differences\n| Aspect                  | Function Declaration                  | Function Expression                  |\n|-------------------------|---------------------------------------|---------------------------------------|\n| **Hoisting**            | Hoisted to the top of the scope.      | Not hoisted.                         |\n| **Usage Before Definition** | Can be called before it is defined. | Cannot be called before it is defined. |\n| **Naming**              | Always has a name.                   | Can be anonymous or named.           |\n\n### Example\n```javascript\n// Function Declaration\ngreet(); // Works because of hoisting\nfunction greet() {\n  console.log(\"Hello from declaration!\");\n}\n\n// Function Expression\ntry {\n  greetExpression(); // Error: Cannot access 'greetExpression' before initialization\n} catch (e) {\n  console.log(e.message);\n}\nconst greetExpression = function() {\n  console.log(\"Hello from expression!\");\n};\n```\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553210Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "1684c9d2-f629-4bf2-85a6-269efcda6a4e",
            "question": "What are JavaScript modules and how do you use them?",
            "answer": "```markdown\n### JavaScript Modules\n\nJavaScript modules are reusable pieces of code that can be exported from one file and imported into another. They help in organizing code into smaller, manageable, and reusable components, making it easier to maintain and debug. Modules also allow for better encapsulation by keeping variables and functions private to the module unless explicitly exported.\n\n#### Key Features of JavaScript Modules:\n1. **Encapsulation**: Variables and functions are scoped to the module by default.\n2. **Reusability**: Code can be reused across different parts of an application.\n3. **Maintainability**: Code is easier to maintain and debug when divided into smaller modules.\n4. **Dependency Management**: Modules can import other modules, creating a clear dependency structure.\n\n#### Using JavaScript Modules\n\n1. **Exporting Code**:\n   You can export variables, functions, or classes from a module using `export`. There are two types of exports:\n   \n   - **Named Exports**: Export multiple values by name.\n     ```javascript\n     // math.js\n     export const add = (a, b) => a + b;\n     export const subtract = (a, b) => a - b;\n     ```\n\n   - **Default Export**: Export a single default value.\n     ```javascript\n     // greet.js\n     export default function greet(name) {\n       return `Hello, ${name}!`;\n     }\n     ```\n\n2. **Importing Code**:\n   Use the `import` keyword to bring in exported code from another module.\n   \n   - Importing named exports:\n     ```javascript\n     import { add, subtract } from './math.js';\n\n     console.log(add(2, 3)); // Output: 5\n     console.log(subtract(5, 2)); // Output: 3\n     ```\n\n   - Importing a default export:\n     ```javascript\n     import greet from './greet.js';\n\n     console.log(greet('Alice')); // Output: Hello, Alice!\n     ```\n\n   - Importing everything as an object:\n     ```javascript\n     import * as math from './math.js';\n\n     console.log(math.add(2, 3)); // Output: 5\n     console.log(math.subtract(5, 2)); // Output: 3\n     ```\n\n3. **Using Modules in the Browser**:\n   To use modules in the browser, include the `type=\"module\"` attribute in the `<script>` tag:\n   ```html\n   <script type=\"module\" src=\"main.js\"></script>\n   ```\n\n4. **Using Modules in Node.js**:\n   In Node.js, you can use ES modules by setting `\"type\": \"module\"` in your `package.json` file or by using `.mjs` file extensions.\n\n#### Example\n```javascript\n// math.js\nexport const multiply = (a, b) => a * b;\nexport const divide = (a, b) => a / b;\n\n// main.js\nimport { multiply, divide } from './math.js';\n\nconsole.log(multiply(4, 5)); // Output: 20\nconsole.log(divide(10, 2));  // Output: 5\n```\n\nJavaScript modules are now widely supported in modern browsers and Node.js, making them a standard way to structure and manage code in JavaScript applications.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553219Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "99566a59-8d64-4bda-830b-96c03adf0bf7",
            "question": "What is the difference between call(), apply(), and bind() in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `call()`, `apply()`, and `bind()` are methods used to control the `this` context of a function and invoke it in different ways. Here's a breakdown of their differences:\n\n### 1. `call()`\n- **Purpose**: Invokes a function with a specified `this` context and arguments provided individually.\n- **Syntax**: `function.call(thisArg, arg1, arg2, ...)`\n- **Use Case**: Use `call()` when you know the arguments beforehand and want to pass them explicitly.\n- **Example**:\n  ```javascript\n  function greet(greeting, punctuation) {\n    console.log(`${greeting}, ${this.name}${punctuation}`);\n  }\n\n  const person = { name: 'Alice' };\n  greet.call(person, 'Hello', '!');\n  // Output: \"Hello, Alice!\"\n  ```\n\n---\n\n### 2. `apply()`\n- **Purpose**: Similar to `call()`, but arguments are passed as an array or array-like object.\n- **Syntax**: `function.apply(thisArg, [argsArray])`\n- **Use Case**: Use `apply()` when you have arguments in an array or need to pass them dynamically.\n- **Example**:\n  ```javascript\n  function greet(greeting, punctuation) {\n    console.log(`${greeting}, ${this.name}${punctuation}`);\n  }\n\n  const person = { name: 'Bob' };\n  greet.apply(person, ['Hi', '!']);\n  // Output: \"Hi, Bob!\"\n  ```\n\n---\n\n### 3. `bind()`\n- **Purpose**: Creates a new function with a specified `this` context and optionally pre-sets arguments. The new function can be invoked later.\n- **Syntax**: `function.bind(thisArg, arg1, arg2, ...)`\n- **Use Case**: Use `bind()` when you want to create a reusable function with a specific `this` context.\n- **Example**:\n  ```javascript\n  function greet(greeting, punctuation) {\n    console.log(`${greeting}, ${this.name}${punctuation}`);\n  }\n\n  const person = { name: 'Charlie' };\n  const boundGreet = greet.bind(person, 'Hey');\n  boundGreet('!');\n  // Output: \"Hey, Charlie!\"\n  ```\n\n---\n\n### Key Differences\n| Method   | Invokes Function Immediately? | Accepts Arguments Individually? | Accepts Arguments as Array? | Returns New Function? |\n|----------|-------------------------------|----------------------------------|-----------------------------|-----------------------|\n| `call()` | Yes                           | Yes                              | No                          | No                    |\n| `apply()`| Yes                           | No                               | Yes                         | No                    |\n| `bind()` | No                            | Yes                              | No                          | Yes                   |\n\nIn summary:\n- Use `call()` or `apply()` to invoke a function immediately with a specific `this` context.\n- Use `bind()` to create a new function with a bound `this` context for later use.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553227Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "6079e67b-b1d6-4e67-b8ed-9d18c18b57bf",
            "question": "What is the difference between for, for...in, and for...of loops in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `for`, `for...in`, and `for...of` loops are used for iteration, but they differ in their use cases and behavior:\n\n### 1. `for` Loop\n- The `for` loop is a general-purpose loop that is used to iterate over a block of code a specific number of times.\n- It is commonly used with arrays or when the number of iterations is known beforehand.\n- Syntax:\n  ```javascript\n  for (initialization; condition; increment/decrement) {\n    // Code to execute\n  }\n  ```\n- Example:\n  ```javascript\n  for (let i = 0; i < 5; i++) {\n    console.log(i); // Outputs: 0, 1, 2, 3, 4\n  }\n  ```\n\n### 2. `for...in` Loop\n- The `for...in` loop is used to iterate over the **enumerable properties** of an object (keys in an object or indices in an array).\n- It is not recommended for iterating over arrays because it iterates over all enumerable properties, including inherited ones, which may lead to unexpected results.\n- Syntax:\n  ```javascript\n  for (key in object) {\n    // Code to execute\n  }\n  ```\n- Example:\n  ```javascript\n  const obj = { a: 1, b: 2, c: 3 };\n  for (let key in obj) {\n    console.log(key, obj[key]); // Outputs: a 1, b 2, c 3\n  }\n  ```\n\n### 3. `for...of` Loop\n- The `for...of` loop is used to iterate over **iterable objects** such as arrays, strings, Maps, Sets, and more.\n- It directly accesses the values of the iterable, making it more suitable for arrays and other iterable objects.\n- Syntax:\n  ```javascript\n  for (value of iterable) {\n    // Code to execute\n  }\n  ```\n- Example:\n  ```javascript\n  const arr = [10, 20, 30];\n  for (let value of arr) {\n    console.log(value); // Outputs: 10, 20, 30\n  }\n  ```\n\n### Key Differences\n| Loop Type   | Use Case                          | Iterates Over                  | Notes                                                                 |\n|-------------|-----------------------------------|--------------------------------|----------------------------------------------------------------------|\n| `for`       | General-purpose iteration         | Indices (manually controlled)  | Best for when you need full control over the iteration process.      |\n| `for...in`  | Iterates over object properties   | Keys (enumerable properties)   | Avoid for arrays; may include inherited properties.                  |\n| `for...of`  | Iterates over iterable objects    | Values of the iterable         | Ideal for arrays, strings, Maps, Sets, and other iterable objects.   |\n\n### Summary\n- Use `for` for traditional loops with a known number of iterations.\n- Use `for...in` for iterating over object properties.\n- Use `for...of` for iterating over the values of iterable objects.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553245Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "1b2aef70-b4d9-4c85-be6c-d331c82e716d",
            "question": "What are JavaScript objects and how do you create them?",
            "answer": "```markdown\n### What are JavaScript Objects and How Do You Create Them?\n\nIn JavaScript, objects are collections of key-value pairs, where the keys are strings (or symbols) and the values can be of any data type, including other objects, arrays, or functions. Objects are used to store and organize data in a structured way.\n\n#### Creating JavaScript Objects\n\n1. **Using Object Literals**:\n   You can create an object using curly braces `{}` and define key-value pairs inside.\n   ```javascript\n   const person = {\n       name: \"John\",\n       age: 30,\n       isStudent: false,\n       greet: function() {\n           console.log(\"Hello!\");\n       }\n   };\n   ```\n\n2. **Using the `new Object()` Constructor**:\n   You can create an object using the `Object` constructor.\n   ```javascript\n   const car = new Object();\n   car.make = \"Toyota\";\n   car.model = \"Corolla\";\n   car.year = 2022;\n   ```\n\n3. **Using a Constructor Function**:\n   You can define a custom constructor function to create objects with specific properties and methods.\n   ```javascript\n   function Person(name, age) {\n       this.name = name;\n       this.age = age;\n   }\n   const person1 = new Person(\"Alice\", 25);\n   ```\n\n4. **Using `Object.create()`**:\n   You can create an object with a specified prototype using `Object.create()`.\n   ```javascript\n   const prototypeObject = {\n       greet: function() {\n           console.log(\"Hello!\");\n       }\n   };\n   const newObject = Object.create(prototypeObject);\n   newObject.name = \"Jane\";\n   ```\n\nObjects are fundamental in JavaScript and are widely used to represent real-world entities, manage data, and implement functionality.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553254Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "43946bd8-6192-4086-8124-850d8e3767ef",
            "question": "What is the difference between shallow copy and deep copy in JavaScript?",
            "answer": "```markdown\nIn JavaScript, the difference between a shallow copy and a deep copy lies in how the data is copied and whether nested objects are duplicated or referenced.\n\n### Shallow Copy\n- A shallow copy creates a new object, but it only copies the top-level properties of the original object.\n- If the original object contains nested objects (like arrays or other objects), the shallow copy will still reference the same nested objects in memory.\n- Changes made to the nested objects in the shallow copy will affect the original object, and vice versa.\n- Common methods to create a shallow copy:\n  - Using the spread operator (`...`): `const shallowCopy = { ...original };`\n  - Using `Object.assign()`: `const shallowCopy = Object.assign({}, original);`\n\n### Deep Copy\n- A deep copy creates a completely independent copy of the original object, including all nested objects.\n- Changes made to the deep copy do not affect the original object, and vice versa.\n- Deep copying is more complex and often requires additional tools or techniques.\n- Common methods to create a deep copy:\n  - Using `JSON.stringify()` and `JSON.parse()`:\n    ```javascript\n    const deepCopy = JSON.parse(JSON.stringify(original));\n    ```\n    *Note: This method has limitations, such as not handling functions, `undefined`, or circular references.*\n  - Using libraries like Lodash (`_.cloneDeep()`):\n    ```javascript\n    const deepCopy = _.cloneDeep(original);\n    ```\n\n### Example\n```javascript\nconst original = { a: 1, b: { c: 2 } };\n\n// Shallow Copy\nconst shallowCopy = { ...original };\nshallowCopy.b.c = 42;\nconsole.log(original.b.c); // Output: 42 (nested object is shared)\n\n// Deep Copy\nconst deepCopy = JSON.parse(JSON.stringify(original));\ndeepCopy.b.c = 99;\nconsole.log(original.b.c); // Output: 2 (nested object is independent)\n```\n\n### Summary\n- **Shallow Copy**: Copies only the top-level properties; nested objects are shared.\n- **Deep Copy**: Creates a completely independent copy, including all nested objects.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553269Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "d254046a-142f-44a4-a76f-7288c5ee7f71",
            "question": "What is the purpose of the JavaScript map() and filter() methods?",
            "answer": "```markdown\nThe `map()` and `filter()` methods in JavaScript are used to manipulate and transform arrays in a functional programming style.\n\n### `map()`\nThe `map()` method is used to create a new array by applying a provided function to each element of the original array. It does not modify the original array but returns a new one with the transformed elements.\n\n**Syntax:**\n```javascript\narray.map(callback(element, index, array))\n```\n\n- **callback**: A function that is called for every element in the array.\n  - **element**: The current element being processed.\n  - **index** (optional): The index of the current element.\n  - **array** (optional): The array `map()` was called on.\n\n**Example:**\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst squared = numbers.map(num => num * num);\nconsole.log(squared); // Output: [1, 4, 9, 16]\n```\n\n---\n\n### `filter()`\nThe `filter()` method is used to create a new array containing only the elements that pass a specified condition (i.e., return `true` when the callback function is executed). Like `map()`, it does not modify the original array.\n\n**Syntax:**\n```javascript\narray.filter(callback(element, index, array))\n```\n\n- **callback**: A function that is called for every element in the array.\n  - **element**: The current element being processed.\n  - **index** (optional): The index of the current element.\n  - **array** (optional): The array `filter()` was called on.\n\n**Example:**\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst evenNumbers = numbers.filter(num => num % 2 === 0);\nconsole.log(evenNumbers); // Output: [2, 4]\n```\n\n---\n\n### Key Differences:\n- `map()` transforms every element in the array and returns a new array of the same length.\n- `filter()` selects elements based on a condition and returns a new array with fewer or the same number of elements as the original.\n\nBoth methods are commonly used in functional programming to work with arrays in a clean and readable way.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553279Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "a1c7dee7-8a11-411a-a0ca-3a2a330c19f5",
            "question": "What is the difference between localStorage, sessionStorage, and cookies in JavaScript?",
            "answer": "```markdown\n### Difference Between `localStorage`, `sessionStorage`, and Cookies in JavaScript\n\n1. **Storage Duration**:\n   - **localStorage**: Data persists even after the browser is closed and remains until explicitly deleted.\n   - **sessionStorage**: Data persists only for the duration of the page session. It is cleared when the browser tab is closed.\n   - **Cookies**: Can be set with an expiration date. If no expiration is set, they are treated as session cookies and are deleted when the browser is closed.\n\n2. **Storage Capacity**:\n   - **localStorage**: Typically allows up to 5-10 MB of data per origin.\n   - **sessionStorage**: Similar to `localStorage`, it allows up to 5-10 MB of data per origin.\n   - **Cookies**: Limited to around 4 KB per cookie.\n\n3. **Accessibility**:\n   - **localStorage**: Accessible only from the same origin (protocol, domain, and port).\n   - **sessionStorage**: Also accessible only from the same origin, but limited to the specific browser tab.\n   - **Cookies**: Can be accessed server-side (sent with every HTTP request) and client-side (via JavaScript).\n\n4. **Use Cases**:\n   - **localStorage**: Suitable for storing large amounts of data that need to persist across sessions, such as user preferences or application state.\n   - **sessionStorage**: Ideal for temporary data that should only exist during a single session, such as form data or one-time calculations.\n   - **Cookies**: Best for storing small amounts of data that need to be sent to the server with every request, such as authentication tokens or user session identifiers.\n\n5. **Data Transmission**:\n   - **localStorage**: Data is not sent to the server with HTTP requests.\n   - **sessionStorage**: Data is also not sent to the server with HTTP requests.\n   - **Cookies**: Automatically sent to the server with every HTTP request, which can impact performance.\n\n6. **Security**:\n   - **localStorage** and **sessionStorage**: Data is stored in plain text and is vulnerable to cross-site scripting (XSS) attacks if not handled properly.\n   - **Cookies**: Can be secured using flags like `HttpOnly` (to prevent client-side access) and `Secure` (to ensure transmission over HTTPS).\n\n### Summary Table\n\n| Feature             | localStorage       | sessionStorage    | Cookies          |\n|---------------------|--------------------|-------------------|------------------|\n| Persistence         | Until explicitly deleted | Until tab is closed | Depends on expiration |\n| Capacity            | 5-10 MB           | 5-10 MB           | ~4 KB per cookie |\n| Accessibility       | Client-side only  | Client-side only  | Client & server  |\n| Data Transmission   | Not sent to server | Not sent to server | Sent with requests |\n| Security Features   | Vulnerable to XSS | Vulnerable to XSS | `HttpOnly`, `Secure` flags |\n\nBy understanding these differences, you can choose the most appropriate storage mechanism for your application's needs.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553293Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "f914d053-9fbf-4ff3-a74b-136a56d2e602",
            "question": "What are JavaScript callbacks and how are they used?",
            "answer": "```markdown\n### What are JavaScript Callbacks and How Are They Used?\n\nA **callback** in JavaScript is a function that is passed as an argument to another function and is executed after the completion of that function. Callbacks are commonly used to handle asynchronous operations, such as fetching data from an API, reading files, or handling events.\n\n#### How Callbacks Work\n1. A function is defined and passed as an argument to another function.\n2. The receiving function executes the callback at the appropriate time, often after completing some task.\n\n#### Example of a Callback\n```javascript\nfunction fetchData(callback) {\n  console.log(\"Fetching data...\");\n  setTimeout(() => {\n    console.log(\"Data fetched!\");\n    callback(\"Here is your data\");\n  }, 2000); // Simulates a 2-second delay\n}\n\nfunction processData(data) {\n  console.log(\"Processing:\", data);\n}\n\n// Using the callback\nfetchData(processData);\n```\n\nIn this example:\n- `fetchData` simulates an asynchronous operation (e.g., fetching data).\n- `processData` is passed as a callback to `fetchData` and is executed after the data is fetched.\n\n#### Why Use Callbacks?\n- **Asynchronous Programming**: Callbacks allow JavaScript to handle tasks without blocking the main thread.\n- **Event Handling**: Callbacks are used in event listeners to execute code when an event occurs.\n- **Customizable Behavior**: They enable passing custom logic to functions for flexibility.\n\n#### Common Use Cases\n- Handling API responses (e.g., `fetch` or `XMLHttpRequest`).\n- Event listeners (e.g., `button.addEventListener('click', callback)`).\n- Timers (e.g., `setTimeout` or `setInterval`).\n\n#### Callback Pitfalls\nUsing too many nested callbacks can lead to \"callback hell,\" making code difficult to read and maintain. To address this, modern JavaScript often uses **Promises** or **async/await** for cleaner asynchronous code.\n\n```javascript\n// Example of callback hell\ndoTask1(() => {\n  doTask2(() => {\n    doTask3(() => {\n      console.log(\"All tasks completed!\");\n    });\n  });\n});\n```\n\nBy understanding and using callbacks effectively, you can write more efficient and responsive JavaScript code.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553306Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "eef15ed8-d8c7-4487-8a5a-72ece478a73f",
            "question": "What is the purpose of the JavaScript reduce() method?",
            "answer": "```markdown\nThe `reduce()` method in JavaScript is used to execute a reducer function on each element of an array, resulting in a single output value. It is commonly used to accumulate or combine array elements into a single value, such as summing numbers, flattening arrays, or building objects.\n\nThe `reduce()` method takes two arguments:\n1. A reducer function, which is called for each element in the array. This function takes four parameters:\n   - `accumulator`: The accumulated result from the previous iteration.\n   - `currentValue`: The current element being processed in the array.\n   - `currentIndex` (optional): The index of the current element.\n   - `array` (optional): The array `reduce()` was called on.\n2. An initial value (optional): The starting value for the accumulator. If not provided, the first element of the array is used as the initial value, and the iteration starts from the second element.\n\n### Syntax:\n```javascript\narray.reduce(callback, initialValue)\n```\n\n### Example:\n```javascript\n// Summing numbers in an array\nconst numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\nconsole.log(sum); // Output: 10\n\n// Flattening an array of arrays\nconst nestedArrays = [[1, 2], [3, 4], [5, 6]];\nconst flattened = nestedArrays.reduce((acc, curr) => acc.concat(curr), []);\nconsole.log(flattened); // Output: [1, 2, 3, 4, 5, 6]\n```\n\nThe `reduce()` method is a powerful tool for transforming and aggregating data in arrays.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553319Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "e45dcff3-36d3-4b14-9846-9d149e1c12c4",
            "question": "What is the difference between a promise and an observable in JavaScript?",
            "answer": "```markdown\nIn JavaScript, both Promises and Observables are used to handle asynchronous operations, but they differ significantly in their behavior, features, and use cases.\n\n### Promises\n1. **Eager Execution**: A Promise starts executing immediately when it is created. It represents a single value that will be resolved or rejected in the future.\n2. **Single Emission**: A Promise can only resolve or reject once. After that, its state is immutable, and it cannot emit additional values.\n3. **Chaining**: Promises use `.then()`, `.catch()`, and `.finally()` methods to handle asynchronous operations and errors in a chainable manner.\n4. **Push-based**: Promises are push-based, meaning the producer (async operation) pushes the resolved value to the consumer.\n5. **Simpler API**: Promises are simpler to use and are well-suited for straightforward, single-value asynchronous operations.\n\n   Example:\n   ```javascript\n   const promise = new Promise((resolve, reject) => {\n       setTimeout(() => resolve(\"Promise resolved\"), 1000);\n   });\n\n   promise.then(value => console.log(value));\n   ```\n\n### Observables\n1. **Lazy Execution**: An Observable does not start emitting values until it is subscribed to. It represents a stream of values over time.\n2. **Multiple Emissions**: Observables can emit multiple values over time, making them suitable for handling streams of data (e.g., user input, WebSocket messages).\n3. **Operators**: Observables provide a rich set of operators (e.g., `map`, `filter`, `merge`, `debounceTime`) for transforming, combining, and manipulating streams of data.\n4. **Pull-based**: Observables are pull-based, meaning the consumer (subscriber) requests data from the producer.\n5. **Complex API**: Observables are more complex and are typically used in scenarios requiring advanced asynchronous data handling, such as reactive programming.\n\n   Example:\n   ```javascript\n   import { Observable } from 'rxjs';\n\n   const observable = new Observable(subscriber => {\n       subscriber.next(\"First value\");\n       setTimeout(() => subscriber.next(\"Second value\"), 1000);\n       setTimeout(() => subscriber.complete(), 2000);\n   });\n\n   observable.subscribe({\n       next: value => console.log(value),\n       complete: () => console.log(\"Observable complete\")\n   });\n   ```\n\n### Key Differences\n| Feature               | Promise                     | Observable                  |\n|-----------------------|-----------------------------|-----------------------------|\n| Execution             | Eager                      | Lazy                        |\n| Emissions             | Single value               | Multiple values             |\n| Cancellation          | Not cancellable            | Cancellable via `unsubscribe` |\n| Operators             | Limited (`then`, `catch`)  | Rich set of operators       |\n| Use Case              | Simple async operations    | Streams of data over time   |\n\n### Summary\n- Use **Promises** for simple, one-time asynchronous operations like fetching data from an API.\n- Use **Observables** for handling continuous streams of data or when you need advanced control over asynchronous workflows.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553334Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "1e49cbdd-d420-409b-a890-a4ef790cc7f4",
            "question": "What is the purpose of the JavaScript setTimeout() and setInterval() functions?",
            "answer": "```markdown\nIn JavaScript, the `setTimeout()` and `setInterval()` functions are used to execute code after a specified amount of time or at regular intervals, respectively.\n\n1. **`setTimeout()`**: This function is used to execute a piece of code or a function after a specified delay (in milliseconds). It runs the code only once after the delay.\n\n   **Syntax**:\n   ```javascript\n   setTimeout(function, delay);\n   ```\n\n   **Example**:\n   ```javascript\n   setTimeout(() => {\n       console.log(\"This message appears after 2 seconds.\");\n   }, 2000);\n   ```\n\n2. **`setInterval()`**: This function is used to repeatedly execute a piece of code or a function at a specified interval (in milliseconds). It continues to run until explicitly stopped using `clearInterval()`.\n\n   **Syntax**:\n   ```javascript\n   setInterval(function, interval);\n   ```\n\n   **Example**:\n   ```javascript\n   const intervalId = setInterval(() => {\n       console.log(\"This message appears every 1 second.\");\n   }, 1000);\n\n   // To stop the interval after 5 seconds\n   setTimeout(() => {\n       clearInterval(intervalId);\n       console.log(\"Interval stopped.\");\n   }, 5000);\n   ```\n\n**Key Differences**:\n- `setTimeout()` executes code once after the delay.\n- `setInterval()` executes code repeatedly at the specified interval.\n\nBoth functions are useful for scheduling tasks in JavaScript.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553349Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "ae533f57-85f6-4b10-a5c3-7d640c6aefcd",
            "question": "What are JavaScript generators and how do they work?",
            "answer": "```markdown\n### JavaScript Generators and How They Work\n\nJavaScript generators are special functions that can pause their execution and later resume from where they left off. They are introduced in ES6 and are defined using the `function*` syntax. Generators provide a powerful way to handle asynchronous programming, lazy evaluation, and custom iteration.\n\n#### Key Characteristics of Generators:\n1. **Pause and Resume**: Generators can pause execution at any point using the `yield` keyword and resume later from the same point.\n2. **Iterator Protocol**: Generators implement the iterator protocol, meaning they return an object with a `next()` method that can be used to iterate through their values.\n3. **State Preservation**: Generators maintain their state between pauses, allowing them to remember where they left off.\n\n#### Syntax:\n```javascript\nfunction* generatorFunction() {\n  yield 'First value';\n  yield 'Second value';\n  return 'Final value';\n}\n```\n\n#### How Generators Work:\n1. When a generator function is called, it does not execute immediately. Instead, it returns a generator object.\n2. The generator object has a `next()` method, which starts or resumes the generator's execution.\n3. Each call to `next()` runs the generator until it encounters a `yield` statement, at which point it pauses and returns the value specified by `yield`.\n4. When the generator completes execution (reaches the end or a `return` statement), the `done` property of the result returned by `next()` is set to `true`.\n\n#### Example:\n```javascript\nfunction* simpleGenerator() {\n  console.log('Start');\n  yield 1;\n  console.log('After first yield');\n  yield 2;\n  console.log('After second yield');\n  return 3;\n}\n\nconst gen = simpleGenerator();\n\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: true }\nconsole.log(gen.next()); // { value: undefined, done: true }\n```\n\n#### Use Cases:\n1. **Asynchronous Programming**: Generators can be used with `yield` to pause execution and wait for asynchronous operations.\n2. **Custom Iterators**: Generators can create custom iterable objects.\n3. **Infinite Sequences**: Generators can produce infinite sequences without consuming large amounts of memory.\n\n#### Example: Infinite Sequence\n```javascript\nfunction* infiniteSequence() {\n  let i = 0;\n  while (true) {\n    yield i++;\n  }\n}\n\nconst seq = infiniteSequence();\nconsole.log(seq.next().value); // 0\nconsole.log(seq.next().value); // 1\nconsole.log(seq.next().value); // 2\n```\n\n#### Conclusion:\nGenerators are a powerful feature in JavaScript that enable more flexible and efficient control over function execution. By leveraging the `yield` keyword and the iterator protocol, they simplify complex workflows, especially in scenarios involving asynchronous operations or custom iteration logic.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553365Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "d9c84dcd-74e5-41f5-8d21-1f5fd44e78f2",
            "question": "What is the difference between mutable and immutable data in JavaScript?",
            "answer": "```markdown\nIn JavaScript, the difference between mutable and immutable data lies in whether the data can be changed after it is created.\n\n### Mutable Data\n- Mutable data can be modified after it is created.\n- Changes to mutable data affect the original data structure.\n- Examples of mutable data types in JavaScript include:\n  - Objects (`{}`): You can add, remove, or update properties.\n  - Arrays (`[]`): You can modify elements, add new elements, or remove elements.\n\n```javascript\nlet obj = { name: \"Alice\" };\nobj.age = 25; // Modifies the object by adding a new property\nconsole.log(obj); // { name: \"Alice\", age: 25 }\n\nlet arr = [1, 2, 3];\narr.push(4); // Modifies the array by adding a new element\nconsole.log(arr); // [1, 2, 3, 4]\n```\n\n### Immutable Data\n- Immutable data cannot be changed after it is created.\n- Any modification results in the creation of a new value or data structure, leaving the original unchanged.\n- Examples of immutable data types in JavaScript include:\n  - Primitive types: `String`, `Number`, `Boolean`, `null`, `undefined`, `Symbol`, and `BigInt`.\n\n```javascript\nlet str = \"Hello\";\nlet newStr = str + \" World\"; // Creates a new string\nconsole.log(str); // \"Hello\" (original string remains unchanged)\nconsole.log(newStr); // \"Hello World\"\n\nlet num = 42;\nlet newNum = num + 1; // Creates a new number\nconsole.log(num); // 42 (original number remains unchanged)\nconsole.log(newNum); // 43\n```\n\n### Key Differences\n| Aspect                | Mutable Data                  | Immutable Data               |\n|-----------------------|-------------------------------|------------------------------|\n| Can be modified       | Yes                           | No                           |\n| Original data changes | Yes                           | No                           |\n| Examples              | Objects, Arrays              | Strings, Numbers, Booleans   |\n\nUnderstanding the distinction between mutable and immutable data is essential for managing state and avoiding unintended side effects in JavaScript applications.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553380Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "96756d9c-c919-45d4-a20f-c798194d56ca",
            "question": "What is the purpose of the JavaScript Symbol data type?",
            "answer": "```markdown\nThe `Symbol` data type in JavaScript is a primitive type introduced in ECMAScript 6 (ES6). Its primary purpose is to create unique and immutable identifiers. Symbols are often used as keys for object properties to avoid naming collisions, as each Symbol is guaranteed to be unique, even if two Symbols have the same description.\n\n### Key Characteristics of Symbols:\n1. **Uniqueness**: Every Symbol is unique, even if created with the same description.\n   ```javascript\n   const sym1 = Symbol('description');\n   const sym2 = Symbol('description');\n   console.log(sym1 === sym2); // false\n   ```\n2. **Immutability**: Symbols are immutable, meaning their value cannot be changed once created.\n3. **Non-enumerable by default**: Properties keyed by Symbols are not included in `for...in` or `Object.keys()` iterations, making them useful for defining hidden or internal object properties.\n\n### Common Use Cases:\n1. **Object Property Keys**: Symbols can be used as keys for object properties to ensure uniqueness and avoid property name conflicts.\n   ```javascript\n   const uniqueKey = Symbol('key');\n   const obj = {\n       [uniqueKey]: 'value'\n   };\n   console.log(obj[uniqueKey]); // 'value'\n   ```\n\n2. **Defining Constants**: Symbols can represent constants where uniqueness is important.\n   ```javascript\n   const COLOR_RED = Symbol('red');\n   const COLOR_BLUE = Symbol('blue');\n   ```\n\n3. **Customizing Object Behavior**: Symbols are used in well-known Symbol properties to customize object behavior, such as:\n   - `Symbol.iterator` for making objects iterable.\n   - `Symbol.toStringTag` for customizing the default string description of an object.\n   ```javascript\n   const myObject = {\n       [Symbol.toStringTag]: 'CustomObject'\n   };\n   console.log(Object.prototype.toString.call(myObject)); // [object CustomObject]\n   ```\n\n### Conclusion:\nThe `Symbol` data type is a powerful feature in JavaScript that provides a way to create unique, immutable identifiers. It is particularly useful in scenarios where property name conflicts need to be avoided or when customizing object behavior through well-known Symbols.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553395Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "338e386a-6c3c-4706-b29b-912d79510a2e",
            "question": "What is the difference between an arrow function and a regular function in terms of 'this' binding?",
            "answer": "```markdown\nIn JavaScript, the key difference between an arrow function and a regular function lies in how they handle the `this` keyword:\n\n1. **Arrow Functions**:\n   - Arrow functions do not have their own `this` context. Instead, they inherit `this` from the surrounding (lexical) scope where they are defined.\n   - This makes arrow functions particularly useful in scenarios where you want to preserve the `this` value from the outer context, such as in callbacks or event handlers.\n   - Example:\n     ```javascript\n     const obj = {\n       value: 10,\n       regularFunction: function () {\n         console.log(this.value); // `this` refers to `obj`\n       },\n       arrowFunction: () => {\n         console.log(this.value); // `this` refers to the outer scope, not `obj`\n       }\n     };\n\n     obj.regularFunction(); // Output: 10\n     obj.arrowFunction();   // Output: undefined (or an error in strict mode)\n     ```\n\n2. **Regular Functions**:\n   - Regular functions have their own `this` context, which is determined by how the function is called (runtime binding).\n   - If called as a method of an object, `this` refers to the object. If called as a standalone function, `this` is `undefined` in strict mode or refers to the global object in non-strict mode.\n   - Example:\n     ```javascript\n     function regularFunction() {\n       console.log(this);\n     }\n\n     const obj = { method: regularFunction };\n     obj.method(); // `this` refers to `obj`\n     regularFunction(); // `this` is undefined in strict mode or the global object otherwise\n     ```\n\n### Summary:\n- Arrow functions: Lexical `this` (inherits from the surrounding scope).\n- Regular functions: Dynamic `this` (determined by how the function is called).\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553408Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "490f1837-0413-40d3-a542-b1aa2b378a51",
            "question": "What is the purpose of the JavaScript Array.from() method?",
            "answer": "```markdown\nThe `Array.from()` method in JavaScript is used to create a new array instance from an array-like or iterable object. It allows you to convert objects such as `NodeList`, `arguments`, or any iterable (like a string or a `Set`) into a proper array.\n\n### Key Features:\n1. **Array-like to Array Conversion**: Converts objects with a `length` property (e.g., `arguments` or `NodeList`) into an array.\n2. **Iterable to Array Conversion**: Converts iterable objects (e.g., strings, `Set`, `Map`) into an array.\n3. **Mapping Function**: Accepts an optional mapping function as the second argument to transform each element during the conversion.\n\n### Syntax:\n```javascript\nArray.from(arrayLike, mapFunction, thisArg)\n```\n\n- `arrayLike`: The array-like or iterable object to convert.\n- `mapFunction` (optional): A function to apply to each element before adding it to the new array.\n- `thisArg` (optional): A value to use as `this` when executing the `mapFunction`.\n\n### Examples:\n\n#### Converting a String to an Array:\n```javascript\nconst str = \"hello\";\nconst arr = Array.from(str);\nconsole.log(arr); // Output: ['h', 'e', 'l', 'l', 'o']\n```\n\n#### Converting a Set to an Array:\n```javascript\nconst mySet = new Set([1, 2, 3]);\nconst arr = Array.from(mySet);\nconsole.log(arr); // Output: [1, 2, 3]\n```\n\n#### Using a Mapping Function:\n```javascript\nconst numbers = Array.from([1, 2, 3], x => x * 2);\nconsole.log(numbers); // Output: [2, 4, 6]\n```\n\n#### Converting a NodeList to an Array:\n```javascript\nconst nodeList = document.querySelectorAll('div');\nconst nodesArray = Array.from(nodeList);\nconsole.log(nodesArray); // Output: Array of div elements\n```\n\n### Use Cases:\n- Converting `arguments` or `NodeList` to an array for easier manipulation.\n- Duplicating or transforming iterable objects.\n- Creating arrays from custom objects with a `length` property.\n\nThe `Array.from()` method is particularly useful when working with array-like objects that do not have array methods like `map`, `filter`, or `reduce`.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553418Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "06e10221-e1cd-42cc-ab06-38431255885c",
            "question": "What is the difference between a shallow merge and a deep merge in JavaScript?",
            "answer": "```markdown\nIn JavaScript, the difference between a shallow merge and a deep merge lies in how the properties of objects are copied or merged:\n\n### Shallow Merge\n- A shallow merge copies only the first level of properties from one object to another.\n- If a property is an object or array, only the reference to that object/array is copied, not the actual nested structure.\n- Changes made to the nested object/array in the source or target will affect both, as they share the same reference.\n- Example of a shallow merge:\n  ```javascript\n  const obj1 = { a: 1, b: { c: 2 } };\n  const obj2 = { d: 3 };\n  const shallowMerged = Object.assign({}, obj1, obj2);\n  console.log(shallowMerged); // { a: 1, b: { c: 2 }, d: 3 }\n  shallowMerged.b.c = 42;\n  console.log(obj1.b.c); // 42 (shared reference)\n  ```\n\n### Deep Merge\n- A deep merge involves recursively copying all properties, including nested objects and arrays, creating entirely new references for them.\n- Changes made to the nested objects/arrays in the source or target will not affect each other, as they are independent.\n- Deep merging requires additional logic, as JavaScript does not provide a built-in method for this. Libraries like Lodash (`_.merge`) or custom recursive functions are commonly used.\n- Example of a deep merge:\n  ```javascript\n  const obj1 = { a: 1, b: { c: 2 } };\n  const obj2 = { d: 3 };\n  const deepMerged = _.merge({}, obj1, obj2); // Using Lodash\n  console.log(deepMerged); // { a: 1, b: { c: 2 }, d: 3 }\n  deepMerged.b.c = 42;\n  console.log(obj1.b.c); // 2 (independent reference)\n  ```\n\n### Key Differences\n| Aspect            | Shallow Merge                          | Deep Merge                              |\n|--------------------|----------------------------------------|-----------------------------------------|\n| Depth of Copy      | First level only                      | All levels (recursive)                  |\n| Nested Objects/Arrays | References are shared               | New references are created              |\n| Built-in Support   | Supported (e.g., `Object.assign`)      | Not built-in, requires custom logic or libraries |\n| Use Case           | Simple merges with flat structures    | Complex merges with nested structures   |\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553428Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "1a73f799-ff6d-4e97-a9c5-886586d6483e",
            "question": "What is the purpose of the JavaScript WeakMap and WeakSet objects?",
            "answer": "```markdown\n### Purpose of JavaScript `WeakMap` and `WeakSet` Objects\n\nThe `WeakMap` and `WeakSet` objects in JavaScript are specialized collections designed to hold \"weak\" references to their keys or values. These weak references allow the garbage collector to reclaim memory if there are no other strong references to the objects, making them useful for certain memory-sensitive use cases.\n\n#### **WeakMap**\n- A `WeakMap` is a collection of key-value pairs where the keys must be objects, and the values can be arbitrary data.\n- The keys in a `WeakMap` are weakly referenced, meaning they do not prevent the key object from being garbage-collected if there are no other references to it.\n- This makes `WeakMap` ideal for associating metadata or private data with objects without risking memory leaks.\n\n**Key Characteristics of `WeakMap`:**\n1. Keys must be objects (not primitive values).\n2. Values can be of any type.\n3. Keys are weakly held, allowing garbage collection when no other references exist.\n4. It does not have methods to iterate over its elements (e.g., no `forEach` or `keys` methods) to ensure the privacy of the keys.\n\n**Use Cases:**\n- Storing private data for objects.\n- Caching data tied to objects without preventing garbage collection.\n\n#### **WeakSet**\n- A `WeakSet` is a collection of objects, where each object is stored as a weak reference.\n- Like `WeakMap`, the objects in a `WeakSet` can be garbage-collected if there are no other references to them.\n\n**Key Characteristics of `WeakSet`:**\n1. Only objects can be added to a `WeakSet` (no primitive values).\n2. Objects are weakly held, allowing garbage collection when no other references exist.\n3. It does not support iteration or methods to retrieve its elements.\n\n**Use Cases:**\n- Tracking objects without preventing their garbage collection.\n- Managing a set of objects that may dynamically appear and disappear during runtime.\n\n#### **Key Differences from `Map` and `Set`:**\n- `WeakMap` and `WeakSet` do not prevent garbage collection of their keys or objects.\n- They do not expose their elements for iteration or inspection, ensuring privacy and efficiency.\n- They are suitable for use cases where memory management and object lifecycle are critical.\n\nBy using `WeakMap` and `WeakSet`, developers can manage memory more effectively and avoid memory leaks in scenarios where objects may become unreachable but still need temporary associations or tracking.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553438Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "fe82c9a8-ba36-40a8-98d0-ac9fa2709ba3",
            "question": "What is the difference between Object.freeze() and Object.seal() in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `Object.freeze()` and `Object.seal()` are methods used to restrict modifications to objects, but they differ in their level of restriction:\n\n### `Object.freeze()`\n- Prevents **adding**, **removing**, or **modifying** properties of an object.\n- The object becomes **completely immutable**.\n- Existing property values cannot be changed, and no new properties can be added.\n- The `writable` and `configurable` attributes of all properties are set to `false`.\n- Example:\n  ```javascript\n  const obj = { name: \"Alice\" };\n  Object.freeze(obj);\n\n  obj.name = \"Bob\"; // Does nothing (in strict mode, throws an error)\n  obj.age = 25;     // Does nothing (in strict mode, throws an error)\n  delete obj.name;  // Does nothing (in strict mode, throws an error)\n\n  console.log(obj); // { name: \"Alice\" }\n  ```\n\n### `Object.seal()`\n- Prevents **adding** or **removing** properties from an object.\n- Existing properties can still be **modified** if their `writable` attribute is `true`.\n- The `configurable` attribute of all properties is set to `false`, but the `writable` attribute remains unchanged.\n- Example:\n  ```javascript\n  const obj = { name: \"Alice\" };\n  Object.seal(obj);\n\n  obj.name = \"Bob\"; // Allowed (modifying existing property)\n  obj.age = 25;     // Does nothing (in strict mode, throws an error)\n  delete obj.name;  // Does nothing (in strict mode, throws an error)\n\n  console.log(obj); // { name: \"Bob\" }\n  ```\n\n### Key Differences\n| Feature                  | `Object.freeze()`                     | `Object.seal()`                     |\n|--------------------------|----------------------------------------|--------------------------------------|\n| Add new properties       | Not allowed                           | Not allowed                         |\n| Remove properties        | Not allowed                           | Not allowed                         |\n| Modify existing values   | Not allowed                           | Allowed if `writable` is `true`     |\n| Configurable properties  | Set to `false`                        | Set to `false`                      |\n| Writable properties      | Set to `false`                        | Unchanged                           |\n\nIn summary, `Object.freeze()` makes an object completely immutable, while `Object.seal()` allows modification of existing properties but prevents adding or removing properties.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553447Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "a4c63028-2d3f-4973-9570-5fa71db40979",
            "question": "What are JavaScript promises and how do they handle errors?",
            "answer": "```markdown\n### JavaScript Promises and Error Handling\n\nA **JavaScript Promise** is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises are used to handle asynchronous operations in a more readable and manageable way compared to traditional callback-based approaches.\n\nA promise can be in one of three states:\n1. **Pending**: The initial state, neither fulfilled nor rejected.\n2. **Fulfilled**: The operation completed successfully, and the promise has a resulting value.\n3. **Rejected**: The operation failed, and the promise has a reason for the failure (an error).\n\n#### Syntax\nA promise is created using the `Promise` constructor:\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // Perform an asynchronous operation\n  if (/* operation successful */) {\n    resolve(\"Success!\");\n  } else {\n    reject(\"Error occurred!\");\n  }\n});\n```\n\n#### Handling Errors in Promises\nErrors in promises can be handled using the `.catch()` method or by chaining `.then()` with a rejection handler. Here's how it works:\n\n1. **Using `.catch()`**:\n   The `.catch()` method is used to handle errors or rejections in a promise chain. It catches any error that occurs in the promise or in any of the preceding `.then()` handlers.\n   ```javascript\n   const promise = new Promise((resolve, reject) => {\n     reject(\"Something went wrong!\");\n   });\n\n   promise\n     .then((result) => {\n       console.log(result);\n     })\n     .catch((error) => {\n       console.error(\"Error:\", error);\n     });\n   ```\n\n2. **Using `.then()` with a rejection handler**:\n   The `.then()` method can take two arguments: a success handler and a rejection handler. The rejection handler is invoked if the promise is rejected.\n   ```javascript\n   const promise = new Promise((resolve, reject) => {\n     reject(\"Something went wrong!\");\n   });\n\n   promise.then(\n     (result) => {\n       console.log(result);\n     },\n     (error) => {\n       console.error(\"Error:\", error);\n     }\n   );\n   ```\n\n3. **Error Propagation**:\n   If an error occurs in a `.then()` block and is not handled, it propagates down the chain until it is caught by a `.catch()` block.\n   ```javascript\n   const promise = new Promise((resolve, reject) => {\n     resolve(\"Success!\");\n   });\n\n   promise\n     .then((result) => {\n       console.log(result);\n       throw new Error(\"Something went wrong!\");\n     })\n     .catch((error) => {\n       console.error(\"Caught error:\", error.message);\n     });\n   ```\n\n4. **Using `finally()`**:\n   The `.finally()` method is executed after the promise is settled (fulfilled or rejected), regardless of the outcome. It is typically used for cleanup operations.\n   ```javascript\n   const promise = new Promise((resolve, reject) => {\n     reject(\"Error occurred!\");\n   });\n\n   promise\n     .catch((error) => {\n       console.error(\"Error:\", error);\n     })\n     .finally(() => {\n       console.log(\"Cleanup complete.\");\n     });\n   ```\n\nBy using promises, JavaScript provides a clean and structured way to handle asynchronous operations and errors, making code easier to read and maintain.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553456Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "df9b88bc-f350-4391-82c0-56c7f63ca2f3",
            "question": "What is the purpose of the JavaScript Rest parameter syntax?",
            "answer": "```markdown\nThe JavaScript Rest parameter syntax (`...`) allows a function to accept an indefinite number of arguments as an array. It provides a way to handle multiple arguments without explicitly defining each one in the function's parameter list. This is particularly useful when the number of arguments is unknown or can vary.\n\n### Key Points:\n1. The Rest parameter is represented by three dots (`...`) followed by a name.\n2. It collects all remaining arguments passed to the function into a single array.\n3. It must be the last parameter in the function's parameter list.\n\n### Example:\n```javascript\nfunction sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3, 4)); // Output: 10\nconsole.log(sum(5, 10));      // Output: 15\n```\n\nIn this example, the `sum` function uses the Rest parameter to gather all arguments into the `numbers` array, which is then processed using the `reduce` method.\n\n### Benefits:\n- Simplifies handling of variable numbers of arguments.\n- Makes functions more flexible and reusable.\n- Avoids the need to use the `arguments` object, which is less intuitive and lacks array methods.\n\nThe Rest parameter is a modern feature introduced in ES6 (ECMAScript 2015) and is widely used in JavaScript programming.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553465Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "c3cf2829-f18f-4499-adb0-f6bfd1affdc6",
            "question": "What is the difference between a JavaScript class and a constructor function?",
            "answer": "```markdown\n### Difference Between a JavaScript Class and a Constructor Function\n\nIn JavaScript, both classes and constructor functions are used to create objects, but they have some key differences:\n\n1. **Syntax**:\n   - A class is a syntactic sugar introduced in ES6 that provides a cleaner and more structured way to define object blueprints.\n   - A constructor function is an older way of creating objects using regular functions.\n\n   ```javascript\n   // Class Example\n   class Person {\n       constructor(name, age) {\n           this.name = name;\n           this.age = age;\n       }\n\n       greet() {\n           console.log(`Hello, my name is ${this.name}`);\n       }\n   }\n\n   // Constructor Function Example\n   function Person(name, age) {\n       this.name = name;\n       this.age = age;\n   }\n\n   Person.prototype.greet = function() {\n       console.log(`Hello, my name is ${this.name}`);\n   };\n   ```\n\n2. **Inheritance**:\n   - Classes use the `extends` keyword and the `super()` function to handle inheritance, making it more intuitive.\n   - Constructor functions use `Object.create()` or `prototype` chaining for inheritance, which can be more verbose and less straightforward.\n\n   ```javascript\n   // Class Inheritance\n   class Employee extends Person {\n       constructor(name, age, job) {\n           super(name, age);\n           this.job = job;\n       }\n   }\n\n   // Constructor Function Inheritance\n   function Employee(name, age, job) {\n       Person.call(this, name, age);\n       this.job = job;\n   }\n\n   Employee.prototype = Object.create(Person.prototype);\n   Employee.prototype.constructor = Employee;\n   ```\n\n3. **`class` is not hoisted**:\n   - Classes are not hoisted, meaning you cannot use a class before it is defined.\n   - Constructor functions are hoisted, so they can be used before their definition (though this is not recommended).\n\n   ```javascript\n   // Class Example (Throws an error)\n   const obj = new MyClass(); // ReferenceError\n   class MyClass {}\n\n   // Constructor Function Example (Works)\n   const obj2 = new MyFunction();\n   function MyFunction() {}\n   ```\n\n4. **Strict Mode**:\n   - Classes always operate in strict mode, even if you don't explicitly enable it.\n   - Constructor functions do not enforce strict mode unless you explicitly enable it with `\"use strict\"`.\n\n5. **Static Methods**:\n   - Classes allow you to define static methods directly using the `static` keyword.\n   - In constructor functions, static methods are added manually to the constructor itself.\n\n   ```javascript\n   // Class Static Method\n   class Person {\n       static sayHello() {\n           console.log(\"Hello from Person class\");\n       }\n   }\n\n   // Constructor Function Static Method\n   function Person() {}\n   Person.sayHello = function() {\n       console.log(\"Hello from Person function\");\n   };\n   ```\n\n6. **Readability and Modern Features**:\n   - Classes provide a more readable and modern syntax, making the code easier to understand and maintain.\n   - Constructor functions rely on older patterns and can be less intuitive for developers familiar with modern JavaScript.\n\n### Conclusion\nWhile both classes and constructor functions achieve similar outcomes, classes are the preferred approach in modern JavaScript due to their cleaner syntax, built-in features like inheritance, and alignment with modern programming paradigms.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553474Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "850d5c92-926b-4303-89f0-88ac5dd3c0d2",
            "question": "What is the purpose of the JavaScript async generator functions?",
            "answer": "```markdown\n### Purpose of JavaScript Async Generator Functions\n\nAsync generator functions in JavaScript are used to handle asynchronous iteration. They allow you to work with streams of data that are produced asynchronously, such as fetching data from an API in chunks or processing events over time. These functions combine the capabilities of `async` functions and generator functions, enabling you to yield promises and wait for their resolution during iteration.\n\n#### Key Features:\n1. **Asynchronous Iteration**: Async generator functions return an `AsyncGenerator` object, which can be iterated using the `for await...of` loop. This allows you to process asynchronous data sequentially.\n2. **Non-blocking Execution**: They enable non-blocking code execution while waiting for asynchronous operations to complete, improving performance and responsiveness.\n3. **Streamlined Data Handling**: Useful for scenarios like reading files, processing streams, or fetching paginated API data.\n\n#### Syntax:\n```javascript\nasync function* asyncGenerator() {\n  const data = [1, 2, 3];\n  for (const item of data) {\n    await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate async operation\n    yield item;\n  }\n}\n\n(async () => {\n  for await (const value of asyncGenerator()) {\n    console.log(value); // Logs 1, 2, 3 with a 1-second delay between each\n  }\n})();\n```\n\n#### Use Cases:\n- Fetching data in chunks (e.g., paginated API responses).\n- Processing real-time data streams (e.g., WebSocket messages).\n- Handling large datasets incrementally to avoid memory overload.\n\nAsync generator functions provide a powerful and elegant way to manage asynchronous workflows in JavaScript, especially when dealing with iterable data sources.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553482Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "6315bddd-ccd9-475a-9e75-9096ee22ee5e",
            "question": "What is the difference between event capturing and event bubbling in JavaScript?",
            "answer": "```markdown\nIn JavaScript, event capturing and event bubbling are two phases of event propagation in the DOM (Document Object Model).\n\n### Event Capturing (Capture Phase)\n- Event capturing, also known as the \"trickling phase,\" is the process where the event starts from the outermost element (ancestor) and propagates down to the target element.\n- In this phase, the event listener on the outer elements is triggered before the inner elements.\n- To use event capturing, the `addEventListener` method's third parameter (or `options` object) must be set to `true`:\n  ```javascript\n  element.addEventListener('click', handler, true);\n  ```\n\n### Event Bubbling (Bubble Phase)\n- Event bubbling is the process where the event starts from the target element and propagates up to the outermost ancestor element.\n- In this phase, the event listener on the inner elements is triggered before the outer elements.\n- By default, event listeners in JavaScript use the bubbling phase unless specified otherwise:\n  ```javascript\n  element.addEventListener('click', handler);\n  ```\n\n### Key Differences\n| Aspect                | Event Capturing                     | Event Bubbling                      |\n|-----------------------|--------------------------------------|-------------------------------------|\n| Propagation Direction | Outer to inner (ancestor to target) | Inner to outer (target to ancestor) |\n| Default Behavior      | Not default, must be explicitly set | Default behavior in JavaScript      |\n| Use Case             | Useful for intercepting events early | Useful for handling events at the target or higher levels |\n\n### Example\n```javascript\n// HTML structure\n// <div id=\"parent\">\n//   <button id=\"child\">Click Me</button>\n// </div>\n\nconst parent = document.getElementById('parent');\nconst child = document.getElementById('child');\n\n// Event listener in capturing phase\nparent.addEventListener('click', () => {\n  console.log('Parent clicked (capturing phase)');\n}, true);\n\n// Event listener in bubbling phase\nchild.addEventListener('click', () => {\n  console.log('Child clicked (bubbling phase)');\n});\n```\n\n### Output when the button is clicked:\n1. \"Parent clicked (capturing phase)\" (capturing phase)\n2. \"Child clicked (bubbling phase)\" (bubbling phase)\n```\n\nThis explanation highlights the differences and provides an example for better understanding.",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553491Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "f86ce0a1-71a5-49f2-9a23-725cafffcf7c",
            "question": "What is the purpose of the JavaScript fetch() API?",
            "answer": "```markdown\nThe `fetch()` API in JavaScript is used to make network requests to retrieve resources, such as data from a server. It provides a modern, promise-based approach to handling HTTP requests and responses, making it easier to work with asynchronous operations compared to older methods like `XMLHttpRequest`.\n\n### Key Features of `fetch()`:\n1. **Promise-based**: It returns a `Promise` that resolves to the `Response` object, allowing you to handle success and error cases using `.then()` and `.catch()`.\n2. **Simplified Syntax**: The API is straightforward and easier to read compared to older alternatives.\n3. **Supports Modern Features**: It supports features like streaming responses, custom headers, and request methods (GET, POST, PUT, DELETE, etc.).\n4. **Cross-Origin Requests**: It adheres to the same-origin policy and supports CORS (Cross-Origin Resource Sharing) for secure cross-origin requests.\n\n### Example Usage:\n```javascript\nfetch('https://api.example.com/data')\n  .then(response => {\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    return response.json(); // Parse the JSON data from the response\n  })\n  .then(data => {\n    console.log(data); // Handle the fetched data\n  })\n  .catch(error => {\n    console.error('There was a problem with the fetch operation:', error);\n  });\n```\n\n### Notes:\n- The `fetch()` API does not reject the promise on HTTP errors (e.g., 404 or 500). You need to manually check the `response.ok` property to handle such cases.\n- It is widely supported in modern browsers but may require polyfills for older environments.\n\nThe `fetch()` API is a powerful tool for making HTTP requests and is commonly used in web development for interacting with REST APIs.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553500Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "d5a0b978-d1fb-40a2-ada1-dfc7e9f3785a",
            "question": "What is the difference between JSON.stringify() and JSON.parse() in JavaScript?",
            "answer": "```markdown\nIn JavaScript, `JSON.stringify()` and `JSON.parse()` are methods used to work with JSON (JavaScript Object Notation) data:\n\n1. **`JSON.stringify()`**:\n   - Converts a JavaScript object or value into a JSON string.\n   - Commonly used to prepare data for storage or transmission (e.g., sending data to a server).\n   - Example:\n     ```javascript\n     const obj = { name: \"Alice\", age: 25 };\n     const jsonString = JSON.stringify(obj);\n     console.log(jsonString); // Output: '{\"name\":\"Alice\",\"age\":25}'\n     ```\n\n2. **`JSON.parse()`**:\n   - Converts a JSON string back into a JavaScript object.\n   - Commonly used to parse JSON data received from a server or other sources.\n   - Example:\n     ```javascript\n     const jsonString = '{\"name\":\"Alice\",\"age\":25}';\n     const obj = JSON.parse(jsonString);\n     console.log(obj); // Output: { name: 'Alice', age: 25 }\n     ```\n\nIn summary:\n- Use `JSON.stringify()` to convert an object to a JSON string.\n- Use `JSON.parse()` to convert a JSON string back to an object.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553508Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "aa4af8ac-c353-4c6a-bf15-fdb77de648e7",
            "question": "What are JavaScript template literals and how are they used?",
            "answer": "```markdown\n### What are JavaScript Template Literals and How Are They Used?\n\nTemplate literals are a feature in JavaScript introduced in ES6 that allow for easier creation of strings. They are enclosed by backticks (`` ` ``) instead of single or double quotes and provide enhanced functionality, such as:\n\n1. **String Interpolation**: Embedding expressions directly into strings using the `${expression}` syntax.\n2. **Multiline Strings**: Creating strings that span multiple lines without needing escape characters.\n3. **Tagged Templates**: Custom processing of template literals using a function.\n\n#### Syntax\n```javascript\nconst name = \"John\";\nconst age = 30;\n\n// String Interpolation\nconst greeting = `Hello, my name is ${name} and I am ${age} years old.`;\nconsole.log(greeting); // Output: Hello, my name is John and I am 30 years old.\n\n// Multiline Strings\nconst multiline = `This is a string\nthat spans multiple\nlines.`;\nconsole.log(multiline);\n\n// Tagged Templates\nfunction tagExample(strings, ...values) {\n  console.log(strings); // Array of string literals\n  console.log(values); // Array of interpolated values\n}\n\nconst result = tagExample`Hello, ${name}! You are ${age} years old.`;\n```\n\nTemplate literals make string manipulation more readable and concise compared to traditional string concatenation.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553517Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "b8ae8cd2-d6cb-4bf4-943f-b3d2c586fa99",
            "question": "What is the purpose of the JavaScript Promise.all() method?",
            "answer": "```markdown\nThe `Promise.all()` method in JavaScript is used to execute multiple promises concurrently and aggregate their results. It takes an array (or any iterable) of promises as input and returns a single promise that resolves when all the promises in the array have resolved or rejects if any of the promises in the array reject.\n\n### Key Points:\n1. **Resolve Behavior**: The returned promise resolves with an array of the results of the input promises, in the same order as the input.\n2. **Reject Behavior**: If any promise in the array rejects, the returned promise immediately rejects with the reason of the first rejected promise.\n3. **Concurrency**: All promises are executed concurrently, not sequentially.\n\n### Example:\n```javascript\nconst promise1 = Promise.resolve(10);\nconst promise2 = Promise.resolve(20);\nconst promise3 = Promise.resolve(30);\n\nPromise.all([promise1, promise2, promise3])\n  .then(results => {\n    console.log(results); // Output: [10, 20, 30]\n  })\n  .catch(error => {\n    console.error(error); // If any promise rejects, this will handle the error.\n  });\n```\n\n### Use Case:\n`Promise.all()` is useful when you need to wait for multiple asynchronous operations to complete before proceeding, such as fetching data from multiple APIs or performing batch operations.\n\n### Note:\nIf the input array is empty, `Promise.all()` resolves immediately with an empty array.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553525Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "9664273e-9df0-4215-844b-2672157a5de4",
            "question": "What is the difference between a JavaScript Map and an Object?",
            "answer": "```markdown\n### Difference Between a JavaScript Map and an Object\n\nJavaScript `Map` and `Object` are both used to store key-value pairs, but they have significant differences:\n\n1. **Key Types**:\n   - **Map**: Keys can be of any data type, including objects, functions, and primitives.\n   - **Object**: Keys are always strings or symbols. Non-string keys are automatically converted to strings.\n\n2. **Key Order**:\n   - **Map**: Keys are ordered in the order they were added.\n   - **Object**: Keys are not guaranteed to maintain insertion order (though modern JavaScript engines often do for string keys).\n\n3. **Performance**:\n   - **Map**: Optimized for frequent additions and removals of key-value pairs.\n   - **Object**: May have slower performance for these operations due to its additional features like prototype inheritance.\n\n4. **Size Property**:\n   - **Map**: Has a `size` property that directly returns the number of key-value pairs.\n   - **Object**: Requires manual calculation of size using `Object.keys(obj).length`.\n\n5. **Iteration**:\n   - **Map**: Iterates directly using methods like `map.keys()`, `map.values()`, or `map.entries()`. It also supports `for...of` iteration.\n   - **Object**: Requires manual iteration using `for...in` or `Object.keys(obj)`.\n\n6. **Prototype Inheritance**:\n   - **Map**: Does not have a prototype chain affecting its keys.\n   - **Object**: Inherits from `Object.prototype`, which may lead to unintended key collisions unless `Object.create(null)` is used.\n\n7. **Use Cases**:\n   - **Map**: Preferred when you need a collection of key-value pairs with guaranteed order and diverse key types.\n   - **Object**: Better suited for structured data or when working with JSON-like data.\n\n### Example:\n\n```javascript\n// Using a Map\nconst map = new Map();\nmap.set('key1', 'value1');\nmap.set(42, 'value2');\nconsole.log(map.get(42)); // Output: 'value2'\n\n// Using an Object\nconst obj = {};\nobj['key1'] = 'value1';\nobj[42] = 'value2'; // Key is converted to string '42'\nconsole.log(obj[42]); // Output: 'value2'\n```\n\nIn summary, `Map` is more versatile and efficient for managing key-value pairs, while `Object` is better for traditional data structures and compatibility with JSON.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:52:50.553535Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "6e6e5f43-b928-4b38-bce3-92ff5a29806c",
            "question": "What is the purpose of the JavaScript Reflect API?",
            "answer": "The JavaScript Reflect API is a built-in object introduced in ECMAScript 2015 (ES6) that provides a set of static methods for performing common object operations. Its primary purpose is to offer a more predictable and functional way to interact with objects, while also complementing the `Proxy` object by exposing methods that are internally used by JavaScript.\n\n### Key Purposes of the Reflect API:\n1. **Standardized Object Operations**:  \n   Reflect provides methods for tasks like property manipulation, function invocation, and object construction, which were previously handled using `Object` methods or direct operations. For example:\n   - `Reflect.get()` for accessing properties.\n   - `Reflect.set()` for setting properties.\n   - `Reflect.deleteProperty()` for deleting properties.\n\n2. **Improved Consistency**:  \n   Reflect methods return `true` or `false` to indicate success or failure, instead of throwing errors in certain cases. This makes error handling more predictable.\n\n3. **Proxy Integration**:  \n   The Reflect API is designed to work seamlessly with the `Proxy` object. It allows developers to call default behavior within proxy traps, ensuring that proxies can mimic or extend native object behavior.\n\n4. **Functional Programming Style**:  \n   Reflect methods are purely functional and do not rely on the context (`this`), making them easier to use in functional programming paradigms.\n\n### Example Usage:\n```javascript\nconst obj = { name: 'Alice' };\n\n// Using Reflect to get a property\nconsole.log(Reflect.get(obj, 'name')); // Output: Alice\n\n// Using Reflect to set a property\nReflect.set(obj, 'age', 25);\nconsole.log(obj.age); // Output: 25\n\n// Using Reflect to delete a property\nReflect.deleteProperty(obj, 'name');\nconsole.log(obj.name); // Output: undefined\n```\n\n### Common Reflect Methods:\n- `Reflect.get(target, propertyKey[, receiver])`\n- `Reflect.set(target, propertyKey, value[, receiver])`\n- `Reflect.has(target, propertyKey)`\n- `Reflect.deleteProperty(target, propertyKey)`\n- `Reflect.ownKeys(target)`\n- `Reflect.apply(target, thisArgument, argumentsList)`\n- `Reflect.construct(target, argumentsList[, newTarget])`\n- `Reflect.defineProperty(target, propertyKey, attributes)`\n- `Reflect.getOwnPropertyDescriptor(target, propertyKey)`\n\n### Advantages:\n- Provides a unified interface for object operations.\n- Simplifies working with proxies.\n- Reduces the need for custom error handling by returning boolean values for success/failure.\n\nIn summary, the Reflect API enhances the way developers interact with objects by offering a consistent, functional, and proxy-friendly set of methods for common operations.",
            "level": "Advanced",
            "created_at": "2025-03-28T17:52:50.553544Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        },
        {
            "id": "cbff8e6d-3936-4fa9-b335-b6f9ad343755",
            "question": "What is the difference between a stack and a queue in JavaScript?",
            "answer": "```markdown\nIn JavaScript, a **stack** and a **queue** are data structures used to manage collections of data, but they operate differently in terms of how elements are added and removed:\n\n1. **Stack**:\n   - Follows the **LIFO** (Last In, First Out) principle.\n   - The last element added to the stack is the first one to be removed.\n   - Common methods:\n     - `push()`: Adds an element to the top of the stack.\n     - `pop()`: Removes the top element from the stack.\n\n   Example:\n   ```javascript\n   let stack = [];\n   stack.push(1); // [1]\n   stack.push(2); // [1, 2]\n   stack.pop();   // [1] (removes 2)\n   ```\n\n2. **Queue**:\n   - Follows the **FIFO** (First In, First Out) principle.\n   - The first element added to the queue is the first one to be removed.\n   - Common methods:\n     - `push()`: Adds an element to the end of the queue.\n     - `shift()`: Removes the first element from the queue.\n\n   Example:\n   ```javascript\n   let queue = [];\n   queue.push(1); // [1]\n   queue.push(2); // [1, 2]\n   queue.shift(); // [2] (removes 1)\n   ```\n\nIn summary, a stack removes elements from the top (last added), while a queue removes elements from the front (first added).\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:52:50.553553Z",
            "topic": "97892842-6ded-4b1d-b8db-95a54a72d66e"
        }
    ]
}