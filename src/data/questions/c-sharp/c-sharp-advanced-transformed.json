[
  {
    "id": "8cce5da0-a64b-4bcd-bfae-70316565a157",
    "question": "What is the difference between shallow copy and deep copy in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, the difference between shallow copy and deep copy lies in how the objects and their references are duplicated:\n\n### Shallow Copy\n- A shallow copy creates a new object, but it copies only the references of the objects contained within the original object.\n- If the original object contains references to other objects, the shallow copy will point to the same references. Changes made to the referenced objects will affect both the original and the copied object.\n- It is typically created using the `MemberwiseClone()` method.\n\n**Example:**"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class Person\n{\n    public string Name { get; set; }\n    public Address Address { get; set; }\n}\n\nclass Address\n{\n    public string City { get; set; }\n}\n\nPerson original = new Person\n{\n    Name = \"John\",\n    Address = new Address { City = \"New York\" }\n};\n\nPerson shallowCopy = (Person)original.MemberwiseClone();\nshallowCopy.Address.City = \"Los Angeles\";\n\nConsole.WriteLine(original.Address.City); // Output: Los Angeles"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class Person\n{\n    public string Name { get; set; }\n    public Address Address { get; set; }\n\n    public Person DeepCopy()\n    {\n        return new Person\n        {\n            Name = this.Name,\n            Address = new Address { City = this.Address.City }\n        };\n    }\n}\n\nclass Address\n{\n    public string City { get; set; }\n}\n\nPerson original = new Person\n{\n    Name = \"John\",\n    Address = new Address { City = \"New York\" }\n};\n\nPerson deepCopy = original.DeepCopy();\ndeepCopy.Address.City = \"Los Angeles\";\n\nConsole.WriteLine(original.Address.City); // Output: New York"
      }
    ]
  },
  {
    "id": "c3ddf64a-16a5-491a-8802-27f7cb478461",
    "question": "What is the difference between a class and a struct in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, the primary differences between a class and a struct are:\n\n1. **Type**:\n   - A class is a reference type, meaning it is allocated on the heap, and variables hold a reference to the memory location.\n   - A struct is a value type, meaning it is allocated on the stack, and variables hold the actual data.\n\n2. **Memory Management**:\n   - Classes are garbage-collected, which means the runtime manages their memory.\n   - Structs are not garbage-collected; they are automatically deallocated when they go out of scope.\n\n3. **Inheritance**:\n   - Classes support inheritance, allowing you to create derived classes.\n   - Structs do not support inheritance but can implement interfaces.\n\n4. **Default Constructor**:\n   - Classes can have explicit parameterless constructors defined by the programmer.\n   - Structs cannot have explicit parameterless constructors; they always have an implicit parameterless constructor provided by the compiler.\n\n5. **Performance**:\n   - Structs are generally more efficient for small, lightweight objects because they avoid heap allocation and garbage collection overhead.\n   - Classes are better suited for large, complex objects or scenarios where polymorphism is required.\n\n6. **Nullability**:\n   - Class instances can be null.\n   - Struct instances cannot be null unless they are declared as nullable (e.g., `int?`).\n\n7. **Usage**:\n   - Use classes for objects that represent entities with complex behavior or require inheritance.\n   - Use structs for small, immutable data structures that represent a single value or concept.\n\nExample:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Class example\npublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n\n// Struct example\npublic struct Point\n{\n    public int X { get; set; }\n    public int Y { get; set; }\n}"
      }
    ]
  },
  {
    "id": "a4dca500-409e-4872-89c5-def5e1ff21d3",
    "question": "Explain the concept of properties in C# and how they are used.",
    "answer": [
      {
        "type": "text",
        "content": "### Properties in C#\n\nIn C#, properties are members of a class that provide a flexible mechanism to read, write, or compute the values of private fields. They act as a bridge between private fields and the outside world, allowing controlled access to the data while maintaining encapsulation.\n\nA property typically has two accessors:\n- **Getter (`get`)**: Used to retrieve the value of a private field.\n- **Setter (`set`)**: Used to assign a value to a private field.\n\nProperties can be:\n1. **Read-Only**: Only have a `get` accessor.\n2. **Write-Only**: Only have a `set` accessor.\n3. **Read-Write**: Have both `get` and `set` accessors.\n\n#### Syntax"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class Example\n{\n    private int _number; // Private field\n\n    // Property with both get and set accessors\n    public int Number\n    {\n        get { return _number; } // Getter\n        set { _number = value; } // Setter\n    }\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Example example = new Example();\nexample.Number = 10; // Using the setter\nConsole.WriteLine(example.Number); // Using the getter"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class Example\n{\n    public int Number { get; set; } // Auto-implemented property\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class Example\n{\n    private int _age;\n\n    public int Age\n    {\n        get { return _age; }\n        set\n        {\n            if (value < 0)\n                throw new ArgumentException(\"Age cannot be negative\");\n            _age = value;\n        }\n    }\n}"
      }
    ]
  },
  {
    "id": "202f30c4-feb4-4ebd-825f-3a421d0a2ad4",
    "question": "What is the purpose of the 'using' statement in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `using` statement in C# serves two primary purposes:\n\n1. **Namespace Inclusion**: It allows you to include namespaces in your code, making it easier to access classes, methods, and other members without needing to specify their fully qualified names. For example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using System;\n   class Program\n   {\n       static void Main()\n       {\n           Console.WriteLine(\"Hello, World!\");\n       }\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using (var file = new StreamWriter(\"example.txt\"))\n   {\n       file.WriteLine(\"Hello, World!\");\n   }\n   // The StreamWriter object is automatically disposed of here."
      }
    ]
  },
  {
    "id": "7e552a46-f196-4cc1-be90-d9698e3581b0",
    "question": "What are nullable types in C# and how do you use them?",
    "answer": [
      {
        "type": "text",
        "content": "### Nullable Types in C#\n\nNullable types in C# allow value types (e.g., `int`, `double`, `bool`, etc.) to represent `null` values. Normally, value types cannot be assigned `null`, but nullable types provide a way to indicate the absence of a value.\n\n#### Syntax\nA nullable type is declared using the `?` symbol after the value type. For example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int? nullableInt = null;"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int? age = null;\n\nif (age.HasValue)\n{\n    Console.WriteLine($\"Age is {age.Value}\");\n}\nelse\n{\n    Console.WriteLine(\"Age is not specified.\");\n}\n\n// Assigning a value\nage = 25;\n\nif (age.HasValue)\n{\n    Console.WriteLine($\"Age is {age.Value}\");\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int? nullableInt = null;\nint result = nullableInt ?? 0; // result will be 0"
      }
    ]
  },
  {
    "id": "ac592527-97ae-457a-bf94-d3210ae11dc4",
    "question": "What is the difference between 'ref' and 'out' keywords in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both `ref` and `out` are used to pass arguments by reference to a method. However, there are key differences between them:\n\n1. **Initialization Requirement**:\n   - `ref`: The variable must be initialized before it is passed to the method.\n   - `out`: The variable does not need to be initialized before being passed to the method. However, it must be assigned a value within the method before the method returns.\n\n2. **Purpose**:\n   - `ref`: Used when the method needs to read and modify the value of the variable.\n   - `out`: Used when the method is expected to assign a value to the variable and return it to the caller.\n\n3. **Usage**:\n   - `ref`: Indicates that the variable is already holding a value that might be modified by the method.\n   - `out`: Indicates that the variable is intended to be used as an output parameter.\n\n4. **Example**:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Using ref\n   void ModifyValue(ref int number)\n   {\n       number += 10;\n   }\n\n   int value = 5;\n   ModifyValue(ref value); // value becomes 15\n\n   // Using out\n   void GetValues(out int result)\n   {\n       result = 42; // Must assign a value before returning\n   }\n\n   int output;\n   GetValues(out output); // output is now 42"
      }
    ]
  },
  {
    "id": "25ecbfb3-febc-4fe2-8dff-ed88014513f7",
    "question": "What is the difference between an abstract class and an interface in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both abstract classes and interfaces are used to define contracts for other classes to implement, but they have key differences:\n\n1. **Definition**:\n   - An **abstract class** is a class that cannot be instantiated and may contain abstract methods (methods without implementation) as well as concrete methods (methods with implementation).\n   - An **interface** is a completely abstract type that can only contain method signatures, properties, events, or indexers without any implementation.\n\n2. **Implementation**:\n   - A class can inherit from only one abstract class (single inheritance).\n   - A class can implement multiple interfaces (multiple inheritance).\n\n3. **Members**:\n   - Abstract classes can have fields, constructors, destructors, and access modifiers for its members.\n   - Interfaces cannot have fields, constructors, or destructors, and all members are implicitly public.\n\n4. **Default Implementation**:\n   - Abstract classes can provide default implementations for some methods.\n   - Interfaces (starting from C# 8.0) can also provide default implementations using `default` methods, but this is limited compared to abstract classes.\n\n5. **Use Case**:\n   - Use an abstract class when classes share common functionality or state.\n   - Use an interface when you want to define a contract that multiple unrelated classes can implement.\n\n**Example**:\n\nAbstract Class:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public abstract class Animal\n{\n    public abstract void Speak(); // Abstract method\n    public void Eat() // Concrete method\n    {\n        Console.WriteLine(\"Eating...\");\n    }\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public interface IAnimal\n{\n    void Speak(); // Method signature\n    void Eat();   // Method signature\n}"
      }
    ]
  },
  {
    "id": "e8f485e6-bed7-4e1c-bada-9ec47e9ad67d",
    "question": "What is the purpose of the 'static' keyword in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `static` keyword in C# is used to declare members (fields, methods, properties, etc.) or classes that belong to the type itself rather than to any specific instance of the type. This means:\n\n1. **Static Members**: A static member is shared across all instances of a class and can be accessed without creating an object of the class. For example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n   {\n       public static int Counter = 0;\n   }\n\n   // Accessing the static member\n   int count = Example.Counter;"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public static class MathHelper\n   {\n       public static int Add(int a, int b)\n       {\n           return a + b;\n       }\n   }\n\n   // Using the static class\n   int result = MathHelper.Add(5, 3);"
      }
    ]
  },
  {
    "id": "789a4163-2011-42c3-9677-7e87c8c6d92b",
    "question": "What is the difference between 'const' and 'readonly' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both `const` and `readonly` are used to define values that cannot be modified after their assignment, but there are key differences between them:\n\n1. **`const`**:\n   - The value of a `const` field is set at compile time and cannot be changed afterward.\n   - It is implicitly static, meaning it belongs to the type, not an instance of the type.\n   - Only primitive types, enums, or string literals can be declared as `const`.\n   - Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public const int MaxValue = 100;"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public readonly int MaxValue;\n\n     public MyClass(int value)\n     {\n         MaxValue = value;\n     }"
      }
    ]
  },
  {
    "id": "3072963a-6199-4e61-9607-ccbdcf8a8c38",
    "question": "What are generics in C# and why are they useful?",
    "answer": [
      {
        "type": "text",
        "content": "### Generics in C# and Their Usefulness\n\nGenerics in C# allow you to define classes, methods, interfaces, and delegates with a placeholder for the type of data they store or use. This placeholder is specified using type parameters, which are defined when the generic type or method is instantiated.\n\n#### Key Features of Generics:\n1. **Type Safety**: Generics ensure type safety by allowing you to work with strongly-typed objects without the need for explicit casting or boxing/unboxing.\n2. **Code Reusability**: You can create a single generic class or method that works with any data type, reducing code duplication.\n3. **Performance**: Generics eliminate the need for boxing and unboxing (in the case of value types), improving performance.\n4. **Compile-Time Errors**: Errors related to type mismatches are caught at compile time, reducing runtime errors.\n\n#### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Generic class\npublic class GenericList<T>\n{\n    private List<T> items = new List<T>();\n\n    public void Add(T item)\n    {\n        items.Add(item);\n    }\n\n    public T Get(int index)\n    {\n        return items[index];\n    }\n}\n\n// Usage\nGenericList<int> intList = new GenericList<int>();\nintList.Add(10);\nint value = intList.Get(0);\n\nGenericList<string> stringList = new GenericList<string>();\nstringList.Add(\"Hello\");\nstring text = stringList.Get(0);"
      }
    ]
  },
  {
    "id": "c302ed26-b780-4f96-a3dc-6c34c80a7c99",
    "question": "What is a delegate in C# and how is it used?",
    "answer": [
      {
        "type": "text",
        "content": "A delegate in C# is a type that represents references to methods with a specific signature and return type. It is similar to a function pointer in C or C++, but it is type-safe and object-oriented. Delegates are used to pass methods as arguments to other methods, define callback methods, and implement event handling.\n\n### Key Features of Delegates:\n1. **Type Safety**: Delegates ensure that the method signature matches the delegate's signature.\n2. **Multicast Support**: A delegate can reference multiple methods, allowing invocation of multiple methods in a single call.\n3. **Encapsulation**: Delegates encapsulate method references, making them flexible and reusable.\n\n### Syntax:\nTo declare a delegate:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public delegate void MyDelegate(string message);"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using System;\n\npublic class Program\n{\n    // Step 1: Declare a delegate\n    public delegate void DisplayMessage(string message);\n\n    // Step 2: Define a method matching the delegate signature\n    public static void ShowMessage(string message)\n    {\n        Console.WriteLine(message);\n    }\n\n    public static void Main()\n    {\n        // Step 3: Instantiate the delegate\n        DisplayMessage del = new DisplayMessage(ShowMessage);\n\n        // Step 4: Invoke the delegate\n        del(\"Hello, Delegates!\");\n    }\n}"
      }
    ]
  },
  {
    "id": "2ba49c35-63cb-4677-8d7f-8c2a1d391e9d",
    "question": "What is the difference between 'is' and 'as' operators in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, the `is` and `as` operators are used for type checking and type conversion, but they serve different purposes:\n\n### `is` Operator\n- The `is` operator is used to check if an object is of a specific type.\n- It returns a boolean value (`true` or `false`).\n- It does not perform any type conversion.\n\n**Example:**"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "object obj = \"Hello, World!\";\nif (obj is string)\n{\n    Console.WriteLine(\"obj is a string.\");\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "object obj = \"Hello, World!\";\nstring str = obj as string;\nif (str != null)\n{\n    Console.WriteLine(\"obj was successfully cast to a string.\");\n}"
      }
    ]
  },
  {
    "id": "f4d15ef3-239c-4218-ada6-a9b5779005be",
    "question": "What is LINQ in C# and how does it work?",
    "answer": [
      {
        "type": "text",
        "content": "### What is LINQ in C# and How Does it Work?\n\nLINQ (Language Integrated Query) in C# is a powerful feature that allows developers to query data from various data sources (like collections, databases, XML, etc.) in a consistent and readable manner. It integrates query capabilities directly into the C# language, enabling developers to write queries using syntax similar to SQL.\n\n#### How LINQ Works:\n1. **Data Source**: LINQ works with any enumerable data source, such as arrays, lists, XML, or databases (via LINQ to SQL or Entity Framework).\n2. **Query Creation**: A LINQ query is written using query syntax or method syntax. The query is defined but not executed immediately (deferred execution).\n3. **Query Execution**: When the query is iterated (e.g., using a `foreach` loop), LINQ executes the query and retrieves the results.\n\n#### Key Components of LINQ:\n- **Query Syntax**: A declarative way to write queries, similar to SQL."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "var result = from item in collection\n               where item.Property > 10\n               select item;"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "var result = collection.Where(item => item.Property > 10)\n                         .Select(item => item);"
      }
    ]
  },
  {
    "id": "b9d4458e-cef7-4335-a0cc-3bcd81c00d97",
    "question": "Explain the concept of extension methods in C#.",
    "answer": [
      {
        "type": "text",
        "content": "### Extension Methods in C#\n\nExtension methods in C# are a way to add new methods to existing types without modifying their source code or creating a new derived type. They allow developers to \"extend\" the functionality of a class, struct, or interface in a clean and reusable manner.\n\n#### Key Points:\n1. **Static Class Requirement**: Extension methods must be defined in a static class.\n2. **Static Method**: The method itself must also be static.\n3. **`this` Keyword**: The first parameter of the extension method specifies the type it operates on and is prefixed with the `this` keyword.\n4. **Usage**: Once defined, the extension method can be called as if it were a regular instance method on the type being extended.\n\n#### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Define an extension method in a static class\npublic static class StringExtensions\n{\n    // Extension method to count words in a string\n    public static int WordCount(this string str)\n    {\n        if (string.IsNullOrWhiteSpace(str))\n            return 0;\n\n        return str.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;\n    }\n}\n\n// Usage of the extension method\nclass Program\n{\n    static void Main()\n    {\n        string sentence = \"Hello, this is an example of an extension method.\";\n        int wordCount = sentence.WordCount(); // Call the extension method\n        Console.WriteLine($\"Word Count: {wordCount}\");\n    }\n}"
      }
    ]
  },
  {
    "id": "11f6eded-ee01-4ae8-be81-3b85145bdd12",
    "question": "What is the difference between IEnumerable and IQueryable in C#?",
    "answer": [
      {
        "type": "text",
        "content": "### Difference Between `IEnumerable` and `IQueryable` in C#\n\n#### 1. **Definition**\n   - **IEnumerable**: Represents a forward-only collection of objects that can be enumerated. It is defined in the `System.Collections` namespace.\n   - **IQueryable**: Represents a collection of data that can be queried using LINQ. It is defined in the `System.Linq` namespace and extends `IEnumerable`.\n\n#### 2. **Execution**\n   - **IEnumerable**: Executes the query on the client side. The entire data is loaded into memory, and then the filtering or processing is performed.\n   - **IQueryable**: Executes the query on the server side (e.g., in a database). Only the filtered data is retrieved, which can improve performance for large datasets.\n\n#### 3. **Use Case**\n   - **IEnumerable**: Suitable for in-memory collections like arrays, lists, or other data structures.\n   - **IQueryable**: Suitable for querying data from external sources like databases using LINQ-to-SQL or Entity Framework.\n\n#### 4. **Deferred Execution**\n   - **IEnumerable**: Supports deferred execution, but the query is executed in memory.\n   - **IQueryable**: Also supports deferred execution, but the query is translated into a database-specific query (e.g., SQL) and executed on the server.\n\n#### 5. **Query Customization**\n   - **IEnumerable**: LINQ queries are executed in memory, and the filtering logic is applied after retrieving all the data.\n   - **IQueryable**: LINQ queries are translated into SQL or other query languages, allowing the filtering logic to be applied at the data source.\n\n#### 6. **Performance**\n   - **IEnumerable**: Less efficient for large datasets as it retrieves all data into memory before applying filters.\n   - **IQueryable**: More efficient for large datasets as it retrieves only the required data from the source.\n\n#### Example"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Using IEnumerable\nIEnumerable<Product> products = db.Products.ToList(); // Loads all data into memory\nvar filteredProducts = products.Where(p => p.Price > 100); // Filtering happens in memory\n\n// Using IQueryable\nIQueryable<Product> productsQuery = db.Products; // Query is not executed yet\nvar filteredProductsQuery = productsQuery.Where(p => p.Price > 100); // Filtering happens in the database"
      }
    ]
  },
  {
    "id": "3a18a184-49bf-43bc-9718-15faeec10053",
    "question": "What is the purpose of the 'yield' keyword in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `yield` keyword in C# is used to simplify the implementation of iterators. It allows you to create an enumerable sequence of values without the need to explicitly implement the `IEnumerator` or `IEnumerable` interfaces. When a `yield return` statement is encountered, the current value is returned to the caller, and the state of the iterator is preserved. This enables the method to resume execution from the same point when the next value in the sequence is requested.\n\n### Key Points:\n1. **Simplifies Iterators**: Eliminates the need for manually managing the state of the iteration.\n2. **Deferred Execution**: The sequence is generated on demand, which can improve performance and reduce memory usage.\n3. **State Preservation**: The method retains its state between calls, allowing it to continue from where it left off.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public IEnumerable<int> GetNumbers()\n{\n    for (int i = 1; i <= 5; i++)\n    {\n        yield return i; // Returns the current value and pauses execution\n    }\n}\n\n// Usage\nforeach (var number in GetNumbers())\n{\n    Console.WriteLine(number);\n}"
      }
    ]
  },
  {
    "id": "2beb378d-4d53-4dac-9821-6ec7e839fa32",
    "question": "Explain the concept of covariance and contravariance in C#.",
    "answer": [
      {
        "type": "text",
        "content": "### Covariance and Contravariance in C#\n\nCovariance and contravariance are concepts in C# that allow for more flexible assignment compatibility and method parameter passing in the context of generics, delegates, and arrays. They enable you to use derived types and base types interchangeably in certain scenarios.\n\n#### Covariance\nCovariance allows a method to return a more derived type than specified by the generic type parameter. It enables you to assign a generic type of a derived class to a generic type of its base class. Covariance is supported in C# for **output parameters** (e.g., return types).\n\nFor example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "IEnumerable<string> strings = new List<string>();\nIEnumerable<object> objects = strings; // Covariance: IEnumerable<string> is assignable to IEnumerable<object>"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public interface IEnumerable<out T>\n{\n    T GetItem();\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Action<object> actionObject = obj => Console.WriteLine(obj);\nAction<string> actionString = actionObject; // Contravariance: Action<object> is assignable to Action<string>"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public interface IComparer<in T>\n{\n    int Compare(T x, T y);\n}"
      }
    ]
  },
  {
    "id": "768dafee-5391-47e2-ba19-349ec6bfce89",
    "question": "What is the difference between synchronous and asynchronous programming in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, the difference between synchronous and asynchronous programming lies in how tasks are executed and how the program handles waiting for operations to complete:\n\n### Synchronous Programming\n- In synchronous programming, tasks are executed sequentially, one after the other.\n- The program waits for a task to complete before moving on to the next one.\n- If a task takes a long time (e.g., a network call or file I/O), the program is blocked and cannot perform other operations during that time.\n- Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "void PerformTask()\n  {\n      var result = LongRunningOperation(); // Blocks until the operation completes\n      Console.WriteLine(result);\n  }\n\n  string LongRunningOperation()\n  {\n      Thread.Sleep(5000); // Simulates a long-running task\n      return \"Task Completed\";\n  }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "async Task PerformTaskAsync()\n  {\n      var result = await LongRunningOperationAsync(); // Non-blocking\n      Console.WriteLine(result);\n  }\n\n  async Task<string> LongRunningOperationAsync()\n  {\n      await Task.Delay(5000); // Simulates a long-running task\n      return \"Task Completed\";\n  }"
      }
    ]
  },
  {
    "id": "780384bc-4a9a-4d40-ad69-5793ba1be4f8",
    "question": "What is the Task Parallel Library (TPL) in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The Task Parallel Library (TPL) in C# is a set of public types and APIs in the `System.Threading.Tasks` namespace that simplifies the process of adding parallelism and concurrency to applications. It provides a higher-level abstraction for managing and executing tasks, which represent asynchronous operations.\n\nKey features of TPL include:\n\n1. **Task-based Programming Model**: TPL uses the `Task` and `Task<TResult>` classes to represent asynchronous operations, making it easier to work with threads and manage their lifecycle.\n\n2. **Efficient Thread Pooling**: TPL leverages the .NET ThreadPool to efficiently manage threads, ensuring optimal use of system resources.\n\n3. **Parallel Execution**: It provides constructs like `Parallel.For`, `Parallel.ForEach`, and `Parallel.Invoke` to execute loops and actions in parallel.\n\n4. **Support for Continuations**: TPL allows chaining tasks using continuations with methods like `ContinueWith`, enabling better control over task execution flow.\n\n5. **Exception Handling**: It provides robust mechanisms for handling exceptions in parallel tasks using `AggregateException`.\n\n6. **Cancellation Support**: TPL supports task cancellation through the use of `CancellationToken` and `CancellationTokenSource`.\n\n7. **Scalability**: TPL automatically scales the degree of concurrency based on the available hardware resources, making it suitable for modern multi-core processors.\n\nBy using TPL, developers can write clean, maintainable, and efficient code for parallel and asynchronous programming without dealing with the complexities of manually managing threads."
      }
    ]
  },
  {
    "id": "34eb7af8-0e11-47ff-8dce-bd0952d69ae2",
    "question": "What is the difference between 'lock' and 'Monitor' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both `lock` and `Monitor` are used to handle multithreading and provide thread synchronization, but there are some key differences between them:\n\n### `lock`:\n- `lock` is a simplified and more readable way to use the `Monitor` class.\n- It is a syntactic sugar for `Monitor.Enter` and `Monitor.Exit`.\n- Automatically ensures that `Monitor.Exit` is called, even if an exception occurs within the locked block.\n- Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "private readonly object _lockObject = new object();\n\n  public void Method()\n  {\n      lock (_lockObject)\n      {\n          // Critical section\n      }\n  }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "private readonly object _lockObject = new object();\n\n  public void Method()\n  {\n      Monitor.Enter(_lockObject);\n      try\n      {\n          // Critical section\n      }\n      finally\n      {\n          Monitor.Exit(_lockObject);\n      }\n  }"
      }
    ]
  },
  {
    "id": "65140fcb-1de7-4abb-b6a7-0ce6f8a34d52",
    "question": "What is the purpose of the 'async' and 'await' keywords in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `async` and `await` keywords in C# are used to work with asynchronous programming, allowing developers to write non-blocking, scalable, and responsive code.\n\n- **`async`**: This modifier is applied to a method, lambda expression, or anonymous method to indicate that it contains asynchronous operations. An `async` method typically returns a `Task`, `Task<T>`, or `void` (for event handlers). It enables the use of the `await` keyword within the method.\n\n- **`await`**: This keyword is used to pause the execution of an `async` method until the awaited `Task` completes. It allows the program to continue executing other code (e.g., handling UI interactions) while waiting for the asynchronous operation to finish. Once the `Task` is complete, execution resumes from the point where `await` was used.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public async Task<string> FetchDataAsync()\n{\n    // Simulate an asynchronous operation (e.g., fetching data from a web API)\n    await Task.Delay(2000); // Pauses execution for 2 seconds\n    return \"Data fetched successfully!\";\n}\n\npublic async Task MainAsync()\n{\n    Console.WriteLine(\"Fetching data...\");\n    string result = await FetchDataAsync(); // Execution pauses here until FetchDataAsync completes\n    Console.WriteLine(result);\n}"
      }
    ]
  },
  {
    "id": "a9e506bc-e492-435e-8e1e-035be541778a",
    "question": "What are expression-bodied members in C#?",
    "answer": [
      {
        "type": "text",
        "content": "Expression-bodied members in C# provide a concise syntax for defining members of a class, struct, or interface using lambda-like expressions. They are typically used to simplify the implementation of properties, methods, constructors, destructors, and indexers when the logic can be expressed in a single expression.\n\nInstead of using a full block of code with curly braces `{ }`, you can use the `=>` (lambda arrow) syntax to define the member.\n\n### Examples:\n\n1. **Expression-bodied Methods**:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n   {\n       public int Add(int a, int b) => a + b;\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n   {\n       private int _value;\n       public int Value => _value * 2; // Read-only property\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n   {\n       private string _name;\n       public Example(string name) => _name = name;\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n   {\n       ~Example() => Console.WriteLine(\"Destructor called\");\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n   {\n       private int[] _numbers = { 1, 2, 3 };\n       public int this[int index] => _numbers[index];\n   }"
      }
    ]
  },
  {
    "id": "11af6466-317a-40e3-897b-e10ba0cb0235",
    "question": "What is dependency injection in C# and why is it important?",
    "answer": [
      {
        "type": "text",
        "content": "### Dependency Injection in C# and Its Importance\n\n**Dependency Injection (DI)** is a design pattern used in C# (and other programming languages) to achieve Inversion of Control (IoC) between classes and their dependencies. It allows an object to receive its dependencies from an external source rather than creating them internally. This is typically done by passing the dependencies through constructors, properties, or methods.\n\n#### Key Concepts of Dependency Injection:\n1. **Dependency**: An object that another object relies on.\n2. **Injection**: The process of providing the dependency to the dependent object.\n\n#### Types of Dependency Injection:\n1. **Constructor Injection**: Dependencies are provided through the class constructor.\n2. **Property Injection**: Dependencies are set through public properties.\n3. **Method Injection**: Dependencies are passed as parameters to a method.\n\n#### Example of Constructor Injection:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public interface ILogger\n{\n    void Log(string message);\n}\n\npublic class ConsoleLogger : ILogger\n{\n    public void Log(string message)\n    {\n        Console.WriteLine(message);\n    }\n}\n\npublic class Application\n{\n    private readonly ILogger _logger;\n\n    public Application(ILogger logger)\n    {\n        _logger = logger;\n    }\n\n    public void Run()\n    {\n        _logger.Log(\"Application is running...\");\n    }\n}\n\n// Usage\nvar logger = new ConsoleLogger();\nvar app = new Application(logger);\napp.Run();"
      }
    ]
  },
  {
    "id": "ad4424da-29e3-419d-bdcd-4996d5d42c10",
    "question": "What is the difference between value types and reference types in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, value types and reference types are two categories of data types that differ in how they store and manage data in memory.\n\n### Value Types:\n1. **Definition**: Value types directly contain their data. When a value type variable is assigned to another, the data is copied.\n2. **Memory Allocation**: Stored in the stack, which is a region of memory used for static memory allocation.\n3. **Examples**: `int`, `float`, `bool`, `char`, `struct`, `enum`.\n4. **Behavior**: Each variable has its own copy of the data, so changes to one variable do not affect another."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int a = 10;\n   int b = a; // b gets a copy of a's value\n   b = 20;    // Changing b does not affect a\n   Console.WriteLine(a); // Output: 10"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class MyClass\n   {\n       public int Value;\n   }\n\n   MyClass obj1 = new MyClass();\n   obj1.Value = 10;\n   MyClass obj2 = obj1; // obj2 references the same object as obj1\n   obj2.Value = 20;     // Changing obj2 affects obj1\n   Console.WriteLine(obj1.Value); // Output: 20"
      }
    ]
  },
  {
    "id": "7d33ba8f-f45e-4e81-bb25-4159f711e022",
    "question": "What is the purpose of the IDisposable interface in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The purpose of the `IDisposable` interface in C# is to provide a mechanism for releasing unmanaged resources explicitly. When a class implements the `IDisposable` interface, it is required to define the `Dispose` method, which is intended to clean up resources such as file handles, database connections, or unmanaged memory that the garbage collector cannot handle.\n\nBy calling the `Dispose` method, developers can ensure that these resources are released promptly, rather than waiting for the garbage collector to finalize the object. This is particularly important for improving performance and avoiding resource leaks.\n\nThe `IDisposable` interface is often used in conjunction with the `using` statement, which ensures that the `Dispose` method is called automatically when the object goes out of scope, even if an exception occurs.\n\n### Example"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class ResourceHandler : IDisposable\n{\n    private bool disposed = false;\n\n    public void UseResource()\n    {\n        if (disposed)\n            throw new ObjectDisposedException(\"ResourceHandler\");\n\n        Console.WriteLine(\"Using resource...\");\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposed)\n        {\n            if (disposing)\n            {\n                // Release managed resources here\n            }\n\n            // Release unmanaged resources here\n\n            disposed = true;\n        }\n    }\n\n    ~ResourceHandler()\n    {\n        Dispose(false);\n    }\n}\n\n// Usage\nusing (var handler = new ResourceHandler())\n{\n    handler.UseResource();\n}"
      }
    ]
  },
  {
    "id": "6125abe6-4776-4367-be77-e51c7e8f0439",
    "question": "What is reflection in C# and how is it used?",
    "answer": [
      {
        "type": "text",
        "content": "### Reflection in C#\n\nReflection in C# is the process of inspecting and interacting with the metadata of types at runtime. It allows you to dynamically obtain information about assemblies, modules, and types, such as classes, methods, properties, fields, and events. Reflection is part of the `System.Reflection` namespace.\n\n#### Key Features of Reflection:\n1. **Type Inspection**: Retrieve information about the structure of types, such as their methods, properties, fields, and events.\n2. **Dynamic Invocation**: Invoke methods or access fields and properties dynamically at runtime.\n3. **Assembly Loading**: Load assemblies and inspect their contents.\n4. **Custom Attributes**: Access custom attributes applied to types, methods, or properties.\n\n#### Common Use Cases:\n- Building frameworks or libraries that need to work with unknown types at runtime.\n- Creating dynamic applications, such as plugins or dependency injection systems.\n- Performing runtime type discovery and metadata analysis.\n- Accessing private members (though this should generally be avoided for security and maintainability reasons).\n\n#### Example of Using Reflection:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using System;\nusing System.Reflection;\n\nclass Program\n{\n    static void Main()\n    {\n        // Get the type of a class\n        Type type = typeof(SampleClass);\n\n        // Display the name of the type\n        Console.WriteLine($\"Class Name: {type.Name}\");\n\n        // Get and display all methods of the class\n        MethodInfo[] methods = type.GetMethods();\n        foreach (var method in methods)\n        {\n            Console.WriteLine($\"Method: {method.Name}\");\n        }\n\n        // Dynamically invoke a method\n        object instance = Activator.CreateInstance(type);\n        MethodInfo greetMethod = type.GetMethod(\"Greet\");\n        greetMethod.Invoke(instance, new object[] { \"John\" });\n    }\n}\n\nclass SampleClass\n{\n    public void Greet(string name)\n    {\n        Console.WriteLine($\"Hello, {name}!\");\n    }\n}"
      }
    ]
  },
  {
    "id": "ac60e33f-13dd-4fdf-a1c9-8f02f98db78b",
    "question": "What is the purpose of the 'dynamic' keyword in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `dynamic` keyword in C# is used to bypass compile-time type checking and defer type resolution to runtime. It allows you to work with objects whose type is not known until runtime. This is particularly useful when working with COM objects, reflection, or dynamic languages like Python or JavaScript.\n\nWhen you declare a variable as `dynamic`, the compiler does not enforce type checking, and you can call methods or access properties on the object without knowing its type at compile time. However, if the member does not exist or is used incorrectly, a runtime exception will occur.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "dynamic obj = \"Hello, World!\";\nConsole.WriteLine(obj.Length); // Works because the runtime resolves the type as string\n\nobj = 12345;\nConsole.WriteLine(obj.Length); // Runtime exception, as int does not have a Length property"
      }
    ]
  },
  {
    "id": "8ba891bc-21f2-45e1-83be-1a08de04f601",
    "question": "What is the difference between early binding and late binding in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, early binding and late binding refer to how methods and properties of objects are resolved at runtime or compile time.\n\n### Early Binding\n- **Definition**: Early binding refers to the process where the method or property to be called is determined at compile time.\n- **Key Characteristics**:\n  - The type of the object is known at compile time.\n  - Provides better performance because the compiler has all the information needed to resolve method calls.\n  - Enables compile-time checking, reducing runtime errors.\n  - Typically used with strongly typed objects.\n- **Example**:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class Example\n  {\n      public void Display()\n      {\n          Console.WriteLine(\"Early Binding Example\");\n      }\n  }\n\n  Example obj = new Example();\n  obj.Display(); // Resolved at compile time"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using System;\n\n  class Example\n  {\n      public void Display()\n      {\n          Console.WriteLine(\"Late Binding Example\");\n      }\n  }\n\n  object obj = new Example();\n  var method = obj.GetType().GetMethod(\"Display\");\n  method.Invoke(obj, null); // Resolved at runtime"
      }
    ]
  },
  {
    "id": "9e4d71b4-74ec-47be-aacc-fffea0d35455",
    "question": "What are async streams in C# and how do they work?",
    "answer": [
      {
        "type": "text",
        "content": "### Async Streams in C# and How They Work\n\nAsync streams in C# are a feature introduced in C# 8.0 that allow asynchronous iteration over a sequence of data. They combine the concepts of asynchronous programming (`async/await`) with the ability to work with streams of data using `IAsyncEnumerable<T>`.\n\n#### Key Concepts:\n1. **`IAsyncEnumerable<T>`**:\n   - Async streams are based on the `IAsyncEnumerable<T>` interface, which represents an asynchronous sequence of elements.\n   - It works similarly to `IEnumerable<T>` but allows asynchronous iteration using `await foreach`.\n\n2. **`await foreach`**:\n   - To consume an async stream, you use the `await foreach` loop, which asynchronously retrieves elements from the stream one at a time.\n   - This is particularly useful when dealing with data sources that produce elements over time, such as reading data from a network, file, or database.\n\n3. **Asynchronous Iterators**:\n   - You can create an async stream by defining an asynchronous iterator method using the `async` modifier and the `yield return` statement.\n   - The method must return `IAsyncEnumerable<T>`.\n\n#### How Async Streams Work:\n1. **Producer**:\n   - The producer generates data asynchronously and yields it using `yield return`.\n   - The method can use `await` to perform asynchronous operations (e.g., fetching data from an API or database).\n\n2. **Consumer**:\n   - The consumer uses `await foreach` to asynchronously retrieve and process each item in the stream.\n   - The loop waits for each element to be produced before continuing.\n\n#### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        await foreach (var number in GenerateNumbersAsync())\n        {\n            Console.WriteLine(number);\n        }\n    }\n\n    static async IAsyncEnumerable<int> GenerateNumbersAsync()\n    {\n        for (int i = 1; i <= 5; i++)\n        {\n            await Task.Delay(1000); // Simulate asynchronous work\n            yield return i; // Yield each number\n        }\n    }\n}"
      }
    ]
  },
  {
    "id": "bce068df-0f5e-4583-9f2f-9afdd3d07934",
    "question": "What is the difference between a thread and a task in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both threads and tasks are used for concurrent programming, but they differ in their abstraction level, usage, and management:\n\n### **Thread**\n- A thread is a lower-level construct provided by the operating system.\n- It represents a single execution path within a process.\n- Threads are part of the `System.Threading` namespace.\n- Threads require explicit management, such as starting, stopping, and synchronizing.\n- Threads are more resource-intensive as they require their own stack and context switching.\n- Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Thread thread = new Thread(() => Console.WriteLine(\"Running on a thread\"));\n  thread.Start();"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Task task = Task.Run(() => Console.WriteLine(\"Running on a task\"));\n  await task;"
      }
    ]
  },
  {
    "id": "4c18d29b-423a-45a0-8416-8a6397deb61b",
    "question": "What is the difference between 'Func', 'Action', and 'Predicate' delegates in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, `Func`, `Action`, and `Predicate` are predefined generic delegates used to encapsulate methods. They differ in their purpose and signature:\n\n### 1. **Func Delegate**\n- **Purpose**: Represents a method that returns a value.\n- **Signature**: Can take 0 to 16 input parameters and must return a value.\n- **Example**:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Func<int, int, int> add = (x, y) => x + y;\n  int result = add(5, 10); // result = 15"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Action<string> printMessage = message => Console.WriteLine(message);\n  printMessage(\"Hello, World!\"); // Output: Hello, World!"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "Predicate<int> isEven = number => number % 2 == 0;\n  bool result = isEven(4); // result = true"
      }
    ]
  },
  {
    "id": "1541b2f5-f4ba-4404-992d-4755c9e6a90a",
    "question": "What is the purpose of the 'Span<T>' and 'Memory<T>' types in C#?",
    "answer": [
      {
        "type": "text",
        "content": "### Purpose of `Span<T>` and `Memory<T>` in C#\n\n`Span<T>` and `Memory<T>` are advanced types in C# introduced to improve performance and memory efficiency when working with contiguous memory regions, such as arrays, strings, or other buffers. They are part of the `System` namespace and are designed to minimize memory allocations and improve data manipulation efficiency.\n\n#### 1. **`Span<T>`**\n- `Span<T>` is a stack-only type that provides a type-safe and memory-safe view over a contiguous region of memory.\n- It is used for high-performance scenarios where you need to process slices of data without copying or allocating additional memory.\n- It can represent:\n  - Arrays\n  - Strings (via `Span<char>`)\n  - Unmanaged memory\n  - Memory from custom buffers\n- Since `Span<T>` is stack-allocated, it cannot be stored in fields or used across `async` methods.\n- Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int[] numbers = { 1, 2, 3, 4, 5 };\n  Span<int> slice = numbers.AsSpan(1, 3); // Represents { 2, 3, 4 }\n  slice[0] = 10; // Modifies the original array"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int[] numbers = { 1, 2, 3, 4, 5 };\n  Memory<int> memory = new Memory<int>(numbers, 1, 3); // Represents { 2, 3, 4 }\n  Span<int> span = memory.Span;\n  span[0] = 10; // Modifies the original array"
      }
    ]
  },
  {
    "id": "14f4fda8-4379-46cd-872e-a9f00eae1518",
    "question": "What is the difference between boxing and unboxing in C#?",
    "answer": [
      {
        "type": "text",
        "content": "### Difference Between Boxing and Unboxing in C#\n\nIn C#, **boxing** and **unboxing** are processes used to convert value types and reference types.\n\n#### **Boxing**\n- Boxing is the process of converting a value type (e.g., `int`, `float`) into a reference type (e.g., `object` or an interface type).\n- It involves wrapping the value type inside a `System.Object` or any compatible reference type.\n- Boxing is an implicit operation.\n\n**Example:**"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int num = 42; // Value type\nobject boxedNum = num; // Boxing"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "object boxedNum = 42; // Boxing\nint num = (int)boxedNum; // Unboxing"
      }
    ]
  },
  {
    "id": "3279cb3a-a029-491b-97fd-ca6b159318d6",
    "question": "What is the purpose of the 'unsafe' keyword in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `unsafe` keyword in C# is used to denote a block of code or a method that uses unmanaged code or performs operations that require pointer manipulation. By default, C# is a type-safe language, meaning it prevents direct memory access to ensure safety and security. However, in certain scenarios, such as interacting with low-level system APIs, working with performance-critical code, or interfacing with unmanaged code, you may need to bypass this safety.\n\nWhen using the `unsafe` keyword, you can work with pointers, perform pointer arithmetic, and directly access memory. To compile and run unsafe code, the project must be compiled with the `/unsafe` compiler option enabled.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "unsafe\n{\n    int value = 10;\n    int* pointer = &value; // Pointer to the variable\n    Console.WriteLine($\"Value: {value}, Pointer Address: {(long)pointer}\");\n}"
      }
    ]
  },
  {
    "id": "2747f5c5-1efa-486f-84e5-160f7d219594",
    "question": "What is a memory leak in C# and how can it be prevented?",
    "answer": [
      {
        "type": "text",
        "content": "### What is a Memory Leak in C#?\n\nA memory leak in C# occurs when objects are no longer needed by the application but are still referenced, preventing the Garbage Collector (GC) from reclaiming the memory. This can lead to excessive memory usage and eventually degrade the application's performance or cause it to crash.\n\n### Common Causes of Memory Leaks in C#\n\n1. **Event Handlers**: Subscribing to events without unsubscribing can cause objects to remain in memory.\n2. **Static References**: Objects referenced by static fields are not garbage collected until the application ends.\n3. **Unmanaged Resources**: Resources like file handles, database connections, or sockets not properly released.\n4. **Circular References**: Although the GC can handle most circular references, improper use of objects can still lead to leaks.\n5. **Large Object Heap (LOH)**: Frequent allocation of large objects without proper management can fragment memory.\n\n### How to Prevent Memory Leaks in C#\n\n1. **Unsubscribe from Events**: Always unsubscribe from events when the object is no longer needed."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "eventHandler -= MyEventHandler;"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "WeakReference weakRef = new WeakReference(myObject);"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using (var resource = new Resource())\n   {\n       // Use resource\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "myStaticField = null;"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class MyClass : IDisposable\n{\n    private bool _disposed = false;\n\n    public event EventHandler MyEvent;\n\n    public void DoSomething()\n    {\n        MyEvent?.Invoke(this, EventArgs.Empty);\n    }\n\n    public void Dispose()\n    {\n        if (!_disposed)\n        {\n            // Unsubscribe from events\n            MyEvent = null;\n\n            // Release unmanaged resources\n            // Example: _resource.Dispose();\n\n            _disposed = true;\n        }\n    }\n}"
      }
    ]
  },
  {
    "id": "aad6c09b-4f68-4c29-9376-ff02010d323d",
    "question": "What is the difference between 'Dispose' and 'Finalize' methods in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both `Dispose` and `Finalize` are used for resource cleanup, but they serve different purposes and are implemented differently:\n\n### `Dispose` Method:\n- **Purpose**: Explicitly releases unmanaged resources and performs cleanup in a controlled manner.\n- **Implementation**: Part of the `IDisposable` interface, which a class implements to provide a `Dispose` method.\n- **Usage**: Called manually by the developer or automatically when used with a `using` statement.\n- **Scope**: Can be used to clean up both managed and unmanaged resources.\n- **Deterministic**: The cleanup happens immediately when `Dispose` is called.\n- **Best Practice**: Recommended for releasing resources like database connections, file streams, etc.\n\n### `Finalize` Method:\n- **Purpose**: Acts as a safety net to release unmanaged resources if `Dispose` is not called.\n- **Implementation**: Defined in the `Object` class and overridden in derived classes. Implemented using a destructor (`~ClassName()`).\n- **Usage**: Called by the Garbage Collector (GC) before the object is destroyed.\n- **Scope**: Only used to clean up unmanaged resources.\n- **Non-Deterministic**: The exact time when the GC will call the `Finalize` method is not guaranteed.\n- **Performance Impact**: Finalization adds overhead to the GC process, as objects with finalizers require additional processing.\n\n### Key Differences:\n| Aspect              | `Dispose`                     | `Finalize`                     |\n|---------------------|-------------------------------|--------------------------------|\n| **Trigger**         | Called explicitly by code.    | Called by the Garbage Collector. |\n| **Determinism**     | Deterministic cleanup.        | Non-deterministic cleanup.     |\n| **Implementation**  | Requires `IDisposable`.       | Implemented as a destructor.   |\n| **Performance**     | Efficient.                   | Less efficient due to GC overhead. |\n| **Usage**           | For both managed and unmanaged resources. | Primarily for unmanaged resources. |\n\n### Best Practices:\n1. Use `Dispose` for deterministic cleanup of resources.\n2. Implement `Finalize` only if necessary, and ensure it is minimal to avoid performance issues.\n3. Combine both by implementing the [Dispose Pattern](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose) for proper resource management."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Example of Dispose Pattern\npublic class ResourceHolder : IDisposable\n{\n    private bool disposed = false;\n\n    // Destructor (Finalize)\n    ~ResourceHolder()\n    {\n        Dispose(false);\n    }\n\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this); // Prevent Finalize from being called\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!disposed)\n        {\n            if (disposing)\n            {\n                // Free managed resources\n            }\n            // Free unmanaged resources\n            disposed = true;\n        }\n    }\n}"
      }
    ]
  },
  {
    "id": "8ff9896b-2d48-4345-8272-5f9fa717a3a5",
    "question": "What is the purpose of the 'GC.Collect()' method in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `GC.Collect()` method in C# is used to explicitly trigger garbage collection in the .NET runtime. Garbage collection is responsible for reclaiming memory occupied by objects that are no longer in use, thereby preventing memory leaks. While the garbage collector typically runs automatically, calling `GC.Collect()` allows developers to force a collection at a specific time.\n\n### Purpose of `GC.Collect()`:\n1. **Immediate Cleanup**: It can be used to clean up unused objects immediately, especially in scenarios where memory is a critical resource.\n2. **Testing and Debugging**: Useful in testing and debugging to simulate garbage collection and observe its effects on the application.\n3. **Releasing Resources**: Ensures that objects with finalizers are cleaned up promptly, which can be important for releasing unmanaged resources.\n\n### Considerations:\n- **Performance Impact**: Forcing garbage collection can negatively impact performance, as it interrupts the normal execution of the program.\n- **Best Practices**: It is generally recommended to let the garbage collector manage memory automatically unless there is a specific and compelling reason to intervene.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        // Create some objects\n        for (int i = 0; i < 1000; i++)\n        {\n            var obj = new object();\n        }\n\n        // Force garbage collection\n        GC.Collect();\n        GC.WaitForPendingFinalizers();\n\n        Console.WriteLine(\"Garbage collection triggered.\");\n    }\n}"
      }
    ]
  },
  {
    "id": "b46de6de-1c5c-4bb0-9e4a-b616889b8333",
    "question": "What is the difference between 'volatile' and 'readonly' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, `volatile` and `readonly` are two distinct keywords used for different purposes:\n\n### `volatile`\n- The `volatile` keyword is used to indicate that a field might be modified by multiple threads simultaneously.\n- It ensures that the most recent value of the field is always read from memory, rather than relying on a cached value in the CPU.\n- It is used to prevent compiler optimizations that could reorder instructions or cache the value of the field in a register.\n- Applicable only to fields of specific types: `bool`, `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `char`, `float`, `Pointer`, `Reference`, or `enum` types with an underlying type of the aforementioned types.\n- Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n  {\n      private volatile bool _isRunning;\n\n      public void Stop()\n      {\n          _isRunning = false;\n      }\n\n      public void Run()\n      {\n          while (_isRunning)\n          {\n              // Perform some work\n          }\n      }\n  }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n  {\n      public readonly int MaxValue;\n\n      public Example(int maxValue)\n      {\n          MaxValue = maxValue;\n      }\n  }"
      }
    ]
  },
  {
    "id": "a1635b4b-2eae-41af-ada3-e913b49b4ef3",
    "question": "What is the purpose of the 'sealed' keyword in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `sealed` keyword in C# is used to prevent a class from being inherited or to prevent a method or property from being overridden in derived classes. \n\n### Purpose of `sealed`:\n1. **Sealing a Class**: When a class is marked as `sealed`, it cannot be used as a base class. This is useful when you want to restrict further inheritance for security, design, or performance reasons."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "sealed class MyClass\n   {\n       public void Display()\n       {\n           Console.WriteLine(\"This is a sealed class.\");\n       }\n   }\n\n   // The following would result in a compile-time error:\n   // class DerivedClass : MyClass { }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "class BaseClass\n   {\n       public virtual void Display()\n       {\n           Console.WriteLine(\"Base class display method.\");\n       }\n   }\n\n   class DerivedClass : BaseClass\n   {\n       public sealed override void Display()\n       {\n           Console.WriteLine(\"Derived class sealed display method.\");\n       }\n   }\n\n   // The following would result in a compile-time error:\n   // class AnotherDerivedClass : DerivedClass\n   // {\n   //     public override void Display() { }\n   // }"
      }
    ]
  },
  {
    "id": "8bcccd52-34f7-4c30-a9df-a2f6f42c63bc",
    "question": "What are record types in C# and how are they different from classes?",
    "answer": [
      {
        "type": "text",
        "content": "### Record Types in C# and Their Differences from Classes\n\nRecord types in C# are a special kind of reference type introduced in C# 9.0, designed to represent immutable data models. They are particularly useful for scenarios where the primary purpose of the type is to hold data, such as data transfer objects (DTOs) or value objects.\n\n#### Key Features of Record Types:\n1. **Immutability**: By default, records are immutable. You can define properties with `init` accessors, allowing them to be set only during object initialization.\n2. **Value-Based Equality**: Records override the `Equals` and `GetHashCode` methods to provide value-based equality. This means two record instances are considered equal if their properties have the same values, unlike classes which use reference-based equality by default.\n3. **Concise Syntax**: Records support a concise syntax for defining data models using positional parameters.\n4. **With Expressions**: Records support `with` expressions, allowing you to create a new record instance by copying an existing one with modifications to specific properties.\n\n#### Example of a Record:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public record Person(string FirstName, string LastName);"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Person\n{\n    public string FirstName { get; set; }\n    public string LastName { get; set; }\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "var person1 = new Person(\"John\", \"Doe\");\nvar person2 = person1 with { LastName = \"Smith\" }; // Creates a new record with modified LastName"
      }
    ]
  },
  {
    "id": "a00c7a66-0d98-4d5d-a395-478af0ef129b",
    "question": "What is the difference between 'Task.Run' and 'Task.Factory.StartNew' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both `Task.Run` and `Task.Factory.StartNew` are used to create and start tasks, but there are key differences between them:\n\n### 1. **Default Behavior**\n   - **`Task.Run`**: It is a higher-level API introduced in .NET 4.5, designed for simplicity. It schedules the task on the default `TaskScheduler` and uses the `ThreadPool` for execution.\n   - **`Task.Factory.StartNew`**: It is a lower-level API introduced in .NET 4.0. It provides more control over task creation and scheduling but requires specifying options explicitly for common scenarios.\n\n### 2. **Ease of Use**\n   - **`Task.Run`**: Simplifies task creation for most common scenarios, such as running CPU-bound or I/O-bound operations asynchronously.\n   - **`Task.Factory.StartNew`**: Requires more parameters to configure the task, making it more verbose and complex for simple use cases.\n\n### 3. **Task Creation Options**\n   - **`Task.Run`**: Automatically uses `TaskCreationOptions.DenyChildAttach`, which prevents child tasks from attaching to the parent task.\n   - **`Task.Factory.StartNew`**: Allows specifying `TaskCreationOptions`, giving more flexibility for advanced scenarios like long-running tasks, attached child tasks, etc.\n\n### 4. **Default Scheduler**\n   - **`Task.Run`**: Always uses the default `TaskScheduler` (usually the thread pool).\n   - **`Task.Factory.StartNew`**: Allows specifying a custom `TaskScheduler`, enabling tasks to run on a specific scheduler.\n\n### 5. **Long-Running Tasks**\n   - **`Task.Run`**: Not optimized for long-running tasks; it is designed for short-lived operations.\n   - **`Task.Factory.StartNew`**: Can be configured with `TaskCreationOptions.LongRunning` for tasks that are expected to run for an extended period, potentially creating a dedicated thread.\n\n### 6. **Continuation Behavior**\n   - **`Task.Run`**: Automatically detaches child tasks, ensuring they do not affect the parent task's lifecycle.\n   - **`Task.Factory.StartNew`**: By default, child tasks can attach to the parent task unless `TaskCreationOptions.DenyChildAttach` is specified.\n\n### Example"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Using Task.Run\nTask task1 = Task.Run(() => {\n    Console.WriteLine(\"Task.Run example\");\n});\n\n// Using Task.Factory.StartNew\nTask task2 = Task.Factory.StartNew(() => {\n    Console.WriteLine(\"Task.Factory.StartNew example\");\n}, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default);"
      }
    ]
  },
  {
    "id": "b423fa8f-4875-4bfd-9251-7df279d286e2",
    "question": "What is the purpose of the 'IAsyncDisposable' interface in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `IAsyncDisposable` interface in C# is used to provide a mechanism for releasing unmanaged resources asynchronously. It is particularly useful in scenarios where resource cleanup involves asynchronous operations, such as closing file streams, releasing database connections, or disposing of objects that rely on asynchronous APIs.\n\nThe interface defines a single method:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public interface IAsyncDisposable\n{\n    ValueTask DisposeAsync();\n}"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class AsyncResource : IAsyncDisposable\n{\n    public async ValueTask DisposeAsync()\n    {\n        // Perform asynchronous cleanup\n        await Task.Delay(1000);\n        Console.WriteLine(\"Resource disposed asynchronously.\");\n    }\n}\n\npublic async Task UseResourceAsync()\n{\n    await using (var resource = new AsyncResource())\n    {\n        Console.WriteLine(\"Using resource...\");\n    }\n    // Resource is disposed asynchronously here\n}"
      }
    ]
  },
  {
    "id": "234efdb3-14b8-456e-af8d-24c21c4c58d2",
    "question": "What is the difference between 'StringBuilder' and 'string' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, `StringBuilder` and `string` are used to work with text, but they differ significantly in terms of mutability, performance, and use cases:\n\n### 1. **Mutability**:\n   - **`string`**: Strings in C# are immutable. Once a string is created, its value cannot be changed. Any operation that appears to modify a string (e.g., concatenation, replacement) actually creates a new string object in memory.\n   - **`StringBuilder`**: `StringBuilder` is mutable. It allows modification of the string content without creating new objects, making it more efficient for scenarios involving frequent string manipulations.\n\n### 2. **Performance**:\n   - **`string`**: Since strings are immutable, operations like concatenation or appending create new string objects, which can lead to higher memory usage and slower performance when dealing with large or repetitive operations.\n   - **`StringBuilder`**: Designed for better performance in scenarios with frequent modifications. It modifies the existing object, avoiding the overhead of creating new objects.\n\n### 3. **Use Cases**:\n   - **`string`**: Best suited for scenarios where the text content is not expected to change frequently, such as storing constant values or performing simple operations.\n   - **`StringBuilder`**: Ideal for scenarios involving extensive string manipulations, such as building large strings dynamically, appending in loops, or performing multiple replacements.\n\n### 4. **Thread Safety**:\n   - **`string`**: Strings are inherently thread-safe because they are immutable.\n   - **`StringBuilder`**: Not thread-safe by default. If thread safety is required, you can use the `StringBuilder` constructor overload that accepts a `System.Threading` `lock` object.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "// Using string\nstring str = \"Hello\";\nstr += \" World\"; // Creates a new string object in memory\n\n// Using StringBuilder\nStringBuilder sb = new StringBuilder(\"Hello\");\nsb.Append(\" World\"); // Modifies the existing object"
      }
    ]
  },
  {
    "id": "c697e521-469d-48c8-9e77-d49636cd8a58",
    "question": "What is the purpose of the 'nameof' operator in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `nameof` operator in C# is used to obtain the name of a variable, type, or member as a string. It is particularly useful for improving code readability, maintainability, and reducing the risk of errors caused by hardcoding string literals. By using `nameof`, you ensure that the string representation of the name is updated automatically if the referenced variable, type, or member is renamed during refactoring.\n\n### Key Benefits:\n1. **Refactoring Safety**: When renaming a variable, type, or member, the `nameof` operator ensures the string representation is updated automatically.\n2. **Improved Readability**: It makes the code more expressive and easier to understand.\n3. **Error Prevention**: Reduces the risk of typos or mismatches in string literals.\n\n### Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "public class Example\n{\n    public string PropertyName { get; set; }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        var example = new Example();\n        Console.WriteLine(nameof(example.PropertyName)); // Output: \"PropertyName\"\n    }\n}"
      }
    ]
  },
  {
    "id": "be415a1c-0c8d-499c-99c6-951220b80be9",
    "question": "What is the difference between 'throw' and 'throw ex' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, both `throw` and `throw ex` are used to throw exceptions, but they differ in how they preserve the original stack trace of the exception:\n\n1. **`throw`**:\n   - When you use `throw` without specifying the exception object, it rethrows the original exception while preserving the original stack trace.\n   - This is useful when you want to propagate the exception without losing the context of where it was originally thrown.\n\n   Example:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "try\n   {\n       // Some code that throws an exception\n   }\n   catch (Exception)\n   {\n       // Rethrow the original exception\n       throw;\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "try\n   {\n       // Some code that throws an exception\n   }\n   catch (Exception ex)\n   {\n       // Throw the exception with a new stack trace\n       throw ex;\n   }"
      }
    ]
  },
  {
    "id": "c84353ed-ec28-40ef-a40e-fd19e339f77a",
    "question": "What is the purpose of the 'default' keyword in C#?",
    "answer": [
      {
        "type": "text",
        "content": "The `default` keyword in C# serves multiple purposes depending on the context:\n\n1. **Default Value for Generics**: In generic programming, `default` is used to initialize variables to their default values when the type is not known at compile time. For example:\n   - For reference types, the default value is `null`.\n   - For value types, the default value is the type's zero-equivalent (e.g., `0` for `int`, `false` for `bool`, etc.)."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "T value = default(T); // Assigns the default value of type T"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "switch (value)\n   {\n       case 1:\n           Console.WriteLine(\"Case 1\");\n           break;\n       case 2:\n           Console.WriteLine(\"Case 2\");\n           break;\n       default:\n           Console.WriteLine(\"Default case\");\n           break;\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "int number = default; // Equivalent to 0\n   string text = default; // Equivalent to null"
      }
    ]
  },
  {
    "id": "f290518c-6603-4a61-9fa6-d58ba6c566a1",
    "question": "What is the difference between 'var', 'dynamic', and 'object' in C#?",
    "answer": [
      {
        "type": "text",
        "content": "In C#, `var`, `dynamic`, and `object` are used for variable declarations, but they have distinct differences in terms of behavior, type checking, and usage:\n\n### 1. `var`\n- **Type Inference**: The `var` keyword allows the compiler to infer the type of the variable at compile time based on the assigned value.\n- **Compile-Time Checking**: The type is determined at compile time, so all type-related errors are caught during compilation.\n- **Usage**: It is strongly typed, meaning once the type is inferred, it cannot be changed.\n- **Example**:"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "var number = 10; // Inferred as int\n  var name = \"Hello\"; // Inferred as string\n  // number = \"test\"; // Compile-time error"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "dynamic value = 10; // Initially an int\n  value = \"Hello\"; // Now a string\n  Console.WriteLine(value.Length); // Works if value is a string"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "object obj = 10; // Boxing\n  int number = (int)obj; // Unboxing\n  // Console.WriteLine(obj.Length); // Compile-time error"
      }
    ]
  },
  {
    "id": "313ac814-7a81-43b7-bd2c-bed7214ce385",
    "question": "What is the purpose of the 'pattern matching' feature in C#?",
    "answer": [
      {
        "type": "text",
        "content": "### Purpose of the 'Pattern Matching' Feature in C#\n\nThe purpose of the 'pattern matching' feature in C# is to enable developers to write more concise, readable, and type-safe code by providing a way to test an object against a specific type, structure, or condition. It allows the deconstruction of objects, conditional checks, and type casting in a streamlined manner, reducing boilerplate code.\n\n#### Key Benefits:\n1. **Type Checking and Casting Simplification**: Eliminates the need for explicit type casting by combining type checks and variable assignments in a single step."
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "if (obj is string str)\n   {\n       Console.WriteLine($\"String length: {str.Length}\");\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "switch (shape)\n   {\n       case Circle c:\n           Console.WriteLine($\"Circle with radius {c.Radius}\");\n           break;\n       case Rectangle r:\n           Console.WriteLine($\"Rectangle with width {r.Width} and height {r.Height}\");\n           break;\n       default:\n           Console.WriteLine(\"Unknown shape\");\n           break;\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "if (point is (int x, int y))\n   {\n       Console.WriteLine($\"Point coordinates: ({x}, {y})\");\n   }"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "var result = shape switch\n   {\n       Circle c => $\"Circle with radius {c.Radius}\",\n       Rectangle r => $\"Rectangle with width {r.Width} and height {r.Height}\",\n       _ => \"Unknown shape\"\n   };"
      },
      {
        "type": "code",
        "language": "csharp",
        "content": "if (obj is int i and > 0)\n   {\n       Console.WriteLine($\"Positive integer: {i}\");\n   }"
      }
    ]
  }
]