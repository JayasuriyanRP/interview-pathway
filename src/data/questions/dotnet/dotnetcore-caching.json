[
  {
    "id": "712466ca-1abd-4c46-b3cc-08b19f2b0bae",
    "question": "How do you remove an item from the cache in .NET Core?",
    "answer": "To remove an item from the cache in .NET Core, you can use the Remove method provided by the cache interface (such as IMemoryCache). Here’s an example:\n\n```csharp\n// Assume _cache is an instance of IMemoryCache\n_cache.Remove(\"myCacheKey\");\n```\n\nReplace \"myCacheKey\" with the key of the item you want to remove. This will delete the cached item associated with that key.",
    "level": "Beginner"
  },
  {
    "id": "acc1059f-ebf7-426f-b8c4-6af302b2ffef",
    "question": "What is cache eviction?",
    "answer": "**Cache eviction** in .NET Core refers to the process of removing items from the cache to free up memory or to ensure that outdated or unnecessary data is not served to users. Eviction can happen for several reasons, such as:\n\n- **Expiration:** Items are removed after a specified time (absolute or sliding expiration).\n- **Memory Pressure:** When the system is low on memory, the cache may remove items to free up space.\n- **Manual Removal:** Items can be explicitly removed from the cache by the application.\n\n.NET Core provides built-in caching mechanisms like **MemoryCache** and **DistributedCache**, which support various eviction policies to manage cached data efficiently.",
    "level": "Beginner"
  },
  {
    "id": "a0651f8b-5757-4db2-b7bb-3d5264ebc3cb",
    "question": "How do you use cache tags in .NET Core?",
    "answer": "```markdown\nIn .NET Core, especially when working with ASP.NET Core, **cache tags** are not a built-in feature of the framework's memory or distributed caching systems. However, you can implement similar functionality using **cache dependencies** or by managing cache keys in a way that allows you to invalidate groups of cached items together.\n\n### Common Approach: Tagging via Key Naming Convention\n\nYou can simulate cache tags by including a tag or group identifier in your cache keys. For example:\n\n```csharp\n// Set cache with a tag in the key\nstring tag = \"Product\";\nstring cacheKey = $\"{tag}_123\";\nmemoryCache.Set(cacheKey, product, TimeSpan.FromMinutes(10));\n```\n\nTo invalidate all items with a specific tag, you can keep a list of keys for each tag:\n\n```csharp\n// Store all keys for a tag\nList<string> productKeys = new List<string> { \"Product_123\", \"Product_456\" };\nmemoryCache.Set(\"Product_Tag_Keys\", productKeys);\n\n// To remove all items with the \"Product\" tag\nforeach (var key in productKeys)\n{\n    memoryCache.Remove(key);\n}\nmemoryCache.Remove(\"Product_Tag_Keys\");\n```\n\n### Using IChangeToken for Tag-like Invalidation\n\nASP.NET Core supports `IChangeToken` for cache invalidation. You can use this to mimic tag-based invalidation:\n\n1. Create a `CancellationTokenSource` for each tag.\n2. When you want to invalidate all items with a tag, cancel the token.\n\n```csharp\n// Create a token source for the tag\nvar cts = new CancellationTokenSource();\nmemoryCache.Set(\"Product_Tag_Token\", cts);\n\n// Set cache entry with expiration token\nmemoryCache.Set(\"Product_123\", product, new MemoryCacheEntryOptions\n{\n    ExpirationTokens = { new CancellationChangeToken(cts.Token) }\n});\n\n// To invalidate all items with the tag\ncts.Cancel();\n```\n\n### Third-Party Libraries\n\nSome third-party libraries (like [CacheManager](https://github.com/MichaCo/CacheManager)) provide more advanced cache tagging features out of the box.\n\n---\n\n**Summary:**  \n.NET Core does not have built-in cache tags, but you can implement them by managing cache keys or using `IChangeToken` for group invalidation. For more advanced scenarios, consider using a third-party caching library.\n```\n",
    "level": "Intermediate"
  },
  {
    "id": "37cb852a-a397-486c-acd5-9aa37c3ae33f",
    "question": "What is caching in .NET Core?",
    "answer": "**Caching in .NET Core** is a technique used to temporarily store frequently accessed data in memory, so that future requests for that data can be served faster without having to fetch or compute it again. This improves the performance and scalability of applications.\n\nIn .NET Core, caching can be implemented in several ways:\n\n- **In-Memory Caching**: Stores data in the server’s memory. Suitable for single-server or small-scale applications.\n- **Distributed Caching**: Stores data in an external cache (like Redis or SQL Server), making it accessible across multiple servers.\n\n.NET Core provides built-in support for caching through interfaces like `IMemoryCache` for in-memory caching and `IDistributedCache` for distributed caching.\n\n**Example (In-Memory Caching):**\n\n```csharp\n// Register IMemoryCache in Startup.cs (for .NET Core 3.x or earlier)\n// services.AddMemoryCache();\n\npublic class MyService\n{\n    private readonly IMemoryCache _cache;\n\n    public MyService(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n\n    public string GetData()\n    {\n        // Try to get the cached value\n        if (!_cache.TryGetValue(\"myKey\", out string data))\n        {\n            // If not found, fetch or compute the data\n            data = \"Expensive data fetch result\";\n            // Store in cache for 5 minutes\n            _cache.Set(\"myKey\", data, TimeSpan.FromMinutes(5));\n        }\n        return data;\n    }\n}\n```\n\n**Summary:**  \nCaching in .NET Core helps improve application performance by storing data temporarily, reducing the need for repeated data retrieval or computation.",
    "level": "Beginner"
  },
  {
    "id": "cae7d37b-dc99-42b4-90e1-aaeb0fd49c54",
    "question": "Why is caching important in web applications?",
    "answer": "Caching is important in web applications because it helps improve performance and scalability. By temporarily storing frequently accessed data in memory, caching reduces the need to repeatedly fetch data from slower sources like databases or external services. This leads to:\n\n- **Faster response times:** Users experience quicker page loads since data can be retrieved from the cache instead of being recalculated or re-fetched.\n- **Reduced server load:** Fewer database queries and external requests mean less strain on backend resources.\n- **Better scalability:** Applications can handle more users and requests efficiently.\n\nIn summary, caching enhances user experience and optimizes resource usage in web applications.",
    "level": "Beginner"
  },
  {
    "id": "675271f3-ef4a-4711-be13-e51dd5ef1448",
    "question": "What are the main types of caching supported in .NET Core?",
    "answer": "```markdown\nIn .NET Core, the main types of caching supported are:\n\n1. **In-Memory Caching**\n   - Stores data in the memory of the web server.\n   - Suitable for small to medium-sized applications or single-server scenarios.\n   - Provided by the `IMemoryCache` interface.\n\n2. **Distributed Caching**\n   - Stores data outside the application's process, often in external systems like Redis or SQL Server.\n   - Suitable for applications running on multiple servers or in cloud environments.\n   - Provided by the `IDistributedCache` interface.\n\n3. **Response Caching**\n   - Caches HTTP responses to reduce the need to generate the same response repeatedly.\n   - Implemented using middleware and response headers.\n\n**Summary Table:**\n\n| Caching Type        | Interface         | Typical Use Case                  |\n|---------------------|------------------|-----------------------------------|\n| In-Memory Caching   | IMemoryCache     | Single server, small applications |\n| Distributed Caching | IDistributedCache| Multi-server, cloud applications  |\n| Response Caching    | Middleware       | HTTP response optimization        |\n```\n",
    "level": "Beginner"
  },
  {
    "id": "ffbe3ec9-9adf-4bbd-82bc-2e74595b1179",
    "question": "What is in-memory caching in .NET Core?",
    "answer": "In-memory caching in .NET Core is a technique used to temporarily store frequently accessed data in the server's memory (RAM). This allows applications to quickly retrieve data without having to fetch it from a slower source, such as a database or an external service, every time it's needed.\n\n**Key Points:**\n- In-memory caching is implemented using the IMemoryCache interface in .NET Core.\n- Cached data is stored locally on the server and is lost if the application restarts.\n- It is best suited for small to medium-sized data that is frequently accessed and can be regenerated if lost.\n- It improves application performance and reduces load on data sources.\n\n**Example Usage:**\n```csharp\n// Register IMemoryCache in Startup.cs (for .NET Core 3.x and earlier)\nservices.AddMemoryCache();\n\n// Inject IMemoryCache in your class\nprivate readonly IMemoryCache _cache;\n\npublic MyService(IMemoryCache cache)\n{\n    _cache = cache;\n}\n\npublic string GetData()\n{\n    // Try to get the cached value\n    if (!_cache.TryGetValue(\"myKey\", out string cachedValue))\n    {\n        // Value not in cache, so get it from the source\n        cachedValue = \"Expensive to get data\";\n        \n        // Set cache options\n        var cacheEntryOptions = new MemoryCacheEntryOptions()\n            .SetSlidingExpiration(TimeSpan.FromMinutes(5));\n        \n        // Save data in cache\n        _cache.Set(\"myKey\", cachedValue, cacheEntryOptions);\n    }\n    return cachedValue;\n}\n```\n\n**Summary:**  \nIn-memory caching in .NET Core is a simple and effective way to boost application performance by storing and retrieving data from memory, reducing the need for repeated expensive operations.",
    "level": "Beginner"
  },
  {
    "id": "9987b5dc-97c2-486e-9fae-86eeb53e23f9",
    "question": "How do you enable in-memory caching in a .NET Core application?",
    "answer": "To enable in-memory caching in a .NET Core application, follow these steps:\n\n1. **Add the required NuGet package**  \n   If you’re using ASP.NET Core, the package is usually included by default. If not, install:\n\n   ```\n   dotnet add package Microsoft.Extensions.Caching.Memory\n   ```\n\n2. **Register the caching service in `Startup.cs` or `Program.cs`**  \n   In ASP.NET Core 3.1 or later, add the following line in the `ConfigureServices` method:\n\n   ```csharp\n   services.AddMemoryCache();\n   ```\n\n   In .NET 6 or later (minimal hosting model), add:\n\n   ```csharp\n   builder.Services.AddMemoryCache();\n   ```\n\n3. **Inject and use `IMemoryCache` in your classes**  \n   Example usage in a controller or service:\n\n   ```csharp\n   public class MyService\n   {\n       private readonly IMemoryCache _cache;\n\n       public MyService(IMemoryCache cache)\n       {\n           _cache = cache;\n       }\n\n       public string GetOrSetValue()\n       {\n           string cacheKey = \"myKey\";\n           if (!_cache.TryGetValue(cacheKey, out string value))\n           {\n               // Key not in cache, so get data.\n               value = \"This is cached data\";\n\n               // Set cache options.\n               var cacheEntryOptions = new MemoryCacheEntryOptions()\n                   .SetSlidingExpiration(TimeSpan.FromMinutes(5));\n\n               // Save data in cache.\n               _cache.Set(cacheKey, value, cacheEntryOptions);\n           }\n           return value;\n       }\n   }\n   ```\n\n**Summary:**  \n- Add the `Microsoft.Extensions.Caching.Memory` package if needed.\n- Register the memory cache service.\n- Inject `IMemoryCache` and use its methods to store and retrieve cached data.",
    "level": "Beginner"
  },
  {
    "id": "b7571b54-96e3-4a4d-8a4a-c14b684ea5a6",
    "question": "What is distributed caching in .NET Core?",
    "answer": "**Distributed caching** in .NET Core is a caching mechanism where cached data is stored outside of the application's memory, typically in an external service or system such as Redis or SQL Server. This allows multiple application instances (such as those running on different servers in a web farm or cloud environment) to share the same cache, ensuring consistency and scalability.\n\n### Key Points\n\n- **Shared Cache:** Data is accessible by all application instances.\n- **Scalability:** Supports scaling out your application without losing cached data.\n- **Persistence:** Cached data can survive application restarts.\n- **Providers:** Common distributed cache providers in .NET Core include Redis and SQL Server.\n\n### Example\n\nTo use distributed caching in .NET Core, you typically configure a provider in `Startup.cs`:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddStackExchangeRedisCache(options =>\n    {\n        options.Configuration = \"localhost:6379\";\n        options.InstanceName = \"SampleInstance\";\n    });\n}\n```\n\nYou can then use `IDistributedCache` to store and retrieve data:\n\n```csharp\npublic class MyService\n{\n    private readonly IDistributedCache _cache;\n\n    public MyService(IDistributedCache cache)\n    {\n        _cache = cache;\n    }\n\n    public async Task SetCacheAsync(string key, string value)\n    {\n        await _cache.SetStringAsync(key, value);\n    }\n\n    public async Task<string> GetCacheAsync(string key)\n    {\n        return await _cache.GetStringAsync(key);\n    }\n}\n```\n\n**Summary:**  \nDistributed caching in .NET Core helps improve performance and scalability by storing cache data in a central location accessible by all application instances.",
    "level": "Beginner"
  },
  {
    "id": "6773ae8c-1de1-492a-8ea2-4ceb8bf5e7c1",
    "question": "Name some distributed cache providers supported by .NET Core.",
    "answer": "**Answer:**\n\nSome distributed cache providers supported by .NET Core include:\n\n- **SQL Server** (`Microsoft.Extensions.Caching.SqlServer`)\n- **Redis** (`Microsoft.Extensions.Caching.StackExchangeRedis`)\n- **NCache** (`Alachisoft.NCache.OpenSource.SDK`)\n- **Memcached** (via third-party packages)\n\nThese providers allow you to store cache data outside of your application's memory, enabling sharing across multiple servers or instances.",
    "level": "Beginner"
  },
  {
    "id": "6da1f9f0-c4be-4aaa-812f-ba4adc7903b0",
    "question": "How do you add distributed caching to a .NET Core application?",
    "answer": "To add distributed caching to a .NET Core application, follow these steps:\n\n1. **Add the Required NuGet Package**\n\nFor example, to use Redis as the distributed cache:\n\n```bash\ndotnet add package Microsoft.Extensions.Caching.StackExchangeRedis\n```\n\n2. **Configure the Distributed Cache in `Startup.cs` or `Program.cs`**\n\nFor .NET 6 and later (using `Program.cs`):\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddStackExchangeRedisCache(options =>\n{\n    options.Configuration = \"localhost:6379\"; // Replace with your Redis server address\n    options.InstanceName = \"SampleInstance\";\n});\n\nvar app = builder.Build();\n```\n\n3. **Use the Distributed Cache in Your Application**\n\nInject `IDistributedCache` where needed (e.g., in a controller):\n\n```csharp\npublic class SampleController : Controller\n{\n    private readonly IDistributedCache _cache;\n\n    public SampleController(IDistributedCache cache)\n    {\n        _cache = cache;\n    }\n\n    public async Task<IActionResult> Index()\n    {\n        string cacheKey = \"sampleKey\";\n        string cachedValue = await _cache.GetStringAsync(cacheKey);\n\n        if (string.IsNullOrEmpty(cachedValue))\n        {\n            cachedValue = \"This is a cached value!\";\n            await _cache.SetStringAsync(cacheKey, cachedValue, new DistributedCacheEntryOptions\n            {\n                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)\n            });\n        }\n\n        ViewBag.Message = cachedValue;\n        return View();\n    }\n}\n```\n\n**Summary Table**\n\n| Step                  | Description                                  |\n|-----------------------|----------------------------------------------|\n| Add NuGet Package     | Install Redis or SQL Server cache provider   |\n| Configure Services    | Add cache configuration in DI container      |\n| Use IDistributedCache | Inject and use in your services/controllers  |\n\n**References:**\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)",
    "level": "Beginner"
  },
  {
    "id": "d6625c88-d4f8-42df-b9c0-f7f47cd679e0",
    "question": "What is the difference between in-memory and distributed caching?",
    "answer": "**In-memory caching** and **distributed caching** are two common caching strategies in .NET Core:\n\n### In-Memory Caching\n\n- **Stored in application memory:** Data is cached in the memory of the web server where the application is running.\n- **Fast access:** Since data is stored locally, retrieval is very quick.\n- **Not shared:** Each server has its own cache. In a multi-server environment, cached data is not shared between servers.\n- **Volatile:** Cache is lost if the application restarts or the server goes down.\n\n> Example: Using `IMemoryCache` in .NET Core.\n\n---\n\n### Distributed Caching\n\n- **Stored externally:** Data is stored in an external service (like Redis or SQL Server), not in the application’s memory.\n- **Shared across servers:** All application instances can access the same cache, making it suitable for load-balanced or cloud environments.\n- **Persistent:** Cache can survive application restarts (depending on the external cache provider).\n- **Slightly slower:** Access is over the network, so it’s a bit slower than in-memory caching.\n\n> Example: Using `IDistributedCache` with Redis in .NET Core.\n\n---\n\n**Summary Table:**\n\n| Feature           | In-Memory Cache         | Distributed Cache         |\n|-------------------|------------------------|--------------------------|\n| Storage Location  | Application memory     | External service         |\n| Shared Across App | No                     | Yes                      |\n| Speed             | Very fast              | Fast (network involved)  |\n| Persistence       | Lost on restart        | Can persist              |\n| Use Case          | Single server          | Multiple servers         |\n\n---\n\n**When to use which?**\n\n- Use **in-memory caching** for simple, single-server applications.\n- Use **distributed caching** for applications running on multiple servers or in the cloud.",
    "level": "Beginner"
  },
  {
    "id": "a56aa78d-9a2a-406d-b361-5b3882f03783",
    "question": "What is the IDistributedCache interface used for?",
    "answer": "The `IDistributedCache` interface in .NET Core is used to provide a simple way to store and retrieve data across multiple servers or processes. It is designed for distributed caching scenarios, where cached data needs to be shared between different instances of an application, such as in a cloud or web farm environment.\n\n**Key Points:**\n- It allows you to cache data in external stores like Redis or SQL Server.\n- It provides methods to set, get, and remove cached items.\n- It helps improve application performance and scalability by reducing database load.\n\n**Example Usage:**\n```csharp\npublic class MyService\n{\n    private readonly IDistributedCache _cache;\n\n    public MyService(IDistributedCache cache)\n    {\n        _cache = cache;\n    }\n\n    public async Task SetCacheAsync(string key, string value)\n    {\n        await _cache.SetStringAsync(key, value);\n    }\n\n    public async Task<string> GetCacheAsync(string key)\n    {\n        return await _cache.GetStringAsync(key);\n    }\n}\n```\n\n**Common Implementations:**\n- `DistributedMemoryCache` (in-memory, for development/testing)\n- `RedisCache` (using Redis)\n- `SqlServerCache` (using SQL Server)\n\n**Summary:**  \n`IDistributedCache` is used to manage cache data in a distributed environment, making it easier to scale .NET Core applications.",
    "level": "Beginner"
  },
  {
    "id": "826c2bb3-f1ae-4043-8f78-951c4776fea4",
    "question": "How do you store and retrieve data from IMemoryCache?",
    "answer": "To store and retrieve data using IMemoryCache in .NET Core, follow these steps:\n\n1. **Inject IMemoryCache**  \n   Inject IMemoryCache into your class via constructor injection:\n\n   ```csharp\n   public class MyService\n   {\n       private readonly IMemoryCache _cache;\n\n       public MyService(IMemoryCache cache)\n       {\n           _cache = cache;\n       }\n   }\n   ```\n\n2. **Store Data in Cache**  \n   Use the Set method to store data:\n\n   ```csharp\n   // Store a value with a key and optional expiration\n   _cache.Set(\"myKey\", \"myValue\", TimeSpan.FromMinutes(5));\n   ```\n\n3. **Retrieve Data from Cache**  \n   Use the TryGetValue method to retrieve data safely:\n\n   ```csharp\n   if (_cache.TryGetValue(\"myKey\", out string value))\n   {\n       // value found in cache\n       Console.WriteLine(value);\n   }\n   else\n   {\n       // value not found in cache\n   }\n   ```\n\n   Or use the Get method (returns null if not found):\n\n   ```csharp\n   var value = _cache.Get<string>(\"myKey\");\n   ```\n\n**Summary Table**\n\n| Operation   | Method Example                                   |\n|-------------|--------------------------------------------------|\n| Store       | _cache.Set(\"key\", value, expirationOptions);     |\n| Retrieve    | _cache.TryGetValue(\"key\", out value);            |\n| Retrieve    | var value = _cache.Get<Type>(\"key\");             |\n\n**Note:**  \nRemember to register IMemoryCache in your Startup.cs (for ASP.NET Core):\n\n```csharp\nservices.AddMemoryCache();\n```\n\n**References:**  \n- [Microsoft Docs: IMemoryCache](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.imemorycache)",
    "level": "Beginner"
  },
  {
    "id": "970ce5e6-f691-4ff5-8ef7-55718fb04cda",
    "question": "What is cache expiration?",
    "answer": "**Cache expiration** in .NET Core refers to the process of automatically removing cached data after a certain period or under specific conditions. This ensures that the cache does not serve outdated or stale information and helps manage memory usage.\n\nThere are two common types of cache expiration:\n\n1. **Absolute Expiration**: The cached item is removed after a fixed time, regardless of how often it is accessed.\n   ```csharp\n   var cacheEntryOptions = new MemoryCacheEntryOptions()\n       .SetAbsoluteExpiration(TimeSpan.FromMinutes(10));\n   ```\n\n2. **Sliding Expiration**: The cached item is removed if it hasn't been accessed for a specified duration. Each access resets the timer.\n   ```csharp\n   var cacheEntryOptions = new MemoryCacheEntryOptions()\n       .SetSlidingExpiration(TimeSpan.FromMinutes(5));\n   ```\n\nBy setting cache expiration, you ensure your application serves fresh data and uses memory efficiently.",
    "level": "Beginner"
  },
  {
    "id": "f614b38c-331d-47ee-9dee-88b19ed404af",
    "question": "What is absolute expiration in caching?",
    "answer": "**Absolute expiration** in caching refers to a fixed point in time after which a cached item is automatically removed from the cache, regardless of how often it is accessed. Once the absolute expiration time is reached, the cached data becomes invalid and is evicted from the cache.\n\nIn .NET Core, you can set absolute expiration for cached items like this:\n\n```csharp\nvar cacheEntryOptions = new MemoryCacheEntryOptions()\n    .SetAbsoluteExpiration(TimeSpan.FromMinutes(10));\n\nmemoryCache.Set(\"key\", \"value\", cacheEntryOptions);\n```\n\nIn this example, the cached item will be removed exactly 10 minutes after it is added, no matter how many times it is accessed during that period.",
    "level": "Beginner"
  },
  {
    "id": "ac81f4cb-15a6-4482-bcff-34848312cd4e",
    "question": "What is sliding expiration in caching?",
    "answer": "**Sliding expiration** in caching is a technique where the expiration timer for a cached item is reset every time that item is accessed. This means the cached data will remain available as long as it is being used frequently. If the item is not accessed within a specified time interval, it will be removed from the cache.\n\nFor example, if you set a sliding expiration of 10 minutes, and the cached item is accessed after 5 minutes, the expiration timer resets, and the item will now expire 10 minutes after this latest access.\n\n**In .NET Core**, you can set sliding expiration like this:\n\n```csharp\nvar cacheEntryOptions = new MemoryCacheEntryOptions()\n    .SetSlidingExpiration(TimeSpan.FromMinutes(10));\n\nmemoryCache.Set(\"key\", value, cacheEntryOptions);\n```\n\n**Key points:**\n- Sliding expiration keeps frequently used items in the cache.\n- The expiration timer resets on each access.\n- Helps optimize memory usage by removing unused items automatically.",
    "level": "Beginner"
  },
  {
    "id": "83fa496f-2e77-4ee0-ab80-8ecaeb4d03d8",
    "question": "How do you configure cache size limits in .NET Core?",
    "answer": "To configure cache size limits in .NET Core, you typically use the MemoryCache implementation provided by Microsoft.Extensions.Caching.Memory. You can set size limits by configuring MemoryCacheOptions and specifying the SizeLimit property. Additionally, when adding items to the cache, you must specify the size of each entry.\n\nHere's how you can do it:\n\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\n\nvar cacheOptions = new MemoryCacheOptions\n{\n    SizeLimit = 1024 // Set the size limit (e.g., 1024 units)\n};\n\nvar memoryCache = new MemoryCache(cacheOptions);\n\n// When adding an item, specify its size\nmemoryCache.Set(\n    \"myKey\",\n    \"myValue\",\n    new MemoryCacheEntryOptions\n    {\n        Size = 1 // The size of this entry\n    }\n);\n```\n\n**Key Points:**\n\n- The SizeLimit property sets the maximum total size for the cache (in arbitrary units you define).\n- Each cache entry must specify its Size property; otherwise, an exception will be thrown when a size limit is set.\n- The size unit is up to you (e.g., bytes, kilobytes, number of items), but you must be consistent.\n\n**In ASP.NET Core (Startup.cs):**\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMemoryCache(options =>\n    {\n        options.SizeLimit = 1024; // Set cache size limit\n    });\n}\n```\n\nWhen injecting IMemoryCache, always specify the Size when adding entries:\n\n```csharp\npublic class MyService\n{\n    private readonly IMemoryCache _cache;\n\n    public MyService(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n\n    public void CacheSomething()\n    {\n        _cache.Set(\"key\", \"value\", new MemoryCacheEntryOptions\n        {\n            Size = 1\n        });\n    }\n}\n```\n\n**Summary:**  \nSet the SizeLimit in MemoryCacheOptions and specify Size for each cache entry to enforce cache size limits in .NET Core.",
    "level": "Intermediate"
  },
  {
    "id": "438b2910-f874-4b54-8c3d-2b37ee54ae1d",
    "question": "What is cache dependency and how is it implemented in .NET Core?",
    "answer": "**Cache Dependency in .NET Core**\n\nCache dependency refers to a mechanism where cached data is automatically invalidated or refreshed when a related resource changes. This ensures that the cache does not serve stale or outdated data.\n\n### How Cache Dependency Works\n\n- **Purpose:** To keep cached data in sync with its underlying data source (like a database, file, or another cache entry).\n- **Example:** If a cache entry depends on a database record, and that record changes, the cache entry should be invalidated.\n\n### Implementing Cache Dependency in .NET Core\n\n.NET Core provides in-memory caching via `IMemoryCache` and distributed caching via `IDistributedCache`. While .NET Core does not have built-in support for complex cache dependencies (like SQL cache dependency in classic ASP.NET), you can implement basic dependencies using cache entry options.\n\n#### 1. Using Expiration Tokens\n\nYou can use `IChangeToken` to link cache entries to external change notifications.\n\n```csharp\npublic class MyChangeToken : IChangeToken\n{\n    private bool _hasChanged = false;\n    public bool HasChanged => _hasChanged;\n    public bool ActiveChangeCallbacks => true;\n\n    public IDisposable RegisterChangeCallback(Action<object> callback, object state)\n    {\n        // Call the callback when the change occurs\n        return null;\n    }\n\n    public void SignalChange()\n    {\n        _hasChanged = true;\n    }\n}\n```\n\nUsage:\n\n```csharp\nvar changeToken = new MyChangeToken();\n\n_memoryCache.Set(\"myKey\", \"myValue\", new MemoryCacheEntryOptions\n{\n    ExpirationTokens = { changeToken }\n});\n\n// When the underlying data changes:\nchangeToken.SignalChange(); // This will invalidate the cache entry\n```\n\n#### 2. Using Post Eviction Callbacks\n\nYou can set up callbacks to handle cache eviction and potentially refresh dependent entries.\n\n```csharp\n_memoryCache.Set(\"myKey\", \"myValue\", new MemoryCacheEntryOptions\n{\n    PostEvictionCallbacks =\n    {\n        new PostEvictionCallbackRegistration\n        {\n            EvictionCallback = (key, value, reason, state) =>\n            {\n                // Handle cache eviction, e.g., refresh dependent cache\n            }\n        }\n    }\n});\n```\n\n#### 3. Manual Dependency Management\n\nFor more complex scenarios (e.g., database dependencies), you may need to:\n\n- Monitor the data source for changes (using events, polling, or triggers).\n- Invalidate or refresh the cache manually when a change is detected.\n\n### Summary Table\n\n| Method                  | Description                                 | Use Case                           |\n|-------------------------|---------------------------------------------|------------------------------------|\n| IChangeToken            | Invalidate cache on external change signal  | File changes, custom triggers      |\n| Post Eviction Callback  | React to cache eviction                     | Refresh or clean up dependencies   |\n| Manual Invalidation     | Custom logic to manage dependencies         | Database changes, complex scenarios|\n\n---\n\n**In summary:**  \nCache dependency in .NET Core is typically implemented using `IChangeToken` for automatic invalidation, post-eviction callbacks for handling removals, or custom logic for more advanced scenarios. .NET Core does not provide built-in database cache dependencies, so these must be implemented as needed.",
    "level": "Intermediate"
  },
  {
    "id": "f1945cc6-44a2-4100-a98a-670051097f95",
    "question": "How can you cache the output of a controller action in ASP.NET Core?",
    "answer": "You can cache the output of a controller action in ASP.NET Core using the `ResponseCache` attribute or by using middleware such as in-memory caching or distributed caching. The most straightforward way is to use the `ResponseCache` attribute, which sets appropriate headers for client/proxy caching. For server-side caching, you can use the `IMemoryCache` or `IDistributedCache` services.\n\n### Using the `ResponseCache` Attribute\n\n```csharp\n[ResponseCache(Duration = 60, Location = ResponseCacheLocation.Client)]\npublic IActionResult MyAction()\n{\n    // Your logic here\n    return View();\n}\n```\n- `Duration` specifies the time (in seconds) the response is cached.\n- `Location` specifies where the response is cached (Client, Any, or None).\n\n### Using In-Memory Caching (`IMemoryCache`)\n\n```csharp\npublic class MyController : Controller\n{\n    private readonly IMemoryCache _cache;\n\n    public MyController(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n\n    public IActionResult MyAction()\n    {\n        string cacheKey = \"myData\";\n        if (!_cache.TryGetValue(cacheKey, out MyDataType data))\n        {\n            // Data not in cache, so get it from source\n            data = GetDataFromSource();\n\n            // Set cache options\n            var cacheEntryOptions = new MemoryCacheEntryOptions()\n                .SetSlidingExpiration(TimeSpan.FromMinutes(5));\n\n            // Save data in cache\n            _cache.Set(cacheKey, data, cacheEntryOptions);\n        }\n\n        return View(data);\n    }\n}\n```\n\n### Summary\n\n- Use `[ResponseCache]` for HTTP header-based caching.\n- Use `IMemoryCache` or `IDistributedCache` for server-side caching of action results or data.\n- Choose the method based on your caching requirements (client/proxy vs. server-side).",
    "level": "Intermediate"
  },
  {
    "id": "5c14c953-3fcd-41fb-800d-6c8f7dea83ce",
    "question": "What is response caching middleware in ASP.NET Core?",
    "answer": "**Response caching middleware** in ASP.NET Core is a component that enables caching of HTTP responses to improve the performance and scalability of web applications. When enabled, it stores responses for subsequent requests, reducing the need to generate the same response repeatedly.\n\n### Key Points\n\n- **Purpose:** It caches HTTP responses based on cache-related headers (like `Cache-Control`, `Vary`, etc.) sent by the server.\n- **How it works:** When a request is received, the middleware checks if a cached response exists and is valid. If so, it serves the cached response instead of invoking the rest of the pipeline.\n- **Configuration:** You add it in `Startup.cs` (or `Program.cs` in .NET 6+) with `app.UseResponseCaching()` and configure caching headers in your controllers/actions.\n\n### Example Usage\n\n```csharp\n// In Program.cs or Startup.cs\napp.UseResponseCaching();\n\n// In a controller\n[HttpGet]\n[ResponseCache(Duration = 60, Location = ResponseCacheLocation.Any, VaryByQueryKeys = new[] { \"id\" })]\npublic IActionResult Get(int id)\n{\n    // Your logic here\n    return Ok($\"Response for id={id} at {DateTime.Now}\");\n}\n```\n\n### Notes\n\n- The middleware only caches responses for GET and HEAD requests.\n- It respects cache headers you set in your responses.\n- It does **not** cache responses with certain headers (e.g., `Set-Cookie`).\n- For more advanced scenarios (like distributed caching), consider using other caching mechanisms.\n\n**References:**  \n- [Microsoft Docs: Response caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/middleware)",
    "level": "Intermediate"
  },
  {
    "id": "44d356d6-a4af-4ff0-a37c-683ce6dd5f82",
    "question": "How can you invalidate cache entries in .NET Core?",
    "answer": "You can invalidate cache entries in .NET Core using several approaches, depending on the caching mechanism you are using (in-memory, distributed, etc.). Here are common methods for invalidating cache entries:\n\n### 1. Manual Removal\n\nIf you are using `IMemoryCache` or `IDistributedCache`, you can explicitly remove a cache entry by its key:\n\n```csharp\n// For IMemoryCache\nmemoryCache.Remove(\"myCacheKey\");\n\n// For IDistributedCache\nawait distributedCache.RemoveAsync(\"myCacheKey\");\n```\n\n---\n\n### 2. Expiration Policies\n\nYou can set expiration policies when adding items to the cache, so they are automatically invalidated:\n\n#### Absolute Expiration\n\nThe cache entry expires after a fixed time, regardless of access.\n\n```csharp\nmemoryCache.Set(\"myCacheKey\", myValue, TimeSpan.FromMinutes(10));\n```\n\n#### Sliding Expiration\n\nThe cache entry expires if it hasn't been accessed within a specified time window.\n\n```csharp\nmemoryCache.Set(\"myCacheKey\", myValue, new MemoryCacheEntryOptions\n{\n    SlidingExpiration = TimeSpan.FromMinutes(5)\n});\n```\n\n---\n\n### 3. Using Cache Dependencies (Eviction Tokens)\n\nYou can use `CancellationToken` to invalidate cache entries programmatically:\n\n```csharp\nvar cts = new CancellationTokenSource();\nmemoryCache.Set(\"myCacheKey\", myValue, new MemoryCacheEntryOptions\n{\n    ExpirationTokens = { new CancellationChangeToken(cts.Token) }\n});\n\n// Invalidate the cache entry\ncts.Cancel();\n```\n\n---\n\n### 4. Clearing All Cache Entries\n\nFor `IMemoryCache`, there is no built-in method to clear all entries, but you can use a wrapper or recreate the cache instance. For distributed caches like Redis, you can use Redis commands to clear keys.\n\n---\n\n**Summary Table**\n\n| Method                | Description                                 |\n|-----------------------|---------------------------------------------|\n| Remove(key)           | Manually remove by key                      |\n| Absolute Expiration   | Expires after a fixed time                  |\n| Sliding Expiration    | Expires after inactivity                    |\n| Eviction Tokens       | Invalidate programmatically                 |\n| Clear All             | Recreate cache or use backend-specific APIs |\n\n---\n\n**References:**\n- [Microsoft Docs: Cache in-memory in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/memory)\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)",
    "level": "Intermediate"
  },
  {
    "id": "360952b4-776d-4326-b7f0-aa5ba9b6e6f2",
    "question": "What are cache keys and why are they important?",
    "answer": "**Cache keys** are unique identifiers used to store and retrieve items in a cache. In .NET Core caching, a cache key is typically a string (or sometimes a composite object) that represents the data being cached.\n\n### Why Are Cache Keys Important?\n\n- **Uniqueness:** Each cache key must uniquely identify a cached item. If two different pieces of data use the same key, one will overwrite the other.\n- **Efficient Retrieval:** Cache keys allow you to quickly look up cached data without recomputing or refetching it.\n- **Organization:** Well-designed cache keys help organize cached data, making it easier to manage and invalidate specific entries.\n- **Avoiding Collisions:** Properly structured keys prevent accidental collisions, ensuring that cached data is accurate and consistent.\n\n**Example:**\n```csharp\n// Storing an item in the cache\ncache.Set(\"UserProfile_123\", userProfile);\n\n// Retrieving the item later\nvar cachedProfile = cache.Get<UserProfile>(\"UserProfile_123\");\n```\nIn this example, \"UserProfile_123\" is the cache key that uniquely identifies the cached user profile with ID 123.\n\n**Summary:**  \nCache keys are crucial in .NET Core caching because they ensure that cached data is uniquely identified, efficiently retrievable, and well-organized, preventing data conflicts and improving application performance.",
    "level": "Intermediate"
  },
  {
    "id": "d91e29f7-f13e-4204-bea3-93b352406077",
    "question": "How do you serialize complex objects for distributed caching?",
    "answer": "To serialize complex objects for distributed caching in .NET Core, you typically use a serialization library to convert your objects into a byte array or string format before storing them in the cache. The most common approach is to use JSON serialization with System.Text.Json or Newtonsoft.Json.\n\nHere's a step-by-step example using System.Text.Json with IDistributedCache:\n\n```csharp\nusing Microsoft.Extensions.Caching.Distributed;\nusing System.Text.Json;\n\n// Example complex object\npublic class MyComplexObject\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\n// Serialize and store in distributed cache\npublic async Task SetCacheAsync(IDistributedCache cache, string key, MyComplexObject obj)\n{\n    var jsonString = JsonSerializer.Serialize(obj);\n    await cache.SetStringAsync(key, jsonString);\n}\n\n// Retrieve and deserialize from distributed cache\npublic async Task<MyComplexObject> GetCacheAsync(IDistributedCache cache, string key)\n{\n    var jsonString = await cache.GetStringAsync(key);\n    if (jsonString == null)\n        return null;\n\n    return JsonSerializer.Deserialize<MyComplexObject>(jsonString);\n}\n```\n\n**Key Points:**\n\n- Use `JsonSerializer.Serialize()` to convert the object to a JSON string.\n- Store the JSON string using `SetStringAsync`.\n- Retrieve and deserialize using `GetStringAsync` and `JsonSerializer.Deserialize()`.\n- For binary serialization (for performance or compatibility reasons), you can use libraries like MessagePack or Protocol Buffers.\n\n**Tip:** Always handle versioning and backward compatibility when caching complex objects, as changes to the object structure can cause deserialization issues.",
    "level": "Intermediate"
  },
  {
    "id": "b99ff8b0-b728-4121-b888-de4f33dbf141",
    "question": "How do you handle cache stampede in .NET Core?",
    "answer": "```markdown\nTo handle **cache stampede** (also known as cache avalanche or thundering herd problem) in .NET Core, you can use several strategies to prevent multiple threads or requests from simultaneously regenerating an expired cache entry. Here are some effective approaches:\n\n### 1. **Locking (Mutex/Semaphore)**\nWrap the cache population logic in a lock so that only one thread can regenerate the cache at a time. Others wait for the cache to be refreshed.\n\n```csharp\nprivate static readonly SemaphoreSlim _cacheLock = new SemaphoreSlim(1, 1);\n\npublic async Task<T> GetOrAddAsync<T>(string key, Func<Task<T>> factory, TimeSpan cacheDuration)\n{\n    var cache = _memoryCache.Get<T>(key);\n    if (cache != null)\n        return cache;\n\n    await _cacheLock.WaitAsync();\n    try\n    {\n        // Double-check after acquiring the lock\n        cache = _memoryCache.Get<T>(key);\n        if (cache != null)\n            return cache;\n\n        var result = await factory();\n        _memoryCache.Set(key, result, cacheDuration);\n        return result;\n    }\n    finally\n    {\n        _cacheLock.Release();\n    }\n}\n```\n\n### 2. **Distributed Locking**\nFor distributed systems (e.g., multiple servers), use a distributed lock (e.g., Redis RedLock) to ensure only one instance regenerates the cache.\n\n- Use libraries like [RedLock.net](https://github.com/samcook/RedLock.net) with Redis.\n\n### 3. **Cache-Aside Pattern with Early Refresh**\nProactively refresh the cache before it expires (soft expiration), so requests rarely see a cache miss.\n\n- Store both the value and its logical expiration.\n- If the logical expiration is near, trigger a background refresh, but continue serving the stale value until the refresh completes.\n\n```csharp\npublic class CacheItem<T>\n{\n    public T Value { get; set; }\n    public DateTime LogicalExpiration { get; set; }\n}\n\npublic async Task<T> GetWithEarlyRefreshAsync<T>(string key, Func<Task<T>> factory, TimeSpan cacheDuration, TimeSpan refreshThreshold)\n{\n    var cacheItem = _memoryCache.Get<CacheItem<T>>(key);\n    if (cacheItem != null && cacheItem.LogicalExpiration > DateTime.UtcNow)\n        return cacheItem.Value;\n\n    if (cacheItem != null && cacheItem.LogicalExpiration + refreshThreshold > DateTime.UtcNow)\n    {\n        // Trigger background refresh\n        _ = Task.Run(async () =>\n        {\n            var refreshed = await factory();\n            _memoryCache.Set(key, new CacheItem<T> { Value = refreshed, LogicalExpiration = DateTime.UtcNow.Add(cacheDuration) });\n        });\n        return cacheItem.Value; // Serve stale\n    }\n\n    // Cache miss or too stale\n    var value = await factory();\n    _memoryCache.Set(key, new CacheItem<T> { Value = value, LogicalExpiration = DateTime.UtcNow.Add(cacheDuration) });\n    return value;\n}\n```\n\n### 4. **Randomized Expiration (Jitter)**\nAdd randomness to cache expiration times to avoid many keys expiring simultaneously.\n\n```csharp\nvar random = new Random();\nvar jitter = TimeSpan.FromSeconds(random.Next(0, 30));\n_memoryCache.Set(key, value, cacheDuration + jitter);\n```\n\n---\n\n## **Summary Table**\n\n| Strategy                | Description                                         | Use Case                  |\n|-------------------------|-----------------------------------------------------|---------------------------|\n| Locking                 | Local lock to serialize cache regeneration          | Single server             |\n| Distributed Locking     | Distributed lock (e.g., Redis)                      | Multi-server/distributed  |\n| Early Refresh           | Refresh cache before it expires                     | High-read, low-latency    |\n| Randomized Expiration   | Add jitter to expiration times                      | Large cache sets          |\n\n**Best Practice:**  \nCombine these strategies as needed. For example, use distributed locking with early refresh for critical, high-traffic cache entries in a multi-server environment.\n\n---\n**References:**\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)\n- [RedLock.net](https://github.com/samcook/RedLock.net)\n```\n",
    "level": "Advanced"
  },
  {
    "id": "9b3bdc8f-39f8-4a11-9a80-307055815b0e",
    "question": "What is cache poisoning and how can you prevent it in .NET Core?",
    "answer": "**Cache poisoning** is a security vulnerability where an attacker injects malicious or incorrect data into a cache, causing subsequent requests to receive and potentially act on this manipulated data. In the context of .NET Core, this can happen if user-controllable input is used to generate cache keys or cache entries, or if untrusted data is cached without validation.\n\n### How Cache Poisoning Occurs\n\n- **Unvalidated Input in Cache Keys:** If cache keys are constructed using user input without proper validation or sanitization, attackers can manipulate the cache to serve incorrect or malicious content.\n- **Shared Caches:** In multi-tenant or shared environments, one user might poison the cache for others if isolation is not enforced.\n- **Improper Cache Invalidation:** If cache entries are not invalidated correctly, stale or malicious data can persist.\n\n---\n\n## Preventing Cache Poisoning in .NET Core\n\n### 1. **Validate and Sanitize Input**\n\nAlways validate and sanitize any user input that is used to generate cache keys or cache values.\n\n```csharp\n// Example: Only allow alphanumeric user IDs\nif (!Regex.IsMatch(userId, @\"^[a-zA-Z0-9]+$\"))\n{\n    throw new ArgumentException(\"Invalid user ID\");\n}\nvar cacheKey = $\"UserProfile_{userId}\";\n```\n\n### 2. **Use Strong Cache Key Generation**\n\n- Avoid using raw user input directly in cache keys.\n- Use a consistent, canonical format for cache keys.\n- Consider hashing sensitive or complex input.\n\n```csharp\nvar cacheKey = $\"UserProfile_{Hash(userId)}\";\n```\n\n### 3. **Cache Only Trusted Data**\n\n- Only cache data that has been validated and is known to be safe.\n- Avoid caching data that comes directly from user input without processing.\n\n### 4. **Implement Proper Cache Segregation**\n\n- Use separate cache namespaces or prefixes for different users or tenants.\n- In distributed cache scenarios, ensure that cache entries for one user cannot be accessed by another.\n\n```csharp\nvar cacheKey = $\"Tenant_{tenantId}_UserProfile_{userId}\";\n```\n\n### 5. **Set Appropriate Expiration Policies**\n\n- Use sliding or absolute expiration to limit the lifetime of cached data.\n- Regularly invalidate or refresh cache entries to prevent stale or poisoned data from persisting.\n\n```csharp\nvar cacheEntryOptions = new MemoryCacheEntryOptions()\n    .SetSlidingExpiration(TimeSpan.FromMinutes(30));\n```\n\n### 6. **Monitor and Audit Cache Usage**\n\n- Log cache hits, misses, and invalidations.\n- Monitor for unusual patterns that might indicate cache poisoning attempts.\n\n---\n\n## Summary Table\n\n| Prevention Technique         | Description                                            |\n|-----------------------------|--------------------------------------------------------|\n| Input Validation             | Sanitize all input used in cache keys/values           |\n| Strong Key Generation        | Use canonical, hashed, or prefixed keys                |\n| Cache Trusted Data Only      | Validate data before caching                           |\n| Cache Segregation            | Isolate cache entries per user/tenant                  |\n| Expiration Policies          | Limit cache lifetime                                   |\n| Monitoring                   | Audit and log cache activity                           |\n\n---\n\n**In .NET Core, always treat cache as a potential attack vector and apply these best practices to prevent cache poisoning.**",
    "level": "Advanced"
  },
  {
    "id": "2fb5a832-1aae-4e7f-a454-a6d4bf9497cc",
    "question": "How do you implement cache prefetching in .NET Core?",
    "answer": "```markdown\n### Implementing Cache Prefetching in .NET Core\n\n**Cache prefetching** involves proactively loading data into the cache before it is requested, reducing latency for end-users. In .NET Core, this can be implemented using background services and the built-in caching mechanisms (`IMemoryCache`, `IDistributedCache`, etc.).\n\n#### Steps to Implement Cache Prefetching\n\n1. **Identify Data to Prefetch**\n   - Analyze usage patterns to determine which data is frequently accessed and suitable for prefetching.\n\n2. **Create a Background Service**\n   - Use `IHostedService` or `BackgroundService` to run prefetching logic periodically.\n\n3. **Fetch and Store Data in Cache**\n   - Retrieve the data from the source (e.g., database, API).\n   - Store it in the cache with appropriate keys and expiration policies.\n\n#### Example: Prefetching with IMemoryCache\n\n```csharp\npublic class PrefetchCacheService : BackgroundService\n{\n    private readonly IMemoryCache _cache;\n    private readonly ILogger<PrefetchCacheService> _logger;\n\n    public PrefetchCacheService(IMemoryCache cache, ILogger<PrefetchCacheService> logger)\n    {\n        _cache = cache;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                // Example: Prefetch data every 10 minutes\n                await PrefetchDataAsync();\n                await Task.Delay(TimeSpan.FromMinutes(10), stoppingToken);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error during cache prefetching.\");\n            }\n        }\n    }\n\n    private async Task PrefetchDataAsync()\n    {\n        // Fetch data from source\n        var data = await GetDataFromSourceAsync();\n\n        // Store in cache\n        _cache.Set(\"PrefetchedDataKey\", data, TimeSpan.FromMinutes(15));\n    }\n\n    private Task<List<string>> GetDataFromSourceAsync()\n    {\n        // Simulate data fetch\n        return Task.FromResult(new List<string> { \"item1\", \"item2\", \"item3\" });\n    }\n}\n```\n\n**Register the service in `Startup.cs` or `Program.cs`:**\n\n```csharp\nservices.AddMemoryCache();\nservices.AddHostedService<PrefetchCacheService>();\n```\n\n#### Tips\n\n- **Expiration Policy:** Set cache expiration slightly longer than the prefetch interval to avoid cache misses.\n- **Concurrency:** Ensure thread safety if multiple services may update the same cache entry.\n- **Distributed Cache:** For multi-instance apps, use `IDistributedCache` (e.g., Redis) for shared cache prefetching.\n\n#### References\n\n- [Microsoft Docs: Background tasks with hosted services in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services)\n- [Microsoft Docs: Caching in .NET](https://learn.microsoft.com/en-us/dotnet/core/extensions/caching)\n\n---\nBy leveraging background services and caching abstractions, you can efficiently implement cache prefetching in .NET Core to improve application performance.\n```\n",
    "level": "Advanced"
  },
  {
    "id": "be0a10b2-72ad-4542-bf3d-246972968f62",
    "question": "How can you monitor cache performance in .NET Core?",
    "answer": "To monitor cache performance in .NET Core, you can use a combination of built-in diagnostics, logging, and third-party tools. Here’s how you can approach it:\n\n## 1. **Use EventCounters and DiagnosticSource**\n\n.NET Core provides built-in diagnostics for caching components like `MemoryCache` and distributed caches. You can listen to these events using `EventListener` or tools like dotnet-counters.\n\n### Example: Using dotnet-counters\n\n```bash\ndotnet-counters monitor --process-id <your-app-pid>\n```\n\nLook for counters related to `Microsoft.Extensions.Caching.Memory` or your distributed cache provider.\n\n## 2. **Enable Logging**\n\nConfigure logging for cache operations. For `IMemoryCache`, you can log cache hits, misses, and evictions by wrapping cache access in your own methods and logging accordingly.\n\n```csharp\nif (!_cache.TryGetValue(key, out value))\n{\n    _logger.LogInformation(\"Cache miss for key: {Key}\", key);\n    // Fetch and set cache\n}\nelse\n{\n    _logger.LogInformation(\"Cache hit for key: {Key}\", key);\n}\n```\n\n## 3. **Use Performance Counters (Windows only)**\n\nIf running on Windows, you can use Performance Counters for memory cache metrics, though this is less common in .NET Core compared to .NET Framework.\n\n## 4. **Application Insights or Other APM Tools**\n\nIntegrate Application Insights, New Relic, or similar tools to track custom cache metrics. You can create custom telemetry for cache hits, misses, and evictions.\n\n```csharp\nTelemetryClient telemetry = new TelemetryClient();\ntelemetry.TrackEvent(\"CacheHit\", new Dictionary<string, string> { { \"Key\", key } });\n```\n\n## 5. **Expose Custom Metrics**\n\nExpose cache metrics via endpoints (e.g., `/metrics` for Prometheus) using libraries like `prometheus-net`. Track and export metrics such as:\n\n- Cache hit rate\n- Cache miss rate\n- Cache size\n- Eviction count\n\n## 6. **Monitor Distributed Cache Backends**\n\nIf using Redis or SQL Server as a distributed cache, monitor their performance using their respective monitoring tools (e.g., Redis CLI, Azure Redis metrics, SQL Server DMVs).\n\n---\n\n### **Summary Table**\n\n| Method                          | What You Get                       |\n|----------------------------------|------------------------------------|\n| EventCounters/dotnet-counters    | Real-time cache stats              |\n| Logging                         | Custom cache hit/miss logs         |\n| Performance Counters             | Windows-only, low-level metrics    |\n| Application Insights/APM         | End-to-end telemetry and tracing   |\n| Custom Metrics/Prometheus        | Exportable, dashboard-ready stats  |\n| Backend Monitoring               | Health and performance of backend  |\n\n---\n\n**Best Practice:**  \nCombine several of these methods for comprehensive cache performance monitoring in your .NET Core applications.",
    "level": "Advanced"
  },
  {
    "id": "5246a8d9-4e80-47eb-86f3-09d12cf41840",
    "question": "What are some best practices for cache key design in .NET Core?",
    "answer": "**Best Practices for Cache Key Design in .NET Core**\n\nDesigning effective cache keys is crucial for maximizing cache efficiency, avoiding collisions, and ensuring data consistency. Here are some advanced best practices for cache key design in .NET Core:\n\n---\n\n### 1. **Use Predictable and Unique Keys**\n- Construct keys that uniquely identify the cached data.\n- Combine relevant parameters (e.g., user ID, query parameters) to avoid collisions.\n\n```csharp\nstring cacheKey = $\"UserProfile:{userId}:Settings:{settingsVersion}\";\n```\n\n---\n\n### 2. **Be Consistent with Key Formatting**\n- Use a consistent delimiter (e.g., colon `:`) to separate key segments.\n- Avoid spaces and special characters that may cause parsing issues.\n\n---\n\n### 3. **Include Versioning**\n- Add a version segment to the key to handle schema or logic changes without stale data issues.\n\n```csharp\nstring cacheKey = $\"Product:v2:{productId}\";\n```\n\n---\n\n### 4. **Keep Keys Short but Descriptive**\n- Long keys can impact performance, especially in distributed caches like Redis.\n- Avoid unnecessary verbosity but ensure enough context for uniqueness.\n\n---\n\n### 5. **Avoid Sensitive Data**\n- Never include sensitive or personal information (e.g., passwords, tokens) in cache keys.\n\n---\n\n### 6. **Normalize Parameter Values**\n- Convert parameters to a standard format (e.g., lowercase, trimmed) to prevent duplicate cache entries for semantically identical requests.\n\n```csharp\nstring normalizedEmail = email.Trim().ToLowerInvariant();\nstring cacheKey = $\"UserByEmail:{normalizedEmail}\";\n```\n\n---\n\n### 7. **Use Hashing for Complex Keys**\n- For keys with many or large parameters, use a hash (e.g., SHA256) to keep the key length manageable.\n\n```csharp\nstring rawKey = $\"{userId}:{string.Join(\",\", permissions)}\";\nstring hashedKey = $\"UserPerms:{ComputeSha256Hash(rawKey)}\";\n```\n\n---\n\n### 8. **Namespace Keys by Context**\n- Prefix keys with application or module names to avoid cross-application collisions, especially in shared caches.\n\n```csharp\nstring cacheKey = $\"MyApp:Orders:{orderId}\";\n```\n\n---\n\n### 9. **Document Key Structures**\n- Maintain documentation or constants for key formats to ensure consistency across the codebase.\n\n```csharp\npublic static class CacheKeys\n{\n    public static string UserProfile(int userId) => $\"UserProfile:{userId}\";\n}\n```\n\n---\n\n### 10. **Test for Collisions**\n- Regularly review and test key generation logic to ensure uniqueness and prevent accidental overwrites.\n\n---\n\nBy following these best practices, you can design robust, maintainable, and efficient cache keys in your .NET Core applications.",
    "level": "Advanced"
  },
  {
    "id": "56324929-8532-4887-ae6e-3be820320b77",
    "question": "How do you implement distributed caching with Redis in .NET Core?",
    "answer": "To implement distributed caching with Redis in .NET Core, follow these steps:\n\n1. **Install the Required NuGet Package**\n\n   Add the `Microsoft.Extensions.Caching.StackExchangeRedis` package to your project:\n\n   ```bash\n   dotnet add package Microsoft.Extensions.Caching.StackExchangeRedis\n   ```\n\n2. **Configure Redis in `appsettings.json`**\n\n   ```json\n   {\n     \"Redis\": {\n       \"Configuration\": \"localhost:6379\"\n     }\n   }\n   ```\n\n3. **Register Redis Cache in `Startup.cs` or Program Setup**\n\n   ```csharp\n   // For .NET 6+ (Minimal API style)\n   var builder = WebApplication.CreateBuilder(args);\n\n   builder.Services.AddStackExchangeRedisCache(options =>\n   {\n       options.Configuration = builder.Configuration.GetSection(\"Redis:Configuration\").Value;\n   });\n\n   var app = builder.Build();\n   // ...\n   ```\n\n   For older versions, use `ConfigureServices` in `Startup.cs`.\n\n4. **Use `IDistributedCache` in Your Services or Controllers**\n\n   ```csharp\n   public class MyService\n   {\n       private readonly IDistributedCache _cache;\n\n       public MyService(IDistributedCache cache)\n       {\n           _cache = cache;\n       }\n\n       public async Task SetCacheAsync(string key, string value)\n       {\n           var options = new DistributedCacheEntryOptions\n           {\n               AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)\n           };\n           await _cache.SetStringAsync(key, value, options);\n       }\n\n       public async Task<string> GetCacheAsync(string key)\n       {\n           return await _cache.GetStringAsync(key);\n       }\n   }\n   ```\n\n5. **Inject and Use the Service**\n\n   ```csharp\n   // In your controller\n   [ApiController]\n   [Route(\"[controller]\")]\n   public class SampleController : ControllerBase\n   {\n       private readonly MyService _service;\n\n       public SampleController(MyService service)\n       {\n           _service = service;\n       }\n\n       [HttpGet(\"{key}\")]\n       public async Task<IActionResult> Get(string key)\n       {\n           var value = await _service.GetCacheAsync(key);\n           return Ok(value ?? \"Not found\");\n       }\n   }\n   ```\n\n---\n\n**Summary Table**\n\n| Step                          | Description                                   |\n|-------------------------------|-----------------------------------------------|\n| Install NuGet package         | `Microsoft.Extensions.Caching.StackExchangeRedis` |\n| Configure Redis               | Add connection string in `appsettings.json`   |\n| Register Redis cache          | In DI container (`AddStackExchangeRedisCache`)|\n| Use `IDistributedCache`       | Inject and use in services/controllers        |\n\n---\n\n**References:**\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-7.0)\n- [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis)",
    "level": "Intermediate"
  },
  {
    "id": "8f09d46a-924a-4016-b5d3-31319dc9e7ee",
    "question": "How do you implement distributed caching with SQL Server in .NET Core?",
    "answer": "To implement distributed caching with SQL Server in .NET Core, follow these steps:\n\n### 1. Install Required NuGet Package\n\nAdd the Microsoft SQL Server distributed cache package to your project:\n\n```bash\ndotnet add package Microsoft.Extensions.Caching.SqlServer\n```\n\n### 2. Configure SQL Server Cache Table\n\nCreate a table in your SQL Server database to store the cache. You can use the provided script:\n\n```bash\ndotnet sql-cache create \"YourConnectionString\" dbo CacheTable\n```\n\n- Replace `\"YourConnectionString\"` with your actual SQL Server connection string.\n- `dbo` is the schema, and `CacheTable` is the table name.\n\n### 3. Configure Distributed Cache in `Startup.cs` or Program Configuration\n\nAdd the distributed SQL Server cache in your service configuration:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddDistributedSqlServerCache(options =>\n    {\n        options.ConnectionString = \"YourConnectionString\";\n        options.SchemaName = \"dbo\";\n        options.TableName = \"CacheTable\";\n    });\n\n    // Other service registrations...\n}\n```\n\n### 4. Use the Distributed Cache in Your Application\n\nInject `IDistributedCache` where you need caching:\n\n```csharp\npublic class MyService\n{\n    private readonly IDistributedCache _cache;\n\n    public MyService(IDistributedCache cache)\n    {\n        _cache = cache;\n    }\n\n    public async Task SetCacheAsync(string key, string value)\n    {\n        await _cache.SetStringAsync(key, value, new DistributedCacheEntryOptions\n        {\n            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)\n        });\n    }\n\n    public async Task<string> GetCacheAsync(string key)\n    {\n        return await _cache.GetStringAsync(key);\n    }\n}\n```\n\n### 5. Notes\n\n- Distributed caching is useful for load-balanced applications where multiple instances need to share cached data.\n- SQL Server caching is slower than in-memory caching but provides persistence and sharing across servers.\n\n---\n\n**References:**\n\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed?view=aspnetcore-7.0)\n- [Microsoft Docs: SQL Server distributed cache](https://learn.microsoft.com/en-us/dotnet/core/extensions/caching-sql-server)",
    "level": "Intermediate"
  },
  {
    "id": "55f4d8c5-eb10-4023-ac2c-b5ab2bd2af4c",
    "question": "What are the limitations of in-memory caching in a cloud environment?",
    "answer": "**Limitations of In-Memory Caching in a Cloud Environment**\n\nIn-memory caching (e.g., using IMemoryCache in .NET Core) stores data within the memory of a single application instance. While simple and fast, it has several limitations in cloud environments:\n\n1. **Lack of Distributed Access**\n   - Each application instance has its own cache. Data cached in one instance is not available to others, leading to cache inconsistency and redundant memory usage.\n\n2. **Scalability Issues**\n   - When scaling out (adding more instances), each instance maintains its own cache, which can result in increased memory consumption and reduced cache hit rates.\n\n3. **Data Loss on Restart**\n   - Cached data is lost if the application restarts, crashes, or is redeployed, which is common in cloud environments due to auto-scaling and updates.\n\n4. **No Persistence**\n   - In-memory caches are volatile and do not persist data across application restarts or failures.\n\n5. **Limited Memory**\n   - The cache size is constrained by the memory available to the application instance. Large caches can lead to out-of-memory exceptions or degraded performance.\n\n6. **No Centralized Management**\n   - There is no centralized way to manage or monitor cache contents across multiple instances.\n\n7. **Session Stickiness Requirement**\n   - To benefit from in-memory cache, requests from the same user may need to be routed to the same instance (session stickiness), which complicates load balancing and reduces flexibility.\n\n**Recommendation:**  \nFor cloud environments, consider using distributed caching solutions (e.g., Redis, Azure Cache for Redis, or SQL Server distributed cache) to overcome these limitations and ensure scalability, reliability, and consistency.",
    "level": "Intermediate"
  },
  {
    "id": "34d41004-ab1f-4f82-946b-2735331cdf5d",
    "question": "How do you use the TryGetValue method in IMemoryCache?",
    "answer": "```markdown\nIn .NET Core, the `IMemoryCache` interface provides the `TryGetValue` method to attempt to retrieve a cached value by its key. This method returns `true` if the value exists in the cache; otherwise, it returns `false`.\n\n**Basic Usage Example:**\n\n```csharp\n// Assume _cache is an instance of IMemoryCache injected via dependency injection\nobject cachedValue;\nif (_cache.TryGetValue(\"myKey\", out cachedValue))\n{\n    // The value exists in the cache\n    Console.WriteLine($\"Cached value: {cachedValue}\");\n}\nelse\n{\n    // The value does not exist in the cache\n    Console.WriteLine(\"Value not found in cache.\");\n}\n```\n\n**With Strong Typing:**\n\n```csharp\nif (_cache.TryGetValue<string>(\"myKey\", out var myValue))\n{\n    // myValue is of type string\n    Console.WriteLine($\"Cached value: {myValue}\");\n}\nelse\n{\n    Console.WriteLine(\"Value not found in cache.\");\n}\n```\n\n**Summary:**\n- `TryGetValue` checks if a key exists in the cache.\n- If found, it outputs the value and returns `true`.\n- If not found, it returns `false` and the output value is set to the default for the type.\n```\n",
    "level": "Beginner"
  },
  {
    "id": "35ce6e36-60c3-42ce-9897-dc03823ee318",
    "question": "How do you use cache entry options in .NET Core?",
    "answer": "In .NET Core, cache entry options allow you to control the behavior of cached items, such as their expiration and eviction policies. You typically use the MemoryCacheEntryOptions class when working with IMemoryCache.\n\nHere's how you can use cache entry options:\n\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\n\n// Inject IMemoryCache (e.g., via constructor)\nprivate readonly IMemoryCache _cache;\n\npublic void SetCacheWithEntryOptions()\n{\n    var cacheKey = \"myKey\";\n    var cacheValue = \"myValue\";\n\n    var cacheEntryOptions = new MemoryCacheEntryOptions()\n        .SetSlidingExpiration(TimeSpan.FromMinutes(5)) // Resets expiration if accessed within 5 minutes\n        .SetAbsoluteExpiration(TimeSpan.FromHours(1))  // Expires after 1 hour regardless of access\n        .SetPriority(CacheItemPriority.High)           // Higher priority for retention under memory pressure\n        .RegisterPostEvictionCallback((key, value, reason, state) =>\n        {\n            // Callback logic when the cache entry is evicted\n            Console.WriteLine($\"Cache entry '{key}' was evicted due to {reason}.\");\n        });\n\n    _cache.Set(cacheKey, cacheValue, cacheEntryOptions);\n}\n```\n\n**Key options:**\n\n- `SetAbsoluteExpiration(DateTimeOffset/TimeSpan)`: Sets a fixed time when the cache entry will expire.\n- `SetSlidingExpiration(TimeSpan)`: Resets the expiration timer every time the cache entry is accessed.\n- `SetPriority(CacheItemPriority)`: Sets the priority for eviction (Low, Normal, High, NeverRemove).\n- `RegisterPostEvictionCallback`: Registers a callback that is invoked when the cache entry is removed.\n\n**Usage summary:**  \nWhen adding an item to the cache, pass a configured MemoryCacheEntryOptions instance to control how and when the item is evicted or expired. This helps manage memory usage and ensures cache consistency.",
    "level": "Intermediate"
  },
  {
    "id": "76713308-0990-4d31-a789-37b101048128",
    "question": "What is cache concurrency and how do you handle it in .NET Core?",
    "answer": "### Cache Concurrency in .NET Core\n\n**Cache concurrency** refers to the challenges that arise when multiple threads or processes attempt to read from or write to a shared cache simultaneously. This can lead to issues such as:\n\n- **Race conditions:** Multiple threads may try to update or invalidate the same cache entry at the same time.\n- **Stale data:** One thread may read outdated data if another thread is updating the cache.\n- **Cache stampede:** Many threads simultaneously detect a cache miss and try to populate the cache with the same data, causing redundant work and potential performance degradation.\n\n#### Handling Cache Concurrency in .NET Core\n\n.NET Core provides several mechanisms and best practices to handle cache concurrency:\n\n#### 1. **Atomic Operations**\n\n- The built-in memory cache (`IMemoryCache`) is thread-safe for basic operations like `Get`, `Set`, and `Remove`.\n- However, complex operations (like \"get or create\") can still suffer from race conditions.\n\n#### 2. **GetOrCreate Pattern**\n\n- Use the `GetOrCreate` or `GetOrCreateAsync` methods provided by `IMemoryCache` to ensure that only one thread populates the cache for a given key:\n\n```csharp\nvar value = await memoryCache.GetOrCreateAsync(\"myKey\", async entry =>\n{\n    entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);\n    return await GetDataFromDatabaseAsync();\n});\n```\n\n- This ensures that if multiple threads request the same key simultaneously, only one will execute the factory method, while others wait for the result.\n\n#### 3. **Distributed Cache Locking**\n\n- When using distributed caches (e.g., Redis), use distributed locks to prevent cache stampede.\n- Libraries like [RedLock.net](https://github.com/samcook/RedLock.net) implement the Redlock algorithm for distributed locking.\n\n#### 4. **Double-Checked Locking**\n\n- For more control, implement double-checked locking using `SemaphoreSlim` or similar constructs:\n\n```csharp\nprivate static readonly SemaphoreSlim semaphore = new SemaphoreSlim(1, 1);\n\npublic async Task<MyData> GetDataAsync()\n{\n    if (!memoryCache.TryGetValue(\"myKey\", out MyData data))\n    {\n        await semaphore.WaitAsync();\n        try\n        {\n            if (!memoryCache.TryGetValue(\"myKey\", out data))\n            {\n                data = await GetDataFromDatabaseAsync();\n                memoryCache.Set(\"myKey\", data, TimeSpan.FromMinutes(5));\n            }\n        }\n        finally\n        {\n            semaphore.Release();\n        }\n    }\n    return data;\n}\n```\n\n#### 5. **Cache Expiration and Invalidation**\n\n- Use appropriate cache expiration policies (absolute, sliding, etc.) to minimize stale data.\n- Use cache dependencies or change tokens to invalidate cache entries when underlying data changes.\n\n---\n\n### Summary Table\n\n| Technique                  | Use Case                        | Thread-Safe? | Notes                                 |\n|----------------------------|---------------------------------|--------------|---------------------------------------|\n| `IMemoryCache` Get/Set     | Simple cache operations         | Yes          | For basic usage                       |\n| `GetOrCreate`/`GetOrCreateAsync` | Avoiding race conditions        | Yes          | Preferred for \"get or create\" pattern |\n| Distributed Lock (e.g., RedLock) | Distributed cache (Redis, etc.) | Yes          | Prevents cache stampede               |\n| SemaphoreSlim/Lock         | Custom locking                  | Yes          | For advanced scenarios                |\n\n---\n\n**In summary:**  \n.NET Core's caching mechanisms are thread-safe for basic operations, but for advanced scenarios involving concurrent cache population or distributed caches, you should use patterns like `GetOrCreate`, distributed locks, or explicit synchronization to ensure data consistency and avoid race conditions.",
    "level": "Advanced"
  },
  {
    "id": "9e93a65c-9599-4143-ad3f-936a7c41e50b",
    "question": "How do you use cache dependencies with file changes in .NET Core?",
    "answer": "```markdown\nIn .NET Core, you can implement cache dependencies on file changes using the `IChangeToken` mechanism. This allows your cached data to be invalidated automatically when a specific file changes. The most common approach is to use the `PhysicalFileProvider` to monitor file changes and link it to your cache entry.\n\nHere's how you can do it:\n\n### 1. Add Required Namespaces\n\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.FileProviders;\nusing Microsoft.Extensions.Primitives;\n```\n\n### 2. Set Up the File Provider\n\n```csharp\nvar fileProvider = new PhysicalFileProvider(@\"C:\\path\\to\\your\\directory\");\n```\n\n### 3. Create the Change Token\n\n```csharp\nIChangeToken changeToken = fileProvider.Watch(\"yourfile.txt\");\n```\n\n### 4. Add Cache Entry with Expiration Token\n\n```csharp\nvar cache = new MemoryCache(new MemoryCacheOptions());\n\ncache.Set(\n    \"cacheKey\",\n    \"cached value\",\n    new MemoryCacheEntryOptions()\n        .AddExpirationToken(changeToken)\n);\n```\n\n### 5. Usage Example\n\nWhenever `yourfile.txt` changes, the cache entry with key `\"cacheKey\"` will be invalidated automatically.\n\n### 6. Complete Example\n\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.FileProviders;\nusing Microsoft.Extensions.Primitives;\n\nvar fileProvider = new PhysicalFileProvider(@\"C:\\path\\to\\your\\directory\");\nvar cache = new MemoryCache(new MemoryCacheOptions());\n\nIChangeToken changeToken = fileProvider.Watch(\"yourfile.txt\");\n\ncache.Set(\n    \"cacheKey\",\n    \"cached value\",\n    new MemoryCacheEntryOptions()\n        .AddExpirationToken(changeToken)\n);\n\n// Later, when you try to get the value:\nif (!cache.TryGetValue(\"cacheKey\", out string value))\n{\n    // The cache was invalidated due to file change, reload and set again\n}\n```\n\n### Notes\n\n- The `Watch` method supports globbing patterns (e.g., `\"*.json\"`).\n- This approach works for both in-memory and distributed cache if the distributed cache supports change tokens.\n- For production scenarios, ensure the file path and permissions are correct.\n\n**References:**\n- [Microsoft Docs: Expiration and Eviction in MemoryCache](https://learn.microsoft.com/en-us/dotnet/core/extensions/caching-memory#expiration)\n- [Microsoft Docs: IFileProvider Interface](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.fileproviders.ifileprovider)\n```\n",
    "level": "Advanced"
  },
  {
    "id": "470c3293-fb23-4701-97fb-7645ef2ee7e7",
    "question": "How do you implement cache busting in .NET Core?",
    "answer": "```markdown\n### Implementing Cache Busting in .NET Core\n\nCache busting ensures that clients receive the latest version of resources by invalidating or updating cached content when it changes. In .NET Core, cache busting can be implemented at various levels: static files, in-memory/distributed cache, and HTTP responses.\n\n#### 1. **Static Files Cache Busting**\n\nFor static files (e.g., CSS, JS), use the `asp-append-version` tag helper, which appends a hash of the file content as a query string. When the file changes, the hash changes, forcing browsers to fetch the new version.\n\n**Example (Razor View):**\n```html\n<link rel=\"stylesheet\" href=\"~/css/site.css\" asp-append-version=\"true\" />\n```\n\n**Startup Configuration:**\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseStaticFiles(); // Enables static file serving with cache busting support\n}\n```\n\n#### 2. **In-Memory/Distributed Cache Busting**\n\nFor data cached using `IMemoryCache` or `IDistributedCache`, bust the cache by removing or updating the cache entry when the underlying data changes.\n\n**Example:**\n```csharp\n// Set cache\n_memoryCache.Set(\"MyKey\", data, TimeSpan.FromMinutes(10));\n\n// Bust cache when data changes\n_memoryCache.Remove(\"MyKey\");\n```\n\n**With Cache Dependencies:**\nYou can use `CancellationToken` or `IChangeToken` to expire cache entries when a change is detected.\n\n```csharp\nvar cacheEntryOptions = new MemoryCacheEntryOptions()\n    .AddExpirationToken(new CancellationChangeToken(myChangeToken));\n_memoryCache.Set(\"MyKey\", data, cacheEntryOptions);\n```\n\n#### 3. **HTTP Response Cache Busting**\n\nFor API responses, control cache headers to ensure clients fetch fresh data when needed.\n\n**Example:**\n```csharp\n[ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]\npublic IActionResult Get()\n{\n    // ...\n}\n```\n\nOr set headers manually:\n```csharp\nResponse.Headers[\"Cache-Control\"] = \"no-cache, no-store, must-revalidate\";\nResponse.Headers[\"Pragma\"] = \"no-cache\";\nResponse.Headers[\"Expires\"] = \"0\";\n```\n\n#### 4. **Versioning URLs**\n\nFor assets or API endpoints, include a version in the URL or as a query parameter. When the resource changes, increment the version.\n\n**Example:**\n```html\n<script src=\"~/js/site.js?v=2.1.0\"></script>\n```\n\n---\n\n**Summary Table**\n\n| Cache Type        | Busting Method                                  |\n|-------------------|------------------------------------------------|\n| Static Files      | `asp-append-version`, versioned URLs           |\n| In-Memory Cache   | Remove/Update cache entry, use change tokens   |\n| Distributed Cache | Remove/Update cache entry                      |\n| HTTP Responses    | Set cache headers, use `[ResponseCache]`       |\n\n**References:**\n- [Static Files in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/static-files)\n- [Caching in .NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/overview)\n```\n",
    "level": "Advanced"
  },
  {
    "id": "4f089f89-1650-4b01-ab4f-ef4ff1b075c8",
    "question": "What is lazy caching and how can it be implemented in .NET Core?",
    "answer": "**Lazy Caching in .NET Core**\n\nLazy caching is a caching strategy where data is only loaded and stored in the cache when it is first requested. If the data is not present in the cache, it is fetched (often from a database or external service), stored in the cache, and then returned. Subsequent requests retrieve the data directly from the cache, improving performance and reducing repeated data source calls.\n\n### Benefits of Lazy Caching\n\n- **Efficiency:** Data is only loaded when needed.\n- **Performance:** Reduces unnecessary data fetching and improves response times for repeated requests.\n- **Resource Optimization:** Avoids loading and storing unused data.\n\n---\n\n## Implementing Lazy Caching in .NET Core\n\nYou can implement lazy caching in .NET Core using `IMemoryCache` or third-party libraries like [LazyCache](https://github.com/alastairtree/LazyCache).\n\n### Using IMemoryCache\n\n```csharp\npublic class MyService\n{\n    private readonly IMemoryCache _cache;\n\n    public MyService(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n\n    public async Task<MyData> GetDataAsync(string key)\n    {\n        return await _cache.GetOrCreateAsync(key, async entry =>\n        {\n            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10);\n            // Fetch data from the source (e.g., database)\n            return await FetchDataFromSourceAsync(key);\n        });\n    }\n}\n```\n\n### Using LazyCache Library\n\nLazyCache simplifies lazy caching with a thread-safe, easy-to-use API.\n\n1. **Install the package:**\n   ```bash\n   dotnet add package LazyCache\n   ```\n\n2. **Usage:**\n   ```csharp\n   public class MyService\n   {\n       private readonly IAppCache _cache;\n\n       public MyService(IAppCache cache)\n       {\n           _cache = cache;\n       }\n\n       public async Task<MyData> GetDataAsync(string key)\n       {\n           return await _cache.GetOrAddAsync(key, () => FetchDataFromSourceAsync(key), TimeSpan.FromMinutes(10));\n       }\n   }\n   ```\n\n---\n\n### Summary Table\n\n| Approach         | Library      | Thread-Safe | Example Method         |\n|------------------|--------------|-------------|-----------------------|\n| Manual           | IMemoryCache | No*         | GetOrCreateAsync      |\n| With LazyCache   | LazyCache    | Yes         | GetOrAddAsync         |\n\n\\*IMemoryCache is thread-safe, but LazyCache adds additional safety for concurrent value creation.\n\n---\n\n**In summary:**  \nLazy caching in .NET Core is a pattern where data is loaded and cached only when first requested. It can be implemented using `IMemoryCache` or the LazyCache library for a more streamlined and thread-safe approach.",
    "level": "Intermediate"
  },
  {
    "id": "9f3b6f7c-1b68-4508-8eab-0eb78ba64d2e",
    "question": "How do you use the GetOrCreate method in IMemoryCache?",
    "answer": "To use the GetOrCreate method in IMemoryCache in .NET Core, you first inject IMemoryCache into your class (usually via constructor injection). Then, you can use the GetOrCreate method to either get a cached value by key or create and cache it if it doesn't exist.\n\nHere's a simple example:\n\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\n\npublic class MyService\n{\n    private readonly IMemoryCache _cache;\n\n    public MyService(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n\n    public string GetCachedValue()\n    {\n        // \"myKey\" is the cache key\n        // The lambda provides the value if the key is not found in the cache\n        return _cache.GetOrCreate(\"myKey\", entry =>\n        {\n            // Optional: set cache options\n            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5);\n\n            // Generate and return the value to cache\n            return \"This is the cached value!\";\n        });\n    }\n}\n```\n\n**Explanation:**\n\n- If \"myKey\" exists in the cache, its value is returned.\n- If not, the lambda is executed, the value is cached, and then returned.\n- You can set cache options (like expiration) on the entry parameter.\n\n**References:**\n- [Microsoft Docs: IMemoryCache.GetOrCreate](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.memory.imemorycache.getorcreate)",
    "level": "Beginner"
  },
  {
    "id": "34142631-5e56-4b2a-bae8-5f3e245a0a62",
    "question": "How do you cache data in a Razor Page in ASP.NET Core?",
    "answer": "To cache data in a Razor Page in ASP.NET Core, you typically use in-memory caching via the IMemoryCache service. Here’s how you can implement it:\n\n### 1. Register IMemoryCache\n\nIMemoryCache is registered by default in ASP.NET Core. If not, add it in `Startup.cs` (for .NET Core 3.1 or earlier) or in `Program.cs` (for .NET 6+):\n\n```csharp\nbuilder.Services.AddMemoryCache();\n```\n\n### 2. Inject IMemoryCache into Your Page Model\n\nInject `IMemoryCache` into your Razor Page model via constructor injection:\n\n```csharp\npublic class IndexModel : PageModel\n{\n    private readonly IMemoryCache _cache;\n\n    public IndexModel(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n\n    public string CachedData { get; set; }\n\n    public void OnGet()\n    {\n        // Try to get the cached value\n        if (!_cache.TryGetValue(\"MyCacheKey\", out string data))\n        {\n            // Data not in cache, so fetch and cache it\n            data = \"Expensive to generate data at \" + DateTime.Now;\n\n            var cacheEntryOptions = new MemoryCacheEntryOptions()\n                .SetSlidingExpiration(TimeSpan.FromMinutes(5));\n\n            _cache.Set(\"MyCacheKey\", data, cacheEntryOptions);\n        }\n\n        CachedData = data;\n    }\n}\n```\n\n### 3. Use the Cached Data in Your Razor Page\n\n```html\n@page\n@model IndexModel\n\n<h2>Cached Data Example</h2>\n<p>@Model.CachedData</p>\n```\n\n### 4. Notes\n\n- **Cache Key**: Use a unique string as the cache key.\n- **Expiration**: Configure expiration policies (absolute, sliding, etc.) as needed.\n- **Thread Safety**: IMemoryCache is thread-safe.\n\n### Summary\n\nBy injecting and using `IMemoryCache` in your Razor Page model, you can efficiently cache and reuse data, improving performance and reducing unnecessary data fetching or computation.",
    "level": "Intermediate"
  },
  {
    "id": "c4760eb9-2959-45e0-af6f-0cee98036cb2",
    "question": "How do you secure sensitive data in cache in .NET Core?",
    "answer": "```markdown\nTo secure sensitive data in cache in .NET Core, consider the following best practices:\n\n1. **Avoid Caching Sensitive Data When Possible**  \n   - Only cache sensitive data if absolutely necessary. Evaluate if the performance benefit outweighs the security risk.\n\n2. **Use In-Memory Caching with Restricted Access**  \n   - Use `IMemoryCache` for sensitive data, as it is process-local and not shared across servers or persisted to disk.\n   - Ensure the application and server are properly secured to prevent unauthorized access.\n\n3. **Encrypt Data Before Caching**  \n   - Encrypt sensitive data before storing it in the cache.\n   - Use strong encryption algorithms (e.g., AES) and manage keys securely (e.g., using Azure Key Vault or AWS KMS).\n   - Example:\n     ```csharp\n     var encryptedData = Encrypt(sensitiveData, encryptionKey);\n     memoryCache.Set(cacheKey, encryptedData);\n     ```\n\n4. **Secure Distributed Caches**  \n   - For distributed caches like Redis or SQL Server:\n     - Enable SSL/TLS to encrypt data in transit.\n     - Use authentication and strong passwords.\n     - Restrict network access (firewalls, VPCs).\n     - Consider encrypting data at rest and in transit.\n\n5. **Set Appropriate Cache Expiration Policies**  \n   - Use short expiration times for sensitive data to limit exposure.\n   - Use sliding or absolute expiration as appropriate.\n\n6. **Avoid Caching Authentication Tokens or Passwords**  \n   - Never cache passwords or authentication tokens unless absolutely necessary and always encrypted.\n\n7. **Audit and Monitor Cache Access**  \n   - Log and monitor cache access for suspicious activity.\n   - Regularly review cache usage and security settings.\n\n**Example: Encrypting Data Before Caching**\n```csharp\n// Encryption helper methods not shown for brevity\nvar sensitiveData = \"secret\";\nvar encryptedData = Encrypt(sensitiveData, encryptionKey);\nmemoryCache.Set(\"cacheKey\", encryptedData);\n\n// When retrieving:\nvar cachedEncrypted = memoryCache.Get<string>(\"cacheKey\");\nvar decryptedData = Decrypt(cachedEncrypted, encryptionKey);\n```\n\n**References:**\n- [Microsoft Docs: Secure sensitive data in .NET applications](https://learn.microsoft.com/en-us/dotnet/standard/security/)\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)\n\nBy following these practices, you can help ensure that sensitive data cached in .NET Core applications remains secure.\n```\n",
    "level": "Advanced"
  },
  {
    "id": "87e886ce-92b3-4e56-ad27-e1b2ef00bd15",
    "question": "What is the difference between response caching and output caching in ASP.NET Core?",
    "answer": "```markdown\n**Response Caching vs. Output Caching in ASP.NET Core**\n\n| Feature              | Response Caching                                 | Output Caching                                  |\n|----------------------|--------------------------------------------------|-------------------------------------------------|\n| **Definition**       | Caches HTTP responses at the client or proxy level (outside the server). | Caches the generated output of actions or pages on the server. |\n| **How it works**     | Uses HTTP headers (`Cache-Control`, etc.) to instruct clients/proxies to cache responses. | Stores the rendered output in server memory, so repeated requests are served from cache without re-executing the action. |\n| **Location**         | Client-side or intermediary (proxy) caching.     | Server-side caching.                            |\n| **Configuration**    | Via `[ResponseCache]` attribute and middleware.  | Via `[OutputCache]` attribute (ASP.NET Core 7+).|\n| **Granularity**      | Whole HTTP response.                             | Whole or partial (fragment) output of actions/pages. |\n| **Use Cases**        | Improve performance by reducing server load for cacheable responses across clients. | Reduce server processing for repeated requests to the same resource. |\n| **ASP.NET Core Support** | Supported via middleware and attributes.      | Introduced in ASP.NET Core 7.0 as `[OutputCache]`. |\n\n**Summary:**\n- **Response Caching** leverages HTTP caching mechanisms to store responses outside the server.\n- **Output Caching** stores generated content on the server, serving repeated requests faster without regenerating the output.\n```\n",
    "level": "Intermediate"
  },
  {
    "id": "a480faa4-c0a7-451c-9705-f9226c8caa01",
    "question": "How do you use cache profiles in ASP.NET Core MVC?",
    "answer": "```markdown\nIn ASP.NET Core MVC, **cache profiles** allow you to define common caching settings in one place (typically in `appsettings.json` or `Startup.cs`) and then apply them to controllers or actions using the `[ResponseCache]` attribute. This promotes consistency and reusability for caching configurations.\n\n### 1. Define Cache Profiles in `Startup.cs`\n\nYou can add cache profiles when configuring MVC services in `Startup.cs` (or `Program.cs` in .NET 6+):\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddControllersWithViews(options =>\n    {\n        options.CacheProfiles.Add(\"Default30\", new CacheProfile()\n        {\n            Duration = 30\n        });\n        options.CacheProfiles.Add(\"NoCache\", new CacheProfile()\n        {\n            NoStore = true,\n            Location = ResponseCacheLocation.None\n        });\n    });\n}\n```\n\n### 2. Apply Cache Profiles to Controllers or Actions\n\nUse the `[ResponseCache]` attribute and specify the `CacheProfileName`:\n\n```csharp\n[ResponseCache(CacheProfileName = \"Default30\")]\npublic IActionResult Index()\n{\n    return View();\n}\n\n[ResponseCache(CacheProfileName = \"NoCache\")]\npublic IActionResult Privacy()\n{\n    return View();\n}\n```\n\n### 3. Benefits\n\n- **Centralized configuration:** Change cache settings in one place.\n- **Reusability:** Apply the same profile to multiple actions/controllers.\n- **Consistency:** Ensures uniform caching behavior.\n\n### 4. Example with `appsettings.json` (Optional)\n\nYou can also define cache profiles in `appsettings.json` and bind them in `Startup.cs` for more flexibility.\n\n---\n\n**Summary:**  \nCache profiles in ASP.NET Core MVC are defined centrally and applied via the `[ResponseCache]` attribute, making it easy to manage and reuse caching settings across your application.\n```\n",
    "level": "Intermediate"
  },
  {
    "id": "a80f889f-3b3a-4763-be6e-c36ada1439a0",
    "question": "How do you test caching logic in .NET Core applications?",
    "answer": "Testing caching logic in .NET Core applications involves verifying that your application correctly stores, retrieves, and invalidates cached data as expected. Here’s how you can approach this:\n\n## 1. Use Dependency Injection for Caching\n\nAlways inject caching abstractions (like IMemoryCache or IDistributedCache) rather than using concrete implementations directly. This allows you to mock or substitute them during testing.\n\n```csharp\npublic class MyService\n{\n    private readonly IMemoryCache _cache;\n    public MyService(IMemoryCache cache)\n    {\n        _cache = cache;\n    }\n    // ...\n}\n```\n\n## 2. Mock the Cache in Unit Tests\n\nUse mocking frameworks (e.g., Moq) to simulate cache behavior.\n\n```csharp\nvar mockCache = new Mock<IMemoryCache>();\nobject cachedValue = \"test\";\nmockCache.Setup(c => c.TryGetValue(\"key\", out cachedValue)).Returns(true);\n\nvar service = new MyService(mockCache.Object);\n// Assert behavior based on cache hit/miss\n```\n\n## 3. Use In-Memory Implementations for Integration Tests\n\nFor integration tests, use the real in-memory cache (IMemoryCache) or a test instance of IDistributedCache (e.g., MemoryDistributedCache).\n\n```csharp\nvar memoryCache = new MemoryCache(new MemoryCacheOptions());\nvar service = new MyService(memoryCache);\n// Test actual caching behavior\n```\n\n## 4. Test Cache Hit and Miss Scenarios\n\n- **Cache Miss:** Ensure the data is fetched from the source and then cached.\n- **Cache Hit:** Ensure the data is served from the cache, not the source.\n- **Cache Expiry:** Simulate expiration and verify data is re-fetched.\n\n```csharp\n// Example: Assert that data is fetched only once when cache is used\nvar fetchCount = 0;\nFunc<string> fetchData = () => { fetchCount++; return \"data\"; };\n\nservice.GetOrAdd(\"key\", fetchData);\nservice.GetOrAdd(\"key\", fetchData);\n\nAssert.Equal(1, fetchCount); // Only fetched once due to caching\n```\n\n## 5. Test Cache Invalidation\n\nIf your logic includes cache removal or invalidation, test that the cache is cleared and subsequent requests fetch fresh data.\n\n```csharp\nservice.Remove(\"key\");\nservice.GetOrAdd(\"key\", fetchData);\nAssert.Equal(2, fetchCount); // Data fetched again after invalidation\n```\n\n## 6. Use Custom Cache Implementations for More Control\n\nFor advanced scenarios, implement a custom IMemoryCache or IDistributedCache that tracks calls and state, allowing you to assert on cache interactions.\n\n## 7. Consider Using Microsoft.Extensions.Caching.Memory\n\nThis package provides in-memory caching and is suitable for both production and testing environments.\n\n---\n\n**Summary Table**\n\n| Test Type         | Approach                                      |\n|-------------------|-----------------------------------------------|\n| Unit Test         | Mock cache interfaces (IMemoryCache, etc.)    |\n| Integration Test  | Use in-memory cache implementations           |\n| Cache Hit/Miss    | Assert data source is called as expected      |\n| Expiry/Invalidation | Simulate and assert correct behavior        |\n\n---\n\n**References:**\n- [Microsoft Docs: Caching in .NET](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/)\n- [Moq Documentation](https://github.com/moq/moq4)\n\nBy following these practices, you can thoroughly test your caching logic in .NET Core applications.",
    "level": "Advanced"
  },
  {
    "id": "04ca2be2-eeeb-4437-8adc-59bc74280859",
    "question": "What are the trade-offs between cache consistency and performance?",
    "answer": "**Trade-offs Between Cache Consistency and Performance in .NET Core Caching**\n\nWhen implementing caching in .NET Core applications, developers must balance cache consistency and performance. Here’s a breakdown of the trade-offs:\n\n---\n\n### 1. **Cache Consistency**\n\n- **Definition:** Ensuring that the cached data always reflects the most current state of the underlying data source.\n- **Techniques:** Write-through, write-behind, cache invalidation, distributed cache synchronization.\n\n#### **Pros:**\n- Users always get up-to-date data.\n- Reduces risk of serving stale or incorrect information.\n\n#### **Cons:**\n- **Performance Overhead:** Frequent cache updates or invalidations can increase latency.\n- **Complexity:** Implementing strong consistency (e.g., distributed cache coherence) is complex and error-prone.\n- **Scalability Issues:** High consistency often requires more network calls and coordination, limiting scalability.\n\n---\n\n### 2. **Performance**\n\n- **Definition:** Maximizing application speed and reducing load on the underlying data source by serving data from cache.\n- **Techniques:** Aggressive caching, longer expiration times, eventual consistency.\n\n#### **Pros:**\n- **Reduced Latency:** Data is served quickly from memory.\n- **Lower Backend Load:** Fewer requests to the database or external services.\n- **Better Scalability:** Applications can handle more requests with less resource usage.\n\n#### **Cons:**\n- **Stale Data:** Users may see outdated information.\n- **Potential Data Inconsistency:** Especially problematic for rapidly changing or critical data.\n\n---\n\n### **Common Approaches in .NET Core**\n\n- **In-Memory Caching:** Fastest, but only suitable for single-instance applications and may have consistency issues in distributed scenarios.\n- **Distributed Caching (e.g., Redis):** Supports multiple instances, but maintaining strong consistency across nodes can be challenging and may impact performance.\n\n---\n\n### **Summary Table**\n\n| Approach           | Consistency Level | Performance | Use Case                              |\n|--------------------|------------------|-------------|----------------------------------------|\n| No Caching         | Strong           | Low         | Critical data, low traffic             |\n| Aggressive Caching | Weak             | High        | Read-heavy, non-critical data          |\n| Write-through      | Strong           | Medium      | Critical, frequently updated data      |\n| Write-behind       | Eventual         | High        | High throughput, less critical data    |\n| Cache Invalidation | Configurable     | Variable    | Mixed workloads, configurable needs    |\n\n---\n\n### **Conclusion**\n\n- **High Consistency:** Comes at the cost of performance and scalability.\n- **High Performance:** May lead to serving stale or inconsistent data.\n- **Best Practice:** Choose the right balance based on the data’s criticality and application requirements. For most scenarios, eventual consistency with periodic cache invalidation offers a good compromise.\n\n---\n\n**References:**\n- [Microsoft Docs: Caching in .NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/)\n- [Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)",
    "level": "Advanced"
  },
  {
    "id": "05b57950-fcb2-4e58-8c51-f28525d2bbcf",
    "question": "How do you handle cache synchronization in a distributed environment?",
    "answer": "```markdown\nIn a distributed environment, cache synchronization is crucial to ensure data consistency across multiple application instances. Here are advanced strategies for handling cache synchronization in .NET Core:\n\n### 1. Use a Distributed Cache Provider\n\nLeverage distributed cache providers such as **Redis** or **SQL Server** via the `IDistributedCache` interface. These providers store cache data centrally, so all application nodes access the same cache, reducing synchronization issues.\n\n```csharp\nservices.AddStackExchangeRedisCache(options =>\n{\n    options.Configuration = \"localhost:6379\";\n    options.InstanceName = \"SampleInstance\";\n});\n```\n\n### 2. Cache Invalidation Patterns\n\n- **Cache Aside (Lazy Loading):** Applications fetch data from the cache first; if not found, load from the database and update the cache.\n- **Publish/Subscribe (Pub/Sub):** Use Redis Pub/Sub or similar mechanisms to notify all nodes when a cache entry changes, prompting them to invalidate or refresh their local cache.\n\n### 3. Distributed Locks\n\nWhen updating cache entries, use distributed locks (e.g., Redis RedLock) to prevent race conditions and ensure only one instance updates the cache at a time.\n\n### 4. Expiration and Eviction Policies\n\nSet appropriate expiration times (`AbsoluteExpiration`, `SlidingExpiration`) to ensure stale data is eventually removed, even if invalidation messages are missed.\n\n### 5. Event-Based Synchronization\n\nIntegrate with messaging systems (e.g., RabbitMQ, Azure Service Bus) to broadcast cache invalidation events across services.\n\n### Example: Redis Pub/Sub for Cache Invalidation\n\n```csharp\n// Publisher: Notify other nodes of cache change\nawait redis.PublishAsync(\"cache-invalidation\", cacheKey);\n\n// Subscriber: Listen for invalidation messages\nredis.Subscribe(\"cache-invalidation\", (channel, key) =>\n{\n    localCache.Remove(key);\n});\n```\n\n### 6. Versioning or Tokens\n\nAttach version numbers or tokens to cache entries. When data changes, increment the version or update the token, and have all nodes check for the latest version before serving cached data.\n\n---\n\n**Summary Table**\n\n| Technique                | Description                                    | .NET Core Support                |\n|--------------------------|------------------------------------------------|----------------------------------|\n| Distributed Cache        | Centralized cache store                        | `IDistributedCache`              |\n| Pub/Sub                  | Broadcast invalidation events                  | Redis, messaging systems         |\n| Distributed Locks        | Prevent concurrent updates                     | Redis RedLock, custom logic      |\n| Expiration/Eviction      | Remove stale data automatically                | Built-in policies                |\n| Versioning/Tokens        | Ensure freshness via version checks            | Custom implementation            |\n\n---\n\n**References:**\n- [Microsoft Docs: Distributed caching in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/distributed)\n- [Redis Pub/Sub documentation](https://redis.io/docs/manual/pubsub/)\n```\n",
    "level": "Advanced"
  },
  {
    "id": "d7430388-67d4-40df-a3db-d88c054f1e97",
    "question": "How do you use the MemoryCache class directly in .NET Core?",
    "answer": "To use the `MemoryCache` class directly in .NET Core, you need to reference the `Microsoft.Extensions.Caching.Memory` package and create an instance of `MemoryCache`. Here’s how you can do it:\n\n```csharp\nusing Microsoft.Extensions.Caching.Memory;\n\n// Create MemoryCacheOptions if you want to customize settings\nvar options = new MemoryCacheOptions\n{\n    // Example: Set size limit or expiration scan frequency\n    // SizeLimit = 1024,\n    // ExpirationScanFrequency = TimeSpan.FromMinutes(5)\n};\n\n// Instantiate MemoryCache\nvar memoryCache = new MemoryCache(options);\n\n// Set a cache entry\nmemoryCache.Set(\"myKey\", \"myValue\", TimeSpan.FromMinutes(10));\n\n// Get a cache entry\nif (memoryCache.TryGetValue(\"myKey\", out string value))\n{\n    Console.WriteLine($\"Cached value: {value}\");\n}\nelse\n{\n    Console.WriteLine(\"Cache miss\");\n}\n\n// Remove a cache entry\nmemoryCache.Remove(\"myKey\");\n```\n\n**Key Points:**\n- You can configure cache behavior via `MemoryCacheOptions`.\n- Use `Set` to add items, `TryGetValue` to retrieve, and `Remove` to delete.\n- For dependency injection and easier management, prefer using `IMemoryCache` in ASP.NET Core applications, but direct usage of `MemoryCache` is suitable for console apps or custom scenarios.\n\n**NuGet Package Reference:**\n```xml\n<PackageReference Include=\"Microsoft.Extensions.Caching.Memory\" Version=\"*\" />\n```\n\n**Note:**  \nAlways dispose of `MemoryCache` when done (e.g., in a `using` statement or by calling `Dispose()`), especially in long-running applications.",
    "level": "Intermediate"
  },
  {
    "id": "51b48f10-d9a9-455b-8872-d1fdb02d1e0a",
    "question": "What is the impact of caching on application scalability?",
    "answer": "Caching can significantly enhance application scalability in .NET Core by reducing the load on backend resources such as databases and external services. When data is cached, repeated requests for the same information can be served directly from the cache, which is much faster than querying the original source. This leads to:\n\n- **Reduced Latency:** Cached data can be retrieved quickly, improving response times for users.\n- **Lower Resource Utilization:** Fewer calls to databases or APIs mean less CPU, memory, and network usage on backend systems.\n- **Improved Throughput:** The application can handle more concurrent users since backend bottlenecks are minimized.\n- **Cost Efficiency:** By offloading work from expensive resources, operational costs can be reduced, especially in cloud environments.\n\nHowever, improper caching strategies (such as caching too much data, not expiring stale data, or using local caches in distributed systems without synchronization) can lead to issues like stale data, cache stampedes, or inconsistent state across application instances. Therefore, it's important to design caching carefully to maximize scalability benefits while maintaining data consistency and freshness.",
    "level": "Intermediate"
  },
  {
    "id": "07d916b6-942c-4733-a172-a90915ff03b1",
    "question": "How do you clear all cache entries in .NET Core?",
    "answer": "```markdown\nIn .NET Core, if you are using the built-in IMemoryCache, there is no direct method to clear all cache entries at once. However, you can achieve this by using a technique called cache \"scoping\" with a CancellationToken. Here’s how you can do it:\n\n### 1. Use a CancellationToken to Invalidate All Entries\n\nWhen you add items to the cache, associate them with a shared `CancellationToken`. To clear the cache, simply cancel the token, which will remove all associated entries.\n\n```csharp\nprivate static CancellationTokenSource _resetCacheToken = new CancellationTokenSource();\n\npublic void SetCacheEntry(IMemoryCache cache, string key, object value)\n{\n    cache.Set(key, value, new MemoryCacheEntryOptions\n    {\n        ExpirationTokens = { new CancellationChangeToken(_resetCacheToken.Token) }\n    });\n}\n\npublic void ClearAllCache()\n{\n    var previousToken = _resetCacheToken;\n    _resetCacheToken = new CancellationTokenSource();\n    previousToken.Cancel();\n}\n```\n\n### 2. For IDistributedCache\n\n`IDistributedCache` (e.g., Redis, SQL Server) does not support clearing all entries natively. You would need to:\n\n- Use a key prefix and delete all keys with that prefix (requires direct access to the cache backend).\n- Or, flush the entire cache database (not recommended in production as it may affect other applications).\n\n### Summary\n\n- **IMemoryCache:** Use a shared `CancellationToken` to invalidate all entries.\n- **IDistributedCache:** No built-in method; requires backend-specific operations.\n\n**References:**\n- [Microsoft Docs: Expiration and Eviction in MemoryCache](https://learn.microsoft.com/en-us/dotnet/core/extensions/caching-memory#expiration-and-eviction)\n```\n",
    "level": "Intermediate"
  }
]
