[
  {
    "id": "80fa40e6-5bb6-4033-bd30-8b9424073f2a",
    "question": "How do you reverse a string in Go?",
    "answer": "```go\n// Reversing a string in Go\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc reverseString(s string) string {\n    // Convert string to rune slice to handle Unicode characters\n    runes := []rune(s)\n    n := len(runes)\n    for i := 0; i < n/2; i++ {\n        // Swap runes\n        runes[i], runes[n-1-i] = runes[n-1-i], runes[i]\n    }\n    return string(runes)\n}\n\nfunc main() {\n    input := \"hello 世界\"\n    reversed := reverseString(input)\n    fmt.Println(reversed) // Output: 界世 olleh\n}\n```\n\n**Explanation:**\n\n- Strings in Go are immutable and are sequences of bytes, which may not represent Unicode characters correctly if reversed byte-wise.\n- To handle Unicode, convert the string to a slice of runes (`[]rune`), reverse the slice, and then convert it back to a string.\n- The function `reverseString` swaps runes from both ends towards the center.\n- The example demonstrates reversing a string containing both ASCII and Unicode characters.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998599Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "251e7fb1-8a07-4e05-be47-de2bbeebdbfe",
    "question": "How do you check if a given string is a palindrome in Go?",
    "answer": "```markdown\n### How do you check if a given string is a palindrome in Go?\n\nA palindrome is a string that reads the same backward as forward (e.g., \"madam\", \"racecar\"). To check if a string is a palindrome in Go, you can compare characters from the start and end of the string, moving towards the center.\n\nHere's a simple Go function to check if a string is a palindrome:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc isPalindrome(s string) bool {\n    // Optional: Normalize the string (e.g., lowercase, remove spaces)\n    s = strings.ToLower(s)\n    left, right := 0, len(s)-1\n\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(isPalindrome(\"madam\"))      // true\n    fmt.Println(isPalindrome(\"racecar\"))    // true\n    fmt.Println(isPalindrome(\"hello\"))      // false\n}\n```\n\n**Explanation:**\n- The function compares the characters at the start (`left`) and end (`right`) of the string.\n- If any pair doesn't match, it returns `false`.\n- If all pairs match, it returns `true`.\n- The example also shows how to use the function.\n\nYou can further enhance this function to ignore spaces, punctuation, or handle Unicode characters as needed.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998623Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "c9d75e6a-cfd0-47c7-9258-019e66caedf7",
    "question": "How do you find the maximum element in an integer slice in Go?",
    "answer": "```markdown\n## How do you find the maximum element in an integer slice in Go?\n\nTo find the maximum element in an integer slice in Go, you can iterate through the slice and keep track of the largest value found so far. Here's a simple example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc findMax(nums []int) int {\n    if len(nums) == 0 {\n        panic(\"slice is empty\")\n    }\n    max := nums[0]\n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n    }\n    return max\n}\n\nfunc main() {\n    numbers := []int{3, 7, 2, 9, 4}\n    fmt.Println(\"Maximum element:\", findMax(numbers))\n}\n```\n\n**Output:**\n```\nMaximum element: 9\n```\n\n**Explanation:**  \n- The function `findMax` initializes `max` with the first element of the slice.\n- It then iterates through each element, updating `max` if a larger value is found.\n- If the slice is empty, it panics to avoid undefined behavior.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998636Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "b09b4358-479a-4d2e-96e8-d99fe6e4fe51",
    "question": "How do you implement binary search on a sorted slice in Go?",
    "answer": "```go\n// BinarySearch performs binary search on a sorted slice of integers.\n// It returns the index of the target if found, or -1 if not found.\nfunc BinarySearch(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\n// Example usage:\n// nums := []int{1, 3, 5, 7, 9, 11}\n// index := BinarySearch(nums, 7) // index will be 3\n```\n\n**Explanation:**\n- The function takes a sorted slice of integers and a target value.\n- It uses two pointers (`left` and `right`) to keep track of the search range.\n- It repeatedly checks the middle element:\n  - If the middle element equals the target, it returns the index.\n  - If the middle element is less than the target, it searches the right half.\n  - If the middle element is greater than the target, it searches the left half.\n- If the target is not found, it returns -1.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998648Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "5423e827-ab25-4b98-b3dc-2f3c2d56ceb5",
    "question": "How do you remove duplicates from a slice of integers in Go?",
    "answer": "```go\n// RemoveDuplicates removes duplicate integers from a slice.\nfunc RemoveDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    result := []int{}\n    for _, num := range nums {\n        if !seen[num] {\n            seen[num] = true\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\n// Example usage\nfunc main() {\n    nums := []int{1, 2, 2, 3, 4, 4, 5}\n    uniqueNums := RemoveDuplicates(nums)\n    fmt.Println(uniqueNums) // Output: [1 2 3 4 5]\n}\n```\n\n**Explanation:**\n- We use a map to keep track of numbers we've already seen.\n- As we iterate through the slice, we add each unique number to the result slice.\n- This preserves the order of the first occurrence of each number.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998662Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "a4bdcc59-eb2f-471d-a4d0-d850f3f98de3",
    "question": "How do you find the factorial of a number using recursion in Go?",
    "answer": "```go\n// Factorial using recursion in Go\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// factorial calculates the factorial of n using recursion\nfunc factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * factorial(n-1)\n}\n\nfunc main() {\n\tnum := 5\n\tresult := factorial(num)\n\tfmt.Printf(\"Factorial of %d is %d\\n\", num, result)\n}\n```\n\n**Explanation:**\n- The factorial of a number n (written as n!) is the product of all positive integers less than or equal to n.\n- The base case is when n is 0, where factorial(0) = 1.\n- The recursive case multiplies n by the factorial of (n-1).\n- In the example above, factorial(5) returns 120.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998670Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "49423684-3beb-4f31-ad8c-5df62422132f",
    "question": "How do you merge two sorted slices into a single sorted slice in Go?",
    "answer": "```go\n// Merges two sorted slices into a single sorted slice in Go.\nfunc mergeSortedSlices(a, b []int) []int {\n    result := make([]int, 0, len(a)+len(b))\n    i, j := 0, 0\n\n    // Compare elements from both slices and append the smaller one.\n    for i < len(a) && j < len(b) {\n        if a[i] < b[j] {\n            result = append(result, a[i])\n            i++\n        } else {\n            result = append(result, b[j])\n            j++\n        }\n    }\n\n    // Append any remaining elements from a or b.\n    result = append(result, a[i:]...)\n    result = append(result, b[j:]...)\n\n    return result\n}\n\n// Example usage\nfunc main() {\n    a := []int{1, 3, 5, 7}\n    b := []int{2, 4, 6, 8}\n    merged := mergeSortedSlices(a, b)\n    fmt.Println(merged) // Output: [1 2 3 4 5 6 7 8]\n}\n```\n\n**Explanation:**\n- The function `mergeSortedSlices` takes two sorted slices `a` and `b`.\n- It uses two pointers (`i` and `j`) to iterate through both slices.\n- It compares the current elements and appends the smaller one to the result.\n- After one slice is exhausted, it appends the remaining elements from the other slice.\n- The result is a single sorted slice containing all elements from both input slices.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998680Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "681a41d0-711c-433c-846e-0f8e7fcd9171",
    "question": "How do you implement bubble sort in Go?",
    "answer": "```go\n// BubbleSort sorts a slice of integers in ascending order using the bubble sort algorithm.\nfunc BubbleSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        // Last i elements are already in place\n        for j := 0; j < n-i-1; j++ {\n            if arr[j] > arr[j+1] {\n                // Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n}\n\nfunc main() {\n    nums := []int{5, 2, 9, 1, 5, 6}\n    BubbleSort(nums)\n    fmt.Println(nums) // Output: [1 2 5 5 6 9]\n}\n```\n\n**Explanation:**\n- The function iterates over the slice multiple times.\n- In each pass, it compares adjacent elements and swaps them if they are in the wrong order.\n- After each pass, the largest unsorted element \"bubbles up\" to its correct position.\n- This process repeats until the slice is sorted.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998693Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "dec87548-cc61-4fe0-8bb9-9349c042b258",
    "question": "How do you count the number of vowels in a string in Go?",
    "answer": "```go\n// CountVowels returns the number of vowels in the given string.\nfunc CountVowels(s string) int {\n    count := 0\n    vowels := \"aeiouAEIOU\"\n    for _, ch := range s {\n        if strings.ContainsRune(vowels, ch) {\n            count++\n        }\n    }\n    return count\n}\n```\n\n**Example usage:**\n```go\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    str := \"Hello, World!\"\n    fmt.Println(CountVowels(str)) // Output: 3\n}\n```\n\n**Explanation:**\n- The function iterates through each character in the string.\n- It checks if the character is a vowel (either uppercase or lowercase).\n- If it is, it increments the count.\n- Finally, it returns the total count of vowels.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998705Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "40d1f15c-4eb0-40f7-86d1-6131980ce429",
    "question": "How do you check if two strings are anagrams in Go?",
    "answer": "```markdown\n### How do you check if two strings are anagrams in Go?\n\nTo check if two strings are anagrams in Go, you can compare the frequency of each character in both strings. If both strings have the same length and the same character counts, they are anagrams.\n\nHere's a simple way to do it:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc areAnagrams(s1, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n\n    count := make(map[rune]int)\n    for _, ch := range s1 {\n        count[ch]++\n    }\n    for _, ch := range s2 {\n        count[ch]--\n        if count[ch] < 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(areAnagrams(\"listen\", \"silent\")) // true\n    fmt.Println(areAnagrams(\"hello\", \"world\"))   // false\n}\n```\n\n**Explanation:**\n- First, check if the lengths are equal.\n- Use a map to count occurrences of each character in the first string.\n- Decrease the count for each character in the second string.\n- If any count goes below zero, the strings are not anagrams.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998717Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "509c7ea7-096d-4e2f-bcc5-14df989396c8",
    "question": "How do you find the nth Fibonacci number using iteration in Go?",
    "answer": "```go\n// Find the nth Fibonacci number using iteration in Go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n\nfunc main() {\n    n := 10\n    fmt.Printf(\"The %dth Fibonacci number is %d\\n\", n, fibonacci(n))\n}\n```\n\n**Explanation:**\n\n- The function `fibonacci(n int) int` calculates the nth Fibonacci number using a loop.\n- It handles the base cases where `n` is 0 or 1.\n- For `n > 1`, it iteratively computes the Fibonacci sequence by updating two variables, `a` and `b`.\n- The result is printed in the `main` function for `n = 10`.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998730Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d1cc85f7-6022-4dad-b8bd-62604c7a6a4f",
    "question": "How do you implement selection sort in Go?",
    "answer": "```go\n// SelectionSort sorts an integer slice in ascending order using the selection sort algorithm.\nfunc SelectionSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        minIdx := i\n        // Find the minimum element in the unsorted part\n        for j := i + 1; j < n; j++ {\n            if arr[j] < arr[minIdx] {\n                minIdx = j\n            }\n        }\n        // Swap the found minimum element with the first element\n        arr[i], arr[minIdx] = arr[minIdx], arr[i]\n    }\n}\n\n// Example usage:\nfunc main() {\n    nums := []int{64, 25, 12, 22, 11}\n    SelectionSort(nums)\n    fmt.Println(nums) // Output: [11 12 22 25 64]\n}\n```\n\n**Explanation:**\n\n- The algorithm divides the slice into a sorted and an unsorted part.\n- It repeatedly selects the smallest element from the unsorted part and swaps it with the first unsorted element.\n- This process is repeated until the entire slice is sorted.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998741Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "6ff40336-c80e-4a20-a885-172132d95de3",
    "question": "How do you find the intersection of two slices in Go?",
    "answer": "```markdown\n### How do you find the intersection of two slices in Go?\n\nTo find the intersection of two slices in Go (i.e., the elements that appear in both slices), you can use a map to efficiently check for common elements. Here's a simple example:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc intersection(a, b []int) []int {\n\tset := make(map[int]struct{})\n\tresult := []int{}\n\n\t// Add all elements from slice 'a' to the set\n\tfor _, val := range a {\n\t\tset[val] = struct{}{}\n\t}\n\n\t// Check if elements in 'b' are in the set\n\tseen := make(map[int]struct{}) // To avoid duplicates in result\n\tfor _, val := range b {\n\t\tif _, exists := set[val]; exists {\n\t\t\tif _, alreadyAdded := seen[val]; !alreadyAdded {\n\t\t\t\tresult = append(result, val)\n\t\t\t\tseen[val] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\ta := []int{1, 2, 3, 4, 5}\n\tb := []int{3, 4, 5, 6, 7}\n\tfmt.Println(\"Intersection:\", intersection(a, b)) // Output: [3 4 5]\n}\n```\n\n**Explanation:**\n- We use a map to store elements of the first slice for fast lookup.\n- We iterate over the second slice and check if each element exists in the map.\n- To avoid duplicates in the result, we use another map called `seen`.\n\nThis approach works efficiently for slices of any size.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998749Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "aa384026-55d8-48a3-8060-e8add9d7613c",
    "question": "How do you reverse a linked list in Go?",
    "answer": "```markdown Certainly! Here’s an intermediate-level answer to reversing a singly linked list in Go, including a clear explanation and code example.\n\n---\n\n## How to Reverse a Linked List in Go\n\nTo reverse a singly linked list, you need to change the direction of the next pointers so that each node points to its previous node instead of the next one. This is typically done iteratively by maintaining three pointers: `prev`, `current`, and `next`.\n\n### Step-by-Step Approach\n\n1. Initialize `prev` as `nil` and `current` as the head of the list.\n2. Iterate through the list:\n    - Store `current.Next` in `next`.\n    - Set `current.Next` to `prev`.\n    - Move `prev` and `current` one step forward.\n3. When `current` becomes `nil`, `prev` will be the new head of the reversed list.\n\n### Go Implementation\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Definition for singly-linked list.\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// Function to reverse the linked list\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    current := head\n\n    for current != nil {\n        next := current.Next   // Store next node\n        current.Next = prev    // Reverse the link\n        prev = current         // Move prev forward\n        current = next         // Move current forward\n    }\n    return prev\n}\n\n// Helper function to print the list\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Printf(\"%d \", head.Val)\n        head = head.Next\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    // Create a sample list: 1 -> 2 -> 3 -> 4 -> nil\n    head := &ListNode{1, &ListNode{2, &ListNode{3, &ListNode{4, nil}}}}\n\n    fmt.Print(\"Original list: \")\n    printList(head)\n\n    reversed := reverseList(head)\n\n    fmt.Print(\"Reversed list: \")\n    printList(reversed)\n}\n```\n\n### Output\n\n```\nOriginal list: 1 2 3 4 \nReversed list: 4 3 2 1 \n```\n\n---\n\n**Summary:**  \nTo reverse a linked list in Go, iterate through the list and reverse the direction of the `Next` pointers. The provided code demonstrates this process with a simple example.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998762Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "9f35d263-396a-4ed0-9d9c-08109cfef89c",
    "question": "How do you detect a cycle in a linked list in Go?",
    "answer": "```markdown\n## How do you detect a cycle in a linked list in Go?\n\nTo detect a cycle in a linked list, you can use Floyd’s Cycle-Finding Algorithm, also known as the \"tortoise and hare\" algorithm. This approach uses two pointers that move at different speeds through the list:\n\n- The slow pointer moves one step at a time.\n- The fast pointer moves two steps at a time.\n\nIf there is a cycle, the fast pointer will eventually meet the slow pointer. If there is no cycle, the fast pointer will reach the end of the list.\n\n### Example Implementation in Go\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Definition for singly-linked list.\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    // Example: Create a list with a cycle\n    node1 := &ListNode{Val: 1}\n    node2 := &ListNode{Val: 2}\n    node3 := &ListNode{Val: 3}\n    node4 := &ListNode{Val: 4}\n    node1.Next = node2\n    node2.Next = node3\n    node3.Next = node4\n    node4.Next = node2 // Creates a cycle\n\n    fmt.Println(hasCycle(node1)) // Output: true\n\n    // Example: Create a list without a cycle\n    node4.Next = nil\n    fmt.Println(hasCycle(node1)) // Output: false\n}\n```\n\n### Explanation\n\n- The `hasCycle` function returns `true` if a cycle is detected, otherwise `false`.\n- The two pointers (`slow` and `fast`) traverse the list at different speeds.\n- If they ever point to the same node, a cycle exists.\n- If the fast pointer reaches the end (`nil`), there is no cycle.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998775Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "84ae8d69-a1d0-4669-9eef-e0cc71fdb558",
    "question": "How do you implement quicksort in Go?",
    "answer": "```markdown Certainly! Here’s how you can implement the Quicksort algorithm in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// quickSort sorts the slice in place using the quicksort algorithm.\nfunc quickSort(arr []int) {\n    if len(arr) < 2 {\n        return\n    }\n    left, right := 0, len(arr)-1\n\n    // Choose a pivot (here, the rightmost element)\n    pivot := arr[right]\n\n    // Partitioning\n    for i := range arr {\n        if arr[i] < pivot {\n            arr[i], arr[left] = arr[left], arr[i]\n            left++\n        }\n    }\n    // Place the pivot after the last smaller element\n    arr[left], arr[right] = arr[right], arr[left]\n\n    // Recursively sort the subarrays\n    quickSort(arr[:left])\n    quickSort(arr[left+1:])\n}\n\nfunc main() {\n    nums := []int{10, 7, 8, 9, 1, 5}\n    quickSort(nums)\n    fmt.Println(\"Sorted array:\", nums)\n}\n```\n\n**Explanation:**\n\n- The function `quickSort` sorts the input slice in place.\n- It chooses the last element as the pivot.\n- It partitions the array such that elements less than the pivot are on the left, and greater ones are on the right.\n- It recursively sorts the subarrays before and after the pivot.\n- The main function demonstrates sorting an example array.\n\n**Output:**\n```\nSorted array: [1 5 7 8 9 10]\n```\n\nThis is a standard in-place quicksort implementation in Go.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998787Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d0f25868-68e1-4b22-ab76-a007d21b42ea",
    "question": "How do you implement merge sort in Go?",
    "answer": "```markdown Certainly! Here’s an explanation and implementation of Merge Sort in Go.\n\n## Merge Sort in Go\n\n**Merge Sort** is a classic divide-and-conquer sorting algorithm. It works by recursively splitting the array into halves, sorting each half, and then merging the sorted halves.\n\n### Steps:\n1. If the array has 1 or 0 elements, it's already sorted.\n2. Split the array into two halves.\n3. Recursively sort each half.\n4. Merge the two sorted halves into a single sorted array.\n\n### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// merge merges two sorted slices into a single sorted slice.\nfunc merge(left, right []int) []int {\n    result := make([]int, 0, len(left)+len(right))\n    i, j := 0, 0\n\n    for i < len(left) && j < len(right) {\n        if left[i] < right[j] {\n            result = append(result, left[i])\n            i++\n        } else {\n            result = append(result, right[j])\n            j++\n        }\n    }\n\n    // Append any remaining elements\n    result = append(result, left[i:]...)\n    result = append(result, right[j:]...)\n\n    return result\n}\n\n// mergeSort recursively sorts the slice using merge sort algorithm.\nfunc mergeSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n\n    mid := len(arr) / 2\n    left := mergeSort(arr[:mid])\n    right := mergeSort(arr[mid:])\n\n    return merge(left, right)\n}\n\nfunc main() {\n    arr := []int{38, 27, 43, 3, 9, 82, 10}\n    sorted := mergeSort(arr)\n    fmt.Println(\"Sorted array:\", sorted)\n}\n```\n\n### Output\n\n```\nSorted array: [3 9 10 27 38 43 82]\n```\n\n---\n\n**Explanation:**\n- `mergeSort` splits the array until it cannot be split further (base case: 1 or 0 elements).\n- `merge` combines two sorted slices into one sorted slice.\n- The main function demonstrates sorting an example array.\n\nMerge Sort has a time complexity of **O(n log n)** and is stable, making it a good choice for many sorting tasks.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998800Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "4ced4ded-36f2-4308-b3b5-3260d26430fe",
    "question": "How do you find the lowest common ancestor in a binary tree in Go?",
    "answer": "```markdown\n### How do you find the lowest common ancestor in a binary tree in Go?\n\nTo find the Lowest Common Ancestor (LCA) of two nodes in a binary tree, you can use a recursive approach. The idea is to traverse the tree from the root. If either of the two nodes is found, return that node. If both left and right subtrees return non-nil, the current node is the LCA.\n\nHere's how you can implement it in Go:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Definition for a binary tree node.\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil || root == p || root == q {\n        return root\n    }\n\n    left := lowestCommonAncestor(root.Left, p, q)\n    right := lowestCommonAncestor(root.Right, p, q)\n\n    if left != nil && right != nil {\n        return root\n    }\n    if left != nil {\n        return left\n    }\n    return right\n}\n\n// Example usage\nfunc main() {\n    /*\n            3\n           / \\\n          5   1\n         / \\ / \\\n        6  2 0  8\n          / \\\n         7   4\n    */\n    root := &TreeNode{Val: 3}\n    root.Left = &TreeNode{Val: 5}\n    root.Right = &TreeNode{Val: 1}\n    root.Left.Left = &TreeNode{Val: 6}\n    root.Left.Right = &TreeNode{Val: 2}\n    root.Right.Left = &TreeNode{Val: 0}\n    root.Right.Right = &TreeNode{Val: 8}\n    root.Left.Right.Left = &TreeNode{Val: 7}\n    root.Left.Right.Right = &TreeNode{Val: 4}\n\n    p := root.Left        // Node with value 5\n    q := root.Left.Right.Right // Node with value 4\n\n    lca := lowestCommonAncestor(root, p, q)\n    fmt.Printf(\"Lowest Common Ancestor: %d\\n\", lca.Val) // Output: 5\n}\n```\n\n**Explanation:**\n- If the current node is `nil`, or matches either `p` or `q`, return it.\n- Recursively search left and right subtrees.\n- If both calls return non-nil, the current node is the LCA.\n- Otherwise, return the non-nil result.\n\nThis approach works for any binary tree (not just BSTs).\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998812Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "b2fb120a-9d3a-443c-a216-be689e01f143",
    "question": "How do you perform level order traversal of a binary tree in Go?",
    "answer": "```markdown\n### Level Order Traversal of a Binary Tree in Go\n\nLevel order traversal (also known as Breadth-First Search, BFS) visits nodes of a binary tree level by level from left to right. This is typically implemented using a queue.\n\n#### Implementation in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Definition for a binary tree node.\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\n// LevelOrder returns the level order traversal of a binary tree as a slice of slices.\nfunc LevelOrder(root *TreeNode) [][]int {\n    var result [][]int\n    if root == nil {\n        return result\n    }\n\n    queue := []*TreeNode{root}\n\n    for len(queue) > 0 {\n        levelSize := len(queue)\n        var level []int\n\n        for i := 0; i < levelSize; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            level = append(level, node.Val)\n\n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n        result = append(result, level)\n    }\n\n    return result\n}\n\nfunc main() {\n    // Example tree:\n    //     1\n    //    / \\\n    //   2   3\n    //  / \\\n    // 4   5\n    root := &TreeNode{Val: 1}\n    root.Left = &TreeNode{Val: 2}\n    root.Right = &TreeNode{Val: 3}\n    root.Left.Left = &TreeNode{Val: 4}\n    root.Left.Right = &TreeNode{Val: 5}\n\n    fmt.Println(LevelOrder(root)) // Output: [[1] [2 3] [4 5]]\n}\n```\n\n#### Explanation\n\n- Use a queue to keep track of nodes at each level.\n- For each level, process all nodes currently in the queue, add their values to the current level, and enqueue their children.\n- Repeat until the queue is empty.\n\nThis approach ensures all nodes are visited level by level.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998828Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "e190165d-8af4-4c55-816f-3471ef36aaa7",
    "question": "How do you implement depth-first search (DFS) in Go?",
    "answer": "```markdown\n## How do you implement depth-first search (DFS) in Go?\n\nDepth-First Search (DFS) is a fundamental graph traversal algorithm. In Go, you can implement DFS either recursively or iteratively (using a stack). Below is a simple recursive implementation for an undirected graph represented using an adjacency list.\n\n### Example: DFS in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Graph structure using adjacency list\ntype Graph struct {\n    vertices int\n    adjList  map[int][]int\n}\n\n// Initialize a new graph\nfunc NewGraph(vertices int) *Graph {\n    return &Graph{\n        vertices: vertices,\n        adjList:  make(map[int][]int),\n    }\n}\n\n// Add an edge to the graph (undirected)\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adjList[u] = append(g.adjList[u], v)\n    g.adjList[v] = append(g.adjList[v], u)\n}\n\n// DFS utility function\nfunc (g *Graph) dfsUtil(v int, visited map[int]bool) {\n    visited[v] = true\n    fmt.Printf(\"%d \", v)\n\n    for _, neighbor := range g.adjList[v] {\n        if !visited[neighbor] {\n            g.dfsUtil(neighbor, visited)\n        }\n    }\n}\n\n// DFS traversal starting from vertex v\nfunc (g *Graph) DFS(start int) {\n    visited := make(map[int]bool)\n    g.dfsUtil(start, visited)\n}\n\nfunc main() {\n    g := NewGraph(5)\n    g.AddEdge(0, 1)\n    g.AddEdge(0, 2)\n    g.AddEdge(1, 3)\n    g.AddEdge(1, 4)\n\n    fmt.Println(\"DFS traversal starting from vertex 0:\")\n    g.DFS(0)\n}\n```\n\n### Output\n\n```\nDFS traversal starting from vertex 0:\n0 1 3 4 2 \n```\n\n### Explanation\n\n- The graph is represented as an adjacency list.\n- The `DFS` function initializes a `visited` map and calls the recursive helper `dfsUtil`.\n- The `dfsUtil` function marks the current node as visited, prints it, and recursively visits all unvisited neighbors.\n\nYou can adapt this code for directed graphs or to perform iterative DFS using a stack.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998835Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f29348bb-1069-4dcd-b74b-dfffe4795b2e",
    "question": "How do you implement breadth-first search (BFS) in Go?",
    "answer": "```markdown\n### How do you implement breadth-first search (BFS) in Go?\n\nBreadth-first search (BFS) is a graph traversal algorithm that explores all neighbors at the present depth prior to moving on to nodes at the next depth level. BFS is typically implemented using a queue.\n\nBelow is an example of BFS in Go for an unweighted graph represented as an adjacency list:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// BFS traverses the graph from the start node and prints the order of traversal.\nfunc BFS(graph map[int][]int, start int) {\n    visited := make(map[int]bool)\n    queue := []int{start}\n    visited[start] = true\n\n    for len(queue) > 0 {\n        // Dequeue the first element\n        node := queue[0]\n        queue = queue[1:]\n        fmt.Printf(\"%d \", node)\n\n        // Enqueue all unvisited neighbors\n        for _, neighbor := range graph[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true\n                queue = append(queue, neighbor)\n            }\n        }\n    }\n}\n\nfunc main() {\n    // Example graph as an adjacency list\n    graph := map[int][]int{\n        1: {2, 3},\n        2: {4, 5},\n        3: {6},\n        4: {},\n        5: {6},\n        6: {},\n    }\n\n    fmt.Print(\"BFS traversal starting from node 1: \")\n    BFS(graph, 1)\n}\n```\n\n**Output:**\n```\nBFS traversal starting from node 1: 1 2 3 4 5 6 \n```\n\n**Explanation:**\n- We use a queue to keep track of nodes to visit.\n- A `visited` map ensures we do not process the same node more than once.\n- We start from the given node, enqueue its neighbors, and repeat until the queue is empty.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998843Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d1499eb3-2646-48d3-8495-e7296f46387d",
    "question": "How do you check if a binary tree is a valid binary search tree in Go?",
    "answer": "```markdown\n### How do you check if a binary tree is a valid binary search tree in Go?\n\nTo determine if a binary tree is a valid Binary Search Tree (BST), you need to ensure that for every node:\n\n- All nodes in the left subtree are less than the node's value.\n- All nodes in the right subtree are greater than the node's value.\n- Both left and right subtrees are also BSTs.\n\nA common approach is to use recursion with a range (`min`, `max`) that each node's value must fall between.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return validate(root, math.MinInt64, math.MaxInt64)\n}\n\nfunc validate(node *TreeNode, min, max int) bool {\n    if node == nil {\n        return true\n    }\n    if node.Val <= min || node.Val >= max {\n        return false\n    }\n    return validate(node.Left, min, node.Val) && validate(node.Right, node.Val, max)\n}\n\n// Example usage\nfunc main() {\n    root := &TreeNode{Val: 2}\n    root.Left = &TreeNode{Val: 1}\n    root.Right = &TreeNode{Val: 3}\n    fmt.Println(isValidBST(root)) // Output: true\n}\n```\n\n#### Explanation\n\n- The `validate` function checks if the current node's value is within the allowed range.\n- For the left child, the maximum allowed value becomes the current node's value.\n- For the right child, the minimum allowed value becomes the current node's value.\n- If all nodes satisfy the BST property, the function returns `true`.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998851Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "4614e364-baf8-41a3-adbc-73f8a468bba7",
    "question": "How do you find the kth largest element in an array in Go?",
    "answer": "```markdown\n## How do you find the kth largest element in an array in Go?\n\nTo find the kth largest element in an array, a common approach is to use a min-heap of size k. Alternatively, you can sort the array and pick the element at the appropriate index. For better performance, especially when k is much smaller than the array size, the heap approach is preferred.\n\nBelow is a Go implementation using the sort package (simple and easy to understand), and another using a min-heap for better efficiency.\n\n### 1. Sorting Approach\n\n```go\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc findKthLargest(nums []int, k int) int {\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\n    return nums[k-1]\n}\n\nfunc main() {\n    nums := []int{3, 2, 1, 5, 6, 4}\n    k := 2\n    fmt.Println(findKthLargest(nums, k)) // Output: 5\n}\n```\n\n### 2. Min-Heap Approach\n\n```go\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\n// MinHeap implements heap.Interface\ntype MinHeap []int\n\nfunc (h MinHeap) Len() int           { return len(h) }\nfunc (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *MinHeap) Push(x interface{}) {\n    *h = append(*h, x.(int))\n}\n\nfunc (h *MinHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc findKthLargest(nums []int, k int) int {\n    h := &MinHeap{}\n    heap.Init(h)\n    for _, num := range nums {\n        heap.Push(h, num)\n        if h.Len() > k {\n            heap.Pop(h)\n        }\n    }\n    return (*h)[0]\n}\n\nfunc main() {\n    nums := []int{3, 2, 1, 5, 6, 4}\n    k := 2\n    fmt.Println(findKthLargest(nums, k)) // Output: 5\n}\n```\n\n**Explanation:**  \n- The sorting approach is straightforward but has O(n log n) time complexity.\n- The min-heap approach maintains a heap of size k, resulting in O(n log k) time complexity, which is more efficient when k is much smaller than n.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998859Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "befa9be5-707d-4748-8fe6-728793f06a0a",
    "question": "How do you implement a stack using slices in Go?",
    "answer": "```markdown\n## How do you implement a stack using slices in Go?\n\nA stack is a Last-In-First-Out (LIFO) data structure. In Go, you can implement a stack using slices by providing methods to push (add) and pop (remove) elements from the end of the slice.\n\nHere's a simple implementation:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\ntype Stack struct {\n    elements []int\n}\n\n// Push adds an element to the top of the stack\nfunc (s *Stack) Push(value int) {\n    s.elements = append(s.elements, value)\n}\n\n// Pop removes and returns the top element of the stack\nfunc (s *Stack) Pop() (int, error) {\n    if len(s.elements) == 0 {\n        return 0, errors.New(\"stack is empty\")\n    }\n    index := len(s.elements) - 1\n    value := s.elements[index]\n    s.elements = s.elements[:index]\n    return value, nil\n}\n\n// Peek returns the top element without removing it\nfunc (s *Stack) Peek() (int, error) {\n    if len(s.elements) == 0 {\n        return 0, errors.New(\"stack is empty\")\n    }\n    return s.elements[len(s.elements)-1], nil\n}\n\n// IsEmpty checks if the stack is empty\nfunc (s *Stack) IsEmpty() bool {\n    return len(s.elements) == 0\n}\n\nfunc main() {\n    stack := &Stack{}\n\n    stack.Push(10)\n    stack.Push(20)\n    stack.Push(30)\n\n    fmt.Println(stack.Peek()) // Output: 30, <nil>\n\n    for !stack.IsEmpty() {\n        val, _ := stack.Pop()\n        fmt.Println(val)\n    }\n}\n```\n\n**Explanation:**\n\n- The `Stack` struct contains a slice of integers.\n- `Push` appends an element to the end of the slice.\n- `Pop` removes and returns the last element.\n- `Peek` returns the last element without removing it.\n- `IsEmpty` checks if the stack is empty.\n\nThis approach leverages Go's slice operations for efficient stack behavior.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998867Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "0ac95ced-ddec-4d89-aba7-ebecec31d518",
    "question": "How do you implement a queue using slices in Go?",
    "answer": "```markdown\n### How do you implement a queue using slices in Go?\n\nA queue is a First-In-First-Out (FIFO) data structure. In Go, you can implement a queue using slices by adding elements to the end and removing them from the front.\n\nHere's a simple implementation:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Queue represents a queue using a slice\ntype Queue struct {\n    items []int\n}\n\n// Enqueue adds an element to the end of the queue\nfunc (q *Queue) Enqueue(item int) {\n    q.items = append(q.items, item)\n}\n\n// Dequeue removes and returns the element from the front of the queue\nfunc (q *Queue) Dequeue() (int, bool) {\n    if len(q.items) == 0 {\n        return 0, false // or return an error\n    }\n    item := q.items[0]\n    q.items = q.items[1:]\n    return item, true\n}\n\n// IsEmpty checks if the queue is empty\nfunc (q *Queue) IsEmpty() bool {\n    return len(q.items) == 0\n}\n\n// Front returns the element at the front without removing it\nfunc (q *Queue) Front() (int, bool) {\n    if len(q.items) == 0 {\n        return 0, false\n    }\n    return q.items[0], true\n}\n\nfunc main() {\n    q := Queue{}\n\n    q.Enqueue(10)\n    q.Enqueue(20)\n    q.Enqueue(30)\n\n    fmt.Println(q.Dequeue()) // Output: 10 true\n    fmt.Println(q.Front())   // Output: 20 true\n    fmt.Println(q.IsEmpty()) // Output: false\n}\n```\n\n**Explanation:**\n- `Enqueue` appends elements to the end of the slice.\n- `Dequeue` removes the first element by slicing from index 1 onward.\n- `IsEmpty` checks if the queue is empty.\n- `Front` peeks at the first element without removing it.\n\nThis approach is simple and idiomatic in Go for small to moderate queue sizes. For very large queues, consider using a circular buffer to avoid slice reallocation overhead.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998874Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "19e7c31c-35ec-48a2-b068-8fb0448abbc2",
    "question": "How do you find the longest substring without repeating characters in Go?",
    "answer": "```markdown\n### How do you find the longest substring without repeating characters in Go?\n\nTo find the longest substring without repeating characters in a string, you can use the sliding window technique with a map to track the last seen index of each character. Here's a Go implementation:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc lengthOfLongestSubstring(s string) int {\n    charIndex := make(map[rune]int)\n    maxLen := 0\n    start := 0\n\n    for i, ch := range s {\n        if lastIdx, found := charIndex[ch]; found && lastIdx >= start {\n            start = lastIdx + 1\n        }\n        charIndex[ch] = i\n        if i-start+1 > maxLen {\n            maxLen = i - start + 1\n        }\n    }\n    return maxLen\n}\n\nfunc main() {\n    s := \"abcabcbb\"\n    fmt.Println(lengthOfLongestSubstring(s)) // Output: 3 (\"abc\")\n}\n```\n\n**Explanation:**\n- We use a map `charIndex` to store the last index of each character.\n- We maintain a `start` pointer for the current window.\n- If we find a repeating character within the current window, we move `start` to one position after the last occurrence.\n- We update `maxLen` with the length of the current window if it's larger than the previous maximum.\n\nThis algorithm runs in O(n) time, where n is the length of the string.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998881Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d6aac2b5-6f83-49be-8eed-5cf08afaa06e",
    "question": "How do you implement Dijkstra's algorithm for shortest path in Go?",
    "answer": "```markdown\n### Dijkstra's Algorithm for Shortest Path in Go\n\nDijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative edge weights. Below is a Go implementation using an adjacency list and a min-heap (priority queue).\n\n#### Implementation\n\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n    \"math\"\n)\n\n// Edge represents a graph edge with a destination and weight.\ntype Edge struct {\n    to     int\n    weight int\n}\n\n// Item is an element in the priority queue.\ntype Item struct {\n    node     int\n    priority int\n    index    int\n}\n\n// PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority < pq[j].priority\n}\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    old[n-1] = nil\n    item.index = -1\n    *pq = old[0 : n-1]\n    return item\n}\n\n// Dijkstra finds shortest paths from source to all nodes.\nfunc Dijkstra(graph map[int][]Edge, source int) map[int]int {\n    dist := make(map[int]int)\n    for node := range graph {\n        dist[node] = math.MaxInt64\n    }\n    dist[source] = 0\n\n    pq := &PriorityQueue{}\n    heap.Init(pq)\n    heap.Push(pq, &Item{node: source, priority: 0})\n\n    for pq.Len() > 0 {\n        curr := heap.Pop(pq).(*Item)\n        u := curr.node\n        if curr.priority > dist[u] {\n            continue // Already found a better path\n        }\n        for _, e := range graph[u] {\n            alt := dist[u] + e.weight\n            if alt < dist[e.to] {\n                dist[e.to] = alt\n                heap.Push(pq, &Item{node: e.to, priority: alt})\n            }\n        }\n    }\n    return dist\n}\n\nfunc main() {\n    // Example graph: adjacency list\n    graph := map[int][]Edge{\n        0: {{1, 4}, {2, 1}},\n        1: {{3, 1}},\n        2: {{1, 2}, {3, 5}},\n        3: {},\n    }\n    source := 0\n    dist := Dijkstra(graph, source)\n    for node, d := range dist {\n        fmt.Printf(\"Shortest distance from %d to %d is %d\\n\", source, node, d)\n    }\n}\n```\n\n#### Explanation\n\n- The graph is represented as an adjacency list: `map[int][]Edge`.\n- The `PriorityQueue` is a min-heap to always process the node with the smallest tentative distance.\n- The `dist` map holds the shortest known distance from the source to each node.\n- For each node, we update the distances to its neighbors if a shorter path is found.\n- The algorithm runs in O((V + E) log V) time using a priority queue.\n\n---\nThis implementation efficiently finds the shortest paths from a source node to all other nodes in a weighted, directed graph.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998888Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "359a7144-1505-4c9c-95cf-4dafdb219210",
    "question": "How do you implement a Trie (prefix tree) in Go?",
    "answer": "```markdown\n## How do you implement a Trie (prefix tree) in Go?\n\nA Trie (prefix tree) is a tree data structure used for efficient retrieval of keys in a dataset of strings, commonly used for autocomplete and spell-checking.\n\n### Implementation in Go\n\nBelow is a basic implementation of a Trie in Go, supporting insertion and search operations:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// TrieNode represents a node in the Trie\ntype TrieNode struct {\n    children map[rune]*TrieNode\n    isEnd    bool\n}\n\n// Trie represents the Trie structure\ntype Trie struct {\n    root *TrieNode\n}\n\n// NewTrie initializes and returns a new Trie\nfunc NewTrie() *Trie {\n    return &Trie{root: &TrieNode{children: make(map[rune]*TrieNode)}}\n}\n\n// Insert adds a word to the Trie\nfunc (t *Trie) Insert(word string) {\n    node := t.root\n    for _, ch := range word {\n        if _, exists := node.children[ch]; !exists {\n            node.children[ch] = &TrieNode{children: make(map[rune]*TrieNode)}\n        }\n        node = node.children[ch]\n    }\n    node.isEnd = true\n}\n\n// Search checks if a word exists in the Trie\nfunc (t *Trie) Search(word string) bool {\n    node := t.root\n    for _, ch := range word {\n        if _, exists := node.children[ch]; !exists {\n            return false\n        }\n        node = node.children[ch]\n    }\n    return node.isEnd\n}\n\n// StartsWith checks if there is any word in the Trie that starts with the given prefix\nfunc (t *Trie) StartsWith(prefix string) bool {\n    node := t.root\n    for _, ch := range prefix {\n        if _, exists := node.children[ch]; !exists {\n            return false\n        }\n        node = node.children[ch]\n    }\n    return true\n}\n\nfunc main() {\n    trie := NewTrie()\n    trie.Insert(\"apple\")\n    fmt.Println(trie.Search(\"apple\"))    // true\n    fmt.Println(trie.Search(\"app\"))      // false\n    fmt.Println(trie.StartsWith(\"app\"))  // true\n    trie.Insert(\"app\")\n    fmt.Println(trie.Search(\"app\"))      // true\n}\n```\n\n### Explanation\n\n- **TrieNode**: Each node contains a map of children nodes and a boolean indicating if it's the end of a word.\n- **Insert**: Iterates through each character, creating child nodes as needed.\n- **Search**: Traverses the Trie to check if the word exists.\n- **StartsWith**: Checks if any word in the Trie starts with the given prefix.\n\nThis implementation can be extended with delete and other advanced operations as needed.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998895Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "654769d3-c918-4456-ac51-cc2bbb5b67cd",
    "question": "How do you implement a LRU (Least Recently Used) cache in Go?",
    "answer": "```markdown\n## How do you implement a LRU (Least Recently Used) cache in Go?\n\nAn LRU (Least Recently Used) cache is a data structure that evicts the least recently accessed item when it reaches its capacity. The typical implementation uses a combination of a doubly linked list and a hash map for O(1) get and put operations.\n\nBelow is a simple implementation in Go:\n\n```go\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\n// Entry represents a key-value pair in the cache\ntype Entry struct {\n    key   int\n    value int\n}\n\n// LRUCache struct\ntype LRUCache struct {\n    capacity int\n    cache    map[int]*list.Element\n    list     *list.List\n}\n\n// Constructor initializes the LRU cache\nfunc Constructor(capacity int) LRUCache {\n    return LRUCache{\n        capacity: capacity,\n        cache:    make(map[int]*list.Element),\n        list:     list.New(),\n    }\n}\n\n// Get returns the value of the key if present, else -1\nfunc (l *LRUCache) Get(key int) int {\n    if elem, ok := l.cache[key]; ok {\n        l.list.MoveToFront(elem)\n        return elem.Value.(*Entry).value\n    }\n    return -1\n}\n\n// Put inserts or updates the value of the key\nfunc (l *LRUCache) Put(key int, value int) {\n    if elem, ok := l.cache[key]; ok {\n        // Update value and move to front\n        elem.Value.(*Entry).value = value\n        l.list.MoveToFront(elem)\n    } else {\n        // Evict if over capacity\n        if l.list.Len() == l.capacity {\n            backElem := l.list.Back()\n            if backElem != nil {\n                l.list.Remove(backElem)\n                delete(l.cache, backElem.Value.(*Entry).key)\n            }\n        }\n        // Insert new entry at front\n        entry := &Entry{key, value}\n        elem := l.list.PushFront(entry)\n        l.cache[key] = elem\n    }\n}\n\n// Example usage\nfunc main() {\n    lru := Constructor(2)\n    lru.Put(1, 1)\n    lru.Put(2, 2)\n    fmt.Println(lru.Get(1)) // returns 1\n    lru.Put(3, 3)           // evicts key 2\n    fmt.Println(lru.Get(2)) // returns -1 (not found)\n    lru.Put(4, 4)           // evicts key 1\n    fmt.Println(lru.Get(1)) // returns -1 (not found)\n    fmt.Println(lru.Get(3)) // returns 3\n    fmt.Println(lru.Get(4)) // returns 4\n}\n```\n\n**Explanation:**\n\n- `list.List` maintains the order of usage (most recent at the front).\n- `cache` is a map for O(1) access to list elements.\n- On `Get`, move the accessed element to the front.\n- On `Put`, update if exists, else insert at front and evict the least recently used if over capacity.\n\nThis ensures both `Get` and `Put` operations run in O(1) time.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998903Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f0ab79e2-e3b3-4006-95d4-3f49f0f3e9eb",
    "question": "How do you implement a min heap in Go?",
    "answer": "```markdown\n### How do you implement a min heap in Go?\n\nA **min heap** is a complete binary tree where the value at each node is less than or equal to the values of its children. In Go, you can implement a min heap using a slice and by defining methods to maintain the heap property.\n\nBelow is an example implementation of a min heap in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// MinHeap struct\ntype MinHeap struct {\n    arr []int\n}\n\n// Insert adds a new element to the heap\nfunc (h *MinHeap) Insert(key int) {\n    h.arr = append(h.arr, key)\n    h.heapifyUp(len(h.arr) - 1)\n}\n\n// ExtractMin removes and returns the minimum element from the heap\nfunc (h *MinHeap) ExtractMin() (int, error) {\n    if len(h.arr) == 0 {\n        return 0, fmt.Errorf(\"heap is empty\")\n    }\n    min := h.arr[0]\n    last := len(h.arr) - 1\n    h.arr[0] = h.arr[last]\n    h.arr = h.arr[:last]\n    h.heapifyDown(0)\n    return min, nil\n}\n\n// heapifyUp maintains the heap property after insertion\nfunc (h *MinHeap) heapifyUp(index int) {\n    for h.arr[parent(index)] > h.arr[index] {\n        h.arr[parent(index)], h.arr[index] = h.arr[index], h.arr[parent(index)]\n        index = parent(index)\n    }\n}\n\n// heapifyDown maintains the heap property after extraction\nfunc (h *MinHeap) heapifyDown(index int) {\n    lastIndex := len(h.arr) - 1\n    l, r := left(index), right(index)\n    smallest := index\n\n    if l <= lastIndex && h.arr[l] < h.arr[smallest] {\n        smallest = l\n    }\n    if r <= lastIndex && h.arr[r] < h.arr[smallest] {\n        smallest = r\n    }\n    if smallest != index {\n        h.arr[smallest], h.arr[index] = h.arr[index], h.arr[smallest]\n        h.heapifyDown(smallest)\n    }\n}\n\n// Helper functions to get parent and children indices\nfunc parent(i int) int { return (i - 1) / 2 }\nfunc left(i int) int   { return 2*i + 1 }\nfunc right(i int) int  { return 2*i + 2 }\n\n// Example usage\nfunc main() {\n    h := &MinHeap{}\n    h.Insert(3)\n    h.Insert(1)\n    h.Insert(6)\n    h.Insert(5)\n    h.Insert(2)\n    h.Insert(4)\n\n    fmt.Println(\"Min Heap array:\", h.arr)\n\n    min, _ := h.ExtractMin()\n    fmt.Println(\"Extracted Min:\", min)\n    fmt.Println(\"Min Heap array after extraction:\", h.arr)\n}\n```\n\n**Output:**\n```\nMin Heap array: [1 2 4 5 3 6]\nExtracted Min: 1\nMin Heap array after extraction: [2 3 4 5 6]\n```\n\n**Explanation:**\n- The `MinHeap` struct uses a slice to store heap elements.\n- `Insert` adds a new element and restores the heap property by moving the element up (`heapifyUp`).\n- `ExtractMin` removes the root (minimum element), replaces it with the last element, and restores the heap property by moving the new root down (`heapifyDown`).\n- Helper functions calculate the indices of parent and children nodes.\n\nThis implementation provides the basic operations for a min heap in Go.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998910Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f41b19ee-bf4b-4af8-9849-ea9b96b29565",
    "question": "How do you implement a max heap in Go?",
    "answer": "```markdown\n### How do you implement a max heap in Go?\n\nA **max heap** is a complete binary tree where each parent node is greater than or equal to its child nodes. The largest element is always at the root. In Go, you can implement a max heap by using a slice and defining methods for insertion, extraction, and heapifying.\n\nBelow is a simple implementation of a max heap in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// MaxHeap structure\ntype MaxHeap struct {\n    array []int\n}\n\n// Insert adds an element to the heap\nfunc (h *MaxHeap) Insert(key int) {\n    h.array = append(h.array, key)\n    h.heapifyUp(len(h.array) - 1)\n}\n\n// Extract returns the largest element and removes it from the heap\nfunc (h *MaxHeap) Extract() int {\n    if len(h.array) == 0 {\n        fmt.Println(\"Heap is empty\")\n        return -1\n    }\n    root := h.array[0]\n    lastIndex := len(h.array) - 1\n    h.array[0] = h.array[lastIndex]\n    h.array = h.array[:lastIndex]\n    h.heapifyDown(0)\n    return root\n}\n\n// heapifyUp moves the element at index up to maintain the heap property\nfunc (h *MaxHeap) heapifyUp(index int) {\n    for h.array[parent(index)] < h.array[index] {\n        h.array[parent(index)], h.array[index] = h.array[index], h.array[parent(index)]\n        index = parent(index)\n    }\n}\n\n// heapifyDown moves the element at index down to maintain the heap property\nfunc (h *MaxHeap) heapifyDown(index int) {\n    lastIndex := len(h.array) - 1\n    l, r := left(index), right(index)\n    largest := index\n\n    if l <= lastIndex && h.array[l] > h.array[largest] {\n        largest = l\n    }\n    if r <= lastIndex && h.array[r] > h.array[largest] {\n        largest = r\n    }\n    if largest != index {\n        h.array[index], h.array[largest] = h.array[largest], h.array[index]\n        h.heapifyDown(largest)\n    }\n}\n\n// Helper functions to get parent and child indices\nfunc parent(i int) int { return (i - 1) / 2 }\nfunc left(i int) int   { return 2*i + 1 }\nfunc right(i int) int  { return 2*i + 2 }\n\n// Example usage\nfunc main() {\n    h := &MaxHeap{}\n    h.Insert(10)\n    h.Insert(20)\n    h.Insert(5)\n    h.Insert(30)\n    fmt.Println(\"Heap array:\", h.array)\n    fmt.Println(\"Extracted max:\", h.Extract())\n    fmt.Println(\"Heap array after extraction:\", h.array)\n}\n```\n\n**Output:**\n```\nHeap array: [30 20 5 10]\nExtracted max: 30\nHeap array after extraction: [20 10 5]\n```\n\n**Explanation:**\n- The `Insert` method adds a new element and maintains the max heap property by moving the element up (`heapifyUp`).\n- The `Extract` method removes and returns the root (maximum value), replaces it with the last element, and restores the heap property by moving the new root down (`heapifyDown`).\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998918Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "c96cb8aa-22ab-4696-80e2-5377c42445ce",
    "question": "How do you solve the N-Queens problem in Go?",
    "answer": "```markdown\n### N-Queens Problem in Go\n\nThe N-Queens problem is a classic backtracking problem where the goal is to place `N` queens on an `N x N` chessboard such that no two queens threaten each other (i.e., no two queens share the same row, column, or diagonal).\n\nBelow is a Go implementation that finds all possible solutions for the N-Queens problem and returns them as a slice of string slices, where each string represents a row of the chessboard.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc solveNQueens(n int) [][]string {\n    var res [][]string\n    board := make([][]byte, n)\n    for i := range board {\n        board[i] = make([]byte, n)\n        for j := range board[i] {\n            board[i][j] = '.'\n        }\n    }\n    cols := make([]bool, n)\n    diag1 := make([]bool, 2*n-1) // row+col\n    diag2 := make([]bool, 2*n-1) // row-col+n-1\n    var backtrack func(row int)\n    backtrack = func(row int) {\n        if row == n {\n            var solution []string\n            for _, r := range board {\n                solution = append(solution, string(r))\n            }\n            res = append(res, solution)\n            return\n        }\n        for col := 0; col < n; col++ {\n            d1 := row + col\n            d2 := row - col + n - 1\n            if cols[col] || diag1[d1] || diag2[d2] {\n                continue\n            }\n            board[row][col] = 'Q'\n            cols[col], diag1[d1], diag2[d2] = true, true, true\n            backtrack(row + 1)\n            board[row][col] = '.'\n            cols[col], diag1[d1], diag2[d2] = false, false, false\n        }\n    }\n    backtrack(0)\n    return res\n}\n\nfunc main() {\n    n := 4\n    solutions := solveNQueens(n)\n    for i, sol := range solutions {\n        fmt.Printf(\"Solution %d:\\n\", i+1)\n        for _, row := range sol {\n            fmt.Println(row)\n        }\n        fmt.Println()\n    }\n}\n```\n\n**Explanation:**\n\n- We use backtracking to try placing a queen in each row.\n- `cols`, `diag1`, and `diag2` are used to track if a column or diagonal is already occupied by a queen.\n- When a solution is found (all rows are filled), we append the board configuration to the result.\n- The function prints all possible solutions for `n = 4`.\n\n**Sample Output:**\n```\nSolution 1:\n.Q..\n...Q\nQ...\n..Q.\n\nSolution 2:\n..Q.\nQ...\n...Q\n.Q..\n```\n```",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998925Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "98186724-4b16-4752-a7fb-97115637c23a",
    "question": "How do you find strongly connected components in a directed graph in Go?",
    "answer": "```markdown\n### How do you find strongly connected components in a directed graph in Go?\n\nTo find strongly connected components (SCCs) in a directed graph, **Tarjan's Algorithm** is commonly used due to its efficiency (O(V + E) time complexity). Below is a Go implementation of Tarjan's Algorithm for finding SCCs.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Graph struct {\n    adj map[int][]int\n}\n\nfunc NewGraph() *Graph {\n    return &Graph{adj: make(map[int][]int)}\n}\n\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adj[u] = append(g.adj[u], v)\n}\n\nfunc (g *Graph) TarjanSCC() [][]int {\n    index := 0\n    indices := make(map[int]int)\n    lowlink := make(map[int]int)\n    onStack := make(map[int]bool)\n    stack := []int{}\n    var sccs [][]int\n\n    var strongConnect func(v int)\n    strongConnect = func(v int) {\n        indices[v] = index\n        lowlink[v] = index\n        index++\n        stack = append(stack, v)\n        onStack[v] = true\n\n        for _, w := range g.adj[v] {\n            if _, found := indices[w]; !found {\n                strongConnect(w)\n                if lowlink[w] < lowlink[v] {\n                    lowlink[v] = lowlink[w]\n                }\n            } else if onStack[w] {\n                if indices[w] < lowlink[v] {\n                    lowlink[v] = indices[w]\n                }\n            }\n        }\n\n        if lowlink[v] == indices[v] {\n            var scc []int\n            for {\n                w := stack[len(stack)-1]\n                stack = stack[:len(stack)-1]\n                onStack[w] = false\n                scc = append(scc, w)\n                if w == v {\n                    break\n                }\n            }\n            sccs = append(sccs, scc)\n        }\n    }\n\n    for v := range g.adj {\n        if _, found := indices[v]; !found {\n            strongConnect(v)\n        }\n    }\n    return sccs\n}\n\nfunc main() {\n    g := NewGraph()\n    g.AddEdge(1, 2)\n    g.AddEdge(2, 3)\n    g.AddEdge(3, 1)\n    g.AddEdge(3, 4)\n    g.AddEdge(4, 5)\n    g.AddEdge(5, 4)\n    g.AddEdge(6, 5)\n    g.AddEdge(6, 7)\n    g.AddEdge(7, 6)\n    g.AddEdge(8, 7)\n    g.AddEdge(8, 8)\n\n    sccs := g.TarjanSCC()\n    fmt.Println(\"Strongly Connected Components:\")\n    for _, scc := range sccs {\n        fmt.Println(scc)\n    }\n}\n```\n\n#### Explanation\n\n- **Graph Representation:** The graph is represented using an adjacency list.\n- **Tarjan's Algorithm:** Uses depth-first search, tracking discovery indices and low-link values.\n- **Stack:** Maintains the current path in the DFS.\n- **SCC Extraction:** When a root node of an SCC is found, nodes are popped off the stack to form the SCC.\n- **Usage:** The `main` function demonstrates finding SCCs in a sample graph.\n\n**Output Example:**\n```\nStrongly Connected Components:\n[3 2 1]\n[4 5]\n[6 7]\n[8]\n```\n\nThis approach efficiently finds all strongly connected components in a directed graph using Go.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998932Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d4885f88-9973-41c3-9b86-0b9c573c0bc5",
    "question": "How do you implement topological sort in Go?",
    "answer": "```markdown\n### Topological Sort in Go\n\nTopological sort is used to order the vertices of a Directed Acyclic Graph (DAG) such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering.\n\n#### Implementation (using DFS):\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Graph represents a directed graph using adjacency list\ntype Graph struct {\n    vertices int\n    adj      [][]int\n}\n\n// NewGraph creates a new graph with n vertices\nfunc NewGraph(n int) *Graph {\n    return &Graph{\n        vertices: n,\n        adj:      make([][]int, n),\n    }\n}\n\n// AddEdge adds a directed edge from u to v\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adj[u] = append(g.adj[u], v)\n}\n\n// topologicalSortUtil is a recursive helper function for DFS\nfunc (g *Graph) topologicalSortUtil(v int, visited []bool, stack *[]int) {\n    visited[v] = true\n\n    for _, neighbor := range g.adj[v] {\n        if !visited[neighbor] {\n            g.topologicalSortUtil(neighbor, visited, stack)\n        }\n    }\n\n    // Push current vertex to stack after visiting neighbors\n    *stack = append(*stack, v)\n}\n\n// TopologicalSort returns a topological ordering of the graph\nfunc (g *Graph) TopologicalSort() ([]int, error) {\n    visited := make([]bool, g.vertices)\n    stack := []int{}\n\n    for i := 0; i < g.vertices; i++ {\n        if !visited[i] {\n            g.topologicalSortUtil(i, visited, &stack)\n        }\n    }\n\n    // Reverse the stack to get the correct order\n    for i, j := 0, len(stack)-1; i < j; i, j = i+1, j-1 {\n        stack[i], stack[j] = stack[j], stack[i]\n    }\n\n    return stack, nil\n}\n\nfunc main() {\n    g := NewGraph(6)\n    g.AddEdge(5, 2)\n    g.AddEdge(5, 0)\n    g.AddEdge(4, 0)\n    g.AddEdge(4, 1)\n    g.AddEdge(2, 3)\n    g.AddEdge(3, 1)\n\n    order, _ := g.TopologicalSort()\n    fmt.Println(\"Topological Sort:\", order)\n}\n```\n\n#### Output\n\n```\nTopological Sort: [5 4 2 3 1 0]\n```\n\n#### Notes\n\n- This implementation uses DFS and a stack to store the order.\n- The time complexity is O(V + E), where V is the number of vertices and E is the number of edges.\n- This implementation does not check for cycles. For cycle detection, you can add an extra visited state (e.g., \"visiting\") to detect back edges.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998940Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "9fe12942-e3e5-46b0-bc24-8babe7ff6726",
    "question": "How do you implement the Knuth-Morris-Pratt (KMP) string matching algorithm in Go?",
    "answer": "```markdown\n### Knuth-Morris-Pratt (KMP) String Matching Algorithm in Go\n\nThe **KMP algorithm** efficiently searches for occurrences of a \"pattern\" string within a \"text\" string by preprocessing the pattern to create a longest prefix suffix (LPS) array. This allows the algorithm to avoid unnecessary re-examinations of previously matched characters.\n\n#### Steps:\n1. **Preprocess the Pattern:** Build the LPS array for the pattern.\n2. **Search:** Use the LPS array to skip characters while matching.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// ComputeLPSArray computes the Longest Prefix Suffix (LPS) array\nfunc computeLPSArray(pattern string) []int {\n    lps := make([]int, len(pattern))\n    length := 0 // length of the previous longest prefix suffix\n\n    i := 1\n    for i < len(pattern) {\n        if pattern[i] == pattern[length] {\n            length++\n            lps[i] = length\n            i++\n        } else {\n            if length != 0 {\n                length = lps[length-1]\n            } else {\n                lps[i] = 0\n                i++\n            }\n        }\n    }\n    return lps\n}\n\n// KMPSearch returns the starting indices of all occurrences of pattern in text\nfunc KMPSearch(text, pattern string) []int {\n    lps := computeLPSArray(pattern)\n    var result []int\n\n    i, j := 0, 0 // i: index for text, j: index for pattern\n    for i < len(text) {\n        if pattern[j] == text[i] {\n            i++\n            j++\n        }\n        if j == len(pattern) {\n            result = append(result, i-j)\n            j = lps[j-1]\n        } else if i < len(text) && pattern[j] != text[i] {\n            if j != 0 {\n                j = lps[j-1]\n            } else {\n                i++\n            }\n        }\n    }\n    return result\n}\n\nfunc main() {\n    text := \"ababcabcabababd\"\n    pattern := \"ababd\"\n    matches := KMPSearch(text, pattern)\n    fmt.Println(\"Pattern found at indices:\", matches)\n}\n```\n\n#### Output\n```\nPattern found at indices: [10]\n```\n\n#### Explanation\n- The `computeLPSArray` function preprocesses the pattern to build the LPS array.\n- The `KMPSearch` function uses the LPS array to efficiently search for the pattern in the text.\n- The algorithm runs in O(N+M) time, where N is the length of the text and M is the length of the pattern.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998947Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "de48aceb-0c1d-4668-9e95-9672e76ee066",
    "question": "How do you implement the Rabin-Karp string search algorithm in Go?",
    "answer": "```markdown\n### Rabin-Karp String Search Algorithm in Go\n\nThe **Rabin-Karp algorithm** is an efficient string searching algorithm that uses hashing to find any one of a set of pattern strings in a text. It computes a hash of the pattern and then slides a window over the text, computing the hash at each position and comparing it to the pattern's hash. If the hashes match, it does a direct string comparison to confirm the match.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nconst (\n    d = 256 // Number of characters in the input alphabet\n    q = 101 // A prime number for modulo operations to reduce collisions\n)\n\n// RabinKarp searches for pattern in text and returns the starting indices of all matches.\nfunc RabinKarp(text, pattern string) []int {\n    n := len(text)\n    m := len(pattern)\n    if m == 0 || n < m {\n        return nil\n    }\n\n    var result []int\n    h := 1\n    p, t := 0, 0\n\n    // The value of h would be pow(d, m-1) % q\n    for i := 0; i < m-1; i++ {\n        h = (h * d) % q\n    }\n\n    // Calculate the hash value of pattern and first window of text\n    for i := 0; i < m; i++ {\n        p = (d*p + int(pattern[i])) % q\n        t = (d*t + int(text[i])) % q\n    }\n\n    // Slide the pattern over text one by one\n    for i := 0; i <= n-m; i++ {\n        // Check the hash values of current window of text and pattern\n        if p == t {\n            // If the hash values match, check for characters one by one\n            if text[i:i+m] == pattern {\n                result = append(result, i)\n            }\n        }\n        // Calculate hash value for next window of text\n        if i < n-m {\n            t = (d*(t-int(text[i])*h) + int(text[i+m])) % q\n            // We might get negative value of t, converting it to positive\n            if t < 0 {\n                t += q\n            }\n        }\n    }\n    return result\n}\n\nfunc main() {\n    text := \"GEEKS FOR GEEKS\"\n    pattern := \"GEEK\"\n    indices := RabinKarp(text, pattern)\n    fmt.Println(\"Pattern found at indices:\", indices)\n}\n```\n\n#### Output\n\n```\nPattern found at indices: [0 10]\n```\n\n#### Explanation\n\n- `d` is the number of possible characters (here, 256 for extended ASCII).\n- `q` is a prime number to minimize hash collisions.\n- The algorithm computes the hash for the pattern and the first window of the text, then slides the window, updating the hash efficiently.\n- When the hash matches, it checks the actual substring to confirm the match.\n\nThis implementation efficiently finds all occurrences of the pattern in the text using the Rabin-Karp algorithm in Go.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998954Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "a11e7b3f-37f2-4c96-9f91-db14bcfa6a2f",
    "question": "How do you implement union-find (disjoint set) in Go?",
    "answer": "```markdown\n### How do you implement union-find (disjoint set) in Go?\n\nThe **union-find** (or **disjoint set**) data structure efficiently supports two operations:\n\n- **Find**: Determine which subset a particular element is in.\n- **Union**: Join two subsets into a single subset.\n\nA common implementation uses **path compression** (to flatten the structure for fast finds) and **union by rank/size** (to keep trees shallow).\n\n#### Go Implementation\n\n```go\npackage main\n\nimport \"fmt\"\n\n// DisjointSet represents the union-find data structure.\ntype DisjointSet struct {\n    parent []int\n    rank   []int\n}\n\n// NewDisjointSet initializes a new disjoint set with n elements (0 to n-1).\nfunc NewDisjointSet(n int) *DisjointSet {\n    parent := make([]int, n)\n    rank := make([]int, n)\n    for i := 0; i < n; i++ {\n        parent[i] = i\n        rank[i] = 0\n    }\n    return &DisjointSet{parent, rank}\n}\n\n// Find returns the representative of the set containing x, with path compression.\nfunc (ds *DisjointSet) Find(x int) int {\n    if ds.parent[x] != x {\n        ds.parent[x] = ds.Find(ds.parent[x]) // Path compression\n    }\n    return ds.parent[x]\n}\n\n// Union merges the sets containing x and y, using union by rank.\nfunc (ds *DisjointSet) Union(x, y int) {\n    xRoot := ds.Find(x)\n    yRoot := ds.Find(y)\n    if xRoot == yRoot {\n        return\n    }\n    // Union by rank\n    if ds.rank[xRoot] < ds.rank[yRoot] {\n        ds.parent[xRoot] = yRoot\n    } else if ds.rank[xRoot] > ds.rank[yRoot] {\n        ds.parent[yRoot] = xRoot\n    } else {\n        ds.parent[yRoot] = xRoot\n        ds.rank[xRoot]++\n    }\n}\n\n// Example usage\nfunc main() {\n    ds := NewDisjointSet(5)\n    ds.Union(0, 1)\n    ds.Union(1, 2)\n    fmt.Println(ds.Find(0)) // Output: representative of set containing 0\n    fmt.Println(ds.Find(2)) // Output: same as above\n    fmt.Println(ds.Find(3)) // Output: representative of set containing 3\n    ds.Union(3, 4)\n    ds.Union(2, 4)\n    fmt.Println(ds.Find(4)) // Output: representative of set containing 0,1,2,3,4\n}\n```\n\n#### Key Points\n\n- **Path compression** in `Find` makes future queries faster.\n- **Union by rank** keeps the tree shallow, improving efficiency.\n- Both operations are nearly constant time, amortized over a sequence of operations.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998962Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "b5513765-c7d1-46b0-8d7c-fce85d386e15",
    "question": "How do you implement a binary search tree with insert, search, and delete operations in Go?",
    "answer": "```markdown\n## Implementing a Binary Search Tree (BST) in Go\n\nBelow is an implementation of a Binary Search Tree in Go, supporting `Insert`, `Search`, and `Delete` operations.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Node represents a node in the BST\ntype Node struct {\n    Key   int\n    Left  *Node\n    Right *Node\n}\n\n// Insert inserts a new key into the BST\nfunc (n *Node) Insert(key int) *Node {\n    if n == nil {\n        return &Node{Key: key}\n    }\n    if key < n.Key {\n        n.Left = n.Left.Insert(key)\n    } else if key > n.Key {\n        n.Right = n.Right.Insert(key)\n    }\n    // If key == n.Key, do nothing (no duplicates)\n    return n\n}\n\n// Search searches for a key in the BST\nfunc (n *Node) Search(key int) *Node {\n    if n == nil || n.Key == key {\n        return n\n    }\n    if key < n.Key {\n        return n.Left.Search(key)\n    }\n    return n.Right.Search(key)\n}\n\n// findMin finds the node with the minimum key in the BST\nfunc (n *Node) findMin() *Node {\n    current := n\n    for current != nil && current.Left != nil {\n        current = current.Left\n    }\n    return current\n}\n\n// Delete deletes a key from the BST\nfunc (n *Node) Delete(key int) *Node {\n    if n == nil {\n        return nil\n    }\n    if key < n.Key {\n        n.Left = n.Left.Delete(key)\n    } else if key > n.Key {\n        n.Right = n.Right.Delete(key)\n    } else {\n        // Node with only one child or no child\n        if n.Left == nil {\n            return n.Right\n        } else if n.Right == nil {\n            return n.Left\n        }\n        // Node with two children: Get the inorder successor (smallest in the right subtree)\n        minRight := n.Right.findMin()\n        n.Key = minRight.Key\n        n.Right = n.Right.Delete(minRight.Key)\n    }\n    return n\n}\n\n// InOrder prints the BST in-order (for testing)\nfunc (n *Node) InOrder() {\n    if n == nil {\n        return\n    }\n    n.Left.InOrder()\n    fmt.Printf(\"%d \", n.Key)\n    n.Right.InOrder()\n}\n\nfunc main() {\n    var root *Node\n    keys := []int{50, 30, 20, 40, 70, 60, 80}\n    for _, key := range keys {\n        root = root.Insert(key)\n    }\n\n    fmt.Print(\"InOrder Traversal: \")\n    root.InOrder()\n    fmt.Println()\n\n    // Search\n    searchKey := 40\n    if root.Search(searchKey) != nil {\n        fmt.Printf(\"Found %d in BST\\n\", searchKey)\n    } else {\n        fmt.Printf(\"%d not found in BST\\n\", searchKey)\n    }\n\n    // Delete\n    root = root.Delete(20)\n    fmt.Print(\"After deleting 20: \")\n    root.InOrder()\n    fmt.Println()\n}\n```\n\n### Explanation\n\n- **Insert:** Recursively finds the correct position and inserts the key.\n- **Search:** Recursively searches for the key.\n- **Delete:** Handles three cases: node with no child, one child, or two children (using inorder successor).\n- **InOrder:** Helper function to print the BST in sorted order.\n\nThis implementation provides a basic, unbalanced BST. For self-balancing trees, consider AVL or Red-Black Trees.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998969Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "da3a7103-306a-470d-b84d-22271ee19de9",
    "question": "How do you implement a graph using adjacency list in Go?",
    "answer": "```markdown\n## How do you implement a graph using adjacency list in Go?\n\nAn adjacency list is a common way to represent a graph, where each node (vertex) maintains a list of its adjacent nodes. In Go, this can be implemented using a map where keys are node identifiers and values are slices of adjacent nodes.\n\nBelow is a simple implementation for an undirected graph using an adjacency list in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Graph represents a graph using an adjacency list\ntype Graph struct {\n    adjList map[int][]int\n}\n\n// NewGraph initializes a new graph\nfunc NewGraph() *Graph {\n    return &Graph{\n        adjList: make(map[int][]int),\n    }\n}\n\n// AddEdge adds an edge between two nodes (u and v)\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adjList[u] = append(g.adjList[u], v)\n    g.adjList[v] = append(g.adjList[v], u) // Remove this line for a directed graph\n}\n\n// Print prints the adjacency list of the graph\nfunc (g *Graph) Print() {\n    for node, neighbors := range g.adjList {\n        fmt.Printf(\"%d: %v\\n\", node, neighbors)\n    }\n}\n\nfunc main() {\n    g := NewGraph()\n    g.AddEdge(1, 2)\n    g.AddEdge(1, 3)\n    g.AddEdge(2, 4)\n    g.AddEdge(3, 4)\n\n    g.Print()\n}\n```\n\n**Output:**\n```\n1: [2 3]\n2: [1 4]\n3: [1 4]\n4: [2 3]\n```\n\n**Explanation:**\n- The `Graph` struct uses a map to store adjacency lists.\n- `AddEdge` adds an edge between two nodes. For undirected graphs, both directions are added.\n- `Print` displays the adjacency list for each node.\n\nYou can modify this structure for directed graphs, weighted graphs, or use custom types for nodes as needed.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998977Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "3555e524-d3ce-4630-ae06-aa8cfa3ccf7c",
    "question": "How do you implement a priority queue in Go?",
    "answer": "```markdown\n## How do you implement a priority queue in Go?\n\nIn Go, a priority queue can be implemented using the `container/heap` package, which provides heap operations for any type that implements the `heap.Interface`. Below is an example of how to implement a min-priority queue (where the smallest item has the highest priority):\n\n### Step 1: Define the Item and PriorityQueue Types\n\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\n// Item is something we manage in a priority queue.\ntype Item struct {\n    value    string // The value of the item; arbitrary.\n    priority int    // The priority of the item in the queue.\n    index    int    // The index of the item in the heap.\n}\n\n// PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    // We want Pop to give us the lowest priority so we use less than here.\n    return pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    old[n-1] = nil  // avoid memory leak\n    item.index = -1 // for safety\n    *pq = old[0 : n-1]\n    return item\n}\n```\n\n### Step 2: Using the Priority Queue\n\n```go\nfunc main() {\n    // Some items and their priorities.\n    items := map[string]int{\n        \"banana\": 3, \"apple\": 2, \"pear\": 4,\n    }\n\n    // Create a priority queue, put the items in it, and establish the heap invariants.\n    pq := make(PriorityQueue, 0)\n    heap.Init(&pq)\n    for value, priority := range items {\n        heap.Push(&pq, &Item{\n            value:    value,\n            priority: priority,\n        })\n    }\n\n    // Insert a new item and then modify its priority.\n    item := &Item{\n        value:    \"orange\",\n        priority: 1,\n    }\n    heap.Push(&pq, item)\n\n    // Remove items in priority order.\n    for pq.Len() > 0 {\n        item := heap.Pop(&pq).(*Item)\n        fmt.Printf(\"%s (priority: %d)\\n\", item.value, item.priority)\n    }\n}\n```\n\n### Output\n\n```\norange (priority: 1)\napple (priority: 2)\nbanana (priority: 3)\npear (priority: 4)\n```\n\n### Notes\n\n- The `container/heap` package requires you to implement the `heap.Interface` methods (`Len`, `Less`, `Swap`, `Push`, and `Pop`).\n- You can adapt the `Less` method for a max-priority queue by reversing the comparison.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998984Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "728b836f-ecb4-4397-9603-d91d41224069",
    "question": "How do you find the shortest path in an unweighted graph using BFS in Go?",
    "answer": "```markdown\n### How do you find the shortest path in an unweighted graph using BFS in Go?\n\nTo find the shortest path in an unweighted graph, you can use Breadth-First Search (BFS). BFS explores nodes in layers, ensuring that the first time you reach a node, it's via the shortest path. You can also keep track of the path by maintaining a predecessor map.\n\nHere's a Go implementation that finds the shortest path between two nodes in an unweighted graph:\n\n```go\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\n// Graph represented as an adjacency list\ntype Graph map[int][]int\n\n// BFSShortestPath finds the shortest path from start to end in an unweighted graph\nfunc BFSShortestPath(graph Graph, start, end int) []int {\n    visited := make(map[int]bool)\n    prev := make(map[int]int)\n    queue := list.New()\n\n    visited[start] = true\n    queue.PushBack(start)\n\n    for queue.Len() > 0 {\n        node := queue.Remove(queue.Front()).(int)\n        if node == end {\n            break\n        }\n        for _, neighbor := range graph[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true\n                prev[neighbor] = node\n                queue.PushBack(neighbor)\n            }\n        }\n    }\n\n    // Reconstruct path\n    path := []int{}\n    at := end\n    for {\n        path = append([]int{at}, path...)\n        if at == start {\n            break\n        }\n        p, ok := prev[at]\n        if !ok {\n            return nil // No path found\n        }\n        at = p\n    }\n    return path\n}\n\nfunc main() {\n    // Example graph\n    graph := Graph{\n        1: {2, 3},\n        2: {1, 4, 5},\n        3: {1, 6},\n        4: {2},\n        5: {2, 6},\n        6: {3, 5},\n    }\n    start, end := 1, 6\n    path := BFSShortestPath(graph, start, end)\n    if path != nil {\n        fmt.Printf(\"Shortest path from %d to %d: %v\\n\", start, end, path)\n    } else {\n        fmt.Printf(\"No path found from %d to %d\\n\", start, end)\n    }\n}\n```\n\n**Explanation:**\n- The graph is represented as an adjacency list.\n- BFS is performed using a queue.\n- A `prev` map is used to reconstruct the path once the end node is reached.\n- The path is reconstructed by backtracking from the end node to the start node.\n\n**Output:**\n```\nShortest path from 1 to 6: [1 3 6]\n```\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998992Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f13c75ed-3b0b-4223-b38a-485b19823294",
    "question": "How do you implement a circular queue in Go?",
    "answer": "```markdown\n## How do you implement a circular queue in Go?\n\nA **circular queue** is a linear data structure that follows the FIFO (First In First Out) principle, but connects the end of the queue back to the front, forming a circle. This allows efficient utilization of space by reusing vacated slots.\n\nBelow is an implementation of a circular queue in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\ntype CircularQueue struct {\n    data        []int\n    front, rear int\n    size, cap   int\n}\n\n// Constructor to initialize the queue\nfunc NewCircularQueue(capacity int) *CircularQueue {\n    return &CircularQueue{\n        data:  make([]int, capacity),\n        front: 0,\n        rear:  0,\n        size:  0,\n        cap:   capacity,\n    }\n}\n\n// Enqueue adds an element to the queue\nfunc (q *CircularQueue) Enqueue(val int) error {\n    if q.IsFull() {\n        return errors.New(\"queue is full\")\n    }\n    q.data[q.rear] = val\n    q.rear = (q.rear + 1) % q.cap\n    q.size++\n    return nil\n}\n\n// Dequeue removes and returns the front element\nfunc (q *CircularQueue) Dequeue() (int, error) {\n    if q.IsEmpty() {\n        return 0, errors.New(\"queue is empty\")\n    }\n    val := q.data[q.front]\n    q.front = (q.front + 1) % q.cap\n    q.size--\n    return val, nil\n}\n\n// IsEmpty checks if the queue is empty\nfunc (q *CircularQueue) IsEmpty() bool {\n    return q.size == 0\n}\n\n// IsFull checks if the queue is full\nfunc (q *CircularQueue) IsFull() bool {\n    return q.size == q.cap\n}\n\n// Front returns the front element without removing it\nfunc (q *CircularQueue) Front() (int, error) {\n    if q.IsEmpty() {\n        return 0, errors.New(\"queue is empty\")\n    }\n    return q.data[q.front], nil\n}\n\n// Rear returns the last element without removing it\nfunc (q *CircularQueue) Rear() (int, error) {\n    if q.IsEmpty() {\n        return 0, errors.New(\"queue is empty\")\n    }\n    // (rear - 1 + cap) % cap handles wrap-around\n    idx := (q.rear - 1 + q.cap) % q.cap\n    return q.data[idx], nil\n}\n\nfunc main() {\n    q := NewCircularQueue(3)\n    fmt.Println(q.Enqueue(1)) // nil\n    fmt.Println(q.Enqueue(2)) // nil\n    fmt.Println(q.Enqueue(3)) // nil\n    fmt.Println(q.Enqueue(4)) // queue is full\n\n    fmt.Println(q.Dequeue()) // 1, nil\n    fmt.Println(q.Enqueue(4)) // nil\n\n    fmt.Println(q.Front()) // 2, nil\n    fmt.Println(q.Rear())  // 4, nil\n}\n```\n\n**Explanation:**\n- The queue uses a fixed-size slice.\n- `front` and `rear` pointers are updated using modulo arithmetic to wrap around.\n- `size` tracks the number of elements to distinguish between full and empty states.\n- Enqueue and Dequeue operations are O(1).\n\nThis implementation efficiently utilizes the allocated space and provides all standard queue operations.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999004Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "6a061d69-c5ad-4928-ae67-404017515aff",
    "question": "How do you find the median of two sorted arrays in Go?",
    "answer": "```markdown\n### How do you find the median of two sorted arrays in Go?\n\nTo find the median of two sorted arrays, you can use a binary search approach to achieve O(log(min(m, n))) time complexity, where `m` and `n` are the lengths of the two arrays. The idea is to partition the arrays such that the left part contains the same number of elements as the right part, and all elements in the left part are less than or equal to those in the right part.\n\nHere's a Go implementation:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n\t// Ensure nums1 is the smaller array\n\tif len(nums1) > len(nums2) {\n\t\treturn findMedianSortedArrays(nums2, nums1)\n\t}\n\tm, n := len(nums1), len(nums2)\n\timin, imax, halfLen := 0, m, (m+n+1)/2\n\n\tfor imin <= imax {\n\t\ti := (imin + imax) / 2\n\t\tj := halfLen - i\n\n\t\tif i < m && nums2[j-1] > nums1[i] {\n\t\t\timin = i + 1 // i is too small\n\t\t} else if i > 0 && nums1[i-1] > nums2[j] {\n\t\t\timax = i - 1 // i is too big\n\t\t} else { // i is perfect\n\t\t\tvar maxOfLeft int\n\t\t\tif i == 0 {\n\t\t\t\tmaxOfLeft = nums2[j-1]\n\t\t\t} else if j == 0 {\n\t\t\t\tmaxOfLeft = nums1[i-1]\n\t\t\t} else {\n\t\t\t\tmaxOfLeft = int(math.Max(float64(nums1[i-1]), float64(nums2[j-1])))\n\t\t\t}\n\n\t\t\tif (m+n)%2 == 1 {\n\t\t\t\treturn float64(maxOfLeft)\n\t\t\t}\n\n\t\t\tvar minOfRight int\n\t\t\tif i == m {\n\t\t\t\tminOfRight = nums2[j]\n\t\t\t} else if j == n {\n\t\t\t\tminOfRight = nums1[i]\n\t\t\t} else {\n\t\t\t\tminOfRight = int(math.Min(float64(nums1[i]), float64(nums2[j])))\n\t\t\t}\n\n\t\t\treturn float64(maxOfLeft+minOfRight) / 2.0\n\t\t}\n\t}\n\treturn 0.0\n}\n\nfunc main() {\n\tnums1 := []int{1, 3}\n\tnums2 := []int{2}\n\tfmt.Println(findMedianSortedArrays(nums1, nums2)) // Output: 2\n\n\tnums1 = []int{1, 2}\n\tnums2 = []int{3, 4}\n\tfmt.Println(findMedianSortedArrays(nums1, nums2)) // Output: 2.5\n}\n```\n\n**Explanation:**\n- The function uses binary search on the smaller array to find a partition such that the left and right halves of the combined arrays are balanced.\n- It handles both even and odd total lengths.\n- The median is either the maximum of the left elements (for odd total length) or the average of the maximum of the left and the minimum of the right (for even total length).\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.999016Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "2425d271-d68a-40e9-b0b7-f875400e1df7",
    "question": "How do you implement a concurrent-safe map in Go?",
    "answer": "```markdown\n### How do you implement a concurrent-safe map in Go?\n\nIn Go, the built-in `map` type is **not safe for concurrent use**. To implement a concurrent-safe map, you have several options:\n\n#### 1. Using `sync.Map`\n\nGo's standard library provides `sync.Map`, which is designed for concurrent use without explicit locking.\n\n```go\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var m sync.Map\n\n    // Store a value\n    m.Store(\"foo\", 42)\n\n    // Load a value\n    if value, ok := m.Load(\"foo\"); ok {\n        fmt.Println(\"Found:\", value)\n    }\n\n    // Delete a value\n    m.Delete(\"foo\")\n}\n```\n\n#### 2. Using `sync.RWMutex` with a Regular Map\n\nFor more control (e.g., custom logic), you can wrap a regular map with a `sync.RWMutex`:\n\n```go\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype SafeMap struct {\n    mu sync.RWMutex\n    m  map[string]int\n}\n\nfunc NewSafeMap() *SafeMap {\n    return &SafeMap{\n        m: make(map[string]int),\n    }\n}\n\nfunc (s *SafeMap) Get(key string) (int, bool) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    val, ok := s.m[key]\n    return val, ok\n}\n\nfunc (s *SafeMap) Set(key string, value int) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.m[key] = value\n}\n\nfunc (s *SafeMap) Delete(key string) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    delete(s.m, key)\n}\n\nfunc main() {\n    sm := NewSafeMap()\n    sm.Set(\"foo\", 42)\n    if val, ok := sm.Get(\"foo\"); ok {\n        fmt.Println(\"Found:\", val)\n    }\n    sm.Delete(\"foo\")\n}\n```\n\n#### Summary\n\n- Use `sync.Map` for simple concurrent maps.\n- Use a map protected by `sync.RWMutex` for more flexibility or custom logic.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.999028Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "c472af58-6538-4b5a-a6c3-863fb4fa6766",
    "question": "How do you implement the producer-consumer problem using channels in Go?",
    "answer": "```markdown\n### Producer-Consumer Problem Using Channels in Go\n\nThe **producer-consumer problem** is a classic example of a multi-process synchronization problem. In Go, channels provide a simple and powerful way to solve this problem by allowing safe communication between goroutines.\n\nBelow is an example implementation where:\n- The **producer** generates integers and sends them to a buffered channel.\n- The **consumer** receives integers from the channel and processes them.\n- The channel is closed by the producer to signal completion.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// Producer function\nfunc producer(ch chan<- int, count int) {\n    for i := 1; i <= count; i++ {\n        fmt.Printf(\"Producing: %d\\n\", i)\n        ch <- i // Send data to channel\n        time.Sleep(time.Millisecond * 500) // Simulate work\n    }\n    close(ch) // Close channel when done\n}\n\n// Consumer function\nfunc consumer(ch <-chan int, done chan<- bool) {\n    for item := range ch { // Receives until channel is closed\n        fmt.Printf(\"Consuming: %d\\n\", item)\n        time.Sleep(time.Millisecond * 800) // Simulate work\n    }\n    done <- true // Signal completion\n}\n\nfunc main() {\n    ch := make(chan int, 5) // Buffered channel\n    done := make(chan bool)\n\n    go producer(ch, 10)\n    go consumer(ch, done)\n\n    <-done // Wait for consumer to finish\n    fmt.Println(\"All items produced and consumed.\")\n}\n```\n\n#### Key Points:\n- **Buffered channels** help decouple producer and consumer speeds.\n- The producer closes the channel to indicate no more items will be sent.\n- The consumer uses `range` to receive until the channel is closed.\n- A `done` channel is used to signal the main goroutine when processing is complete.\n\nThis approach leverages Go's concurrency primitives for a clean and safe solution to the producer-consumer problem.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.999040Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "12c679ae-e8d7-4c18-bf31-e86959d8e0a5",
    "question": "How do you find all permutations of a string in Go?",
    "answer": "```markdown\n## How do you find all permutations of a string in Go?\n\nTo find all permutations of a string in Go, you can use a recursive approach. The idea is to fix each character at the current position and recursively generate all permutations for the remaining characters.\n\nHere's a sample implementation:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// Helper function to swap characters in a slice\nfunc swap(s []rune, i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n// Recursive function to generate permutations\nfunc permute(s []rune, l, r int, result *[]string) {\n\tif l == r {\n\t\t*result = append(*result, string(s))\n\t} else {\n\t\tfor i := l; i <= r; i++ {\n\t\t\tswap(s, l, i)\n\t\t\tpermute(s, l+1, r, result)\n\t\t\tswap(s, l, i) // backtrack\n\t\t}\n\t}\n}\n\n// Function to return all permutations of a string\nfunc getPermutations(str string) []string {\n\tvar result []string\n\ts := []rune(str)\n\tpermute(s, 0, len(s)-1, &result)\n\treturn result\n}\n\nfunc main() {\n\tstr := \"abc\"\n\tperms := getPermutations(str)\n\tfmt.Println(\"Permutations of\", str, \":\")\n\tfor _, p := range perms {\n\t\tfmt.Println(p)\n\t}\n}\n```\n\n### Output\n```\nPermutations of abc :\nabc\nacb\nbac\nbca\ncba\ncab\n```\n\n**Explanation:**\n- The `permute` function recursively generates all permutations by swapping characters.\n- The `swap` function exchanges two characters in the slice.\n- The `getPermutations` function initializes the process and collects results.\n\nThis approach ensures all possible orderings of the input string are generated.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999066Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "3ef10fd6-d11b-4b2e-867e-d511f5c037a4",
    "question": "How do you implement memoization for recursive algorithms in Go?",
    "answer": "```markdown Certainly! Here’s an explanation and example of implementing memoization for recursive algorithms in Go.\n\n---\n\n## How to Implement Memoization for Recursive Algorithms in Go\n\nMemoization is a technique to optimize recursive algorithms by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\n\n### Steps:\n\n1. **Create a cache (map) to store results.**\n2. **Before computing, check if the result is already in the cache.**\n3. **If not, compute and store the result in the cache.**\n4. **Return the cached result.**\n\n### Example: Fibonacci with Memoization\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// fibMemo is a helper function that takes the number n and a memoization map.\nfunc fibMemo(n int, memo map[int]int) int {\n    if n <= 1 {\n        return n\n    }\n    // Check if result is already in the memo\n    if val, exists := memo[n]; exists {\n        return val\n    }\n    // Compute and store in memo\n    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo)\n    return memo[n]\n}\n\nfunc main() {\n    n := 10\n    memo := make(map[int]int)\n    fmt.Printf(\"Fibonacci(%d) = %d\\n\", n, fibMemo(n, memo))\n}\n```\n\n### Output\n\n```\nFibonacci(10) = 55\n```\n\n### Key Points\n\n- The `memo` map stores previously computed Fibonacci numbers.\n- Before each recursive call, the function checks if the value is already computed.\n- This approach reduces the time complexity from exponential to linear for Fibonacci.\n\n---\n\nYou can apply this memoization pattern to other recursive problems in Go by using a map to cache results based on input parameters.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999078Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "37c5ff0e-1e23-4508-8de6-0553cbc964e8",
    "question": "How do you implement a doubly linked list in Go?",
    "answer": "```markdown\n## How do you implement a doubly linked list in Go?\n\nA doubly linked list is a data structure where each node contains a value and pointers to both the next and previous nodes. This allows traversal in both directions.\n\nBelow is a simple implementation of a doubly linked list in Go:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Node represents a node in the doubly linked list\ntype Node struct {\n    value int\n    prev  *Node\n    next  *Node\n}\n\n// DoublyLinkedList represents the linked list\ntype DoublyLinkedList struct {\n    head *Node\n    tail *Node\n}\n\n// InsertAtEnd adds a new node at the end of the list\nfunc (dll *DoublyLinkedList) InsertAtEnd(value int) {\n    newNode := &Node{value: value}\n    if dll.head == nil {\n        dll.head = newNode\n        dll.tail = newNode\n        return\n    }\n    dll.tail.next = newNode\n    newNode.prev = dll.tail\n    dll.tail = newNode\n}\n\n// Delete removes the first node with the given value\nfunc (dll *DoublyLinkedList) Delete(value int) {\n    current := dll.head\n    for current != nil {\n        if current.value == value {\n            if current.prev != nil {\n                current.prev.next = current.next\n            } else {\n                dll.head = current.next\n            }\n            if current.next != nil {\n                current.next.prev = current.prev\n            } else {\n                dll.tail = current.prev\n            }\n            return\n        }\n        current = current.next\n    }\n}\n\n// Display prints the list from head to tail\nfunc (dll *DoublyLinkedList) Display() {\n    current := dll.head\n    for current != nil {\n        fmt.Print(current.value, \" \")\n        current = current.next\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    dll := &DoublyLinkedList{}\n    dll.InsertAtEnd(1)\n    dll.InsertAtEnd(2)\n    dll.InsertAtEnd(3)\n    dll.Display() // Output: 1 2 3\n\n    dll.Delete(2)\n    dll.Display() // Output: 1 3\n}\n```\n\n**Explanation:**\n- Each `Node` has a `value`, a pointer to the previous node (`prev`), and a pointer to the next node (`next`).\n- The `DoublyLinkedList` struct keeps track of the `head` and `tail`.\n- `InsertAtEnd` adds a new node at the end.\n- `Delete` removes the first node with the given value.\n- `Display` prints the list from head to tail.\n\nThis is a basic implementation; you can add more methods as needed (like insertion at the beginning, reverse traversal, etc.).\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999091Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "eeeafc0d-7301-42a5-bf94-201706b6bac2",
    "question": "How do you implement the Sieve of Eratosthenes to find prime numbers in Go?",
    "answer": "```markdown\n### How do you implement the Sieve of Eratosthenes to find prime numbers in Go?\n\nThe Sieve of Eratosthenes is an efficient algorithm to find all prime numbers up to a given number `n`. It works by iteratively marking the multiples of each prime number starting from 2.\n\nHere's how you can implement it in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// SieveOfEratosthenes returns a slice of all prime numbers up to n\nfunc SieveOfEratosthenes(n int) []int {\n    if n < 2 {\n        return []int{}\n    }\n\n    // Create a boolean slice to track prime numbers\n    isPrime := make([]bool, n+1)\n    for i := 2; i <= n; i++ {\n        isPrime[i] = true\n    }\n\n    for i := 2; i*i <= n; i++ {\n        if isPrime[i] {\n            for j := i * i; j <= n; j += i {\n                isPrime[j] = false\n            }\n        }\n    }\n\n    // Collect all prime numbers\n    primes := []int{}\n    for i := 2; i <= n; i++ {\n        if isPrime[i] {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc main() {\n    n := 30\n    primes := SieveOfEratosthenes(n)\n    fmt.Println(\"Prime numbers up to\", n, \":\", primes)\n}\n```\n\n**Output:**\n```\nPrime numbers up to 30 : [2 3 5 7 11 13 17 19 23 29]\n```\n\n**Explanation:**\n- We create a boolean slice `isPrime` to keep track of which numbers are prime.\n- We initialize all entries as `true` (except 0 and 1).\n- For each number `i` starting from 2, if it's marked as prime, we mark all its multiples as not prime.\n- Finally, we collect all numbers that are still marked as prime.\n\nThis algorithm has a time complexity of O(n log log n).\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.999104Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  }
]
