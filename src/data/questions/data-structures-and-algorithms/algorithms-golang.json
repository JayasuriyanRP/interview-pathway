[
  {
    "id": "80fa40e6-5bb6-4033-bd30-8b9424073f2a",
    "question": "How do you reverse a string in Go?",
    "answer": "```go\n// Reversing a string in Go\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc reverseString(s string) string {\n    // Convert string to rune slice to handle Unicode characters\n    runes := []rune(s)\n    n := len(runes)\n    for i := 0; i < n/2; i++ {\n        // Swap runes\n        runes[i], runes[n-1-i] = runes[n-1-i], runes[i]\n    }\n    return string(runes)\n}\n\nfunc main() {\n    input := \"hello 世界\"\n    reversed := reverseString(input)\n    fmt.Println(reversed) // Output: 界世 olleh\n}\n```\n\n**Explanation:**\n\n- Strings in Go are immutable and are sequences of bytes, which may not represent Unicode characters correctly if reversed byte-wise.\n- To handle Unicode, convert the string to a slice of runes (`[]rune`), reverse the slice, and then convert it back to a string.\n- The function `reverseString` swaps runes from both ends towards the center.\n- The example demonstrates reversing a string containing both ASCII and Unicode characters.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998599Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "251e7fb1-8a07-4e05-be47-de2bbeebdbfe",
    "question": "How do you check if a given string is a palindrome in Go?",
    "answer": "```markdown\n### How do you check if a given string is a palindrome in Go?\n\nA palindrome is a string that reads the same backward as forward (e.g., \"madam\", \"racecar\"). To check if a string is a palindrome in Go, you can compare characters from the start and end of the string, moving towards the center.\n\nHere's a simple Go function to check if a string is a palindrome:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc isPalindrome(s string) bool {\n    // Optional: Normalize the string (e.g., lowercase, remove spaces)\n    s = strings.ToLower(s)\n    left, right := 0, len(s)-1\n\n    for left < right {\n        if s[left] != s[right] {\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(isPalindrome(\"madam\"))      // true\n    fmt.Println(isPalindrome(\"racecar\"))    // true\n    fmt.Println(isPalindrome(\"hello\"))      // false\n}\n```\n\n**Explanation:**\n- The function compares the characters at the start (`left`) and end (`right`) of the string.\n- If any pair doesn't match, it returns `false`.\n- If all pairs match, it returns `true`.\n- The example also shows how to use the function.\n\nYou can further enhance this function to ignore spaces, punctuation, or handle Unicode characters as needed.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998623Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "c9d75e6a-cfd0-47c7-9258-019e66caedf7",
    "question": "How do you find the maximum element in an integer slice in Go?",
    "answer": "```markdown\n## How do you find the maximum element in an integer slice in Go?\n\nTo find the maximum element in an integer slice in Go, you can iterate through the slice and keep track of the largest value found so far. Here's a simple example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc findMax(nums []int) int {\n    if len(nums) == 0 {\n        panic(\"slice is empty\")\n    }\n    max := nums[0]\n    for _, num := range nums {\n        if num > max {\n            max = num\n        }\n    }\n    return max\n}\n\nfunc main() {\n    numbers := []int{3, 7, 2, 9, 4}\n    fmt.Println(\"Maximum element:\", findMax(numbers))\n}\n```\n\n**Output:**\n```\nMaximum element: 9\n```\n\n**Explanation:**  \n- The function `findMax` initializes `max` with the first element of the slice.\n- It then iterates through each element, updating `max` if a larger value is found.\n- If the slice is empty, it panics to avoid undefined behavior.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998636Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "b09b4358-479a-4d2e-96e8-d99fe6e4fe51",
    "question": "How do you implement binary search on a sorted slice in Go?",
    "answer": "```go\n// BinarySearch performs binary search on a sorted slice of integers.\n// It returns the index of the target if found, or -1 if not found.\nfunc BinarySearch(nums []int, target int) int {\n    left, right := 0, len(nums)-1\n\n    for left <= right {\n        mid := left + (right-left)/2\n        if nums[mid] == target {\n            return mid\n        } else if nums[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n    return -1\n}\n\n// Example usage:\n// nums := []int{1, 3, 5, 7, 9, 11}\n// index := BinarySearch(nums, 7) // index will be 3\n```\n\n**Explanation:**\n- The function takes a sorted slice of integers and a target value.\n- It uses two pointers (`left` and `right`) to keep track of the search range.\n- It repeatedly checks the middle element:\n  - If the middle element equals the target, it returns the index.\n  - If the middle element is less than the target, it searches the right half.\n  - If the middle element is greater than the target, it searches the left half.\n- If the target is not found, it returns -1.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998648Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "5423e827-ab25-4b98-b3dc-2f3c2d56ceb5",
    "question": "How do you remove duplicates from a slice of integers in Go?",
    "answer": "```go\n// RemoveDuplicates removes duplicate integers from a slice.\nfunc RemoveDuplicates(nums []int) []int {\n    seen := make(map[int]bool)\n    result := []int{}\n    for _, num := range nums {\n        if !seen[num] {\n            seen[num] = true\n            result = append(result, num)\n        }\n    }\n    return result\n}\n\n// Example usage\nfunc main() {\n    nums := []int{1, 2, 2, 3, 4, 4, 5}\n    uniqueNums := RemoveDuplicates(nums)\n    fmt.Println(uniqueNums) // Output: [1 2 3 4 5]\n}\n```\n\n**Explanation:**\n- We use a map to keep track of numbers we've already seen.\n- As we iterate through the slice, we add each unique number to the result slice.\n- This preserves the order of the first occurrence of each number.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998662Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "a4bdcc59-eb2f-471d-a4d0-d850f3f98de3",
    "question": "How do you find the factorial of a number using recursion in Go?",
    "answer": "```go\n// Factorial using recursion in Go\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// factorial calculates the factorial of n using recursion\nfunc factorial(n int) int {\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn n * factorial(n-1)\n}\n\nfunc main() {\n\tnum := 5\n\tresult := factorial(num)\n\tfmt.Printf(\"Factorial of %d is %d\\n\", num, result)\n}\n```\n\n**Explanation:**\n- The factorial of a number n (written as n!) is the product of all positive integers less than or equal to n.\n- The base case is when n is 0, where factorial(0) = 1.\n- The recursive case multiplies n by the factorial of (n-1).\n- In the example above, factorial(5) returns 120.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998670Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "49423684-3beb-4f31-ad8c-5df62422132f",
    "question": "How do you merge two sorted slices into a single sorted slice in Go?",
    "answer": "```go\n// Merges two sorted slices into a single sorted slice in Go.\nfunc mergeSortedSlices(a, b []int) []int {\n    result := make([]int, 0, len(a)+len(b))\n    i, j := 0, 0\n\n    // Compare elements from both slices and append the smaller one.\n    for i < len(a) && j < len(b) {\n        if a[i] < b[j] {\n            result = append(result, a[i])\n            i++\n        } else {\n            result = append(result, b[j])\n            j++\n        }\n    }\n\n    // Append any remaining elements from a or b.\n    result = append(result, a[i:]...)\n    result = append(result, b[j:]...)\n\n    return result\n}\n\n// Example usage\nfunc main() {\n    a := []int{1, 3, 5, 7}\n    b := []int{2, 4, 6, 8}\n    merged := mergeSortedSlices(a, b)\n    fmt.Println(merged) // Output: [1 2 3 4 5 6 7 8]\n}\n```\n\n**Explanation:**\n- The function `mergeSortedSlices` takes two sorted slices `a` and `b`.\n- It uses two pointers (`i` and `j`) to iterate through both slices.\n- It compares the current elements and appends the smaller one to the result.\n- After one slice is exhausted, it appends the remaining elements from the other slice.\n- The result is a single sorted slice containing all elements from both input slices.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998680Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "681a41d0-711c-433c-846e-0f8e7fcd9171",
    "question": "How do you implement bubble sort in Go?",
    "answer": "```go\n// BubbleSort sorts a slice of integers in ascending order using the bubble sort algorithm.\nfunc BubbleSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        // Last i elements are already in place\n        for j := 0; j < n-i-1; j++ {\n            if arr[j] > arr[j+1] {\n                // Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n}\n\nfunc main() {\n    nums := []int{5, 2, 9, 1, 5, 6}\n    BubbleSort(nums)\n    fmt.Println(nums) // Output: [1 2 5 5 6 9]\n}\n```\n\n**Explanation:**\n- The function iterates over the slice multiple times.\n- In each pass, it compares adjacent elements and swaps them if they are in the wrong order.\n- After each pass, the largest unsorted element \"bubbles up\" to its correct position.\n- This process repeats until the slice is sorted.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998693Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "dec87548-cc61-4fe0-8bb9-9349c042b258",
    "question": "How do you count the number of vowels in a string in Go?",
    "answer": "```go\n// CountVowels returns the number of vowels in the given string.\nfunc CountVowels(s string) int {\n    count := 0\n    vowels := \"aeiouAEIOU\"\n    for _, ch := range s {\n        if strings.ContainsRune(vowels, ch) {\n            count++\n        }\n    }\n    return count\n}\n```\n\n**Example usage:**\n```go\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    str := \"Hello, World!\"\n    fmt.Println(CountVowels(str)) // Output: 3\n}\n```\n\n**Explanation:**\n- The function iterates through each character in the string.\n- It checks if the character is a vowel (either uppercase or lowercase).\n- If it is, it increments the count.\n- Finally, it returns the total count of vowels.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998705Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "40d1f15c-4eb0-40f7-86d1-6131980ce429",
    "question": "How do you check if two strings are anagrams in Go?",
    "answer": "```markdown\n### How do you check if two strings are anagrams in Go?\n\nTo check if two strings are anagrams in Go, you can compare the frequency of each character in both strings. If both strings have the same length and the same character counts, they are anagrams.\n\nHere's a simple way to do it:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc areAnagrams(s1, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n\n    count := make(map[rune]int)\n    for _, ch := range s1 {\n        count[ch]++\n    }\n    for _, ch := range s2 {\n        count[ch]--\n        if count[ch] < 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc main() {\n    fmt.Println(areAnagrams(\"listen\", \"silent\")) // true\n    fmt.Println(areAnagrams(\"hello\", \"world\"))   // false\n}\n```\n\n**Explanation:**\n- First, check if the lengths are equal.\n- Use a map to count occurrences of each character in the first string.\n- Decrease the count for each character in the second string.\n- If any count goes below zero, the strings are not anagrams.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998717Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "509c7ea7-096d-4e2f-bcc5-14df989396c8",
    "question": "How do you find the nth Fibonacci number using iteration in Go?",
    "answer": "```go\n// Find the nth Fibonacci number using iteration in Go\npackage main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n\nfunc main() {\n    n := 10\n    fmt.Printf(\"The %dth Fibonacci number is %d\\n\", n, fibonacci(n))\n}\n```\n\n**Explanation:**\n\n- The function `fibonacci(n int) int` calculates the nth Fibonacci number using a loop.\n- It handles the base cases where `n` is 0 or 1.\n- For `n > 1`, it iteratively computes the Fibonacci sequence by updating two variables, `a` and `b`.\n- The result is printed in the `main` function for `n = 10`.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998730Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d1cc85f7-6022-4dad-b8bd-62604c7a6a4f",
    "question": "How do you implement selection sort in Go?",
    "answer": "```go\n// SelectionSort sorts an integer slice in ascending order using the selection sort algorithm.\nfunc SelectionSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        minIdx := i\n        // Find the minimum element in the unsorted part\n        for j := i + 1; j < n; j++ {\n            if arr[j] < arr[minIdx] {\n                minIdx = j\n            }\n        }\n        // Swap the found minimum element with the first element\n        arr[i], arr[minIdx] = arr[minIdx], arr[i]\n    }\n}\n\n// Example usage:\nfunc main() {\n    nums := []int{64, 25, 12, 22, 11}\n    SelectionSort(nums)\n    fmt.Println(nums) // Output: [11 12 22 25 64]\n}\n```\n\n**Explanation:**\n\n- The algorithm divides the slice into a sorted and an unsorted part.\n- It repeatedly selects the smallest element from the unsorted part and swaps it with the first unsorted element.\n- This process is repeated until the entire slice is sorted.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998741Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "6ff40336-c80e-4a20-a885-172132d95de3",
    "question": "How do you find the intersection of two slices in Go?",
    "answer": "```markdown\n### How do you find the intersection of two slices in Go?\n\nTo find the intersection of two slices in Go (i.e., the elements that appear in both slices), you can use a map to efficiently check for common elements. Here's a simple example:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc intersection(a, b []int) []int {\n\tset := make(map[int]struct{})\n\tresult := []int{}\n\n\t// Add all elements from slice 'a' to the set\n\tfor _, val := range a {\n\t\tset[val] = struct{}{}\n\t}\n\n\t// Check if elements in 'b' are in the set\n\tseen := make(map[int]struct{}) // To avoid duplicates in result\n\tfor _, val := range b {\n\t\tif _, exists := set[val]; exists {\n\t\t\tif _, alreadyAdded := seen[val]; !alreadyAdded {\n\t\t\t\tresult = append(result, val)\n\t\t\t\tseen[val] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\ta := []int{1, 2, 3, 4, 5}\n\tb := []int{3, 4, 5, 6, 7}\n\tfmt.Println(\"Intersection:\", intersection(a, b)) // Output: [3 4 5]\n}\n```\n\n**Explanation:**\n- We use a map to store elements of the first slice for fast lookup.\n- We iterate over the second slice and check if each element exists in the map.\n- To avoid duplicates in the result, we use another map called `seen`.\n\nThis approach works efficiently for slices of any size.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.998749Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "aa384026-55d8-48a3-8060-e8add9d7613c",
    "question": "How do you reverse a linked list in Go?",
    "answer": "```markdown Certainly! Here’s an intermediate-level answer to reversing a singly linked list in Go, including a clear explanation and code example.\n\n---\n\n## How to Reverse a Linked List in Go\n\nTo reverse a singly linked list, you need to change the direction of the next pointers so that each node points to its previous node instead of the next one. This is typically done iteratively by maintaining three pointers: `prev`, `current`, and `next`.\n\n### Step-by-Step Approach\n\n1. Initialize `prev` as `nil` and `current` as the head of the list.\n2. Iterate through the list:\n    - Store `current.Next` in `next`.\n    - Set `current.Next` to `prev`.\n    - Move `prev` and `current` one step forward.\n3. When `current` becomes `nil`, `prev` will be the new head of the reversed list.\n\n### Go Implementation\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Definition for singly-linked list.\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\n// Function to reverse the linked list\nfunc reverseList(head *ListNode) *ListNode {\n    var prev *ListNode\n    current := head\n\n    for current != nil {\n        next := current.Next   // Store next node\n        current.Next = prev    // Reverse the link\n        prev = current         // Move prev forward\n        current = next         // Move current forward\n    }\n    return prev\n}\n\n// Helper function to print the list\nfunc printList(head *ListNode) {\n    for head != nil {\n        fmt.Printf(\"%d \", head.Val)\n        head = head.Next\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    // Create a sample list: 1 -> 2 -> 3 -> 4 -> nil\n    head := &ListNode{1, &ListNode{2, &ListNode{3, &ListNode{4, nil}}}}\n\n    fmt.Print(\"Original list: \")\n    printList(head)\n\n    reversed := reverseList(head)\n\n    fmt.Print(\"Reversed list: \")\n    printList(reversed)\n}\n```\n\n### Output\n\n```\nOriginal list: 1 2 3 4 \nReversed list: 4 3 2 1 \n```\n\n---\n\n**Summary:**  \nTo reverse a linked list in Go, iterate through the list and reverse the direction of the `Next` pointers. The provided code demonstrates this process with a simple example.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998762Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "9f35d263-396a-4ed0-9d9c-08109cfef89c",
    "question": "How do you detect a cycle in a linked list in Go?",
    "answer": "```markdown\n## How do you detect a cycle in a linked list in Go?\n\nTo detect a cycle in a linked list, you can use Floyd’s Cycle-Finding Algorithm, also known as the \"tortoise and hare\" algorithm. This approach uses two pointers that move at different speeds through the list:\n\n- The slow pointer moves one step at a time.\n- The fast pointer moves two steps at a time.\n\nIf there is a cycle, the fast pointer will eventually meet the slow pointer. If there is no cycle, the fast pointer will reach the end of the list.\n\n### Example Implementation in Go\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Definition for singly-linked list.\ntype ListNode struct {\n    Val  int\n    Next *ListNode\n}\n\nfunc hasCycle(head *ListNode) bool {\n    slow, fast := head, head\n    for fast != nil && fast.Next != nil {\n        slow = slow.Next\n        fast = fast.Next.Next\n        if slow == fast {\n            return true\n        }\n    }\n    return false\n}\n\nfunc main() {\n    // Example: Create a list with a cycle\n    node1 := &ListNode{Val: 1}\n    node2 := &ListNode{Val: 2}\n    node3 := &ListNode{Val: 3}\n    node4 := &ListNode{Val: 4}\n    node1.Next = node2\n    node2.Next = node3\n    node3.Next = node4\n    node4.Next = node2 // Creates a cycle\n\n    fmt.Println(hasCycle(node1)) // Output: true\n\n    // Example: Create a list without a cycle\n    node4.Next = nil\n    fmt.Println(hasCycle(node1)) // Output: false\n}\n```\n\n### Explanation\n\n- The `hasCycle` function returns `true` if a cycle is detected, otherwise `false`.\n- The two pointers (`slow` and `fast`) traverse the list at different speeds.\n- If they ever point to the same node, a cycle exists.\n- If the fast pointer reaches the end (`nil`), there is no cycle.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998775Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "84ae8d69-a1d0-4669-9eef-e0cc71fdb558",
    "question": "How do you implement quicksort in Go?",
    "answer": "```markdown Certainly! Here’s how you can implement the Quicksort algorithm in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// quickSort sorts the slice in place using the quicksort algorithm.\nfunc quickSort(arr []int) {\n    if len(arr) < 2 {\n        return\n    }\n    left, right := 0, len(arr)-1\n\n    // Choose a pivot (here, the rightmost element)\n    pivot := arr[right]\n\n    // Partitioning\n    for i := range arr {\n        if arr[i] < pivot {\n            arr[i], arr[left] = arr[left], arr[i]\n            left++\n        }\n    }\n    // Place the pivot after the last smaller element\n    arr[left], arr[right] = arr[right], arr[left]\n\n    // Recursively sort the subarrays\n    quickSort(arr[:left])\n    quickSort(arr[left+1:])\n}\n\nfunc main() {\n    nums := []int{10, 7, 8, 9, 1, 5}\n    quickSort(nums)\n    fmt.Println(\"Sorted array:\", nums)\n}\n```\n\n**Explanation:**\n\n- The function `quickSort` sorts the input slice in place.\n- It chooses the last element as the pivot.\n- It partitions the array such that elements less than the pivot are on the left, and greater ones are on the right.\n- It recursively sorts the subarrays before and after the pivot.\n- The main function demonstrates sorting an example array.\n\n**Output:**\n```\nSorted array: [1 5 7 8 9 10]\n```\n\nThis is a standard in-place quicksort implementation in Go.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998787Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d0f25868-68e1-4b22-ab76-a007d21b42ea",
    "question": "How do you implement merge sort in Go?",
    "answer": "```markdown Certainly! Here’s an explanation and implementation of Merge Sort in Go.\n\n## Merge Sort in Go\n\n**Merge Sort** is a classic divide-and-conquer sorting algorithm. It works by recursively splitting the array into halves, sorting each half, and then merging the sorted halves.\n\n### Steps:\n1. If the array has 1 or 0 elements, it's already sorted.\n2. Split the array into two halves.\n3. Recursively sort each half.\n4. Merge the two sorted halves into a single sorted array.\n\n### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// merge merges two sorted slices into a single sorted slice.\nfunc merge(left, right []int) []int {\n    result := make([]int, 0, len(left)+len(right))\n    i, j := 0, 0\n\n    for i < len(left) && j < len(right) {\n        if left[i] < right[j] {\n            result = append(result, left[i])\n            i++\n        } else {\n            result = append(result, right[j])\n            j++\n        }\n    }\n\n    // Append any remaining elements\n    result = append(result, left[i:]...)\n    result = append(result, right[j:]...)\n\n    return result\n}\n\n// mergeSort recursively sorts the slice using merge sort algorithm.\nfunc mergeSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n\n    mid := len(arr) / 2\n    left := mergeSort(arr[:mid])\n    right := mergeSort(arr[mid:])\n\n    return merge(left, right)\n}\n\nfunc main() {\n    arr := []int{38, 27, 43, 3, 9, 82, 10}\n    sorted := mergeSort(arr)\n    fmt.Println(\"Sorted array:\", sorted)\n}\n```\n\n### Output\n\n```\nSorted array: [3 9 10 27 38 43 82]\n```\n\n---\n\n**Explanation:**\n- `mergeSort` splits the array until it cannot be split further (base case: 1 or 0 elements).\n- `merge` combines two sorted slices into one sorted slice.\n- The main function demonstrates sorting an example array.\n\nMerge Sort has a time complexity of **O(n log n)** and is stable, making it a good choice for many sorting tasks.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998800Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "4ced4ded-36f2-4308-b3b5-3260d26430fe",
    "question": "How do you find the lowest common ancestor in a binary tree in Go?",
    "answer": "```markdown\n### How do you find the lowest common ancestor in a binary tree in Go?\n\nTo find the Lowest Common Ancestor (LCA) of two nodes in a binary tree, you can use a recursive approach. The idea is to traverse the tree from the root. If either of the two nodes is found, return that node. If both left and right subtrees return non-nil, the current node is the LCA.\n\nHere's how you can implement it in Go:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Definition for a binary tree node.\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\n    if root == nil || root == p || root == q {\n        return root\n    }\n\n    left := lowestCommonAncestor(root.Left, p, q)\n    right := lowestCommonAncestor(root.Right, p, q)\n\n    if left != nil && right != nil {\n        return root\n    }\n    if left != nil {\n        return left\n    }\n    return right\n}\n\n// Example usage\nfunc main() {\n    /*\n            3\n           / \\\n          5   1\n         / \\ / \\\n        6  2 0  8\n          / \\\n         7   4\n    */\n    root := &TreeNode{Val: 3}\n    root.Left = &TreeNode{Val: 5}\n    root.Right = &TreeNode{Val: 1}\n    root.Left.Left = &TreeNode{Val: 6}\n    root.Left.Right = &TreeNode{Val: 2}\n    root.Right.Left = &TreeNode{Val: 0}\n    root.Right.Right = &TreeNode{Val: 8}\n    root.Left.Right.Left = &TreeNode{Val: 7}\n    root.Left.Right.Right = &TreeNode{Val: 4}\n\n    p := root.Left        // Node with value 5\n    q := root.Left.Right.Right // Node with value 4\n\n    lca := lowestCommonAncestor(root, p, q)\n    fmt.Printf(\"Lowest Common Ancestor: %d\\n\", lca.Val) // Output: 5\n}\n```\n\n**Explanation:**\n- If the current node is `nil`, or matches either `p` or `q`, return it.\n- Recursively search left and right subtrees.\n- If both calls return non-nil, the current node is the LCA.\n- Otherwise, return the non-nil result.\n\nThis approach works for any binary tree (not just BSTs).\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998812Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "b2fb120a-9d3a-443c-a216-be689e01f143",
    "question": "How do you perform level order traversal of a binary tree in Go?",
    "answer": "```markdown\n### Level Order Traversal of a Binary Tree in Go\n\nLevel order traversal (also known as Breadth-First Search, BFS) visits nodes of a binary tree level by level from left to right. This is typically implemented using a queue.\n\n#### Implementation in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Definition for a binary tree node.\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\n// LevelOrder returns the level order traversal of a binary tree as a slice of slices.\nfunc LevelOrder(root *TreeNode) [][]int {\n    var result [][]int\n    if root == nil {\n        return result\n    }\n\n    queue := []*TreeNode{root}\n\n    for len(queue) > 0 {\n        levelSize := len(queue)\n        var level []int\n\n        for i := 0; i < levelSize; i++ {\n            node := queue[0]\n            queue = queue[1:]\n            level = append(level, node.Val)\n\n            if node.Left != nil {\n                queue = append(queue, node.Left)\n            }\n            if node.Right != nil {\n                queue = append(queue, node.Right)\n            }\n        }\n        result = append(result, level)\n    }\n\n    return result\n}\n\nfunc main() {\n    // Example tree:\n    //     1\n    //    / \\\n    //   2   3\n    //  / \\\n    // 4   5\n    root := &TreeNode{Val: 1}\n    root.Left = &TreeNode{Val: 2}\n    root.Right = &TreeNode{Val: 3}\n    root.Left.Left = &TreeNode{Val: 4}\n    root.Left.Right = &TreeNode{Val: 5}\n\n    fmt.Println(LevelOrder(root)) // Output: [[1] [2 3] [4 5]]\n}\n```\n\n#### Explanation\n\n- Use a queue to keep track of nodes at each level.\n- For each level, process all nodes currently in the queue, add their values to the current level, and enqueue their children.\n- Repeat until the queue is empty.\n\nThis approach ensures all nodes are visited level by level.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998828Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "e190165d-8af4-4c55-816f-3471ef36aaa7",
    "question": "How do you implement depth-first search (DFS) in Go?",
    "answer": "```markdown\n## How do you implement depth-first search (DFS) in Go?\n\nDepth-First Search (DFS) is a fundamental graph traversal algorithm. In Go, you can implement DFS either recursively or iteratively (using a stack). Below is a simple recursive implementation for an undirected graph represented using an adjacency list.\n\n### Example: DFS in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Graph structure using adjacency list\ntype Graph struct {\n    vertices int\n    adjList  map[int][]int\n}\n\n// Initialize a new graph\nfunc NewGraph(vertices int) *Graph {\n    return &Graph{\n        vertices: vertices,\n        adjList:  make(map[int][]int),\n    }\n}\n\n// Add an edge to the graph (undirected)\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adjList[u] = append(g.adjList[u], v)\n    g.adjList[v] = append(g.adjList[v], u)\n}\n\n// DFS utility function\nfunc (g *Graph) dfsUtil(v int, visited map[int]bool) {\n    visited[v] = true\n    fmt.Printf(\"%d \", v)\n\n    for _, neighbor := range g.adjList[v] {\n        if !visited[neighbor] {\n            g.dfsUtil(neighbor, visited)\n        }\n    }\n}\n\n// DFS traversal starting from vertex v\nfunc (g *Graph) DFS(start int) {\n    visited := make(map[int]bool)\n    g.dfsUtil(start, visited)\n}\n\nfunc main() {\n    g := NewGraph(5)\n    g.AddEdge(0, 1)\n    g.AddEdge(0, 2)\n    g.AddEdge(1, 3)\n    g.AddEdge(1, 4)\n\n    fmt.Println(\"DFS traversal starting from vertex 0:\")\n    g.DFS(0)\n}\n```\n\n### Output\n\n```\nDFS traversal starting from vertex 0:\n0 1 3 4 2 \n```\n\n### Explanation\n\n- The graph is represented as an adjacency list.\n- The `DFS` function initializes a `visited` map and calls the recursive helper `dfsUtil`.\n- The `dfsUtil` function marks the current node as visited, prints it, and recursively visits all unvisited neighbors.\n\nYou can adapt this code for directed graphs or to perform iterative DFS using a stack.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998835Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f29348bb-1069-4dcd-b74b-dfffe4795b2e",
    "question": "How do you implement breadth-first search (BFS) in Go?",
    "answer": "```markdown\n### How do you implement breadth-first search (BFS) in Go?\n\nBreadth-first search (BFS) is a graph traversal algorithm that explores all neighbors at the present depth prior to moving on to nodes at the next depth level. BFS is typically implemented using a queue.\n\nBelow is an example of BFS in Go for an unweighted graph represented as an adjacency list:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// BFS traverses the graph from the start node and prints the order of traversal.\nfunc BFS(graph map[int][]int, start int) {\n    visited := make(map[int]bool)\n    queue := []int{start}\n    visited[start] = true\n\n    for len(queue) > 0 {\n        // Dequeue the first element\n        node := queue[0]\n        queue = queue[1:]\n        fmt.Printf(\"%d \", node)\n\n        // Enqueue all unvisited neighbors\n        for _, neighbor := range graph[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true\n                queue = append(queue, neighbor)\n            }\n        }\n    }\n}\n\nfunc main() {\n    // Example graph as an adjacency list\n    graph := map[int][]int{\n        1: {2, 3},\n        2: {4, 5},\n        3: {6},\n        4: {},\n        5: {6},\n        6: {},\n    }\n\n    fmt.Print(\"BFS traversal starting from node 1: \")\n    BFS(graph, 1)\n}\n```\n\n**Output:**\n```\nBFS traversal starting from node 1: 1 2 3 4 5 6 \n```\n\n**Explanation:**\n- We use a queue to keep track of nodes to visit.\n- A `visited` map ensures we do not process the same node more than once.\n- We start from the given node, enqueue its neighbors, and repeat until the queue is empty.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998843Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d1499eb3-2646-48d3-8495-e7296f46387d",
    "question": "How do you check if a binary tree is a valid binary search tree in Go?",
    "answer": "```markdown\n### How do you check if a binary tree is a valid binary search tree in Go?\n\nTo determine if a binary tree is a valid Binary Search Tree (BST), you need to ensure that for every node:\n\n- All nodes in the left subtree are less than the node's value.\n- All nodes in the right subtree are greater than the node's value.\n- Both left and right subtrees are also BSTs.\n\nA common approach is to use recursion with a range (`min`, `max`) that each node's value must fall between.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc isValidBST(root *TreeNode) bool {\n    return validate(root, math.MinInt64, math.MaxInt64)\n}\n\nfunc validate(node *TreeNode, min, max int) bool {\n    if node == nil {\n        return true\n    }\n    if node.Val <= min || node.Val >= max {\n        return false\n    }\n    return validate(node.Left, min, node.Val) && validate(node.Right, node.Val, max)\n}\n\n// Example usage\nfunc main() {\n    root := &TreeNode{Val: 2}\n    root.Left = &TreeNode{Val: 1}\n    root.Right = &TreeNode{Val: 3}\n    fmt.Println(isValidBST(root)) // Output: true\n}\n```\n\n#### Explanation\n\n- The `validate` function checks if the current node's value is within the allowed range.\n- For the left child, the maximum allowed value becomes the current node's value.\n- For the right child, the minimum allowed value becomes the current node's value.\n- If all nodes satisfy the BST property, the function returns `true`.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998851Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "4614e364-baf8-41a3-adbc-73f8a468bba7",
    "question": "How do you find the kth largest element in an array in Go?",
    "answer": "```markdown\n## How do you find the kth largest element in an array in Go?\n\nTo find the kth largest element in an array, a common approach is to use a min-heap of size k. Alternatively, you can sort the array and pick the element at the appropriate index. For better performance, especially when k is much smaller than the array size, the heap approach is preferred.\n\nBelow is a Go implementation using the sort package (simple and easy to understand), and another using a min-heap for better efficiency.\n\n### 1. Sorting Approach\n\n```go\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc findKthLargest(nums []int, k int) int {\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\n    return nums[k-1]\n}\n\nfunc main() {\n    nums := []int{3, 2, 1, 5, 6, 4}\n    k := 2\n    fmt.Println(findKthLargest(nums, k)) // Output: 5\n}\n```\n\n### 2. Min-Heap Approach\n\n```go\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\n// MinHeap implements heap.Interface\ntype MinHeap []int\n\nfunc (h MinHeap) Len() int           { return len(h) }\nfunc (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }\nfunc (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *MinHeap) Push(x interface{}) {\n    *h = append(*h, x.(int))\n}\n\nfunc (h *MinHeap) Pop() interface{} {\n    old := *h\n    n := len(old)\n    x := old[n-1]\n    *h = old[0 : n-1]\n    return x\n}\n\nfunc findKthLargest(nums []int, k int) int {\n    h := &MinHeap{}\n    heap.Init(h)\n    for _, num := range nums {\n        heap.Push(h, num)\n        if h.Len() > k {\n            heap.Pop(h)\n        }\n    }\n    return (*h)[0]\n}\n\nfunc main() {\n    nums := []int{3, 2, 1, 5, 6, 4}\n    k := 2\n    fmt.Println(findKthLargest(nums, k)) // Output: 5\n}\n```\n\n**Explanation:**  \n- The sorting approach is straightforward but has O(n log n) time complexity.\n- The min-heap approach maintains a heap of size k, resulting in O(n log k) time complexity, which is more efficient when k is much smaller than n.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998859Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "befa9be5-707d-4748-8fe6-728793f06a0a",
    "question": "How do you implement a stack using slices in Go?",
    "answer": "```markdown\n## How do you implement a stack using slices in Go?\n\nA stack is a Last-In-First-Out (LIFO) data structure. In Go, you can implement a stack using slices by providing methods to push (add) and pop (remove) elements from the end of the slice.\n\nHere's a simple implementation:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\ntype Stack struct {\n    elements []int\n}\n\n// Push adds an element to the top of the stack\nfunc (s *Stack) Push(value int) {\n    s.elements = append(s.elements, value)\n}\n\n// Pop removes and returns the top element of the stack\nfunc (s *Stack) Pop() (int, error) {\n    if len(s.elements) == 0 {\n        return 0, errors.New(\"stack is empty\")\n    }\n    index := len(s.elements) - 1\n    value := s.elements[index]\n    s.elements = s.elements[:index]\n    return value, nil\n}\n\n// Peek returns the top element without removing it\nfunc (s *Stack) Peek() (int, error) {\n    if len(s.elements) == 0 {\n        return 0, errors.New(\"stack is empty\")\n    }\n    return s.elements[len(s.elements)-1], nil\n}\n\n// IsEmpty checks if the stack is empty\nfunc (s *Stack) IsEmpty() bool {\n    return len(s.elements) == 0\n}\n\nfunc main() {\n    stack := &Stack{}\n\n    stack.Push(10)\n    stack.Push(20)\n    stack.Push(30)\n\n    fmt.Println(stack.Peek()) // Output: 30, <nil>\n\n    for !stack.IsEmpty() {\n        val, _ := stack.Pop()\n        fmt.Println(val)\n    }\n}\n```\n\n**Explanation:**\n\n- The `Stack` struct contains a slice of integers.\n- `Push` appends an element to the end of the slice.\n- `Pop` removes and returns the last element.\n- `Peek` returns the last element without removing it.\n- `IsEmpty` checks if the stack is empty.\n\nThis approach leverages Go's slice operations for efficient stack behavior.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998867Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "0ac95ced-ddec-4d89-aba7-ebecec31d518",
    "question": "How do you implement a queue using slices in Go?",
    "answer": "```markdown\n### How do you implement a queue using slices in Go?\n\nA queue is a First-In-First-Out (FIFO) data structure. In Go, you can implement a queue using slices by adding elements to the end and removing them from the front.\n\nHere's a simple implementation:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Queue represents a queue using a slice\ntype Queue struct {\n    items []int\n}\n\n// Enqueue adds an element to the end of the queue\nfunc (q *Queue) Enqueue(item int) {\n    q.items = append(q.items, item)\n}\n\n// Dequeue removes and returns the element from the front of the queue\nfunc (q *Queue) Dequeue() (int, bool) {\n    if len(q.items) == 0 {\n        return 0, false // or return an error\n    }\n    item := q.items[0]\n    q.items = q.items[1:]\n    return item, true\n}\n\n// IsEmpty checks if the queue is empty\nfunc (q *Queue) IsEmpty() bool {\n    return len(q.items) == 0\n}\n\n// Front returns the element at the front without removing it\nfunc (q *Queue) Front() (int, bool) {\n    if len(q.items) == 0 {\n        return 0, false\n    }\n    return q.items[0], true\n}\n\nfunc main() {\n    q := Queue{}\n\n    q.Enqueue(10)\n    q.Enqueue(20)\n    q.Enqueue(30)\n\n    fmt.Println(q.Dequeue()) // Output: 10 true\n    fmt.Println(q.Front())   // Output: 20 true\n    fmt.Println(q.IsEmpty()) // Output: false\n}\n```\n\n**Explanation:**\n- `Enqueue` appends elements to the end of the slice.\n- `Dequeue` removes the first element by slicing from index 1 onward.\n- `IsEmpty` checks if the queue is empty.\n- `Front` peeks at the first element without removing it.\n\nThis approach is simple and idiomatic in Go for small to moderate queue sizes. For very large queues, consider using a circular buffer to avoid slice reallocation overhead.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998874Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "19e7c31c-35ec-48a2-b068-8fb0448abbc2",
    "question": "How do you find the longest substring without repeating characters in Go?",
    "answer": "```markdown\n### How do you find the longest substring without repeating characters in Go?\n\nTo find the longest substring without repeating characters in a string, you can use the sliding window technique with a map to track the last seen index of each character. Here's a Go implementation:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc lengthOfLongestSubstring(s string) int {\n    charIndex := make(map[rune]int)\n    maxLen := 0\n    start := 0\n\n    for i, ch := range s {\n        if lastIdx, found := charIndex[ch]; found && lastIdx >= start {\n            start = lastIdx + 1\n        }\n        charIndex[ch] = i\n        if i-start+1 > maxLen {\n            maxLen = i - start + 1\n        }\n    }\n    return maxLen\n}\n\nfunc main() {\n    s := \"abcabcbb\"\n    fmt.Println(lengthOfLongestSubstring(s)) // Output: 3 (\"abc\")\n}\n```\n\n**Explanation:**\n- We use a map `charIndex` to store the last index of each character.\n- We maintain a `start` pointer for the current window.\n- If we find a repeating character within the current window, we move `start` to one position after the last occurrence.\n- We update `maxLen` with the length of the current window if it's larger than the previous maximum.\n\nThis algorithm runs in O(n) time, where n is the length of the string.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998881Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d6aac2b5-6f83-49be-8eed-5cf08afaa06e",
    "question": "How do you implement Dijkstra's algorithm for shortest path in Go?",
    "answer": "```markdown\n### Dijkstra's Algorithm for Shortest Path in Go\n\nDijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative edge weights. Below is a Go implementation using an adjacency list and a min-heap (priority queue).\n\n#### Implementation\n\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n    \"math\"\n)\n\n// Edge represents a graph edge with a destination and weight.\ntype Edge struct {\n    to     int\n    weight int\n}\n\n// Item is an element in the priority queue.\ntype Item struct {\n    node     int\n    priority int\n    index    int\n}\n\n// PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].priority < pq[j].priority\n}\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    old[n-1] = nil\n    item.index = -1\n    *pq = old[0 : n-1]\n    return item\n}\n\n// Dijkstra finds shortest paths from source to all nodes.\nfunc Dijkstra(graph map[int][]Edge, source int) map[int]int {\n    dist := make(map[int]int)\n    for node := range graph {\n        dist[node] = math.MaxInt64\n    }\n    dist[source] = 0\n\n    pq := &PriorityQueue{}\n    heap.Init(pq)\n    heap.Push(pq, &Item{node: source, priority: 0})\n\n    for pq.Len() > 0 {\n        curr := heap.Pop(pq).(*Item)\n        u := curr.node\n        if curr.priority > dist[u] {\n            continue // Already found a better path\n        }\n        for _, e := range graph[u] {\n            alt := dist[u] + e.weight\n            if alt < dist[e.to] {\n                dist[e.to] = alt\n                heap.Push(pq, &Item{node: e.to, priority: alt})\n            }\n        }\n    }\n    return dist\n}\n\nfunc main() {\n    // Example graph: adjacency list\n    graph := map[int][]Edge{\n        0: {{1, 4}, {2, 1}},\n        1: {{3, 1}},\n        2: {{1, 2}, {3, 5}},\n        3: {},\n    }\n    source := 0\n    dist := Dijkstra(graph, source)\n    for node, d := range dist {\n        fmt.Printf(\"Shortest distance from %d to %d is %d\\n\", source, node, d)\n    }\n}\n```\n\n#### Explanation\n\n- The graph is represented as an adjacency list: `map[int][]Edge`.\n- The `PriorityQueue` is a min-heap to always process the node with the smallest tentative distance.\n- The `dist` map holds the shortest known distance from the source to each node.\n- For each node, we update the distances to its neighbors if a shorter path is found.\n- The algorithm runs in O((V + E) log V) time using a priority queue.\n\n---\nThis implementation efficiently finds the shortest paths from a source node to all other nodes in a weighted, directed graph.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998888Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "359a7144-1505-4c9c-95cf-4dafdb219210",
    "question": "How do you implement a Trie (prefix tree) in Go?",
    "answer": "```markdown\n## How do you implement a Trie (prefix tree) in Go?\n\nA Trie (prefix tree) is a tree data structure used for efficient retrieval of keys in a dataset of strings, commonly used for autocomplete and spell-checking.\n\n### Implementation in Go\n\nBelow is a basic implementation of a Trie in Go, supporting insertion and search operations:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// TrieNode represents a node in the Trie\ntype TrieNode struct {\n    children map[rune]*TrieNode\n    isEnd    bool\n}\n\n// Trie represents the Trie structure\ntype Trie struct {\n    root *TrieNode\n}\n\n// NewTrie initializes and returns a new Trie\nfunc NewTrie() *Trie {\n    return &Trie{root: &TrieNode{children: make(map[rune]*TrieNode)}}\n}\n\n// Insert adds a word to the Trie\nfunc (t *Trie) Insert(word string) {\n    node := t.root\n    for _, ch := range word {\n        if _, exists := node.children[ch]; !exists {\n            node.children[ch] = &TrieNode{children: make(map[rune]*TrieNode)}\n        }\n        node = node.children[ch]\n    }\n    node.isEnd = true\n}\n\n// Search checks if a word exists in the Trie\nfunc (t *Trie) Search(word string) bool {\n    node := t.root\n    for _, ch := range word {\n        if _, exists := node.children[ch]; !exists {\n            return false\n        }\n        node = node.children[ch]\n    }\n    return node.isEnd\n}\n\n// StartsWith checks if there is any word in the Trie that starts with the given prefix\nfunc (t *Trie) StartsWith(prefix string) bool {\n    node := t.root\n    for _, ch := range prefix {\n        if _, exists := node.children[ch]; !exists {\n            return false\n        }\n        node = node.children[ch]\n    }\n    return true\n}\n\nfunc main() {\n    trie := NewTrie()\n    trie.Insert(\"apple\")\n    fmt.Println(trie.Search(\"apple\"))    // true\n    fmt.Println(trie.Search(\"app\"))      // false\n    fmt.Println(trie.StartsWith(\"app\"))  // true\n    trie.Insert(\"app\")\n    fmt.Println(trie.Search(\"app\"))      // true\n}\n```\n\n### Explanation\n\n- **TrieNode**: Each node contains a map of children nodes and a boolean indicating if it's the end of a word.\n- **Insert**: Iterates through each character, creating child nodes as needed.\n- **Search**: Traverses the Trie to check if the word exists.\n- **StartsWith**: Checks if any word in the Trie starts with the given prefix.\n\nThis implementation can be extended with delete and other advanced operations as needed.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998895Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "654769d3-c918-4456-ac51-cc2bbb5b67cd",
    "question": "How do you implement a LRU (Least Recently Used) cache in Go?",
    "answer": "```markdown\n## How do you implement a LRU (Least Recently Used) cache in Go?\n\nAn LRU (Least Recently Used) cache is a data structure that evicts the least recently accessed item when it reaches its capacity. The typical implementation uses a combination of a doubly linked list and a hash map for O(1) get and put operations.\n\nBelow is a simple implementation in Go:\n\n```go\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\n// Entry represents a key-value pair in the cache\ntype Entry struct {\n    key   int\n    value int\n}\n\n// LRUCache struct\ntype LRUCache struct {\n    capacity int\n    cache    map[int]*list.Element\n    list     *list.List\n}\n\n// Constructor initializes the LRU cache\nfunc Constructor(capacity int) LRUCache {\n    return LRUCache{\n        capacity: capacity,\n        cache:    make(map[int]*list.Element),\n        list:     list.New(),\n    }\n}\n\n// Get returns the value of the key if present, else -1\nfunc (l *LRUCache) Get(key int) int {\n    if elem, ok := l.cache[key]; ok {\n        l.list.MoveToFront(elem)\n        return elem.Value.(*Entry).value\n    }\n    return -1\n}\n\n// Put inserts or updates the value of the key\nfunc (l *LRUCache) Put(key int, value int) {\n    if elem, ok := l.cache[key]; ok {\n        // Update value and move to front\n        elem.Value.(*Entry).value = value\n        l.list.MoveToFront(elem)\n    } else {\n        // Evict if over capacity\n        if l.list.Len() == l.capacity {\n            backElem := l.list.Back()\n            if backElem != nil {\n                l.list.Remove(backElem)\n                delete(l.cache, backElem.Value.(*Entry).key)\n            }\n        }\n        // Insert new entry at front\n        entry := &Entry{key, value}\n        elem := l.list.PushFront(entry)\n        l.cache[key] = elem\n    }\n}\n\n// Example usage\nfunc main() {\n    lru := Constructor(2)\n    lru.Put(1, 1)\n    lru.Put(2, 2)\n    fmt.Println(lru.Get(1)) // returns 1\n    lru.Put(3, 3)           // evicts key 2\n    fmt.Println(lru.Get(2)) // returns -1 (not found)\n    lru.Put(4, 4)           // evicts key 1\n    fmt.Println(lru.Get(1)) // returns -1 (not found)\n    fmt.Println(lru.Get(3)) // returns 3\n    fmt.Println(lru.Get(4)) // returns 4\n}\n```\n\n**Explanation:**\n\n- `list.List` maintains the order of usage (most recent at the front).\n- `cache` is a map for O(1) access to list elements.\n- On `Get`, move the accessed element to the front.\n- On `Put`, update if exists, else insert at front and evict the least recently used if over capacity.\n\nThis ensures both `Get` and `Put` operations run in O(1) time.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998903Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f0ab79e2-e3b3-4006-95d4-3f49f0f3e9eb",
    "question": "How do you implement a min heap in Go?",
    "answer": "```markdown\n### How do you implement a min heap in Go?\n\nA **min heap** is a complete binary tree where the value at each node is less than or equal to the values of its children. In Go, you can implement a min heap using a slice and by defining methods to maintain the heap property.\n\nBelow is an example implementation of a min heap in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// MinHeap struct\ntype MinHeap struct {\n    arr []int\n}\n\n// Insert adds a new element to the heap\nfunc (h *MinHeap) Insert(key int) {\n    h.arr = append(h.arr, key)\n    h.heapifyUp(len(h.arr) - 1)\n}\n\n// ExtractMin removes and returns the minimum element from the heap\nfunc (h *MinHeap) ExtractMin() (int, error) {\n    if len(h.arr) == 0 {\n        return 0, fmt.Errorf(\"heap is empty\")\n    }\n    min := h.arr[0]\n    last := len(h.arr) - 1\n    h.arr[0] = h.arr[last]\n    h.arr = h.arr[:last]\n    h.heapifyDown(0)\n    return min, nil\n}\n\n// heapifyUp maintains the heap property after insertion\nfunc (h *MinHeap) heapifyUp(index int) {\n    for h.arr[parent(index)] > h.arr[index] {\n        h.arr[parent(index)], h.arr[index] = h.arr[index], h.arr[parent(index)]\n        index = parent(index)\n    }\n}\n\n// heapifyDown maintains the heap property after extraction\nfunc (h *MinHeap) heapifyDown(index int) {\n    lastIndex := len(h.arr) - 1\n    l, r := left(index), right(index)\n    smallest := index\n\n    if l <= lastIndex && h.arr[l] < h.arr[smallest] {\n        smallest = l\n    }\n    if r <= lastIndex && h.arr[r] < h.arr[smallest] {\n        smallest = r\n    }\n    if smallest != index {\n        h.arr[smallest], h.arr[index] = h.arr[index], h.arr[smallest]\n        h.heapifyDown(smallest)\n    }\n}\n\n// Helper functions to get parent and children indices\nfunc parent(i int) int { return (i - 1) / 2 }\nfunc left(i int) int   { return 2*i + 1 }\nfunc right(i int) int  { return 2*i + 2 }\n\n// Example usage\nfunc main() {\n    h := &MinHeap{}\n    h.Insert(3)\n    h.Insert(1)\n    h.Insert(6)\n    h.Insert(5)\n    h.Insert(2)\n    h.Insert(4)\n\n    fmt.Println(\"Min Heap array:\", h.arr)\n\n    min, _ := h.ExtractMin()\n    fmt.Println(\"Extracted Min:\", min)\n    fmt.Println(\"Min Heap array after extraction:\", h.arr)\n}\n```\n\n**Output:**\n```\nMin Heap array: [1 2 4 5 3 6]\nExtracted Min: 1\nMin Heap array after extraction: [2 3 4 5 6]\n```\n\n**Explanation:**\n- The `MinHeap` struct uses a slice to store heap elements.\n- `Insert` adds a new element and restores the heap property by moving the element up (`heapifyUp`).\n- `ExtractMin` removes the root (minimum element), replaces it with the last element, and restores the heap property by moving the new root down (`heapifyDown`).\n- Helper functions calculate the indices of parent and children nodes.\n\nThis implementation provides the basic operations for a min heap in Go.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998910Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f41b19ee-bf4b-4af8-9849-ea9b96b29565",
    "question": "How do you implement a max heap in Go?",
    "answer": "```markdown\n### How do you implement a max heap in Go?\n\nA **max heap** is a complete binary tree where each parent node is greater than or equal to its child nodes. The largest element is always at the root. In Go, you can implement a max heap by using a slice and defining methods for insertion, extraction, and heapifying.\n\nBelow is a simple implementation of a max heap in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// MaxHeap structure\ntype MaxHeap struct {\n    array []int\n}\n\n// Insert adds an element to the heap\nfunc (h *MaxHeap) Insert(key int) {\n    h.array = append(h.array, key)\n    h.heapifyUp(len(h.array) - 1)\n}\n\n// Extract returns the largest element and removes it from the heap\nfunc (h *MaxHeap) Extract() int {\n    if len(h.array) == 0 {\n        fmt.Println(\"Heap is empty\")\n        return -1\n    }\n    root := h.array[0]\n    lastIndex := len(h.array) - 1\n    h.array[0] = h.array[lastIndex]\n    h.array = h.array[:lastIndex]\n    h.heapifyDown(0)\n    return root\n}\n\n// heapifyUp moves the element at index up to maintain the heap property\nfunc (h *MaxHeap) heapifyUp(index int) {\n    for h.array[parent(index)] < h.array[index] {\n        h.array[parent(index)], h.array[index] = h.array[index], h.array[parent(index)]\n        index = parent(index)\n    }\n}\n\n// heapifyDown moves the element at index down to maintain the heap property\nfunc (h *MaxHeap) heapifyDown(index int) {\n    lastIndex := len(h.array) - 1\n    l, r := left(index), right(index)\n    largest := index\n\n    if l <= lastIndex && h.array[l] > h.array[largest] {\n        largest = l\n    }\n    if r <= lastIndex && h.array[r] > h.array[largest] {\n        largest = r\n    }\n    if largest != index {\n        h.array[index], h.array[largest] = h.array[largest], h.array[index]\n        h.heapifyDown(largest)\n    }\n}\n\n// Helper functions to get parent and child indices\nfunc parent(i int) int { return (i - 1) / 2 }\nfunc left(i int) int   { return 2*i + 1 }\nfunc right(i int) int  { return 2*i + 2 }\n\n// Example usage\nfunc main() {\n    h := &MaxHeap{}\n    h.Insert(10)\n    h.Insert(20)\n    h.Insert(5)\n    h.Insert(30)\n    fmt.Println(\"Heap array:\", h.array)\n    fmt.Println(\"Extracted max:\", h.Extract())\n    fmt.Println(\"Heap array after extraction:\", h.array)\n}\n```\n\n**Output:**\n```\nHeap array: [30 20 5 10]\nExtracted max: 30\nHeap array after extraction: [20 10 5]\n```\n\n**Explanation:**\n- The `Insert` method adds a new element and maintains the max heap property by moving the element up (`heapifyUp`).\n- The `Extract` method removes and returns the root (maximum value), replaces it with the last element, and restores the heap property by moving the new root down (`heapifyDown`).\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998918Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "c96cb8aa-22ab-4696-80e2-5377c42445ce",
    "question": "How do you solve the N-Queens problem in Go?",
    "answer": "```markdown\n### N-Queens Problem in Go\n\nThe N-Queens problem is a classic backtracking problem where the goal is to place `N` queens on an `N x N` chessboard such that no two queens threaten each other (i.e., no two queens share the same row, column, or diagonal).\n\nBelow is a Go implementation that finds all possible solutions for the N-Queens problem and returns them as a slice of string slices, where each string represents a row of the chessboard.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc solveNQueens(n int) [][]string {\n    var res [][]string\n    board := make([][]byte, n)\n    for i := range board {\n        board[i] = make([]byte, n)\n        for j := range board[i] {\n            board[i][j] = '.'\n        }\n    }\n    cols := make([]bool, n)\n    diag1 := make([]bool, 2*n-1) // row+col\n    diag2 := make([]bool, 2*n-1) // row-col+n-1\n    var backtrack func(row int)\n    backtrack = func(row int) {\n        if row == n {\n            var solution []string\n            for _, r := range board {\n                solution = append(solution, string(r))\n            }\n            res = append(res, solution)\n            return\n        }\n        for col := 0; col < n; col++ {\n            d1 := row + col\n            d2 := row - col + n - 1\n            if cols[col] || diag1[d1] || diag2[d2] {\n                continue\n            }\n            board[row][col] = 'Q'\n            cols[col], diag1[d1], diag2[d2] = true, true, true\n            backtrack(row + 1)\n            board[row][col] = '.'\n            cols[col], diag1[d1], diag2[d2] = false, false, false\n        }\n    }\n    backtrack(0)\n    return res\n}\n\nfunc main() {\n    n := 4\n    solutions := solveNQueens(n)\n    for i, sol := range solutions {\n        fmt.Printf(\"Solution %d:\\n\", i+1)\n        for _, row := range sol {\n            fmt.Println(row)\n        }\n        fmt.Println()\n    }\n}\n```\n\n**Explanation:**\n\n- We use backtracking to try placing a queen in each row.\n- `cols`, `diag1`, and `diag2` are used to track if a column or diagonal is already occupied by a queen.\n- When a solution is found (all rows are filled), we append the board configuration to the result.\n- The function prints all possible solutions for `n = 4`.\n\n**Sample Output:**\n```\nSolution 1:\n.Q..\n...Q\nQ...\n..Q.\n\nSolution 2:\n..Q.\nQ...\n...Q\n.Q..\n```\n```",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998925Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "98186724-4b16-4752-a7fb-97115637c23a",
    "question": "How do you find strongly connected components in a directed graph in Go?",
    "answer": "```markdown\n### How do you find strongly connected components in a directed graph in Go?\n\nTo find strongly connected components (SCCs) in a directed graph, **Tarjan's Algorithm** is commonly used due to its efficiency (O(V + E) time complexity). Below is a Go implementation of Tarjan's Algorithm for finding SCCs.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\ntype Graph struct {\n    adj map[int][]int\n}\n\nfunc NewGraph() *Graph {\n    return &Graph{adj: make(map[int][]int)}\n}\n\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adj[u] = append(g.adj[u], v)\n}\n\nfunc (g *Graph) TarjanSCC() [][]int {\n    index := 0\n    indices := make(map[int]int)\n    lowlink := make(map[int]int)\n    onStack := make(map[int]bool)\n    stack := []int{}\n    var sccs [][]int\n\n    var strongConnect func(v int)\n    strongConnect = func(v int) {\n        indices[v] = index\n        lowlink[v] = index\n        index++\n        stack = append(stack, v)\n        onStack[v] = true\n\n        for _, w := range g.adj[v] {\n            if _, found := indices[w]; !found {\n                strongConnect(w)\n                if lowlink[w] < lowlink[v] {\n                    lowlink[v] = lowlink[w]\n                }\n            } else if onStack[w] {\n                if indices[w] < lowlink[v] {\n                    lowlink[v] = indices[w]\n                }\n            }\n        }\n\n        if lowlink[v] == indices[v] {\n            var scc []int\n            for {\n                w := stack[len(stack)-1]\n                stack = stack[:len(stack)-1]\n                onStack[w] = false\n                scc = append(scc, w)\n                if w == v {\n                    break\n                }\n            }\n            sccs = append(sccs, scc)\n        }\n    }\n\n    for v := range g.adj {\n        if _, found := indices[v]; !found {\n            strongConnect(v)\n        }\n    }\n    return sccs\n}\n\nfunc main() {\n    g := NewGraph()\n    g.AddEdge(1, 2)\n    g.AddEdge(2, 3)\n    g.AddEdge(3, 1)\n    g.AddEdge(3, 4)\n    g.AddEdge(4, 5)\n    g.AddEdge(5, 4)\n    g.AddEdge(6, 5)\n    g.AddEdge(6, 7)\n    g.AddEdge(7, 6)\n    g.AddEdge(8, 7)\n    g.AddEdge(8, 8)\n\n    sccs := g.TarjanSCC()\n    fmt.Println(\"Strongly Connected Components:\")\n    for _, scc := range sccs {\n        fmt.Println(scc)\n    }\n}\n```\n\n#### Explanation\n\n- **Graph Representation:** The graph is represented using an adjacency list.\n- **Tarjan's Algorithm:** Uses depth-first search, tracking discovery indices and low-link values.\n- **Stack:** Maintains the current path in the DFS.\n- **SCC Extraction:** When a root node of an SCC is found, nodes are popped off the stack to form the SCC.\n- **Usage:** The `main` function demonstrates finding SCCs in a sample graph.\n\n**Output Example:**\n```\nStrongly Connected Components:\n[3 2 1]\n[4 5]\n[6 7]\n[8]\n```\n\nThis approach efficiently finds all strongly connected components in a directed graph using Go.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998932Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "d4885f88-9973-41c3-9b86-0b9c573c0bc5",
    "question": "How do you implement topological sort in Go?",
    "answer": "```markdown\n### Topological Sort in Go\n\nTopological sort is used to order the vertices of a Directed Acyclic Graph (DAG) such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering.\n\n#### Implementation (using DFS):\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Graph represents a directed graph using adjacency list\ntype Graph struct {\n    vertices int\n    adj      [][]int\n}\n\n// NewGraph creates a new graph with n vertices\nfunc NewGraph(n int) *Graph {\n    return &Graph{\n        vertices: n,\n        adj:      make([][]int, n),\n    }\n}\n\n// AddEdge adds a directed edge from u to v\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adj[u] = append(g.adj[u], v)\n}\n\n// topologicalSortUtil is a recursive helper function for DFS\nfunc (g *Graph) topologicalSortUtil(v int, visited []bool, stack *[]int) {\n    visited[v] = true\n\n    for _, neighbor := range g.adj[v] {\n        if !visited[neighbor] {\n            g.topologicalSortUtil(neighbor, visited, stack)\n        }\n    }\n\n    // Push current vertex to stack after visiting neighbors\n    *stack = append(*stack, v)\n}\n\n// TopologicalSort returns a topological ordering of the graph\nfunc (g *Graph) TopologicalSort() ([]int, error) {\n    visited := make([]bool, g.vertices)\n    stack := []int{}\n\n    for i := 0; i < g.vertices; i++ {\n        if !visited[i] {\n            g.topologicalSortUtil(i, visited, &stack)\n        }\n    }\n\n    // Reverse the stack to get the correct order\n    for i, j := 0, len(stack)-1; i < j; i, j = i+1, j-1 {\n        stack[i], stack[j] = stack[j], stack[i]\n    }\n\n    return stack, nil\n}\n\nfunc main() {\n    g := NewGraph(6)\n    g.AddEdge(5, 2)\n    g.AddEdge(5, 0)\n    g.AddEdge(4, 0)\n    g.AddEdge(4, 1)\n    g.AddEdge(2, 3)\n    g.AddEdge(3, 1)\n\n    order, _ := g.TopologicalSort()\n    fmt.Println(\"Topological Sort:\", order)\n}\n```\n\n#### Output\n\n```\nTopological Sort: [5 4 2 3 1 0]\n```\n\n#### Notes\n\n- This implementation uses DFS and a stack to store the order.\n- The time complexity is O(V + E), where V is the number of vertices and E is the number of edges.\n- This implementation does not check for cycles. For cycle detection, you can add an extra visited state (e.g., \"visiting\") to detect back edges.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998940Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "9fe12942-e3e5-46b0-bc24-8babe7ff6726",
    "question": "How do you implement the Knuth-Morris-Pratt (KMP) string matching algorithm in Go?",
    "answer": "```markdown\n### Knuth-Morris-Pratt (KMP) String Matching Algorithm in Go\n\nThe **KMP algorithm** efficiently searches for occurrences of a \"pattern\" string within a \"text\" string by preprocessing the pattern to create a longest prefix suffix (LPS) array. This allows the algorithm to avoid unnecessary re-examinations of previously matched characters.\n\n#### Steps:\n1. **Preprocess the Pattern:** Build the LPS array for the pattern.\n2. **Search:** Use the LPS array to skip characters while matching.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// ComputeLPSArray computes the Longest Prefix Suffix (LPS) array\nfunc computeLPSArray(pattern string) []int {\n    lps := make([]int, len(pattern))\n    length := 0 // length of the previous longest prefix suffix\n\n    i := 1\n    for i < len(pattern) {\n        if pattern[i] == pattern[length] {\n            length++\n            lps[i] = length\n            i++\n        } else {\n            if length != 0 {\n                length = lps[length-1]\n            } else {\n                lps[i] = 0\n                i++\n            }\n        }\n    }\n    return lps\n}\n\n// KMPSearch returns the starting indices of all occurrences of pattern in text\nfunc KMPSearch(text, pattern string) []int {\n    lps := computeLPSArray(pattern)\n    var result []int\n\n    i, j := 0, 0 // i: index for text, j: index for pattern\n    for i < len(text) {\n        if pattern[j] == text[i] {\n            i++\n            j++\n        }\n        if j == len(pattern) {\n            result = append(result, i-j)\n            j = lps[j-1]\n        } else if i < len(text) && pattern[j] != text[i] {\n            if j != 0 {\n                j = lps[j-1]\n            } else {\n                i++\n            }\n        }\n    }\n    return result\n}\n\nfunc main() {\n    text := \"ababcabcabababd\"\n    pattern := \"ababd\"\n    matches := KMPSearch(text, pattern)\n    fmt.Println(\"Pattern found at indices:\", matches)\n}\n```\n\n#### Output\n```\nPattern found at indices: [10]\n```\n\n#### Explanation\n- The `computeLPSArray` function preprocesses the pattern to build the LPS array.\n- The `KMPSearch` function uses the LPS array to efficiently search for the pattern in the text.\n- The algorithm runs in O(N+M) time, where N is the length of the text and M is the length of the pattern.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998947Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "de48aceb-0c1d-4668-9e95-9672e76ee066",
    "question": "How do you implement the Rabin-Karp string search algorithm in Go?",
    "answer": "```markdown\n### Rabin-Karp String Search Algorithm in Go\n\nThe **Rabin-Karp algorithm** is an efficient string searching algorithm that uses hashing to find any one of a set of pattern strings in a text. It computes a hash of the pattern and then slides a window over the text, computing the hash at each position and comparing it to the pattern's hash. If the hashes match, it does a direct string comparison to confirm the match.\n\n#### Go Implementation\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nconst (\n    d = 256 // Number of characters in the input alphabet\n    q = 101 // A prime number for modulo operations to reduce collisions\n)\n\n// RabinKarp searches for pattern in text and returns the starting indices of all matches.\nfunc RabinKarp(text, pattern string) []int {\n    n := len(text)\n    m := len(pattern)\n    if m == 0 || n < m {\n        return nil\n    }\n\n    var result []int\n    h := 1\n    p, t := 0, 0\n\n    // The value of h would be pow(d, m-1) % q\n    for i := 0; i < m-1; i++ {\n        h = (h * d) % q\n    }\n\n    // Calculate the hash value of pattern and first window of text\n    for i := 0; i < m; i++ {\n        p = (d*p + int(pattern[i])) % q\n        t = (d*t + int(text[i])) % q\n    }\n\n    // Slide the pattern over text one by one\n    for i := 0; i <= n-m; i++ {\n        // Check the hash values of current window of text and pattern\n        if p == t {\n            // If the hash values match, check for characters one by one\n            if text[i:i+m] == pattern {\n                result = append(result, i)\n            }\n        }\n        // Calculate hash value for next window of text\n        if i < n-m {\n            t = (d*(t-int(text[i])*h) + int(text[i+m])) % q\n            // We might get negative value of t, converting it to positive\n            if t < 0 {\n                t += q\n            }\n        }\n    }\n    return result\n}\n\nfunc main() {\n    text := \"GEEKS FOR GEEKS\"\n    pattern := \"GEEK\"\n    indices := RabinKarp(text, pattern)\n    fmt.Println(\"Pattern found at indices:\", indices)\n}\n```\n\n#### Output\n\n```\nPattern found at indices: [0 10]\n```\n\n#### Explanation\n\n- `d` is the number of possible characters (here, 256 for extended ASCII).\n- `q` is a prime number to minimize hash collisions.\n- The algorithm computes the hash for the pattern and the first window of the text, then slides the window, updating the hash efficiently.\n- When the hash matches, it checks the actual substring to confirm the match.\n\nThis implementation efficiently finds all occurrences of the pattern in the text using the Rabin-Karp algorithm in Go.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998954Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "a11e7b3f-37f2-4c96-9f91-db14bcfa6a2f",
    "question": "How do you implement union-find (disjoint set) in Go?",
    "answer": "```markdown\n### How do you implement union-find (disjoint set) in Go?\n\nThe **union-find** (or **disjoint set**) data structure efficiently supports two operations:\n\n- **Find**: Determine which subset a particular element is in.\n- **Union**: Join two subsets into a single subset.\n\nA common implementation uses **path compression** (to flatten the structure for fast finds) and **union by rank/size** (to keep trees shallow).\n\n#### Go Implementation\n\n```go\npackage main\n\nimport \"fmt\"\n\n// DisjointSet represents the union-find data structure.\ntype DisjointSet struct {\n    parent []int\n    rank   []int\n}\n\n// NewDisjointSet initializes a new disjoint set with n elements (0 to n-1).\nfunc NewDisjointSet(n int) *DisjointSet {\n    parent := make([]int, n)\n    rank := make([]int, n)\n    for i := 0; i < n; i++ {\n        parent[i] = i\n        rank[i] = 0\n    }\n    return &DisjointSet{parent, rank}\n}\n\n// Find returns the representative of the set containing x, with path compression.\nfunc (ds *DisjointSet) Find(x int) int {\n    if ds.parent[x] != x {\n        ds.parent[x] = ds.Find(ds.parent[x]) // Path compression\n    }\n    return ds.parent[x]\n}\n\n// Union merges the sets containing x and y, using union by rank.\nfunc (ds *DisjointSet) Union(x, y int) {\n    xRoot := ds.Find(x)\n    yRoot := ds.Find(y)\n    if xRoot == yRoot {\n        return\n    }\n    // Union by rank\n    if ds.rank[xRoot] < ds.rank[yRoot] {\n        ds.parent[xRoot] = yRoot\n    } else if ds.rank[xRoot] > ds.rank[yRoot] {\n        ds.parent[yRoot] = xRoot\n    } else {\n        ds.parent[yRoot] = xRoot\n        ds.rank[xRoot]++\n    }\n}\n\n// Example usage\nfunc main() {\n    ds := NewDisjointSet(5)\n    ds.Union(0, 1)\n    ds.Union(1, 2)\n    fmt.Println(ds.Find(0)) // Output: representative of set containing 0\n    fmt.Println(ds.Find(2)) // Output: same as above\n    fmt.Println(ds.Find(3)) // Output: representative of set containing 3\n    ds.Union(3, 4)\n    ds.Union(2, 4)\n    fmt.Println(ds.Find(4)) // Output: representative of set containing 0,1,2,3,4\n}\n```\n\n#### Key Points\n\n- **Path compression** in `Find` makes future queries faster.\n- **Union by rank** keeps the tree shallow, improving efficiency.\n- Both operations are nearly constant time, amortized over a sequence of operations.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998962Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "b5513765-c7d1-46b0-8d7c-fce85d386e15",
    "question": "How do you implement a binary search tree with insert, search, and delete operations in Go?",
    "answer": "```markdown\n## Implementing a Binary Search Tree (BST) in Go\n\nBelow is an implementation of a Binary Search Tree in Go, supporting `Insert`, `Search`, and `Delete` operations.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Node represents a node in the BST\ntype Node struct {\n    Key   int\n    Left  *Node\n    Right *Node\n}\n\n// Insert inserts a new key into the BST\nfunc (n *Node) Insert(key int) *Node {\n    if n == nil {\n        return &Node{Key: key}\n    }\n    if key < n.Key {\n        n.Left = n.Left.Insert(key)\n    } else if key > n.Key {\n        n.Right = n.Right.Insert(key)\n    }\n    // If key == n.Key, do nothing (no duplicates)\n    return n\n}\n\n// Search searches for a key in the BST\nfunc (n *Node) Search(key int) *Node {\n    if n == nil || n.Key == key {\n        return n\n    }\n    if key < n.Key {\n        return n.Left.Search(key)\n    }\n    return n.Right.Search(key)\n}\n\n// findMin finds the node with the minimum key in the BST\nfunc (n *Node) findMin() *Node {\n    current := n\n    for current != nil && current.Left != nil {\n        current = current.Left\n    }\n    return current\n}\n\n// Delete deletes a key from the BST\nfunc (n *Node) Delete(key int) *Node {\n    if n == nil {\n        return nil\n    }\n    if key < n.Key {\n        n.Left = n.Left.Delete(key)\n    } else if key > n.Key {\n        n.Right = n.Right.Delete(key)\n    } else {\n        // Node with only one child or no child\n        if n.Left == nil {\n            return n.Right\n        } else if n.Right == nil {\n            return n.Left\n        }\n        // Node with two children: Get the inorder successor (smallest in the right subtree)\n        minRight := n.Right.findMin()\n        n.Key = minRight.Key\n        n.Right = n.Right.Delete(minRight.Key)\n    }\n    return n\n}\n\n// InOrder prints the BST in-order (for testing)\nfunc (n *Node) InOrder() {\n    if n == nil {\n        return\n    }\n    n.Left.InOrder()\n    fmt.Printf(\"%d \", n.Key)\n    n.Right.InOrder()\n}\n\nfunc main() {\n    var root *Node\n    keys := []int{50, 30, 20, 40, 70, 60, 80}\n    for _, key := range keys {\n        root = root.Insert(key)\n    }\n\n    fmt.Print(\"InOrder Traversal: \")\n    root.InOrder()\n    fmt.Println()\n\n    // Search\n    searchKey := 40\n    if root.Search(searchKey) != nil {\n        fmt.Printf(\"Found %d in BST\\n\", searchKey)\n    } else {\n        fmt.Printf(\"%d not found in BST\\n\", searchKey)\n    }\n\n    // Delete\n    root = root.Delete(20)\n    fmt.Print(\"After deleting 20: \")\n    root.InOrder()\n    fmt.Println()\n}\n```\n\n### Explanation\n\n- **Insert:** Recursively finds the correct position and inserts the key.\n- **Search:** Recursively searches for the key.\n- **Delete:** Handles three cases: node with no child, one child, or two children (using inorder successor).\n- **InOrder:** Helper function to print the BST in sorted order.\n\nThis implementation provides a basic, unbalanced BST. For self-balancing trees, consider AVL or Red-Black Trees.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.998969Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "da3a7103-306a-470d-b84d-22271ee19de9",
    "question": "How do you implement a graph using adjacency list in Go?",
    "answer": "```markdown\n## How do you implement a graph using adjacency list in Go?\n\nAn adjacency list is a common way to represent a graph, where each node (vertex) maintains a list of its adjacent nodes. In Go, this can be implemented using a map where keys are node identifiers and values are slices of adjacent nodes.\n\nBelow is a simple implementation for an undirected graph using an adjacency list in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// Graph represents a graph using an adjacency list\ntype Graph struct {\n    adjList map[int][]int\n}\n\n// NewGraph initializes a new graph\nfunc NewGraph() *Graph {\n    return &Graph{\n        adjList: make(map[int][]int),\n    }\n}\n\n// AddEdge adds an edge between two nodes (u and v)\nfunc (g *Graph) AddEdge(u, v int) {\n    g.adjList[u] = append(g.adjList[u], v)\n    g.adjList[v] = append(g.adjList[v], u) // Remove this line for a directed graph\n}\n\n// Print prints the adjacency list of the graph\nfunc (g *Graph) Print() {\n    for node, neighbors := range g.adjList {\n        fmt.Printf(\"%d: %v\\n\", node, neighbors)\n    }\n}\n\nfunc main() {\n    g := NewGraph()\n    g.AddEdge(1, 2)\n    g.AddEdge(1, 3)\n    g.AddEdge(2, 4)\n    g.AddEdge(3, 4)\n\n    g.Print()\n}\n```\n\n**Output:**\n```\n1: [2 3]\n2: [1 4]\n3: [1 4]\n4: [2 3]\n```\n\n**Explanation:**\n- The `Graph` struct uses a map to store adjacency lists.\n- `AddEdge` adds an edge between two nodes. For undirected graphs, both directions are added.\n- `Print` displays the adjacency list for each node.\n\nYou can modify this structure for directed graphs, weighted graphs, or use custom types for nodes as needed.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998977Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "3555e524-d3ce-4630-ae06-aa8cfa3ccf7c",
    "question": "How do you implement a priority queue in Go?",
    "answer": "```markdown\n## How do you implement a priority queue in Go?\n\nIn Go, a priority queue can be implemented using the `container/heap` package, which provides heap operations for any type that implements the `heap.Interface`. Below is an example of how to implement a min-priority queue (where the smallest item has the highest priority):\n\n### Step 1: Define the Item and PriorityQueue Types\n\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\n// Item is something we manage in a priority queue.\ntype Item struct {\n    value    string // The value of the item; arbitrary.\n    priority int    // The priority of the item in the queue.\n    index    int    // The index of the item in the heap.\n}\n\n// PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    // We want Pop to give us the lowest priority so we use less than here.\n    return pq[i].priority < pq[j].priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n    pq[i].index = i\n    pq[j].index = j\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    n := len(*pq)\n    item := x.(*Item)\n    item.index = n\n    *pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    old[n-1] = nil  // avoid memory leak\n    item.index = -1 // for safety\n    *pq = old[0 : n-1]\n    return item\n}\n```\n\n### Step 2: Using the Priority Queue\n\n```go\nfunc main() {\n    // Some items and their priorities.\n    items := map[string]int{\n        \"banana\": 3, \"apple\": 2, \"pear\": 4,\n    }\n\n    // Create a priority queue, put the items in it, and establish the heap invariants.\n    pq := make(PriorityQueue, 0)\n    heap.Init(&pq)\n    for value, priority := range items {\n        heap.Push(&pq, &Item{\n            value:    value,\n            priority: priority,\n        })\n    }\n\n    // Insert a new item and then modify its priority.\n    item := &Item{\n        value:    \"orange\",\n        priority: 1,\n    }\n    heap.Push(&pq, item)\n\n    // Remove items in priority order.\n    for pq.Len() > 0 {\n        item := heap.Pop(&pq).(*Item)\n        fmt.Printf(\"%s (priority: %d)\\n\", item.value, item.priority)\n    }\n}\n```\n\n### Output\n\n```\norange (priority: 1)\napple (priority: 2)\nbanana (priority: 3)\npear (priority: 4)\n```\n\n### Notes\n\n- The `container/heap` package requires you to implement the `heap.Interface` methods (`Len`, `Less`, `Swap`, `Push`, and `Pop`).\n- You can adapt the `Less` method for a max-priority queue by reversing the comparison.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998984Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "728b836f-ecb4-4397-9603-d91d41224069",
    "question": "How do you find the shortest path in an unweighted graph using BFS in Go?",
    "answer": "```markdown\n### How do you find the shortest path in an unweighted graph using BFS in Go?\n\nTo find the shortest path in an unweighted graph, you can use Breadth-First Search (BFS). BFS explores nodes in layers, ensuring that the first time you reach a node, it's via the shortest path. You can also keep track of the path by maintaining a predecessor map.\n\nHere's a Go implementation that finds the shortest path between two nodes in an unweighted graph:\n\n```go\npackage main\n\nimport (\n    \"container/list\"\n    \"fmt\"\n)\n\n// Graph represented as an adjacency list\ntype Graph map[int][]int\n\n// BFSShortestPath finds the shortest path from start to end in an unweighted graph\nfunc BFSShortestPath(graph Graph, start, end int) []int {\n    visited := make(map[int]bool)\n    prev := make(map[int]int)\n    queue := list.New()\n\n    visited[start] = true\n    queue.PushBack(start)\n\n    for queue.Len() > 0 {\n        node := queue.Remove(queue.Front()).(int)\n        if node == end {\n            break\n        }\n        for _, neighbor := range graph[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true\n                prev[neighbor] = node\n                queue.PushBack(neighbor)\n            }\n        }\n    }\n\n    // Reconstruct path\n    path := []int{}\n    at := end\n    for {\n        path = append([]int{at}, path...)\n        if at == start {\n            break\n        }\n        p, ok := prev[at]\n        if !ok {\n            return nil // No path found\n        }\n        at = p\n    }\n    return path\n}\n\nfunc main() {\n    // Example graph\n    graph := Graph{\n        1: {2, 3},\n        2: {1, 4, 5},\n        3: {1, 6},\n        4: {2},\n        5: {2, 6},\n        6: {3, 5},\n    }\n    start, end := 1, 6\n    path := BFSShortestPath(graph, start, end)\n    if path != nil {\n        fmt.Printf(\"Shortest path from %d to %d: %v\\n\", start, end, path)\n    } else {\n        fmt.Printf(\"No path found from %d to %d\\n\", start, end)\n    }\n}\n```\n\n**Explanation:**\n- The graph is represented as an adjacency list.\n- BFS is performed using a queue.\n- A `prev` map is used to reconstruct the path once the end node is reached.\n- The path is reconstructed by backtracking from the end node to the start node.\n\n**Output:**\n```\nShortest path from 1 to 6: [1 3 6]\n```\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.998992Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "f13c75ed-3b0b-4223-b38a-485b19823294",
    "question": "How do you implement a circular queue in Go?",
    "answer": "```markdown\n## How do you implement a circular queue in Go?\n\nA **circular queue** is a linear data structure that follows the FIFO (First In First Out) principle, but connects the end of the queue back to the front, forming a circle. This allows efficient utilization of space by reusing vacated slots.\n\nBelow is an implementation of a circular queue in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\ntype CircularQueue struct {\n    data        []int\n    front, rear int\n    size, cap   int\n}\n\n// Constructor to initialize the queue\nfunc NewCircularQueue(capacity int) *CircularQueue {\n    return &CircularQueue{\n        data:  make([]int, capacity),\n        front: 0,\n        rear:  0,\n        size:  0,\n        cap:   capacity,\n    }\n}\n\n// Enqueue adds an element to the queue\nfunc (q *CircularQueue) Enqueue(val int) error {\n    if q.IsFull() {\n        return errors.New(\"queue is full\")\n    }\n    q.data[q.rear] = val\n    q.rear = (q.rear + 1) % q.cap\n    q.size++\n    return nil\n}\n\n// Dequeue removes and returns the front element\nfunc (q *CircularQueue) Dequeue() (int, error) {\n    if q.IsEmpty() {\n        return 0, errors.New(\"queue is empty\")\n    }\n    val := q.data[q.front]\n    q.front = (q.front + 1) % q.cap\n    q.size--\n    return val, nil\n}\n\n// IsEmpty checks if the queue is empty\nfunc (q *CircularQueue) IsEmpty() bool {\n    return q.size == 0\n}\n\n// IsFull checks if the queue is full\nfunc (q *CircularQueue) IsFull() bool {\n    return q.size == q.cap\n}\n\n// Front returns the front element without removing it\nfunc (q *CircularQueue) Front() (int, error) {\n    if q.IsEmpty() {\n        return 0, errors.New(\"queue is empty\")\n    }\n    return q.data[q.front], nil\n}\n\n// Rear returns the last element without removing it\nfunc (q *CircularQueue) Rear() (int, error) {\n    if q.IsEmpty() {\n        return 0, errors.New(\"queue is empty\")\n    }\n    // (rear - 1 + cap) % cap handles wrap-around\n    idx := (q.rear - 1 + q.cap) % q.cap\n    return q.data[idx], nil\n}\n\nfunc main() {\n    q := NewCircularQueue(3)\n    fmt.Println(q.Enqueue(1)) // nil\n    fmt.Println(q.Enqueue(2)) // nil\n    fmt.Println(q.Enqueue(3)) // nil\n    fmt.Println(q.Enqueue(4)) // queue is full\n\n    fmt.Println(q.Dequeue()) // 1, nil\n    fmt.Println(q.Enqueue(4)) // nil\n\n    fmt.Println(q.Front()) // 2, nil\n    fmt.Println(q.Rear())  // 4, nil\n}\n```\n\n**Explanation:**\n- The queue uses a fixed-size slice.\n- `front` and `rear` pointers are updated using modulo arithmetic to wrap around.\n- `size` tracks the number of elements to distinguish between full and empty states.\n- Enqueue and Dequeue operations are O(1).\n\nThis implementation efficiently utilizes the allocated space and provides all standard queue operations.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999004Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "6a061d69-c5ad-4928-ae67-404017515aff",
    "question": "How do you find the median of two sorted arrays in Go?",
    "answer": "```markdown\n### How do you find the median of two sorted arrays in Go?\n\nTo find the median of two sorted arrays, you can use a binary search approach to achieve O(log(min(m, n))) time complexity, where `m` and `n` are the lengths of the two arrays. The idea is to partition the arrays such that the left part contains the same number of elements as the right part, and all elements in the left part are less than or equal to those in the right part.\n\nHere's a Go implementation:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc findMedianSortedArrays(nums1 []int, nums2 []int) float64 {\n\t// Ensure nums1 is the smaller array\n\tif len(nums1) > len(nums2) {\n\t\treturn findMedianSortedArrays(nums2, nums1)\n\t}\n\tm, n := len(nums1), len(nums2)\n\timin, imax, halfLen := 0, m, (m+n+1)/2\n\n\tfor imin <= imax {\n\t\ti := (imin + imax) / 2\n\t\tj := halfLen - i\n\n\t\tif i < m && nums2[j-1] > nums1[i] {\n\t\t\timin = i + 1 // i is too small\n\t\t} else if i > 0 && nums1[i-1] > nums2[j] {\n\t\t\timax = i - 1 // i is too big\n\t\t} else { // i is perfect\n\t\t\tvar maxOfLeft int\n\t\t\tif i == 0 {\n\t\t\t\tmaxOfLeft = nums2[j-1]\n\t\t\t} else if j == 0 {\n\t\t\t\tmaxOfLeft = nums1[i-1]\n\t\t\t} else {\n\t\t\t\tmaxOfLeft = int(math.Max(float64(nums1[i-1]), float64(nums2[j-1])))\n\t\t\t}\n\n\t\t\tif (m+n)%2 == 1 {\n\t\t\t\treturn float64(maxOfLeft)\n\t\t\t}\n\n\t\t\tvar minOfRight int\n\t\t\tif i == m {\n\t\t\t\tminOfRight = nums2[j]\n\t\t\t} else if j == n {\n\t\t\t\tminOfRight = nums1[i]\n\t\t\t} else {\n\t\t\t\tminOfRight = int(math.Min(float64(nums1[i]), float64(nums2[j])))\n\t\t\t}\n\n\t\t\treturn float64(maxOfLeft+minOfRight) / 2.0\n\t\t}\n\t}\n\treturn 0.0\n}\n\nfunc main() {\n\tnums1 := []int{1, 3}\n\tnums2 := []int{2}\n\tfmt.Println(findMedianSortedArrays(nums1, nums2)) // Output: 2\n\n\tnums1 = []int{1, 2}\n\tnums2 = []int{3, 4}\n\tfmt.Println(findMedianSortedArrays(nums1, nums2)) // Output: 2.5\n}\n```\n\n**Explanation:**\n- The function uses binary search on the smaller array to find a partition such that the left and right halves of the combined arrays are balanced.\n- It handles both even and odd total lengths.\n- The median is either the maximum of the left elements (for odd total length) or the average of the maximum of the left and the minimum of the right (for even total length).\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.999016Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "2425d271-d68a-40e9-b0b7-f875400e1df7",
    "question": "How do you implement a concurrent-safe map in Go?",
    "answer": "```markdown\n### How do you implement a concurrent-safe map in Go?\n\nIn Go, the built-in `map` type is **not safe for concurrent use**. To implement a concurrent-safe map, you have several options:\n\n#### 1. Using `sync.Map`\n\nGo's standard library provides `sync.Map`, which is designed for concurrent use without explicit locking.\n\n```go\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var m sync.Map\n\n    // Store a value\n    m.Store(\"foo\", 42)\n\n    // Load a value\n    if value, ok := m.Load(\"foo\"); ok {\n        fmt.Println(\"Found:\", value)\n    }\n\n    // Delete a value\n    m.Delete(\"foo\")\n}\n```\n\n#### 2. Using `sync.RWMutex` with a Regular Map\n\nFor more control (e.g., custom logic), you can wrap a regular map with a `sync.RWMutex`:\n\n```go\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\ntype SafeMap struct {\n    mu sync.RWMutex\n    m  map[string]int\n}\n\nfunc NewSafeMap() *SafeMap {\n    return &SafeMap{\n        m: make(map[string]int),\n    }\n}\n\nfunc (s *SafeMap) Get(key string) (int, bool) {\n    s.mu.RLock()\n    defer s.mu.RUnlock()\n    val, ok := s.m[key]\n    return val, ok\n}\n\nfunc (s *SafeMap) Set(key string, value int) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    s.m[key] = value\n}\n\nfunc (s *SafeMap) Delete(key string) {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    delete(s.m, key)\n}\n\nfunc main() {\n    sm := NewSafeMap()\n    sm.Set(\"foo\", 42)\n    if val, ok := sm.Get(\"foo\"); ok {\n        fmt.Println(\"Found:\", val)\n    }\n    sm.Delete(\"foo\")\n}\n```\n\n#### Summary\n\n- Use `sync.Map` for simple concurrent maps.\n- Use a map protected by `sync.RWMutex` for more flexibility or custom logic.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.999028Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "c472af58-6538-4b5a-a6c3-863fb4fa6766",
    "question": "How do you implement the producer-consumer problem using channels in Go?",
    "answer": "```markdown\n### Producer-Consumer Problem Using Channels in Go\n\nThe **producer-consumer problem** is a classic example of a multi-process synchronization problem. In Go, channels provide a simple and powerful way to solve this problem by allowing safe communication between goroutines.\n\nBelow is an example implementation where:\n- The **producer** generates integers and sends them to a buffered channel.\n- The **consumer** receives integers from the channel and processes them.\n- The channel is closed by the producer to signal completion.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// Producer function\nfunc producer(ch chan<- int, count int) {\n    for i := 1; i <= count; i++ {\n        fmt.Printf(\"Producing: %d\\n\", i)\n        ch <- i // Send data to channel\n        time.Sleep(time.Millisecond * 500) // Simulate work\n    }\n    close(ch) // Close channel when done\n}\n\n// Consumer function\nfunc consumer(ch <-chan int, done chan<- bool) {\n    for item := range ch { // Receives until channel is closed\n        fmt.Printf(\"Consuming: %d\\n\", item)\n        time.Sleep(time.Millisecond * 800) // Simulate work\n    }\n    done <- true // Signal completion\n}\n\nfunc main() {\n    ch := make(chan int, 5) // Buffered channel\n    done := make(chan bool)\n\n    go producer(ch, 10)\n    go consumer(ch, done)\n\n    <-done // Wait for consumer to finish\n    fmt.Println(\"All items produced and consumed.\")\n}\n```\n\n#### Key Points:\n- **Buffered channels** help decouple producer and consumer speeds.\n- The producer closes the channel to indicate no more items will be sent.\n- The consumer uses `range` to receive until the channel is closed.\n- A `done` channel is used to signal the main goroutine when processing is complete.\n\nThis approach leverages Go's concurrency primitives for a clean and safe solution to the producer-consumer problem.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:47.999040Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "12c679ae-e8d7-4c18-bf31-e86959d8e0a5",
    "question": "How do you find all permutations of a string in Go?",
    "answer": "```markdown\n## How do you find all permutations of a string in Go?\n\nTo find all permutations of a string in Go, you can use a recursive approach. The idea is to fix each character at the current position and recursively generate all permutations for the remaining characters.\n\nHere's a sample implementation:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// Helper function to swap characters in a slice\nfunc swap(s []rune, i, j int) {\n\ts[i], s[j] = s[j], s[i]\n}\n\n// Recursive function to generate permutations\nfunc permute(s []rune, l, r int, result *[]string) {\n\tif l == r {\n\t\t*result = append(*result, string(s))\n\t} else {\n\t\tfor i := l; i <= r; i++ {\n\t\t\tswap(s, l, i)\n\t\t\tpermute(s, l+1, r, result)\n\t\t\tswap(s, l, i) // backtrack\n\t\t}\n\t}\n}\n\n// Function to return all permutations of a string\nfunc getPermutations(str string) []string {\n\tvar result []string\n\ts := []rune(str)\n\tpermute(s, 0, len(s)-1, &result)\n\treturn result\n}\n\nfunc main() {\n\tstr := \"abc\"\n\tperms := getPermutations(str)\n\tfmt.Println(\"Permutations of\", str, \":\")\n\tfor _, p := range perms {\n\t\tfmt.Println(p)\n\t}\n}\n```\n\n### Output\n```\nPermutations of abc :\nabc\nacb\nbac\nbca\ncba\ncab\n```\n\n**Explanation:**\n- The `permute` function recursively generates all permutations by swapping characters.\n- The `swap` function exchanges two characters in the slice.\n- The `getPermutations` function initializes the process and collects results.\n\nThis approach ensures all possible orderings of the input string are generated.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999066Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "3ef10fd6-d11b-4b2e-867e-d511f5c037a4",
    "question": "How do you implement memoization for recursive algorithms in Go?",
    "answer": "```markdown Certainly! Here’s an explanation and example of implementing memoization for recursive algorithms in Go.\n\n---\n\n## How to Implement Memoization for Recursive Algorithms in Go\n\nMemoization is a technique to optimize recursive algorithms by storing the results of expensive function calls and returning the cached result when the same inputs occur again.\n\n### Steps:\n\n1. **Create a cache (map) to store results.**\n2. **Before computing, check if the result is already in the cache.**\n3. **If not, compute and store the result in the cache.**\n4. **Return the cached result.**\n\n### Example: Fibonacci with Memoization\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// fibMemo is a helper function that takes the number n and a memoization map.\nfunc fibMemo(n int, memo map[int]int) int {\n    if n <= 1 {\n        return n\n    }\n    // Check if result is already in the memo\n    if val, exists := memo[n]; exists {\n        return val\n    }\n    // Compute and store in memo\n    memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo)\n    return memo[n]\n}\n\nfunc main() {\n    n := 10\n    memo := make(map[int]int)\n    fmt.Printf(\"Fibonacci(%d) = %d\\n\", n, fibMemo(n, memo))\n}\n```\n\n### Output\n\n```\nFibonacci(10) = 55\n```\n\n### Key Points\n\n- The `memo` map stores previously computed Fibonacci numbers.\n- Before each recursive call, the function checks if the value is already computed.\n- This approach reduces the time complexity from exponential to linear for Fibonacci.\n\n---\n\nYou can apply this memoization pattern to other recursive problems in Go by using a map to cache results based on input parameters.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999078Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "37c5ff0e-1e23-4508-8de6-0553cbc964e8",
    "question": "How do you implement a doubly linked list in Go?",
    "answer": "```markdown\n## How do you implement a doubly linked list in Go?\n\nA doubly linked list is a data structure where each node contains a value and pointers to both the next and previous nodes. This allows traversal in both directions.\n\nBelow is a simple implementation of a doubly linked list in Go:\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Node represents a node in the doubly linked list\ntype Node struct {\n    value int\n    prev  *Node\n    next  *Node\n}\n\n// DoublyLinkedList represents the linked list\ntype DoublyLinkedList struct {\n    head *Node\n    tail *Node\n}\n\n// InsertAtEnd adds a new node at the end of the list\nfunc (dll *DoublyLinkedList) InsertAtEnd(value int) {\n    newNode := &Node{value: value}\n    if dll.head == nil {\n        dll.head = newNode\n        dll.tail = newNode\n        return\n    }\n    dll.tail.next = newNode\n    newNode.prev = dll.tail\n    dll.tail = newNode\n}\n\n// Delete removes the first node with the given value\nfunc (dll *DoublyLinkedList) Delete(value int) {\n    current := dll.head\n    for current != nil {\n        if current.value == value {\n            if current.prev != nil {\n                current.prev.next = current.next\n            } else {\n                dll.head = current.next\n            }\n            if current.next != nil {\n                current.next.prev = current.prev\n            } else {\n                dll.tail = current.prev\n            }\n            return\n        }\n        current = current.next\n    }\n}\n\n// Display prints the list from head to tail\nfunc (dll *DoublyLinkedList) Display() {\n    current := dll.head\n    for current != nil {\n        fmt.Print(current.value, \" \")\n        current = current.next\n    }\n    fmt.Println()\n}\n\nfunc main() {\n    dll := &DoublyLinkedList{}\n    dll.InsertAtEnd(1)\n    dll.InsertAtEnd(2)\n    dll.InsertAtEnd(3)\n    dll.Display() // Output: 1 2 3\n\n    dll.Delete(2)\n    dll.Display() // Output: 1 3\n}\n```\n\n**Explanation:**\n- Each `Node` has a `value`, a pointer to the previous node (`prev`), and a pointer to the next node (`next`).\n- The `DoublyLinkedList` struct keeps track of the `head` and `tail`.\n- `InsertAtEnd` adds a new node at the end.\n- `Delete` removes the first node with the given value.\n- `Display` prints the list from head to tail.\n\nThis is a basic implementation; you can add more methods as needed (like insertion at the beginning, reverse traversal, etc.).\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:47.999091Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "eeeafc0d-7301-42a5-bf94-201706b6bac2",
    "question": "How do you implement the Sieve of Eratosthenes to find prime numbers in Go?",
    "answer": "```markdown\n### How do you implement the Sieve of Eratosthenes to find prime numbers in Go?\n\nThe Sieve of Eratosthenes is an efficient algorithm to find all prime numbers up to a given number `n`. It works by iteratively marking the multiples of each prime number starting from 2.\n\nHere's how you can implement it in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// SieveOfEratosthenes returns a slice of all prime numbers up to n\nfunc SieveOfEratosthenes(n int) []int {\n    if n < 2 {\n        return []int{}\n    }\n\n    // Create a boolean slice to track prime numbers\n    isPrime := make([]bool, n+1)\n    for i := 2; i <= n; i++ {\n        isPrime[i] = true\n    }\n\n    for i := 2; i*i <= n; i++ {\n        if isPrime[i] {\n            for j := i * i; j <= n; j += i {\n                isPrime[j] = false\n            }\n        }\n    }\n\n    // Collect all prime numbers\n    primes := []int{}\n    for i := 2; i <= n; i++ {\n        if isPrime[i] {\n            primes = append(primes, i)\n        }\n    }\n    return primes\n}\n\nfunc main() {\n    n := 30\n    primes := SieveOfEratosthenes(n)\n    fmt.Println(\"Prime numbers up to\", n, \":\", primes)\n}\n```\n\n**Output:**\n```\nPrime numbers up to 30 : [2 3 5 7 11 13 17 19 23 29]\n```\n\n**Explanation:**\n- We create a boolean slice `isPrime` to keep track of which numbers are prime.\n- We initialize all entries as `true` (except 0 and 1).\n- For each number `i` starting from 2, if it's marked as prime, we mark all its multiples as not prime.\n- Finally, we collect all numbers that are still marked as prime.\n\nThis algorithm has a time complexity of O(n log log n).\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:47.999104Z",
    "topic": "ad898ac4-4b4f-4708-aa5c-fe48de29104a"
  },
  {
    "id": "40c0de51-89dd-42fd-aa0f-87d875704b5d",
    "question": "What is a sorting algorithm?",
    "answer": "```markdown A **sorting algorithm** is a method or process used to arrange elements in a list or array in a specific order, such as ascending or descending. Sorting makes it easier to search, analyze, and visualize data. Common sorting algorithms include Bubble Sort, Selection Sort, Insertion Sort, Merge Sort, and Quick Sort.\n\nIn Go, you can implement sorting algorithms manually or use the built-in sort package, which provides efficient sorting functions for slices of basic types.\n\n**Example:** Sorting an integer slice in ascending order using the sort package in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    numbers := []int{5, 2, 9, 1, 5, 6}\n    sort.Ints(numbers)\n    fmt.Println(numbers) // Output: [1 2 5 5 6 9]\n}\n```\n\nSorting algorithms are fundamental in computer science and are widely used in various applications.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449684Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "ea67d6be-3e51-41d2-b78c-fabc948ab9d6",
    "question": "Name at least three common sorting algorithms.",
    "answer": "```markdown **Answer:**\n\nHere are three common sorting algorithms:\n\n1. **Bubble Sort**\n2. **Selection Sort**\n3. **Insertion Sort**\n\nThese algorithms are often used for educational purposes and are easy to implement in Go and other programming languages.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449710Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "aef3e28e-99b0-473a-84e9-4dd46041c301",
    "question": "How do you sort a slice of integers in Go using the standard library?",
    "answer": "```markdown To sort a slice of integers in Go using the standard library, you can use the sort package. Specifically, use sort.Ints, which sorts a slice of ints in increasing order.\n\nHere's an example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    nums := []int{5, 2, 9, 1, 5, 6}\n    sort.Ints(nums)\n    fmt.Println(nums) // Output: [1 2 5 5 6 9]\n}\n```\n\n**Explanation:**\n- Import the sort package.\n- Call sort.Ints(slice) to sort the slice in place.\n- The original slice is modified to be in ascending order.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449724Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "fe320306-9cd8-4413-86ad-3cc671cf9f31",
    "question": "What package in Go provides sorting utilities?",
    "answer": "```markdown The sort package in Go provides sorting utilities. You can import it using:\n\n```go\nimport \"sort\"\n```\n\nThis package offers functions to sort slices of built-in types (like int, float64, and string) and also allows custom sorting by implementing the sort.Interface.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449749Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "20232831-7b4e-4499-9007-67e5a07cf7f8",
    "question": "What is the difference between stable and unstable sorting algorithms?",
    "answer": "```markdown **Difference Between Stable and Unstable Sorting Algorithms**\n\n- **Stable Sorting Algorithm:**  \n  A sorting algorithm is called *stable* if it preserves the relative order of elements with equal keys (values). That means, if two items are equal, they will appear in the same order in the sorted output as they did in the input.\n\n  **Example:**  \n  If you sort the following list of pairs by the first value:  \n  ```\n  [(2, 'a'), (1, 'b'), (2, 'c')]\n  ```\n  After stable sorting, the order of `(2, 'a')` and `(2, 'c')` will remain the same.\n\n- **Unstable Sorting Algorithm:**  \n  An *unstable* sorting algorithm does **not** guarantee to preserve the relative order of equal elements. The order of equal items may change after sorting.\n\n  **Example:**  \n  Sorting the same list above with an unstable algorithm could result in:  \n  ```\n  [(1, 'b'), (2, 'c'), (2, 'a')]\n  ```\n  Here, the order of `(2, 'a')` and `(2, 'c')` is not preserved.\n\n---\n\n**In Go:**  \n- The `sort.Stable` function in Go uses a stable sorting algorithm.\n- The `sort.Sort` function may use an unstable sorting algorithm, depending on the implementation.\n\n**Summary Table:**\n\n| Property      | Stable Sort         | Unstable Sort        |\n|---------------|--------------------|----------------------|\n| Order of equal elements | Preserved           | Not preserved         |\n| Example in Go | `sort.Stable`      | `sort.Sort`          |",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449761Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "40cb2cd1-3432-4533-a600-cd9753d38d48",
    "question": "How do you sort a slice of strings in Go?",
    "answer": "```markdown To sort a slice of strings in Go, you can use the sort package from the standard library. The sort.Strings function sorts a slice of strings in increasing order (lexicographically).\n\nHere's an example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    names := []string{\"Charlie\", \"Alice\", \"Bob\"}\n    sort.Strings(names)\n    fmt.Println(names) // Output: [Alice Bob Charlie]\n}\n```\n\n**Explanation:**\n- Import the sort package.\n- Call sort.Strings(yourSlice) to sort the slice in place.\n- The original slice is modified to be in sorted order.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449772Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "a3a48222-3221-464a-b99c-4dbfd6a25896",
    "question": "What is the time complexity of Bubble Sort?",
    "answer": "```markdown **Bubble Sort** has a time complexity of:\n\n- **Best Case:** O(n) (when the array is already sorted)\n- **Average Case:** O(n²)\n- **Worst Case:** O(n²)\n\nBubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted, which leads to its quadratic time complexity in most cases.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449784Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "41d1e917-a75d-499b-a9a8-ee0c63c8ff8b",
    "question": "How do you implement Bubble Sort in Go?",
    "answer": "```markdown Certainly! Here’s how you can implement Bubble Sort in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc bubbleSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        for j := 0; j < n-i-1; j++ {\n            if arr[j] > arr[j+1] {\n                // Swap arr[j] and arr[j+1]\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n}\n\nfunc main() {\n    nums := []int{5, 2, 9, 1, 5, 6}\n    fmt.Println(\"Before sorting:\", nums)\n    bubbleSort(nums)\n    fmt.Println(\"After sorting: \", nums)\n}\n```\n\n**Explanation:**\n- The function `bubbleSort` takes a slice of integers and sorts it in ascending order.\n- It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.\n- This process is repeated until the list is sorted.\n\n**Output:**\n```\nBefore sorting: [5 2 9 1 5 6]\nAfter sorting:  [1 2 5 5 6 9]\n```",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449796Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "2edb21dc-aa5b-4b80-871e-bd5bb2f820cb",
    "question": "What is the time complexity of Insertion Sort?",
    "answer": "```markdown **Answer:**\n\nThe time complexity of Insertion Sort is:\n\n- **Best Case:** O(n) &nbsp;*(when the array is already sorted)*\n- **Average Case:** O(n²)\n- **Worst Case:** O(n²) &nbsp;*(when the array is sorted in reverse order)*\n\nWhere **n** is the number of elements in the array.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449815Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "a1dc2a48-d734-4e12-9151-fa7f49a04c44",
    "question": "How do you implement Selection Sort in Go?",
    "answer": "```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// selectionSort sorts an integer slice using the Selection Sort algorithm.\nfunc selectionSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        minIdx := i\n        // Find the minimum element in the unsorted part\n        for j := i + 1; j < n; j++ {\n            if arr[j] < arr[minIdx] {\n                minIdx = j\n            }\n        }\n        // Swap the found minimum element with the first element\n        arr[i], arr[minIdx] = arr[minIdx], arr[i]\n    }\n}\n\nfunc main() {\n    arr := []int{64, 25, 12, 22, 11}\n    fmt.Println(\"Original array:\", arr)\n    selectionSort(arr)\n    fmt.Println(\"Sorted array:  \", arr)\n}\n```\n\n**Explanation:**\n- The selectionSort function iterates through the array, finds the minimum element in the unsorted part, and swaps it with the first unsorted element.\n- This process repeats until the array is sorted.\n- The main function demonstrates sorting an example array.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449834Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "c054190a-ceba-4969-9ab4-69b4ed21817a",
    "question": "What is the difference between Insertion Sort and Selection Sort?",
    "answer": "```markdown **Difference between Insertion Sort and Selection Sort in Go**\n\n| Aspect            | Insertion Sort                                                                 | Selection Sort                                                                 |\n|-------------------|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------|\n| **How it works**  | Builds the sorted array one element at a time by inserting each item into its correct position. | Repeatedly selects the smallest (or largest) element from the unsorted part and swaps it with the first unsorted element. |\n| **Stability**     | Stable (does not change the relative order of equal elements)                  | Unstable (may change the relative order of equal elements)                    |\n| **Best Case Time**| O(n) (when the array is already sorted)                                        | O(n²)                                                                         |\n| **Worst Case Time**| O(n²)                                                                         | O(n²)                                                                         |\n| **Number of Swaps**| Can be up to O(n²), but usually fewer than Selection Sort                     | Always O(n) swaps (one per pass)                                              |\n| **Use Case**      | Efficient for small or nearly sorted arrays                                    | Simple to implement, but not efficient for large datasets                     |\n\n**Example in Go:**\n\n```go\n// Insertion Sort\nfunc insertionSort(arr []int) {\n    for i := 1; i < len(arr); i++ {\n        key := arr[i]\n        j := i - 1\n        for j >= 0 && arr[j] > key {\n            arr[j+1] = arr[j]\n            j--\n        }\n        arr[j+1] = key\n    }\n}\n\n// Selection Sort\nfunc selectionSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n-1; i++ {\n        minIdx := i\n        for j := i + 1; j < n; j++ {\n            if arr[j] < arr[minIdx] {\n                minIdx = j\n            }\n        }\n        arr[i], arr[minIdx] = arr[minIdx], arr[i]\n    }\n}\n```\n\n**Summary:**  \n- Insertion Sort is better for nearly sorted arrays and is stable.\n- Selection Sort is simple but less efficient and not stable.",
    "level": "Beginner",
    "created_at": "2025-04-21T12:16:44.449845Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "4973b313-5711-47a5-8bac-9236472c7f6e",
    "question": "How do you sort a slice of structs by a specific field in Go?",
    "answer": "```markdown To sort a slice of structs by a specific field in Go, you can use the sort.Slice function from the sort package. You provide the slice and a less function that defines the sorting logic based on the struct field.\n\nHere's an example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    people := []Person{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 35},\n    }\n\n    // Sort by Age (ascending)\n    sort.Slice(people, func(i, j int) bool {\n        return people[i].Age < people[j].Age\n    })\n\n    fmt.Println(\"Sorted by Age:\", people)\n\n    // Sort by Name (alphabetically)\n    sort.Slice(people, func(i, j int) bool {\n        return people[i].Name < people[j].Name\n    })\n\n    fmt.Println(\"Sorted by Name:\", people)\n}\n```\n\n**Explanation:**\n\n- `sort.Slice` takes the slice and a comparison function.\n- The comparison function returns true if the element at index `i` should come before the element at index `j`.\n- You can customize the comparison logic to sort by any field (e.g., `Age`, `Name`).\n\n**Output:**\n```\nSorted by Age: [{Bob 25} {Alice 30} {Charlie 35}]\nSorted by Name: [{Alice 30} {Bob 25} {Charlie 35}]\n```\n\nThis approach is flexible and idiomatic for sorting slices of structs in Go.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449863Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "891886d6-7f5f-48d9-8134-e7ec6e351190",
    "question": "Explain how the sort.Interface works in Go.",
    "answer": "```markdown Certainly! Here’s an explanation in markdown format:\n\n---\n\n## How `sort.Interface` Works in Go\n\nGo’s standard library provides a flexible way to sort slices of any type using the `sort.Interface`. This interface allows you to define custom sorting logic for your data structures.\n\n### The `sort.Interface`\n\nTo use Go’s sorting facilities, a type must implement the following three methods:\n\n```go\ntype Interface interface {\n    Len() int           // returns the number of elements\n    Less(i, j int) bool // reports whether element i should sort before element j\n    Swap(i, j int)      // swaps the elements with indexes i and j\n}\n```\n\n### How It Works\n\n1. **Len()**: Returns the length of the collection.\n2. **Less(i, j int) bool**: Returns `true` if the element at index `i` should come before the element at index `j`.\n3. **Swap(i, j int)**: Swaps the elements at indices `i` and `j`.\n\nOnce your type implements these methods, you can sort it using `sort.Sort()`:\n\n```go\nsort.Sort(yourType)\n```\n\n### Example\n\nSuppose you have a slice of structs:\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n```\n\nYou can now sort a slice of `Person` by age:\n\n```go\npeople := []Person{\n    {\"Alice\", 30},\n    {\"Bob\", 25},\n    {\"Charlie\", 35},\n}\n\nsort.Sort(ByAge(people))\n```\n\n### Summary\n\n- Implement `Len()`, `Less(i, j int)`, and `Swap(i, j int)` for your type.\n- Use `sort.Sort()` to sort your collection.\n- This approach allows sorting of any data structure, not just basic types.\n\n---",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449875Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "ee70f1a8-19a5-4946-bd81-7d2f1f33c187",
    "question": "How do you implement Merge Sort in Go?",
    "answer": "```markdown Certainly! Here’s how you can implement Merge Sort in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// merge merges two sorted slices into one sorted slice\nfunc merge(left, right []int) []int {\n    result := make([]int, 0, len(left)+len(right))\n    i, j := 0, 0\n\n    for i < len(left) && j < len(right) {\n        if left[i] < right[j] {\n            result = append(result, left[i])\n            i++\n        } else {\n            result = append(result, right[j])\n            j++\n        }\n    }\n\n    // Append remaining elements (if any)\n    result = append(result, left[i:]...)\n    result = append(result, right[j:]...)\n\n    return result\n}\n\n// mergeSort recursively sorts the slice using merge sort algorithm\nfunc mergeSort(arr []int) []int {\n    if len(arr) <= 1 {\n        return arr\n    }\n\n    mid := len(arr) / 2\n    left := mergeSort(arr[:mid])\n    right := mergeSort(arr[mid:])\n\n    return merge(left, right)\n}\n\nfunc main() {\n    arr := []int{38, 27, 43, 3, 9, 82, 10}\n    sorted := mergeSort(arr)\n    fmt.Println(\"Sorted array:\", sorted)\n}\n```\n\n**Explanation:**\n\n- The `mergeSort` function recursively splits the array into halves until each subarray has one element.\n- The `merge` function combines two sorted slices into a single sorted slice.\n- In `main`, you can test the function with an example array.\n\n**Output:**\n```\nSorted array: [3 9 10 27 38 43 82]\n```\n\nThis is a classic implementation of Merge Sort in Go.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449886Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "ec4f3f5e-735d-44da-a07c-dd7ba2bef73b",
    "question": "What is the time complexity of Merge Sort?",
    "answer": "```markdown **Merge Sort** is a divide-and-conquer sorting algorithm. Its time complexity is:\n\n- **Best Case:** O(n log n)\n- **Average Case:** O(n log n)\n- **Worst Case:** O(n log n)\n\nWhere **n** is the number of elements to be sorted.\n\n**Explanation:**  \nMerge Sort recursively divides the array into halves (log n levels), and at each level, it merges all elements (n operations per level). Thus, the total time complexity is **O(n log n)**.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449898Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "4ba2c72b-8a37-4092-9323-534928ac9061",
    "question": "How does Quick Sort work?",
    "answer": "```markdown **Quick Sort in Go: How It Works**\n\nQuick Sort is a popular divide-and-conquer sorting algorithm. It works by selecting a \"pivot\" element from the array and partitioning the other elements into two sub-arrays: those less than the pivot and those greater than the pivot. The process is then recursively applied to the sub-arrays.\n\n### Steps of Quick Sort\n\n1. **Choose a Pivot:** Select an element from the array as the pivot (commonly the first, last, or a random element).\n2. **Partitioning:** Rearrange the array so that all elements less than the pivot come before it, and all elements greater come after it.\n3. **Recursion:** Recursively apply the above steps to the sub-arrays of elements with smaller and larger values.\n\n### Example in Go\n\n```go\nfunc quickSort(arr []int) []int {\n    if len(arr) < 2 {\n        return arr\n    }\n    left, right := 0, len(arr)-1\n\n    // Choose the pivot\n    pivot := rand.Int() % len(arr)\n\n    // Move the pivot to the right\n    arr[pivot], arr[right] = arr[right], arr[pivot]\n\n    // Partitioning\n    for i := range arr {\n        if arr[i] < arr[right] {\n            arr[i], arr[left] = arr[left], arr[i]\n            left++\n        }\n    }\n\n    // Move pivot to its final place\n    arr[left], arr[right] = arr[right], arr[left]\n\n    // Recursively sort left and right subarrays\n    quickSort(arr[:left])\n    quickSort(arr[left+1:])\n\n    return arr\n}\n```\n\n### Key Points\n\n- **Time Complexity:** Average case is O(n log n), but worst case is O(n²) (rare with good pivot selection).\n- **In-place:** Quick Sort sorts the array in place, requiring little extra memory.\n- **Not Stable:** The relative order of equal elements may not be preserved.\n\nQuick Sort is efficient for large datasets and is widely used in practice due to its speed and simplicity.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449914Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "621622e4-d553-43f8-a94a-23c23e99d2d4",
    "question": "How do you implement Quick Sort in Go?",
    "answer": "```markdown Certainly! Here’s how you can implement Quick Sort in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// quickSort recursively sorts the slice using the Quick Sort algorithm.\nfunc quickSort(arr []int) []int {\n    if len(arr) < 2 {\n        return arr\n    }\n\n    left, right := 0, len(arr)-1\n\n    // Choose the pivot (here, the rightmost element)\n    pivot := arr[right]\n\n    // Partitioning\n    for i := range arr {\n        if arr[i] < pivot {\n            arr[i], arr[left] = arr[left], arr[i]\n            left++\n        }\n    }\n    // Place pivot in its correct position\n    arr[left], arr[right] = arr[right], arr[left]\n\n    // Recursively sort elements before and after partition\n    quickSort(arr[:left])\n    quickSort(arr[left+1:])\n\n    return arr\n}\n\nfunc main() {\n    arr := []int{10, 7, 8, 9, 1, 5}\n    fmt.Println(\"Unsorted:\", arr)\n    sorted := quickSort(arr)\n    fmt.Println(\"Sorted:  \", sorted)\n}\n```\n\n**Explanation:**\n\n- The function `quickSort` uses recursion to sort the array.\n- It selects the last element as the pivot.\n- Elements less than the pivot are moved to the left, and greater ones to the right.\n- The pivot is placed in its correct sorted position.\n- The process is repeated recursively for the left and right subarrays.\n\n**Output:**\n```\nUnsorted: [10 7 8 9 1 5]\nSorted:   [1 5 7 8 9 10]\n```\n\nThis is a simple and efficient implementation of Quick Sort in Go.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449927Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "8870fa05-52fd-4885-85d1-07aee848e4eb",
    "question": "What is the average and worst-case time complexity of Quick Sort?",
    "answer": "```markdown **Quick Sort** is a popular sorting algorithm that uses the divide-and-conquer approach.\n\n- **Average-case time complexity:**  \n  $O(n \\log n)$\n\n- **Worst-case time complexity:**  \n  $O(n^2)$\n\nThe worst-case occurs when the pivot selection consistently results in highly unbalanced partitions (for example, when the smallest or largest element is always chosen as the pivot in a sorted or nearly sorted array). However, with good pivot selection strategies (like choosing a random pivot or using the median-of-three method), the average-case performance is typically $O(n \\log n)$.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449940Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "1f8af3ef-b0b0-4fff-ac35-d746e2d87246",
    "question": "How do you sort a custom data type in Go?",
    "answer": "```markdown To sort a custom data type in Go, you need to implement the sort.Interface for your type. This involves defining three methods: `Len()`, `Less(i, j int)`, and `Swap(i, j int)`. Then, you can use `sort.Sort()` to sort your data.\n\nHere's an example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\n// Define a custom data type\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Create a slice of Person\ntype ByAge []Person\n\n// Implement sort.Interface for ByAge\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\n\nfunc main() {\n    people := []Person{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 35},\n    }\n\n    // Sort by age\n    sort.Sort(ByAge(people))\n\n    fmt.Println(people)\n}\n```\n\n**Output:**\n```\n[{Bob 25} {Alice 30} {Charlie 35}]\n```\n\n**Explanation:**\n- Define a type (`ByAge`) that is a slice of your custom type.\n- Implement `Len()`, `Swap()`, and `Less()` for that type.\n- Use `sort.Sort()` to sort the slice according to your custom logic.\n\nAlternatively, for simple cases, you can use `sort.Slice()` with a less function:\n\n```go\nsort.Slice(people, func(i, j int) bool {\n    return people[i].Age < people[j].Age\n})\n```\n\nThis approach is more concise and doesn't require defining a new type.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449951Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "923c8eeb-cecf-4fa0-87b4-29b2955c7bbe",
    "question": "What are the advantages of using Merge Sort over Quick Sort?",
    "answer": "```markdown **Advantages of Using Merge Sort Over Quick Sort in Go**\n\n1. **Stable Sorting**  \n   Merge Sort is a stable sort, meaning that it preserves the relative order of equal elements. Quick Sort is not stable by default.\n\n2. **Guaranteed O(n log n) Time Complexity**  \n   Merge Sort always runs in O(n log n) time, regardless of the input data. Quick Sort, while having an average time complexity of O(n log n), can degrade to O(n²) in the worst case (e.g., when the pivot choices are poor).\n\n3. **Better Performance on Linked Lists**  \n   Merge Sort works efficiently with linked lists because it does not require random access to elements, whereas Quick Sort is less efficient on linked lists.\n\n4. **Predictable Performance**  \n   Since Merge Sort's time complexity does not depend on the input distribution, it is more predictable and reliable for time-critical applications.\n\n5. **External Sorting**  \n   Merge Sort is well-suited for external sorting (sorting data that does not fit into memory), as it accesses data sequentially and can efficiently merge large sorted chunks.\n\n**Example in Go:**\n\n```go\nimport \"sort\"\n\n// Go's sort package provides a stable sort (uses merge sort for large slices)\nsort.Stable(yourSlice)\n```\n\n**Summary Table**\n\n| Feature                | Merge Sort         | Quick Sort         |\n|------------------------|-------------------|--------------------|\n| Stability              | Stable            | Not stable         |\n| Worst-case Complexity  | O(n log n)        | O(n²)              |\n| Linked List Support    | Efficient         | Inefficient        |\n| External Sorting       | Suitable          | Not suitable       |\n| In-place Sorting       | No                | Yes                |\n\n**Conclusion:**  \nUse Merge Sort in Go when you need stable sorting, predictable performance, or need to sort linked lists or data that doesn't fit into memory. For most in-memory array sorting, Quick Sort is often faster and uses less memory, but Merge Sort has the above advantages in specific scenarios.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449963Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "1dc66973-8c4e-4a26-94f2-3c073640f904",
    "question": "How do you perform a descending sort in Go?",
    "answer": "```markdown To perform a descending sort in Go, you can use the sort package along with the sort.Sort function and sort.Reverse wrapper. Here's how you can do it for a slice of integers:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    nums := []int{5, 2, 9, 1, 5, 6}\n    sort.Sort(sort.Reverse(sort.IntSlice(nums)))\n    fmt.Println(nums) // Output: [9 6 5 5 2 1]\n}\n```\n\n**Explanation:**\n\n- `sort.IntSlice(nums)` converts the slice to a type that implements sort.Interface.\n- `sort.Reverse(...)` wraps this type to reverse the sorting order (descending).\n- `sort.Sort(...)` sorts the slice in-place.\n\n**For custom types**, implement the sort.Interface and wrap it with sort.Reverse in the same way.\n\n**Example with strings:**\n\n```go\nwords := []string{\"banana\", \"apple\", \"cherry\"}\nsort.Sort(sort.Reverse(sort.StringSlice(words)))\nfmt.Println(words) // Output: [cherry banana apple]\n```\n\nThis approach works for all types supported by the sort package.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449976Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "e91b8a8b-cffb-4b58-a591-9818abefeadb",
    "question": "What is the purpose of the Less method in sort.Interface?",
    "answer": "```markdown The Less method in Go's sort.Interface is used to define the ordering between elements in a collection. When you implement sort.Interface for a type, you must provide three methods: Len(), Swap(), and Less(). The Less method specifically determines whether the element at index i should sort before the element at index j.\n\nHere’s a summary in markdown format:\n\n```markdown\n### What is the purpose of the `Less` method in `sort.Interface`?\n\nThe `Less` method is used to compare two elements in a collection and determine their order. It should return `true` if the element at index `i` should come before the element at index `j` in the sorted order.\n\nWhen you implement the `sort.Interface` in Go, you define the sorting logic by implementing:\n\n- `Len() int` — returns the number of elements.\n- `Swap(i, j int)` — swaps the elements at indices `i` and `j`.\n- `Less(i, j int) bool` — returns `true` if element at `i` should sort before element at `j`.\n\nThe sorting algorithm uses the `Less` method to decide how to order the elements.\n\n#### Example\n\n```go\ntype People []Person\n\nfunc (p People) Len() int           { return len(p) }\nfunc (p People) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\nfunc (p People) Less(i, j int) bool { return p[i].Age < p[j].Age }\n```\n\nIn this example, `Less` sorts people by age in ascending order.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.449988Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "81ffd531-e5f5-4d9c-8d8d-467b15f1be3a",
    "question": "How do you check if a slice is already sorted in Go?",
    "answer": "```markdown\nIn Go, you can check if a slice is already sorted by using the `sort` package, which provides the `sort.SliceIsSorted` function for generic slices and specific functions like `sort.IntsAreSorted`, `sort.StringsAreSorted`, and `sort.Float64sAreSorted` for slices of basic types.\n\n### Example: Checking if an `int` slice is sorted\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    nums := []int{1, 2, 3, 4, 5}\n    if sort.IntsAreSorted(nums) {\n        fmt.Println(\"The slice is sorted.\")\n    } else {\n        fmt.Println(\"The slice is not sorted.\")\n    }\n}\n```\n\n### Example: Checking if a custom slice is sorted\n\nFor slices of custom types or when you want to define your own comparison, use `sort.SliceIsSorted`:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    people := []Person{\n        {\"Alice\", 21},\n        {\"Bob\", 25},\n        {\"Charlie\", 30},\n    }\n    sorted := sort.SliceIsSorted(people, func(i, j int) bool {\n        return people[i].Age < people[j].Age\n    })\n    if sorted {\n        fmt.Println(\"The slice is sorted by age.\")\n    } else {\n        fmt.Println(\"The slice is not sorted by age.\")\n    }\n}\n```\n\n### Summary\n\n- Use `sort.IntsAreSorted`, `sort.StringsAreSorted`, or `sort.Float64sAreSorted` for basic types.\n- Use `sort.SliceIsSorted` for custom types or custom sort orders.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450001Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "c427bf0c-34e6-4880-9d14-cc414615425c",
    "question": "What is the difference between sort.Sort and sort.Stable in Go?",
    "answer": "```markdown\nIn Go, both `sort.Sort` and `sort.Stable` are used to sort slices, but they differ in how they handle elements with equal values (i.e., elements that compare as \"equal\" according to the comparison function).\n\n### `sort.Sort`\n- Uses an **unstable sorting algorithm** (typically quicksort).\n- The **relative order of equal elements is not guaranteed to be preserved**.\n- Faster in practice for most cases due to less overhead.\n\n**Example:**\n```go\nsort.Sort(sort.IntSlice{3, 2, 2, 1})\n```\n\n### `sort.Stable`\n- Uses a **stable sorting algorithm** (typically insertion sort for small slices, merge sort for larger ones).\n- **Preserves the relative order of equal elements**.\n- Slightly slower due to the extra work needed to maintain stability.\n\n**Example:**\n```go\nsort.Stable(sort.IntSlice{3, 2, 2, 1})\n```\n\n### When to Use Which?\n- Use `sort.Sort` when you do **not care** about the order of equal elements and want potentially better performance.\n- Use `sort.Stable` when you **need to preserve** the original order of equal elements (important for multi-level sorting).\n\n### Summary Table\n\n| Function      | Stability | Performance | Use Case                                  |\n|---------------|-----------|-------------|--------------------------------------------|\n| `sort.Sort`   | Unstable  | Faster      | When order of equal elements doesn't matter|\n| `sort.Stable` | Stable    | Slower      | When order of equal elements must be kept  |\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450014Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "e0b46682-2f9a-4268-9ad2-04db22eb74f7",
    "question": "How does Heap Sort work and how can it be implemented in Go?",
    "answer": "```markdown ### Heap Sort: How It Works\n\nHeap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It works in two main phases:\n\n1. **Build a Max Heap:** Rearrange the array into a max heap, where the largest element is at the root.\n2. **Extract Elements:** Repeatedly remove the largest element (the root), swap it with the last item, reduce the heap size, and heapify the root. Repeat until the heap is empty.\n\n**Time Complexity:**  \n- Worst, Average, Best: O(n log n)\n\n**Space Complexity:**  \n- O(1) (in-place)\n\n---\n\n### Heap Sort Implementation in Go\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Heapify a subtree rooted at index i in arr[]\nfunc heapify(arr []int, n, i int) {\n    largest := i\n    left := 2*i + 1\n    right := 2*i + 2\n\n    // If left child is larger than root\n    if left < n && arr[left] > arr[largest] {\n        largest = left\n    }\n\n    // If right child is larger than largest so far\n    if right < n && arr[right] > arr[largest] {\n        largest = right\n    }\n\n    // If largest is not root\n    if largest != i {\n        arr[i], arr[largest] = arr[largest], arr[i] // Swap\n\n        // Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n    }\n}\n\n// Main function to do heap sort\nfunc heapSort(arr []int) {\n    n := len(arr)\n\n    // Build max heap\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(arr, n, i)\n    }\n\n    // Extract elements from heap one by one\n    for i := n - 1; i > 0; i-- {\n        arr[0], arr[i] = arr[i], arr[0] // Swap\n        heapify(arr, i, 0)\n    }\n}\n\nfunc main() {\n    arr := []int{12, 11, 13, 5, 6, 7}\n    fmt.Println(\"Unsorted array:\", arr)\n    heapSort(arr)\n    fmt.Println(\"Sorted array:  \", arr)\n}\n```\n\n---\n\n### Key Points\n\n- Heap Sort is **not stable** (equal elements may not retain their order).\n- It is **in-place** (does not require extra memory).\n- Useful for large datasets where memory usage is a concern.\n\n---\n\n**Summary:**  \nHeap Sort builds a max heap from the input, then repeatedly extracts the maximum element and rebuilds the heap, resulting in a sorted array. The Go implementation above demonstrates this process.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450026Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "e6c90726-2823-438d-968f-c210b45b491d",
    "question": "What is the time complexity of Heap Sort?",
    "answer": "```markdown **Heap Sort Time Complexity in Go**\n\nHeap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. Its time complexities are as follows:\n\n- **Best Case:** O(n log n)\n- **Average Case:** O(n log n)\n- **Worst Case:** O(n log n)\n\nThis is because both the heap construction and the repeated removal of the maximum element (and subsequent heapification) each take O(log n) time, and these operations are performed n times.\n\n**Summary Table:**\n\n| Case         | Time Complexity |\n|--------------|----------------|\n| Best         | O(n log n)     |\n| Average      | O(n log n)     |\n| Worst        | O(n log n)     |\n\nHeap Sort is efficient and guarantees O(n log n) performance regardless of the input data.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450037Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "cc201a7c-101f-4bbf-a929-5f6f7abc207d",
    "question": "How do you sort a map by its values in Go?",
    "answer": "```markdown To sort a map by its values in Go, you need to extract the keys, sort them based on their corresponding values, and then use the sorted keys to access the map in value order. Here's how you can do it:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\n// Example: Sorting a map[string]int by its values\nfunc main() {\n    m := map[string]int{\n        \"apple\":  5,\n        \"banana\": 2,\n        \"orange\": 8,\n        \"grape\":  3,\n    }\n\n    // Step 1: Extract keys into a slice\n    keys := make([]string, 0, len(m))\n    for k := range m {\n        keys = append(keys, k)\n    }\n\n    // Step 2: Sort keys based on map values\n    sort.Slice(keys, func(i, j int) bool {\n        return m[keys[i]] < m[keys[j]] // Ascending order\n    })\n\n    // Step 3: Iterate over sorted keys\n    fmt.Println(\"Sorted by value:\")\n    for _, k := range keys {\n        fmt.Printf(\"%s: %d\\n\", k, m[k])\n    }\n}\n```\n\n**Output:**\n```\nSorted by value:\nbanana: 2\ngrape: 3\napple: 5\norange: 8\n```\n\n**Explanation:**\n\n- Maps in Go are inherently unordered, so you can't sort them directly.\n- By extracting the keys and sorting them using sort.Slice with a custom comparison (based on the map's values), you can achieve a value-based ordering.\n- You can then use the sorted keys to access the map's values in order.\n\n**Note:**  \nThis approach works for any map type; just adjust the key and value types as needed. For descending order, change the comparison to m[keys[i]] > m[keys[j]].",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450049Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "6d6e9960-b84b-404b-a98c-a94209ed2a58",
    "question": "What is Counting Sort and when is it appropriate to use it?",
    "answer": "```markdown Counting Sort in Go\n-------------------\n\n**Counting Sort** is a non-comparison-based sorting algorithm that sorts elements by counting the number of occurrences of each unique value in the input array. It then uses this count information to place each element directly into its correct position in the output array.\n\n### How Counting Sort Works\n\n1. **Find the Range:** Determine the minimum and maximum values in the array.\n2. **Count Occurrences:** Create a count array where each index corresponds to a value in the input array. Increment the count for each occurrence.\n3. **Cumulative Count:** Modify the count array so that each element at each index stores the sum of previous counts. This helps in placing elements in the correct position.\n4. **Build Output:** Iterate over the input array and place each element in its sorted position using the count array.\n\n### Example in Go\n\n```go\nfunc countingSort(arr []int) []int {\n    if len(arr) == 0 {\n        return arr\n    }\n    min, max := arr[0], arr[0]\n    for _, v := range arr {\n        if v < min { min = v }\n        if v > max { max = v }\n    }\n    count := make([]int, max-min+1)\n    for _, v := range arr {\n        count[v-min]++\n    }\n    index := 0\n    for i, c := range count {\n        for c > 0 {\n            arr[index] = i + min\n            index++\n            c--\n        }\n    }\n    return arr\n}\n```\n\n### When to Use Counting Sort\n\nCounting Sort is **appropriate** when:\n\n- The range of input values (max - min) is not significantly larger than the number of elements to sort.\n- The input consists of integers or objects that can be mapped to integers.\n- You need a stable and fast sorting algorithm for small ranges.\n\n**Not suitable** for:\n\n- Sorting floating-point numbers or large ranges of integers.\n- Cases where the range of input values is much larger than the number of elements (as it would require a large count array, wasting memory).\n\n### Time and Space Complexity\n\n- **Time Complexity:** O(n + k), where n is the number of elements and k is the range of input.\n- **Space Complexity:** O(k)\n\n### Summary Table\n\n| Feature         | Counting Sort                  |\n|-----------------|-------------------------------|\n| Type            | Non-comparison-based           |\n| Best Use Case   | Small range of integer values  |\n| Stability       | Stable                         |\n| Time Complexity | O(n + k)                       |\n| Space Complexity| O(k)                           |\n\nCounting Sort is a powerful tool for sorting integers efficiently when the range of values is limited and known in advance.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450061Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "decaa8be-c4cc-4cd5-8c3a-d152498332ae",
    "question": "How do you implement Counting Sort in Go?",
    "answer": "```markdown Certainly! Here’s how you can implement Counting Sort in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// CountingSort sorts an array of non-negative integers using counting sort algorithm\nfunc CountingSort(arr []int) []int {\n    if len(arr) == 0 {\n        return arr\n    }\n\n    // Find the maximum value in arr\n    max := arr[0]\n    for _, v := range arr {\n        if v > max {\n            max = v\n        }\n    }\n\n    // Initialize count array\n    count := make([]int, max+1)\n\n    // Store the count of each element\n    for _, v := range arr {\n        count[v]++\n    }\n\n    // Build the sorted array\n    idx := 0\n    sorted := make([]int, len(arr))\n    for i, c := range count {\n        for c > 0 {\n            sorted[idx] = i\n            idx++\n            c--\n        }\n    }\n\n    return sorted\n}\n\nfunc main() {\n    arr := []int{4, 2, 2, 8, 3, 3, 1}\n    sortedArr := CountingSort(arr)\n    fmt.Println(\"Sorted array:\", sortedArr)\n}\n```\n\n**Explanation:**\n\n- **CountingSort** works efficiently for sorting arrays of non-negative integers where the range of input values is not significantly greater than the number of elements.\n- The algorithm:\n  1. Finds the maximum value to determine the size of the count array.\n  2. Counts the occurrences of each value.\n  3. Iterates through the count array to reconstruct the sorted output.\n\n**Note:**  \nCounting Sort is not suitable for sorting arrays with negative numbers or very large ranges unless you adjust the implementation accordingly.",
    "level": "Intermediate",
    "created_at": "2025-04-21T12:16:44.450073Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "05200977-06bf-45be-a0a4-dd3c5b1c7218",
    "question": "What is Radix Sort and what are its advantages?",
    "answer": "```markdown\n## Radix Sort in Go\n\n**Radix Sort** is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by individual digits that share the same significant position and value. It processes the digits of the numbers from the least significant digit (LSD) to the most significant digit (MSD), or vice versa, depending on the implementation.\n\n### How Radix Sort Works\n\n1. **Digit by Digit Sorting:** Radix Sort sorts the numbers digit by digit, starting from either the least significant digit (LSD) or the most significant digit (MSD).\n2. **Stable Sub-sorting:** For each digit position, a stable sorting algorithm (like Counting Sort) is used to sort the numbers based on that digit.\n3. **Multiple Passes:** The process is repeated for each digit position until the entire list is sorted.\n\n### Example in Go\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc getMax(arr []int) int {\n    max := arr[0]\n    for _, v := range arr {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n\nfunc countingSort(arr []int, exp int) {\n    n := len(arr)\n    output := make([]int, n)\n    count := make([]int, 10)\n\n    for i := 0; i < n; i++ {\n        index := (arr[i] / exp) % 10\n        count[index]++\n    }\n\n    for i := 1; i < 10; i++ {\n        count[i] += count[i-1]\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        index := (arr[i] / exp) % 10\n        output[count[index]-1] = arr[i]\n        count[index]--\n    }\n\n    for i := 0; i < n; i++ {\n        arr[i] = output[i]\n    }\n}\n\nfunc radixSort(arr []int) {\n    max := getMax(arr)\n    for exp := 1; max/exp > 0; exp *= 10 {\n        countingSort(arr, exp)\n    }\n}\n\nfunc main() {\n    arr := []int{170, 45, 75, 90, 802, 24, 2, 66}\n    radixSort(arr)\n    fmt.Println(arr)\n}\n```\n\n### Advantages of Radix Sort\n\n- **Linear Time Complexity:** For fixed-length integer keys, Radix Sort can achieve O(nk) time complexity, where n is the number of elements and k is the number of digits in the largest number. This can be faster than comparison-based algorithms like Quick Sort or Merge Sort for large datasets with small key sizes.\n- **Stable Sorting:** Radix Sort is stable, meaning that it preserves the relative order of elements with equal keys.\n- **Efficient for Large Data:** Particularly efficient for sorting large sets of integers or strings (when treated as sequences of characters/digits).\n- **No Comparisons:** Unlike comparison-based sorts, Radix Sort does not compare elements directly, which can be advantageous for certain data types.\n\n### Limitations\n\n- **Restricted to Integers or Strings:** Radix Sort is generally applicable to data that can be broken down into digits or characters (like integers or fixed-length strings).\n- **Extra Space:** Requires additional space for temporary arrays (like the output and count arrays in Counting Sort).\n- **Not In-Place:** Standard implementations are not in-place due to the use of auxiliary arrays.\n\n### Summary Table\n\n| Feature            | Radix Sort         |\n|--------------------|-------------------|\n| Time Complexity    | O(nk)             |\n| Space Complexity   | O(n + k)          |\n| Stable             | Yes               |\n| In-place           | No                |\n| Comparison-based   | No                |\n| Best for           | Integers, Strings |\n\nRadix Sort is a powerful tool in the right context, especially when dealing with large datasets of integers or strings where comparison-based sorts become less efficient.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450084Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "1e74b54d-ca93-4d7c-bd68-fab919b3def7",
    "question": "How do you implement Radix Sort in Go?",
    "answer": "```go\n// Radix Sort implementation in Go\n\npackage main\n\nimport (\n    \"fmt\"\n)\n\n// getMax finds the maximum value in the array\nfunc getMax(arr []int) int {\n    max := arr[0]\n    for _, v := range arr {\n        if v > max {\n            max = v\n        }\n    }\n    return max\n}\n\n// countingSort performs a counting sort based on the digit represented by exp\nfunc countingSort(arr []int, exp int) {\n    n := len(arr)\n    output := make([]int, n)\n    count := make([]int, 10) // base 10 digits\n\n    // Store count of occurrences in count[]\n    for i := 0; i < n; i++ {\n        index := (arr[i] / exp) % 10\n        count[index]++\n    }\n\n    // Change count[i] so that count[i] now contains actual\n    // position of this digit in output[]\n    for i := 1; i < 10; i++ {\n        count[i] += count[i-1]\n    }\n\n    // Build the output array\n    for i := n - 1; i >= 0; i-- {\n        index := (arr[i] / exp) % 10\n        output[count[index]-1] = arr[i]\n        count[index]--\n    }\n\n    // Copy the output array to arr[], so that arr[] now\n    // contains sorted numbers according to current digit\n    for i := 0; i < n; i++ {\n        arr[i] = output[i]\n    }\n}\n\n// radixSort sorts arr[] using Radix Sort algorithm\nfunc radixSort(arr []int) {\n    // Find the maximum number to know number of digits\n    max := getMax(arr)\n\n    // Do counting sort for every digit. Note that instead\n    // of passing digit number, exp is passed. exp is 10^i\n    // where i is current digit number\n    for exp := 1; max/exp > 0; exp *= 10 {\n        countingSort(arr, exp)\n    }\n}\n\nfunc main() {\n    arr := []int{170, 45, 75, 90, 802, 24, 2, 66}\n    fmt.Println(\"Original array:\", arr)\n    radixSort(arr)\n    fmt.Println(\"Sorted array:  \", arr)\n}\n```\n\n**Explanation:**\n\n- Radix Sort sorts numbers digit by digit starting from the least significant digit (LSD).\n- It uses a stable sub-sorting algorithm (here, Counting Sort) for each digit position.\n- The algorithm first finds the maximum number to determine the number of digits.\n- For each digit position (units, tens, hundreds, ...), it sorts the array using Counting Sort based on that digit.\n- The process repeats for each digit position until the entire array is sorted.\n\n**Note:**  \nThis implementation works for non-negative integers. For negative numbers, you would need to adapt the algorithm.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450095Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "f2eb9b8f-d896-4b02-bdde-1b3805cbabfc",
    "question": "What is Bucket Sort and how does it differ from Counting Sort?",
    "answer": "```markdown\n### Bucket Sort in Go\n\n**Bucket Sort** is a sorting algorithm that distributes elements of an array into several groups called \"buckets.\" Each bucket is then sorted individually, either using a different sorting algorithm or recursively applying the bucket sort. Finally, the sorted buckets are concatenated to form the final sorted array.\n\n#### How Bucket Sort Works:\n1. **Divide**: The input array is divided into a number of buckets.\n2. **Distribute**: Each element is placed into a bucket based on a mapping function (often based on value range).\n3. **Sort Buckets**: Each bucket is sorted individually, often using another sorting algorithm (like Insertion Sort).\n4. **Concatenate**: The sorted buckets are combined to form the final sorted array.\n\n#### Example in Go:\n```go\nfunc bucketSort(arr []float64) []float64 {\n    n := len(arr)\n    if n <= 0 {\n        return arr\n    }\n\n    // 1. Create n empty buckets\n    buckets := make([][]float64, n)\n\n    // 2. Put array elements in different buckets\n    for _, num := range arr {\n        idx := int(num * float64(n))\n        buckets[idx] = append(buckets[idx], num)\n    }\n\n    // 3. Sort individual buckets\n    for i := 0; i < n; i++ {\n        sort.Float64s(buckets[i])\n    }\n\n    // 4. Concatenate all buckets into arr[]\n    idx := 0\n    for _, bucket := range buckets {\n        for _, num := range bucket {\n            arr[idx] = num\n            idx++\n        }\n    }\n    return arr\n}\n```\n\n---\n\n### How Bucket Sort Differs from Counting Sort\n\n| Feature            | Bucket Sort                                         | Counting Sort                                  |\n|--------------------|----------------------------------------------------|------------------------------------------------|\n| **Approach**       | Distributes elements into buckets, sorts buckets   | Counts occurrences of each value               |\n| **Data Type**      | Works well with uniformly distributed floating-point or integer data | Works best with integers in a small range      |\n| **Sorting**        | Each bucket is sorted individually                 | No comparison-based sorting; uses counting     |\n| **Stability**      | Can be stable if stable sort is used for buckets   | Stable by nature                               |\n| **Time Complexity**| O(n + k), where k is the number of buckets         | O(n + k), where k is the range of input        |\n| **Space Complexity**| O(n + k)                                          | O(n + k)                                       |\n| **Use Case**       | When input is uniformly distributed over a range   | When input is integers in a limited range      |\n\n#### Key Differences:\n- **Bucket Sort** is more general and can handle floating-point numbers, while **Counting Sort** is limited to integers.\n- **Bucket Sort** divides data into ranges (buckets) and sorts each range, whereas **Counting Sort** counts the frequency of each unique element.\n- **Counting Sort** is not comparison-based, while **Bucket Sort** may use comparison-based sorting within buckets.\n\n---\n\n**Summary:**  \nBucket Sort is ideal for sorting data that is uniformly distributed over a range (including floating-point numbers), while Counting Sort is best for sorting integers within a small, known range. The main difference lies in how they organize and process the data: Bucket Sort groups and sorts, Counting Sort counts and reconstructs.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450108Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "12874759-4a33-4d90-9387-584d142e8cbd",
    "question": "How do you implement Bucket Sort in Go?",
    "answer": "```go\n// Bucket Sort implementation in Go\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// bucketSort sorts an array of float64 numbers using Bucket Sort algorithm.\nfunc bucketSort(arr []float64) []float64 {\n\tn := len(arr)\n\tif n <= 0 {\n\t\treturn arr\n\t}\n\n\t// 1. Create n empty buckets\n\tbuckets := make([][]float64, n)\n\n\t// 2. Put array elements in different buckets\n\tfor _, num := range arr {\n\t\t// Assuming the input is in [0,1)\n\t\tindex := int(num * float64(n))\n\t\tbuckets[index] = append(buckets[index], num)\n\t}\n\n\t// 3. Sort individual buckets\n\tfor i := range buckets {\n\t\tsort.Float64s(buckets[i])\n\t}\n\n\t// 4. Concatenate all buckets into arr[]\n\tresult := make([]float64, 0, n)\n\tfor _, bucket := range buckets {\n\t\tresult = append(result, bucket...)\n\t}\n\n\treturn result\n}\n\nfunc main() {\n\tarr := []float64{0.42, 0.32, 0.23, 0.52, 0.25, 0.47, 0.51}\n\tfmt.Println(\"Original array:\", arr)\n\tsorted := bucketSort(arr)\n\tfmt.Println(\"Sorted array:  \", sorted)\n}\n```\n\n**Explanation:**\n\n- **Bucket Sort** works best when input is uniformly distributed over a range (commonly [0, 1)).\n- The array is divided into `n` buckets (where `n` is the length of the array).\n- Each element is placed in a bucket based on its value.\n- Each bucket is sorted individually (using Go's built-in `sort.Float64s`).\n- Finally, all buckets are concatenated to produce the sorted array.\n\n**Note:**  \nIf your input is not in [0, 1), you should normalize it before applying bucket sort. Adjust the bucket index calculation accordingly for different ranges.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450120Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "f576e6cd-44aa-44ef-806f-a6f6db1cb3c0",
    "question": "What is TimSort and does Go use it in its standard library?",
    "answer": "```markdown **TimSort** is a hybrid sorting algorithm derived from merge sort and insertion sort. It was designed to perform well on many kinds of real-world data and is the default sorting algorithm in languages like Python and Java (for object arrays). TimSort works by identifying small runs of already sorted elements in the data, then merging them efficiently. Its time complexity is O(n log n) in the worst case, and it performs especially well on partially ordered datasets.\n\n**Does Go use TimSort in its standard library?**\n\nNo, Go does **not** use TimSort in its standard library. Instead, Go’s sort package (as of Go 1.18+) uses a variant of **SymMerge sort** for general sorting (sort.Sort and sort.Slice), which is a stable, in-place merge sort. For small slices, Go uses insertion sort for efficiency. For numeric slices (like sort.Ints), Go uses an optimized version of **quick sort** (with some tweaks for worst-case performance).\n\n**Summary Table**\n\n| Language | Default Sort Algorithm | Stable? | TimSort Used? |\n|----------|-----------------------|---------|--------------|\n| Python   | TimSort               | Yes     | Yes          |\n| Java     | TimSort (objects)     | Yes     | Yes          |\n| Go       | SymMerge/QuickSort    | Yes/No  | No           |\n\n**References:**\n- [Go source code: sort package](https://github.com/golang/go/blob/master/src/sort/sort.go)\n- [TimSort Wikipedia](https://en.wikipedia.org/wiki/Timsort)",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450132Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "401721f4-bdce-4b57-a3f0-79605a8e9bbc",
    "question": "How does Go's sort package choose which sorting algorithm to use?",
    "answer": "```markdown\nGo's `sort` package uses an adaptive sorting algorithm that selects the most efficient method based on the data and the type being sorted. Here's how it works:\n\n### 1. For Built-in Types (`sort.Ints`, `sort.Strings`, etc.)\n\n- **Small Arrays (length < 12):**  \n  Go uses **insertion sort** for small slices because it has low overhead and performs well on small datasets.\n\n- **Larger Arrays:**  \n  Go uses a variant of **quicksort** (specifically, a non-recursive version with median-of-three partitioning and a fallback to heap sort for worst-case scenarios). This approach provides good average-case performance and avoids stack overflows.\n\n### 2. For Custom Types (`sort.Sort` with `sort.Interface`)\n\n- The same adaptive approach is used:\n  - **Insertion sort** for small slices.\n  - **Quicksort** for larger slices, with a fallback to **heap sort** if the recursion depth exceeds a certain limit (to guard against pathological cases).\n\n### 3. Stability\n\n- The basic `sort.Sort` is **not stable** (equal elements may not retain their original order).\n- For stable sorting, Go provides `sort.Stable`, which uses a **stable mergesort** algorithm.\n\n### Summary Table\n\n| Data Size      | Algorithm Used   | Stability   |\n|----------------|------------------|-------------|\n| Small (<12)    | Insertion Sort   | Unstable    |\n| Large          | Quicksort/Heap   | Unstable    |\n| `sort.Stable`  | Mergesort        | Stable      |\n\n### References\n\n- [Go source code: sort package](https://github.com/golang/go/blob/master/src/sort/sort.go)\n- [Go Blog: Sorting slices and user-defined collections](https://blog.golang.org/slices-intro)\n\n**In summary:**  \nGo's `sort` package adaptively chooses between insertion sort, quicksort, and heap sort for efficiency and safety, and uses mergesort for stable sorting.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450144Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "39215201-0342-4231-8ff3-bddb1d0f7625",
    "question": "What are the memory requirements of Merge Sort compared to Quick Sort?",
    "answer": "```markdown ### Memory Requirements of Merge Sort vs Quick Sort in Go\n\n#### **Merge Sort**\n- **Space Complexity:**  \n  - **O(n)** auxiliary space.\n  - Merge Sort requires additional memory to store temporary arrays during the merging process.\n  - For an array of size `n`, it typically allocates a new array of size `n` for merging.\n- **In Go:**  \n  - When implementing Merge Sort, you usually create slices to hold the left and right halves, leading to extra memory usage proportional to the input size.\n\n#### **Quick Sort**\n- **Space Complexity:**  \n  - **O(log n)** auxiliary space (best and average case, due to recursion stack).\n  - **O(n)** in the worst case (when the pivot choices are poor and recursion depth increases).\n  - Quick Sort is an **in-place** sorting algorithm, so it does not require extra arrays for sorting.\n- **In Go:**  \n  - The standard implementation uses recursion, so the main memory overhead comes from the call stack, not from allocating new arrays.\n\n---\n\n#### **Summary Table**\n\n| Algorithm    | Auxiliary Space | In-place? | Notes                                              |\n|--------------|----------------|-----------|----------------------------------------------------|\n| Merge Sort   | O(n)           | No        | Needs extra arrays for merging                     |\n| Quick Sort   | O(log n) avg   | Yes       | Only uses stack space for recursion                |\n|              | O(n) worst     |           | Worst case with poor pivot selection               |\n\n---\n\n#### **Conclusion**\n- **Merge Sort** uses more memory than **Quick Sort** because it requires additional arrays for merging.\n- **Quick Sort** is generally more memory-efficient, especially with good pivot selection, as it sorts in-place and only needs stack space for recursion.\n\n---\n\n**References:**\n- [Go Programming Language: Sorting Algorithms](https://golang.org/pkg/sort/)\n- [Merge Sort vs Quick Sort - GeeksforGeeks](https://www.geeksforgeeks.org/merge-sort-vs-quick-sort/)",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450156Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "074faa98-63dc-4820-b28b-4638e44e16cd",
    "question": "How do you optimize sorting for large datasets in Go?",
    "answer": "```markdown Optimizing Sorting for Large Datasets in Go\n===========================================\n\nWhen dealing with large datasets in Go, sorting efficiently is crucial for performance and resource management. Here are advanced strategies and best practices to optimize sorting in Go:\n\n1. **Choose the Right Algorithm**\n   - Go’s standard library uses an adaptive, hybrid sorting algorithm (`sort.Sort`, `sort.Ints`, etc.), which is efficient for most cases.\n   - For very large datasets, consider external or parallel sorting if data doesn't fit in memory.\n\n2. **Minimize Memory Allocations**\n   - Use slices instead of creating new arrays during sorting.\n   - Implement the `sort.Interface` directly on your data structure to avoid copying.\n\n3. **Parallel Sorting**\n   - For CPU-bound sorts on multi-core systems, split the dataset and sort chunks in parallel using goroutines, then merge the results.\n   - Example using goroutines and channels:\n\n     ```go\n     func parallelSort(data []int, workers int) []int {\n         chunkSize := (len(data) + workers - 1) / workers\n         sortedChunks := make([][]int, workers)\n         var wg sync.WaitGroup\n\n         for i := 0; i < workers; i++ {\n             start := i * chunkSize\n             end := start + chunkSize\n             if end > len(data) {\n                 end = len(data)\n             }\n             wg.Add(1)\n             go func(i, start, end int) {\n                 defer wg.Done()\n                 chunk := make([]int, end-start)\n                 copy(chunk, data[start:end])\n                 sort.Ints(chunk)\n                 sortedChunks[i] = chunk\n             }(i, start, end)\n         }\n         wg.Wait()\n         // Merge sortedChunks here (e.g., k-way merge)\n         return mergeChunks(sortedChunks)\n     }\n     ```\n\n4. **External Sorting**\n   - For datasets larger than available memory, use external sorting: split data into chunks, sort each chunk, write to disk, then merge sorted chunks.\n   - Libraries like [external-sort](https://github.com/gnulab/external-sort) can help, or implement your own using file I/O.\n\n5. **Custom Comparators and Stable Sort**\n   - Use `sort.SliceStable` for stable sorting when order preservation is needed.\n   - Implement custom comparators for complex data structures to avoid unnecessary conversions.\n\n6. **Avoid Reflection**\n   - Prefer `sort.Slice` over `sort.Sort` with reflection-based interfaces for better performance.\n\n7. **Profile and Benchmark**\n   - Use Go’s `pprof` and `testing` packages to benchmark and profile your sorting code.\n   - Identify bottlenecks and optimize accordingly.\n\n8. **Leverage Specialized Libraries**\n   - For highly specialized needs, consider third-party libraries like [gonum](https://github.com/gonum/gonum) for scientific data or [sortutil](https://github.com/shenwei356/sortutil) for large file sorting.\n\n**Example: Efficient In-Memory Sort**\n\n```go\nsort.Slice(data, func(i, j int) bool {\n    return data[i].Key < data[j].Key\n})\n```\n\n**Summary Table**\n\n| Technique                | Use Case                                 | Benefit                |\n|--------------------------|------------------------------------------|------------------------|\n| Standard sort            | Fits in memory, general use              | Simplicity, speed      |\n| Parallel sort            | Multi-core CPUs, large in-memory data    | Faster sorting         |\n| External sort            | Data exceeds memory                      | Scalability            |\n| Custom comparators       | Complex data structures                  | Flexibility            |\n| Avoid reflection         | Performance-critical applications        | Speed                  |\n\n**References**\n- [Go sort package documentation](https://pkg.go.dev/sort)\n- [Go Blog: Sorting slices and user-defined collections](https://blog.golang.org/slices-intro)\n\nBy combining these techniques, you can efficiently sort large datasets in Go, balancing speed, memory usage, and code maintainability.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450175Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "05ec1237-96d4-4940-912b-5860b15bf2c6",
    "question": "How can you parallelize sorting in Go?",
    "answer": "```markdown ### Parallelizing Sorting in Go\n\nParallelizing sorting in Go can significantly improve performance on large datasets by utilizing multiple CPU cores. The most common approach is to parallelize **divide-and-conquer** sorting algorithms, such as **Merge Sort** or **Quick Sort**. Go's built-in concurrency primitives—**goroutines** and **channels**—make this relatively straightforward.\n\n#### Example: Parallel Merge Sort\n\nBelow is an example of how you might parallelize Merge Sort in Go:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n// Merge merges two sorted slices into one sorted slice.\nfunc Merge(left, right []int) []int {\n    result := make([]int, 0, len(left)+len(right))\n    i, j := 0, 0\n    for i < len(left) && j < len(right) {\n        if left[i] < right[j] {\n            result = append(result, left[i])\n            i++\n        } else {\n            result = append(result, right[j])\n            j++\n        }\n    }\n    result = append(result, left[i:]...)\n    result = append(result, right[j:]...)\n    return result\n}\n\n// ParallelMergeSort sorts the slice in parallel.\nfunc ParallelMergeSort(arr []int, wg *sync.WaitGroup, depth int) []int {\n    defer wg.Done()\n\n    if len(arr) <= 1 {\n        return arr\n    }\n\n    mid := len(arr) / 2\n    var left, right []int\n\n    // Limit the depth of parallelism to avoid oversubscription.\n    if depth > 0 {\n        var wgInner sync.WaitGroup\n        wgInner.Add(2)\n        go func() {\n            left = ParallelMergeSort(arr[:mid], &wgInner, depth-1)\n        }()\n        go func() {\n            right = ParallelMergeSort(arr[mid:], &wgInner, depth-1)\n        }()\n        wgInner.Wait()\n    } else {\n        left = ParallelMergeSort(arr[:mid], &sync.WaitGroup{}, 0)\n        right = ParallelMergeSort(arr[mid:], &sync.WaitGroup{}, 0)\n    }\n\n    return Merge(left, right)\n}\n\nfunc main() {\n    arr := []int{38, 27, 43, 3, 9, 82, 10}\n    var wg sync.WaitGroup\n    wg.Add(1)\n    // Set depth to log2(numCPU) for optimal parallelism\n    sorted := ParallelMergeSort(arr, &wg, 3)\n    wg.Wait()\n    fmt.Println(sorted)\n}\n```\n\n#### Key Points\n\n- **Goroutines** are used to sort subarrays in parallel.\n- **sync.WaitGroup** ensures all goroutines finish before merging results.\n- **Depth control** prevents spawning too many goroutines, which could degrade performance.\n- This approach can be adapted for other divide-and-conquer algorithms like Quick Sort.\n\n#### Libraries\n\nFor production use, consider libraries like [sort](https://pkg.go.dev/sort) (standard, not parallel) or third-party packages such as [parsort](https://github.com/tylertreat/parallel-sort) for parallel sorting.\n\n#### Summary Table\n\n| Algorithm      | Parallelizable? | Typical Approach in Go          |\n|----------------|----------------|---------------------------------|\n| Merge Sort     | Yes            | Goroutines for subarrays        |\n| Quick Sort     | Yes            | Goroutines for partitions       |\n| Heap Sort      | No             | Not naturally parallelizable    |\n| Bubble/Insertion| No            | Inefficient for parallelization |\n\n---\n\n**In summary:**  \nParallelizing sorting in Go involves splitting the data, sorting partitions concurrently using goroutines, and merging the results. Always balance the number of goroutines with available CPU cores for optimal performance.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450241Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "e3acc279-2f97-48ed-b87b-7c19c0cacea9",
    "question": "What are the trade-offs between stable and unstable sorting algorithms?",
    "answer": "```markdown ### Trade-offs Between Stable and Unstable Sorting Algorithms in Go\n\nWhen choosing a sorting algorithm in Go (or any language), one important consideration is whether the algorithm is **stable** or **unstable**. Here’s a breakdown of the trade-offs:\n\n#### Stable Sorting Algorithms\n\nA **stable** sorting algorithm preserves the relative order of records with equal keys (i.e., values). For example, if two elements `A` and `B` are equal and `A` appears before `B` in the input, `A` will still appear before `B` in the output.\n\n**Advantages:**\n- **Preserves Order:** Useful when sorting complex data structures where secondary sorting criteria matter.\n- **Predictable Results:** Multiple sorts on different keys can be chained without losing previous orderings.\n- **Essential for Multi-level Sorting:** For example, sorting by last name, then by first name.\n\n**Disadvantages:**\n- **Potentially Slower:** Stable algorithms may require extra operations or memory to maintain stability.\n- **Higher Memory Usage:** Some stable algorithms (like Merge Sort) require additional memory.\n\n#### Unstable Sorting Algorithms\n\nAn **unstable** sorting algorithm does not guarantee the preservation of the relative order of equal elements.\n\n**Advantages:**\n- **Faster in Practice:** Some unstable algorithms (like Quick Sort or Heap Sort) are faster or have better average-case performance.\n- **Lower Memory Overhead:** Many unstable algorithms are in-place and require less additional memory.\n\n**Disadvantages:**\n- **Order Not Preserved:** Can be problematic if the original order of equal elements is important.\n- **Not Suitable for Multi-level Sorting:** Chaining sorts may not produce the expected results.\n\n#### Go Standard Library Examples\n\n- `sort.Sort`: Uses an **unstable** sorting algorithm (introsort).\n- `sort.Stable`: Uses a **stable** sorting algorithm (merge sort).\n\n#### Summary Table\n\n| Aspect             | Stable Sort                | Unstable Sort             |\n|--------------------|---------------------------|---------------------------|\n| Order Preservation | Yes                        | No                        |\n| Memory Usage       | Often higher               | Often lower               |\n| Speed              | Sometimes slower           | Often faster              |\n| Use Case           | Multi-level, complex data  | Simple, performance-critical |\n\n#### When to Use Which?\n\n- **Use stable sort** when the order of equal elements matters (e.g., multi-key sorting, sorting structs with multiple fields).\n- **Use unstable sort** when performance is critical and the order of equal elements is irrelevant.\n\n---\n\n**In Go, choose `sort.Stable` for stability, and `sort.Sort` for performance when stability is not required.**",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450256Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "35031190-684a-4a54-bdf0-f34eaceeacf8",
    "question": "How do you sort a slice of pointers in Go?",
    "answer": "```markdown To sort a slice of pointers in Go, you can use the sort.Slice function, which allows you to define a custom comparison for your data. Here’s how you can do it:\n\nSuppose you have a struct and a slice of pointers to that struct:\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\npeople := []*Person{\n    {Name: \"Alice\", Age: 30},\n    {Name: \"Bob\", Age: 25},\n    {Name: \"Charlie\", Age: 35},\n}\n```\n\nTo sort people by Age in ascending order:\n\n```go\nimport \"sort\"\n\nsort.Slice(people, func(i, j int) bool {\n    return people[i].Age < people[j].Age\n})\n```\n\n**Explanation:**\n\n- `sort.Slice` takes the slice and a less function.\n- The less function receives indices `i` and `j` and should return true if `people[i]` should come before `people[j]`.\n- Since `people` is a slice of pointers, you access fields with `people[i].Age`.\n\n**Full Example:**\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    people := []*Person{\n        {Name: \"Alice\", Age: 30},\n        {Name: \"Bob\", Age: 25},\n        {Name: \"Charlie\", Age: 35},\n    }\n\n    sort.Slice(people, func(i, j int) bool {\n        return people[i].Age < people[j].Age\n    })\n\n    for _, p := range people {\n        fmt.Printf(\"%s: %d\\n\", p.Name, p.Age)\n    }\n}\n```\n\n**Output:**\n```\nBob: 25\nAlice: 30\nCharlie: 35\n```\n\n**Summary:**  \nTo sort a slice of pointers in Go, use `sort.Slice` with a custom less function that dereferences the pointers as needed. This approach is flexible and works for any sorting criteria.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450269Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "e6e17083-fa7b-49a9-8b52-3a362d316944",
    "question": "How can you sort data in Go that does not fit into memory?",
    "answer": "```markdown To sort data in Go that does not fit into memory (external sorting), you typically use an **external sort** algorithm, such as an external merge sort. This approach involves breaking the data into manageable chunks, sorting each chunk individually, and then merging the sorted chunks. Here’s how you can approach this in Go:\n\n## Steps for External Sorting in Go\n\n1. **Divide the Data into Chunks**\n   - Read the data from the source (file, stream, etc.) in chunks that fit into memory.\n   - For each chunk:\n     - Load it into memory.\n     - Sort it using Go’s in-memory sorting (e.g., `sort.Slice`, `sort.Ints`, etc.).\n     - Write the sorted chunk to a temporary file.\n\n2. **Merge the Sorted Chunks**\n   - Open all the sorted chunk files.\n   - Use a min-heap (priority queue) to efficiently merge the sorted chunks:\n     - Read the smallest element from each chunk.\n     - Insert these elements into the heap.\n     - Repeatedly extract the smallest element from the heap and write it to the output.\n     - When you extract an element from a chunk, read the next element from that chunk and insert it into the heap.\n   - Continue until all chunks are fully merged.\n\n## Example Outline in Go\n\n```go\npackage main\n\nimport (\n    \"container/heap\"\n    \"os\"\n    // ... other imports\n)\n\n// Define a struct for heap elements and implement heap.Interface\n\nfunc main() {\n    // 1. Read and sort chunks, write to temp files\n    // 2. Open temp files and initialize heap\n    // 3. Merge chunks using heap, write to output\n}\n```\n\n*Note: Implementing a full external sort is a non-trivial task and requires careful management of file I/O and memory.*\n\n## Libraries and Tools\n\n- **No built-in external sort in Go**: You need to implement the logic yourself or use third-party libraries.\n- **Third-party options**: Libraries like [external-sort](https://github.com/gnames/external-sort) can help, or you can use Unix tools (e.g., `sort` command) from Go via `os/exec` if appropriate.\n\n## References\n\n- [External Sorting - Wikipedia](https://en.wikipedia.org/wiki/External_sorting)\n- [Go sort package](https://pkg.go.dev/sort)\n\n## Summary Table\n\n| Step         | Description                              |\n|--------------|------------------------------------------|\n| Chunking     | Split data into memory-sized chunks      |\n| Sorting      | Sort each chunk in memory                |\n| Saving       | Write sorted chunks to temporary files   |\n| Merging      | Merge sorted files using a min-heap      |\n\n---\n\n**In summary:**  \nTo sort data that does not fit into memory in Go, implement an external sort by chunking, sorting, saving, and merging using file I/O and a heap-based merge process. There is no built-in Go function for this, so you need to manage the process manually or use third-party tools.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450281Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "d3679726-6897-4b96-82d6-c9c8caf28aee",
    "question": "How do you benchmark the performance of different sorting algorithms in Go?",
    "answer": "```markdown\nTo benchmark the performance of different sorting algorithms in Go, you can use Go's built-in testing and benchmarking framework provided by the `testing` package. Here’s a step-by-step guide:\n\n### 1. Implement Sorting Algorithms\n\nSuppose you have two sorting functions: `BubbleSort` and `QuickSort`.\n\n```go\nfunc BubbleSort(arr []int) {\n    n := len(arr)\n    for i := 0; i < n; i++ {\n        for j := 0; j < n-i-1; j++ {\n            if arr[j] > arr[j+1] {\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n            }\n        }\n    }\n}\n\nfunc QuickSort(arr []int) {\n    if len(arr) < 2 {\n        return\n    }\n    left, right := 0, len(arr)-1\n    pivot := rand.Int() % len(arr)\n    arr[pivot], arr[right] = arr[right], arr[pivot]\n    for i := range arr {\n        if arr[i] < arr[right] {\n            arr[i], arr[left] = arr[left], arr[i]\n            left++\n        }\n    }\n    arr[left], arr[right] = arr[right], arr[left]\n    QuickSort(arr[:left])\n    QuickSort(arr[left+1:])\n}\n```\n\n### 2. Write Benchmark Functions\n\nCreate a file named `sort_bench_test.go` and write benchmark functions. Use `b.N` to run the sort multiple times for reliable results.\n\n```go\npackage main\n\nimport (\n    \"math/rand\"\n    \"testing\"\n)\n\nfunc generateRandomSlice(size int) []int {\n    arr := make([]int, size)\n    for i := range arr {\n        arr[i] = rand.Intn(100000)\n    }\n    return arr\n}\n\nfunc BenchmarkBubbleSort(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        arr := generateRandomSlice(1000)\n        BubbleSort(arr)\n    }\n}\n\nfunc BenchmarkQuickSort(b *testing.B) {\n    for i := 0; i < b.N; i++ {\n        arr := generateRandomSlice(1000)\n        QuickSort(arr)\n    }\n}\n```\n\n### 3. Run the Benchmarks\n\nUse the following command to run the benchmarks:\n\n```sh\ngo test -bench=.\n```\n\nThis will output the time taken per operation for each sorting algorithm, allowing you to compare their performance.\n\n### 4. Tips for Accurate Benchmarking\n\n- **Avoid side effects:** Make sure each benchmark iteration uses a fresh copy of the data.\n- **Use realistic data sizes:** Test with different array sizes to see how algorithms scale.\n- **Control randomness:** Use a fixed seed for reproducibility if needed.\n- **Profile memory:** Use `go test -bench=. -benchmem` to measure memory allocations.\n\n### 5. Example Output\n\n```\nBenchmarkBubbleSort-8        1    123456789 ns/op\nBenchmarkQuickSort-8      1000      123456 ns/op\n```\n\n### Summary\n\nBy leveraging Go's `testing` package and writing proper benchmark functions, you can systematically compare the performance of different sorting algorithms under various conditions.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450292Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "fbb3f655-3235-4940-b9de-741cad0127f1",
    "question": "What are the best practices for sorting large files in Go?",
    "answer": "```markdown\n## Best Practices for Sorting Large Files in Go\n\nSorting large files that do not fit entirely into memory requires special strategies beyond standard in-memory sorting. Here are some best practices for efficiently sorting large files in Go:\n\n### 1. Use External Sorting (External Merge Sort)\n- **Divide and Conquer:** Split the large file into manageable chunks that fit into memory.\n- **Sort Each Chunk:** Load each chunk into memory, sort it (using Go's `sort` package), and write the sorted chunk back to disk as a temporary file.\n- **Merge Chunks:** Use a k-way merge algorithm to merge all sorted chunks into a single sorted output file. This can be done efficiently using a min-heap (priority queue).\n\n### 2. Stream Data Efficiently\n- **Buffered I/O:** Use `bufio.Reader` and `bufio.Writer` for efficient reading and writing of large files.\n- **Line-by-Line Processing:** Process files line by line or in blocks to avoid loading the entire file into memory.\n\n### 3. Optimize Disk Usage\n- **Temporary Files:** Store intermediate sorted chunks as temporary files using `os.CreateTemp`.\n- **Clean Up:** Ensure temporary files are deleted after use to free up disk space.\n\n### 4. Parallel Processing\n- **Concurrent Sorting:** Sort different chunks in parallel using goroutines to utilize multiple CPU cores.\n- **Channel Communication:** Use channels to coordinate between goroutines for reading, sorting, and merging.\n\n### 5. Use Efficient Data Structures\n- **Heap for Merging:** Use `container/heap` for efficient k-way merging of sorted chunks.\n- **Custom Comparators:** Implement custom sorting logic by defining the `sort.Interface` for your data type.\n\n### 6. Handle Large Records\n- **Fixed vs. Variable Length:** If records are variable length, ensure your chunking logic does not split records.\n- **Serialization:** For complex data, use efficient serialization formats (e.g., CSV, JSON, or binary).\n\n### 7. Error Handling and Resource Management\n- **Graceful Error Handling:** Check for errors at every I/O operation.\n- **Resource Cleanup:** Use `defer` to close files and release resources.\n\n### Example Libraries and Tools\n- **sort package:** For in-memory sorting.\n- **container/heap:** For merging sorted chunks.\n- **github.com/cheggaaa/pb/v3:** For progress bars (optional).\n- **Third-party tools:** Consider using or learning from tools like [gosort](https://github.com/psilva261/gosort) for inspiration.\n\n### Sample Workflow\n\n```go\n// Pseudocode for external merge sort in Go\n1. Split the large file into N chunks.\n2. For each chunk:\n    a. Read into memory.\n    b. Sort using sort.Slice or sort.Sort.\n    c. Write sorted chunk to a temp file.\n3. Merge all sorted temp files into the final sorted output using a min-heap.\n```\n\n### References\n\n- [External Sorting - Wikipedia](https://en.wikipedia.org/wiki/External_sorting)\n- [Go sort package documentation](https://pkg.go.dev/sort)\n\n---\n\n**Summary:**  \nFor sorting large files in Go, use external merge sort, efficient buffered I/O, parallel processing, and proper resource management. Always handle errors and clean up temporary files. Use Go's standard library and consider third-party tools for inspiration.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450312Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "ed8236f3-8ea2-4ff7-9c67-31c45916085a",
    "question": "How do you sort a slice of interfaces in Go?",
    "answer": "```markdown To sort a slice of interfaces in Go, you need to implement the sort.Interface for your slice. The sort.Interface requires three methods: Len(), Less(i, j int) bool, and Swap(i, j int). Once implemented, you can use the sort.Sort function from the sort package.\n\nHere's an example of how to sort a slice of interface{} values (e.g., []interface{}) based on their integer values:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\n// Define a type for a slice of interface{}\ntype InterfaceSlice []interface{}\n\n// Implement sort.Interface\nfunc (s InterfaceSlice) Len() int {\n    return len(s)\n}\n\nfunc (s InterfaceSlice) Less(i, j int) bool {\n    // Type assertion to int for comparison\n    return s[i].(int) < s[j].(int)\n}\n\nfunc (s InterfaceSlice) Swap(i, j int) {\n    s[i], s[j] = s[j], s[i]\n}\n\nfunc main() {\n    // Example slice of interface{}\n    data := InterfaceSlice{5, 2, 9, 1, 7}\n\n    // Sort the slice\n    sort.Sort(data)\n\n    fmt.Println(data) // Output: [1 2 5 7 9]\n}\n```\n\n**Key Points:**\n- You must define how to compare elements in the Less method, usually via type assertion.\n- This approach works for any type, but you must handle type assertions and possible panics if types are mixed.\n- For custom types, adjust the Less method accordingly.\n\n**Note:**  \nIf you have a slice of a concrete type (e.g., []int, []string), you can use sort.Ints, sort.Strings, etc., directly. The above method is necessary when working with []interface{} or custom types.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450322Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "0c7be4fb-6d5d-4565-8404-5982f44e6df7",
    "question": "How does Go's sort.Search function relate to sorting algorithms?",
    "answer": "```markdown Go’s sort.Search function is not itself a sorting algorithm, but it is closely related to sorting and the use of sorted data. Here’s how:\n\n## Relationship to Sorting Algorithms\n\n- **Purpose**: `sort.Search` is used to perform efficient binary search operations on sorted data. It finds the smallest index `i` in the range `[0, n)` at which a user-defined condition is true.\n- **Precondition**: The data must already be sorted (or at least partitioned according to the search predicate) for `sort.Search` to work correctly. If the data is not sorted, the result is undefined.\n- **Sorting Algorithms**: Go provides several sorting algorithms (like `sort.Ints`, `sort.Strings`, and custom sorts using `sort.Sort`) to arrange data in order. After sorting, `sort.Search` can be used to quickly locate elements or insertion points.\n\n## Example\n\n```go\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    nums := []int{1, 3, 5, 7, 9}\n    // nums must be sorted for sort.Search to work correctly\n    x := 5\n    idx := sort.Search(len(nums), func(i int) bool { return nums[i] >= x })\n    if idx < len(nums) && nums[idx] == x {\n        fmt.Printf(\"Found %d at index %d\\n\", x, idx)\n    } else {\n        fmt.Printf(\"%d not found, can insert at index %d\\n\", x, idx)\n    }\n}\n```\n\n## Summary Table\n\n| Function         | Role                                 |\n|------------------|--------------------------------------|\n| `sort.Sort`      | Sorts data using a sorting algorithm |\n| `sort.Search`    | Searches in sorted data              |\n\n## Conclusion\n\n`sort.Search` is a binary search utility that relies on data being sorted—typically by a sorting algorithm provided by Go’s `sort` package. Sorting algorithms prepare data for efficient searching, and `sort.Search` leverages this order to perform fast lookups.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450337Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "401f1820-4a21-49af-85b3-efa7af10418f",
    "question": "What are the limitations of Go's built-in sorting functions?",
    "answer": "```markdown ### Limitations of Go's Built-in Sorting Functions\n\nGo's standard library provides convenient sorting functions in the `sort` package (e.g., `sort.Ints`, `sort.Strings`, `sort.Sort`, etc.). However, these built-in sorting functions have several limitations:\n\n1. **Limited to In-Place Sorting**\n   - The built-in functions sort slices in place and do not return a new sorted slice. This can be problematic if you need to preserve the original order.\n\n2. **No Support for Custom Comparators in Convenience Functions**\n   - Functions like `sort.Ints` and `sort.Strings` only work with basic types and do not allow custom comparison logic. For custom types or complex sorting criteria, you must implement the `sort.Interface`.\n\n3. **Requires Implementation of `sort.Interface`**\n   - For custom sorting, you must define a type that implements the `Len()`, `Less(i, j int)`, and `Swap(i, j int)` methods. This can be verbose and less ergonomic compared to languages that allow passing comparator functions directly.\n\n4. **No Built-in Stable Sort for Custom Types**\n   - While `sort.Stable` exists, it still requires you to implement `sort.Interface`. There are no convenience functions for stable sorting of slices of basic types.\n\n5. **No Built-in Support for Descending Order**\n   - The built-in functions sort in ascending order only. To sort in descending order, you must implement custom logic in the `Less` method.\n\n6. **Not Generic (Pre Go 1.18)**\n   - Prior to Go 1.18, sorting functions were not generic and required boilerplate code for each type. With Go 1.18+, generics can be used, but the standard library's sorting functions are not yet fully generic.\n\n7. **No Parallel Sorting**\n   - The built-in sorting algorithms are single-threaded and do not utilize multiple cores for large datasets.\n\n8. **No Built-in Support for Sorting Maps**\n   - Go maps are unordered, and the sort package does not provide direct support for sorting map keys or values.\n\n9. **No Direct Support for Multi-Level Sorting**\n   - For sorting by multiple fields (e.g., primary and secondary keys), you must implement custom logic in the `Less` method.\n\n---\n\n#### Example: Custom Sorting\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\ntype ByAge []Person\n\nfunc (a ByAge) Len() int           { return len(a) }\nfunc (a ByAge) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByAge) Less(i, j int) bool { return a[i].Age < a[j].Age }\n\n// Usage:\npeople := []Person{{\"Alice\", 30}, {\"Bob\", 25}}\nsort.Sort(ByAge(people))\n```\n\n---\n\n### Summary Table\n\n| Limitation                                 | Workaround/Note                                  |\n|---------------------------------------------|--------------------------------------------------|\n| In-place only                              | Manually copy slice before sorting               |\n| No custom comparator in convenience funcs  | Implement `sort.Interface`                       |\n| Requires `sort.Interface` for custom types | Boilerplate code needed                          |\n| No stable sort for basic types             | Use `sort.Stable` with custom type               |\n| No descending order                        | Reverse logic in `Less`                          |\n| Not generic (pre Go 1.18)                  | Use generics in Go 1.18+                         |\n| No parallel sorting                        | Implement custom parallel sort if needed         |\n| No map sorting                             | Extract keys/values and sort separately          |\n| No multi-level sorting                     | Implement logic in `Less`                        |\n\n---\n\n**In summary:**  \nGo's built-in sorting functions are efficient and easy for basic use cases, but they lack flexibility for more advanced or customized sorting needs. For complex scenarios, additional code or third-party libraries may be required.",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450357Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "c18b12c1-b9ec-442b-906d-6438e1b06254",
    "question": "How do you handle sorting with nil values in Go slices?",
    "answer": "```markdown\nHandling Sorting with Nil Values in Go Slices\n---------------------------------------------\n\nWhen sorting slices in Go that may contain `nil` values (for example, slices of pointers or interfaces), you need to define how `nil` should be ordered relative to non-`nil` values. The standard `sort` package does not handle `nil` values specially, so you must implement a custom `Less` function.\n\n### Example: Sorting a Slice of Pointers with Nil Values\n\nSuppose you have a slice of pointers to integers:\n\n```go\nnums := []*int{nil, ptr(3), ptr(1), nil, ptr(2)}\n```\n\nYou want to sort so that all `nil` values come first.\n\n#### Step 1: Define a Helper Function\n\n```go\nfunc ptr(i int) *int { return &i }\n```\n\n#### Step 2: Implement Custom Sort\n\n```go\nimport \"sort\"\n\nsort.Slice(nums, func(i, j int) bool {\n    // Place nils first\n    if nums[i] == nil && nums[j] != nil {\n        return true\n    }\n    if nums[i] != nil && nums[j] == nil {\n        return false\n    }\n    if nums[i] == nil && nums[j] == nil {\n        return false // keep original order\n    }\n    // Both non-nil: compare values\n    return *nums[i] < *nums[j]\n})\n```\n\n### Example: Sorting a Slice of Interfaces with Nil Values\n\nIf you have a slice of `interface{}` that may contain `nil`, you can use a similar approach:\n\n```go\nsort.Slice(data, func(i, j int) bool {\n    if data[i] == nil && data[j] != nil {\n        return true\n    }\n    if data[i] != nil && data[j] == nil {\n        return false\n    }\n    if data[i] == nil && data[j] == nil {\n        return false\n    }\n    // Add type assertion and comparison logic here\n    return data[i].(int) < data[j].(int)\n})\n```\n\n### Key Points\n\n- Always check for `nil` before dereferencing pointers or asserting types.\n- Decide whether `nil` should come first or last.\n- The same pattern applies for custom types and structs with pointer fields.\n\n### Summary\n\nTo handle sorting with `nil` values in Go slices, use `sort.Slice` (or implement `sort.Interface`) with a custom comparison function that explicitly checks for `nil` and defines the desired ordering.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450368Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "7c94616a-31a1-48a0-bb71-ae05db4d6478",
    "question": "How do you sort multi-dimensional slices in Go?",
    "answer": "```markdown\nTo sort multi-dimensional slices (e.g., `[][]int`) in Go, you can use the `sort.Slice` function from the `sort` package. This function allows you to define a custom less function, which is ideal for sorting slices of slices based on one or more criteria.\n\n### Example: Sorting a Slice of Slices by the First Element\n\nSuppose you have the following data:\n\n```go\ndata := [][]int{\n    {3, 4, 5},\n    {1, 2, 3},\n    {2, 3, 4},\n}\n```\n\nTo sort `data` by the first element of each inner slice:\n\n```go\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    data := [][]int{\n        {3, 4, 5},\n        {1, 2, 3},\n        {2, 3, 4},\n    }\n\n    sort.Slice(data, func(i, j int) bool {\n        return data[i][0] < data[j][0]\n    })\n\n    fmt.Println(data)\n}\n```\n\n**Output:**\n```\n[[1 2 3] [2 3 4] [3 4 5]]\n```\n\n### Sorting by Multiple Elements (Lexicographical Order)\n\nTo sort lexicographically (by the first element, then the second, etc.):\n\n```go\nsort.Slice(data, func(i, j int) bool {\n    for k := 0; k < len(data[i]) && k < len(data[j]); k++ {\n        if data[i][k] != data[j][k] {\n            return data[i][k] < data[j][k]\n        }\n    }\n    return len(data[i]) < len(data[j])\n})\n```\n\n### Sorting in Descending Order\n\nReverse the comparison:\n\n```go\nsort.Slice(data, func(i, j int) bool {\n    return data[i][0] > data[j][0]\n})\n```\n\n### Summary\n\n- Use `sort.Slice` for custom sorting logic.\n- Define the comparison based on your sorting criteria (single or multiple elements).\n- This approach works for any multi-dimensional slice (e.g., `[][]string`, `[][]float64`).\n\n**References:**\n- [sort.Slice documentation](https://pkg.go.dev/sort#Slice)\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450379Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  },
  {
    "id": "da3b43b9-c5ae-4ffe-ba47-2130cad4e91c",
    "question": "How do you implement a custom comparator for sorting in Go?",
    "answer": "```markdown\nTo implement a custom comparator for sorting in Go, you need to define a type that implements the `sort.Interface`, which requires three methods: `Len()`, `Less(i, j int)`, and `Swap(i, j int)`. The `Less(i, j int)` method acts as the custom comparator, determining the sorting order.\n\n### Example: Sorting a Slice of Structs with a Custom Comparator\n\nSuppose you have a slice of `Person` structs and want to sort them by age in descending order:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// ByAgeDesc implements sort.Interface for []Person based on the Age field (descending).\ntype ByAgeDesc []Person\n\nfunc (a ByAgeDesc) Len() int           { return len(a) }\nfunc (a ByAgeDesc) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByAgeDesc) Less(i, j int) bool { return a[i].Age > a[j].Age } // Descending\n\nfunc main() {\n    people := []Person{\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 35},\n    }\n\n    sort.Sort(ByAgeDesc(people))\n\n    fmt.Println(people)\n}\n```\n\n### Using `sort.Slice` for Inline Comparators\n\nGo 1.8+ provides `sort.Slice`, which allows you to define the comparator inline using a closure:\n\n```go\nsort.Slice(people, func(i, j int) bool {\n    return people[i].Age > people[j].Age // Descending\n})\n```\n\n### Summary\n\n- Implement `sort.Interface` for your type and define the `Less` method as your custom comparator.\n- Alternatively, use `sort.Slice` for an inline comparator function.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T12:16:44.450390Z",
    "topic": "72779b51-719d-44b7-a558-9fe3c3ed7d16"
  }
]
