[
  {
    "id": "algo-1",
    "question": "Implement a function to reverse a linked list.",
    "answer": {
      "type": "code",
      "language": "javascript",
      "content": "/**\n * Definition for singly-linked list node\n */\nclass ListNode {\n  constructor(val = 0, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\n/**\n * Reverses a singly linked list\n * Time Complexity: O(n)\n * Space Complexity: O(1)\n * \n * @param {ListNode} head - Head of the linked list\n * @return {ListNode} - Head of the reversed linked list\n */\nfunction reverseLinkedList(head) {\n  let prev = null;\n  let current = head;\n  \n  while (current !== null) {\n    // Save next node\n    const next = current.next;\n    \n    // Reverse pointer\n    current.next = prev;\n    \n    // Move pointers one step forward\n    prev = current;\n    current = next;\n  }\n  \n  // prev is the new head\n  return prev;\n}\n\n// Example usage:\n// const list = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4))));\n// const reversed = reverseLinkedList(list);\n// Output: 4 -> 3 -> 2 -> 1 -> null"
    }
  },
  {
    "id": "algo-2",
    "question": "Implement a function to find if a binary tree is balanced.",
    "answer": {
      "type": "code",
      "language": "javascript",
      "content": "/**\n * Definition for a binary tree node\n */\nclass TreeNode {\n  constructor(val = 0, left = null, right = null) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * Determines if a binary tree is height-balanced.\n * A height-balanced tree is a tree in which the left and right subtrees \n * of every node differ in height by no more than 1.\n * \n * Time Complexity: O(n) where n is the number of nodes in the tree\n * Space Complexity: O(h) where h is the height of the tree (due to recursion stack)\n * \n * @param {TreeNode} root - Root of the binary tree\n * @return {boolean} - Whether the tree is balanced or not\n */\nfunction isBalanced(root) {\n  // Function returns -1 if the tree is unbalanced, otherwise returns the height\n  function checkHeight(node) {\n    if (node === null) return 0;\n    \n    const leftHeight = checkHeight(node.left);\n    if (leftHeight === -1) return -1; // Left subtree is unbalanced\n    \n    const rightHeight = checkHeight(node.right);\n    if (rightHeight === -1) return -1; // Right subtree is unbalanced\n    \n    // Check if current node is balanced\n    if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n    \n    // Return height of current subtree\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n  \n  return checkHeight(root) !== -1;\n}\n\n// Example usage:\n// const balancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4), new TreeNode(5)), new TreeNode(3));\n// console.log(isBalanced(balancedTree)); // true\n//\n// const unbalancedTree = new TreeNode(1, new TreeNode(2, new TreeNode(4, new TreeNode(8))), new TreeNode(3));\n// console.log(isBalanced(unbalancedTree)); // false"
    }
  }
]
