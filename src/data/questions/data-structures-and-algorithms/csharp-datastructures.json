[
  {
    "id": "590651ef-446f-4f80-b8da-13f501f25789",
    "question": "How do you add and remove elements from a List in C#?",
    "answer": "```markdown\nTo **add** and **remove** elements from a `List` in C#, you can use the following methods:\n\n### Adding Elements\n\n- **Add an element:**\n  ```csharp\n  List<int> numbers = new List<int>();\n  numbers.Add(10); // Adds 10 to the list\n  ```\n\n- **Add multiple elements:**\n  ```csharp\n  numbers.AddRange(new int[] { 20, 30 }); // Adds 20 and 30 to the list\n  ```\n\n### Removing Elements\n\n- **Remove by value:**\n  ```csharp\n  numbers.Remove(10); // Removes the first occurrence of 10 from the list\n  ```\n\n- **Remove by index:**\n  ```csharp\n  numbers.RemoveAt(0); // Removes the element at index 0\n  ```\n\n- **Remove all matching a condition:**\n  ```csharp\n  numbers.RemoveAll(n => n > 15); // Removes all elements greater than 15\n  ```\n\n- **Clear all elements:**\n  ```csharp\n  numbers.Clear(); // Removes all elements from the list\n  ```\n\n**Summary:**  \nUse `Add()` or `AddRange()` to add elements, and `Remove()`, `RemoveAt()`, `RemoveAll()`, or `Clear()` to remove elements from a `List` in C#.\n```",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252038Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "867e8993-50a0-4d71-8bf6-779170a92b08",
    "question": "What is the purpose of the HashSet collection in C#?",
    "answer": "```markdown **Answer:**\n\nThe `HashSet` collection in C# is used to store a set of unique elements, meaning it automatically prevents duplicate values. It is part of the `System.Collections.Generic` namespace and is implemented using a hash table for fast lookups, additions, and deletions. The main purposes of using a `HashSet` are:\n\n- **Ensuring uniqueness:** No duplicate items are allowed.\n- **Efficient operations:** Provides fast operations for adding, removing, and checking if an item exists (typically O(1) time complexity).\n- **Set operations:** Supports mathematical set operations like union, intersection, and difference.\n\n**Example:**\n```csharp\nHashSet<int> numbers = new HashSet<int>();\nnumbers.Add(1);\nnumbers.Add(2);\nnumbers.Add(2); // Duplicate, will not be added\n\nConsole.WriteLine(numbers.Count); // Output: 2\n```\n\n**Summary:**  \n`HashSet` is ideal when you need to store unique items and perform fast lookups or set-based operations.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252050Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "82e4f1d7-a266-4bb9-a15d-3121e60e3523",
    "question": "How do you iterate through a Dictionary in C#?",
    "answer": "```markdown You can iterate through a Dictionary in C# using a foreach loop. The Dictionary<TKey, TValue> class implements IEnumerable, allowing you to loop through its key-value pairs. Here’s a simple example:\n\n```csharp\nDictionary<string, int> ages = new Dictionary<string, int>\n{\n    { \"Alice\", 30 },\n    { \"Bob\", 25 },\n    { \"Charlie\", 35 }\n};\n\nforeach (KeyValuePair<string, int> entry in ages)\n{\n    Console.WriteLine($\"Name: {entry.Key}, Age: {entry.Value}\");\n}\n```\n\nAlternatively, you can iterate through just the keys or just the values:\n\n```csharp\n// Iterate through keys\nforeach (string name in ages.Keys)\n{\n    Console.WriteLine(name);\n}\n\n// Iterate through values\nforeach (int age in ages.Values)\n{\n    Console.WriteLine(age);\n}\n```\n\n**Summary:**  \n- Use foreach with KeyValuePair<TKey, TValue> to access both keys and values.\n- Use .Keys or .Values to iterate through only keys or only values.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252063Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "97ef8e21-fdf1-4fdd-b850-fcb6c344f9b2",
    "question": "What is the difference between an array and a List in C#?",
    "answer": "```markdown **Answer:**\n\nIn C#, both arrays and Lists are used to store collections of items, but they have some key differences:\n\n| Feature         | Array                                     | List (List<T>)                             |\n|-----------------|-------------------------------------------|--------------------------------------------|\n| Size            | Fixed size (set at creation)              | Dynamic size (can grow or shrink)          |\n| Type            | Can be single or multi-dimensional        | Always single-dimensional                  |\n| Performance     | Slightly faster for fixed-size collections| Slightly slower due to dynamic resizing    |\n| Flexibility     | Limited (cannot add/remove elements)      | Flexible (can add, remove, insert, etc.)   |\n| Syntax Example  | `int[] numbers = new int[5];`             | `List<int> numbers = new List<int>();`     |\n| Namespace       | Built-in                                  | Requires `using System.Collections.Generic;`|\n\n**Summary:**  \nUse an array when you know the number of elements in advance and it won’t change. Use a List when you need a collection that can change size during runtime.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.251970Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "f3855453-a931-422d-83a6-cb01f9f97d55",
    "question": "How do you declare and initialize a Dictionary in C#?",
    "answer": "```markdown\nTo declare and initialize a Dictionary in C#, you use the `Dictionary<TKey, TValue>` class from the `System.Collections.Generic` namespace. Here’s a simple example:\n\n```csharp\n// Declare and initialize a Dictionary with string keys and int values\nDictionary<string, int> ages = new Dictionary<string, int>()\n{\n    { \"Alice\", 30 },\n    { \"Bob\", 25 },\n    { \"Charlie\", 35 }\n};\n```\n\n- `string` is the type of the key.\n- `int` is the type of the value.\n- The curly braces `{}` are used to add key-value pairs during initialization.\n\nYou can also add items later using the `Add` method:\n\n```csharp\nages.Add(\"David\", 28);\n```\n```",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252011Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "bbb11475-1e3b-4235-99c3-0bade86550d9",
    "question": "What are the main differences between Stack and Queue in C#?",
    "answer": "```markdown **Answer:**\n\nThe main differences between Stack and Queue in C# are:\n\n| Feature         | Stack                                | Queue                                 |\n|-----------------|--------------------------------------|---------------------------------------|\n| Order           | Last-In, First-Out (LIFO)            | First-In, First-Out (FIFO)            |\n| Main Methods    | Push (add), Pop (remove), Peek       | Enqueue (add), Dequeue (remove), Peek |\n| Usage Example   | Undo functionality, expression parsing| Print job scheduling, task processing  |\n| Namespace       | System.Collections.Generic.Stack<T>  | System.Collections.Generic.Queue<T>    |\n\n**Summary:**  \n- **Stack**: The last element added is the first one to be removed.\n- **Queue**: The first element added is the first one to be removed.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252026Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "a5877084-f8a9-4f83-ad11-e04c8ece4cf9",
    "question": "What is the difference between IEnumerable and ICollection interfaces?",
    "answer": "```markdown **Difference between IEnumerable and ICollection interfaces in C#:**\n\n| Feature          | IEnumerable                          | ICollection                                 |\n|------------------|--------------------------------------|---------------------------------------------|\n| **Namespace**    | System.Collections                   | System.Collections, System.Collections.Generic |\n| **Purpose**      | Enables simple iteration over a collection (read-only access). | Extends IEnumerable; represents a collection of objects that can be enumerated, and supports additional operations like add, remove, and count. |\n| **Key Members**  | `IEnumerator GetEnumerator()`        | Inherits `GetEnumerator()`; adds `Count`, `Add()`, `Remove()`, `Clear()`, `Contains()`, `CopyTo()` |\n| **Modification** | Does not support modifying the collection. | Supports modifying the collection (if not read-only). |\n| **Count Property** | Not available                       | Available (`Count`)                          |\n| **Usage**        | Used for read-only iteration (e.g., `foreach`). | Used when you need to modify the collection or need to know its size. |\n\n**Example:**\n\n```csharp\nIEnumerable<int> enumerable = new List<int> { 1, 2, 3 };\nforeach (var item in enumerable)\n{\n    // Can only read items\n}\n\nICollection<int> collection = new List<int> { 1, 2, 3 };\ncollection.Add(4);    // Can add items\nint count = collection.Count; // Can get count\n```\n\n**Summary:**  \n- Use `IEnumerable` for simple, read-only iteration.\n- Use `ICollection` when you need to modify the collection or access its size.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252078Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "6c2b52c1-14e2-4020-98bf-f6569b3511bc",
    "question": "Explain the concept of boxing and unboxing in the context of C# collections.",
    "answer": "```markdown ### Boxing and Unboxing in C# Collections\n\n**Boxing** and **unboxing** are concepts in C# that deal with converting value types (like `int`, `double`, `struct`, etc.) to reference types (`object`) and vice versa.\n\n#### Boxing\n\n- **Definition:** Boxing is the process of converting a value type to an object type (reference type).\n- **How it works:** The value is wrapped inside a System.Object and stored on the heap instead of the stack.\n- **Example:**\n    ```csharp\n    int num = 42;\n    object boxedNum = num; // Boxing\n    ```\n\n#### Unboxing\n\n- **Definition:** Unboxing is the process of extracting the value type from the object.\n- **How it works:** The object is explicitly cast back to the original value type.\n- **Example:**\n    ```csharp\n    object boxedNum = 42;\n    int num = (int)boxedNum; // Unboxing\n    ```\n\n#### Boxing and Unboxing in Collections\n\nBefore the introduction of generics in C#, collections like `ArrayList` could only store objects of type `object`. When you added a value type (e.g., `int`) to such a collection, it was **boxed**. When retrieving it, you had to **unbox** it.\n\n**Example using ArrayList:**\n```csharp\nArrayList list = new ArrayList();\nint x = 10;\nlist.Add(x); // Boxing occurs here\n\nint y = (int)list[0]; // Unboxing occurs here\n```\n\n**Drawbacks:**\n- **Performance Overhead:** Boxing and unboxing are computationally expensive because they involve copying and type conversion.\n- **Type Safety:** Unboxing requires explicit casting, which can lead to runtime errors if the types do not match.\n\n#### Modern Approach: Generics\n\nWith the introduction of generics (e.g., `List<int>`), boxing and unboxing can be avoided because generics allow collections to store value types directly, improving performance and type safety.\n\n**Example using List<int>:**\n```csharp\nList<int> list = new List<int>();\nlist.Add(10); // No boxing\nint y = list[0]; // No unboxing\n```\n\n---\n\n**Summary:**  \nBoxing and unboxing are important concepts when working with non-generic collections in C#. They allow value types to be stored in collections that expect reference types, but at the cost of performance and type safety. Using generic collections is the recommended approach to avoid these issues.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252091Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "7202413b-9569-4a0a-ba1a-c5335bf2c4dc",
    "question": "How do you sort a List of custom objects in C#?",
    "answer": "```markdown To sort a List of custom objects in C#, you can use the List<T>.Sort() method. There are two common approaches:\n\n### 1. Implementing IComparable<T> in Your Class\n\nImplement the IComparable<T> interface in your custom class and define the comparison logic in the CompareTo method.\n\n```csharp\npublic class Person : IComparable<Person>\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n\n    public int CompareTo(Person other)\n    {\n        // Sort by Age\n        return this.Age.CompareTo(other.Age);\n    }\n}\n\n// Usage\nList<Person> people = new List<Person>\n{\n    new Person { Name = \"Alice\", Age = 30 },\n    new Person { Name = \"Bob\", Age = 25 }\n};\n\npeople.Sort(); // Sorts by Age\n```\n\n### 2. Using a Custom Comparer or Lambda Expression\n\nYou can also pass a custom comparison delegate or use a lambda expression with the Sort method.\n\n```csharp\nList<Person> people = new List<Person>\n{\n    new Person { Name = \"Alice\", Age = 30 },\n    new Person { Name = \"Bob\", Age = 25 }\n};\n\n// Sort by Name\npeople.Sort((p1, p2) => p1.Name.CompareTo(p2.Name));\n```\n\n### Summary\n\n- Implement `IComparable<T>` for default sorting.\n- Use a custom `IComparer<T>` or a lambda for flexible, on-the-fly sorting.\n\nThis allows you to sort lists of custom objects based on any property or custom logic you need.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252104Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "357af23e-16e4-4081-902d-d7b8c34709ae",
    "question": "What is the difference between List<T> and LinkedList<T> in C#?",
    "answer": "```markdown\n**Difference between `List<T>` and `LinkedList<T>` in C#:**\n\n| Feature                | `List<T>`                                   | `LinkedList<T>`                             |\n|------------------------|---------------------------------------------|---------------------------------------------|\n| **Underlying Structure** | Backed by a dynamic array                   | Doubly linked list                          |\n| **Access Time**        | O(1) for index-based access (`list[i]`)     | O(n) for access by index                    |\n| **Insertion/Removal**  | O(n) for insert/remove (except at end)      | O(1) for insert/remove at known node        |\n| **Memory Overhead**    | Less (just array + a few fields)            | More (each node stores references to next/prev) |\n| **Random Access**      | Supported (via index)                       | Not supported                               |\n| **Best Use Case**      | Frequent access by index, few insertions/removals except at end | Frequent insertions/removals in the middle or at both ends |\n\n**Summary:**  \n- Use `List<T>` when you need fast random access and mostly add/remove at the end.\n- Use `LinkedList<T>` when you need fast insertions/removals at both ends or in the middle, and don't need index-based access.\n```",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252118Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "981f7375-a1ce-4152-9113-c7b91a6a167e",
    "question": "When would you use a Dictionary over a List in C#?",
    "answer": "```markdown You would use a `Dictionary` over a `List` in C# when you need to store and quickly retrieve values based on a unique key, rather than by their position (index) in a collection.\n\n### Key Differences\n\n- **Dictionary**\n  - Stores key-value pairs.\n  - Provides fast lookups, additions, and deletions based on the key (on average O(1) time complexity).\n  - Keys must be unique.\n  - Useful when you need to associate data (e.g., mapping employee IDs to employee records).\n\n- **List**\n  - Stores items in a sequential order.\n  - Accessed by index (integer position).\n  - Searching for an item by value is O(n) time complexity.\n  - Useful when order matters or when you need to iterate through all items.\n\n### Example Scenario\n\n- **Use a Dictionary:** When you need to look up a student's record by their unique student ID.\n- **Use a List:** When you need to maintain a collection of items in a specific order, such as a list of tasks to complete.\n\n### Sample Code\n\n```csharp\n// Using a Dictionary for fast lookups by key\nDictionary<int, string> studentNames = new Dictionary<int, string>();\nstudentNames[101] = \"Alice\";\nstudentNames[102] = \"Bob\";\n\n// Using a List for ordered collection\nList<string> taskList = new List<string>();\ntaskList.Add(\"Do laundry\");\ntaskList.Add(\"Write report\");\n```\n\n**In summary:**  \nUse a `Dictionary` when you need efficient key-based access, and a `List` when you need ordered, index-based access.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252130Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "657339f3-b074-44aa-8e2d-1ce69c3188b8",
    "question": "How does the capacity of a List<T> work and how can it affect performance?",
    "answer": "```markdown\n**How does the capacity of a List<T> work and how can it affect performance?**\n\nThe `List<T>` class in C# is a dynamic array that manages an internal array to store its elements. The **capacity** of a `List<T>` refers to the number of elements the internal array can hold before it needs to resize. The **Count** property, on the other hand, represents the actual number of elements in the list.\n\n### How Capacity Works\n\n- When you create a new `List<T>`, it has a default capacity (usually 0 or a small number).\n- As you add elements, if the number of elements exceeds the current capacity, the `List<T>` automatically resizes its internal array.\n- The resizing process typically involves allocating a new, larger array (usually double the previous capacity), copying existing elements to the new array, and then discarding the old array.\n\n### Performance Implications\n\n- **Resizing Overhead:** Each time the capacity is exceeded, resizing occurs, which is an O(n) operation (where n is the number of elements in the list). Frequent resizing can degrade performance, especially if you add a large number of items one by one.\n- **Memory Usage:** If you set the capacity much higher than needed, memory is allocated but unused, leading to wasted resources.\n- **Optimization:** If you know the approximate number of items in advance, you can set the capacity using the constructor or the `Capacity` property to minimize resizing operations.\n\n### Example\n\n```csharp\nList<int> numbers = new List<int>(1000); // sets initial capacity to 1000\n```\n\n### Best Practices\n\n- **Set Capacity When Possible:** If you know the number of elements ahead of time, set the capacity to avoid multiple resizes.\n- **Trim Excess:** After removing a large number of elements, you can call `TrimExcess()` to reduce the capacity and free unused memory.\n\n### Summary Table\n\n| Property      | Description                                 |\n|---------------|---------------------------------------------|\n| Capacity      | Number of elements the list can hold        |\n| Count         | Number of elements actually in the list     |\n| TrimExcess()  | Reduces capacity to match the count         |\n\n**In summary:** The capacity of a `List<T>` determines how many elements it can hold before resizing. Managing capacity wisely can improve performance by reducing the number of costly resizing operations and optimizing memory usage.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252149Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "7f0555c4-a4d8-48f8-9ef9-79232af8cf84",
    "question": "What is the difference between a shallow copy and a deep copy of a collection?",
    "answer": "```markdown **Difference Between Shallow Copy and Deep Copy of a Collection in C#:**\n\n- **Shallow Copy:**\n  - A shallow copy of a collection copies the references of the objects in the collection, not the actual objects themselves.\n  - Both the original and the copied collection point to the same objects in memory.\n  - Modifying an object in one collection will reflect in the other.\n  - Example: Using `MemberwiseClone()` or the `Clone()` method of some collections.\n\n  ```csharp\n  List<Person> originalList = new List<Person> { new Person(\"Alice\"), new Person(\"Bob\") };\n  List<Person> shallowCopy = new List<Person>(originalList);\n  shallowCopy[0].Name = \"Charlie\";\n  // originalList[0].Name is now \"Charlie\" as well\n  ```\n\n- **Deep Copy:**\n  - A deep copy creates new instances of the objects in the collection, recursively copying all objects.\n  - The original and copied collections are completely independent.\n  - Modifying an object in one collection does not affect the other.\n  - Deep copy usually requires custom implementation, such as serialization or manual cloning.\n\n  ```csharp\n  List<Person> originalList = new List<Person> { new Person(\"Alice\"), new Person(\"Bob\") };\n  List<Person> deepCopy = originalList.Select(p => new Person(p.Name)).ToList();\n  deepCopy[0].Name = \"Charlie\";\n  // originalList[0].Name remains \"Alice\"\n  ```\n\n**Summary Table:**\n\n| Aspect           | Shallow Copy                                         | Deep Copy                                         |\n|------------------|-----------------------------------------------------|---------------------------------------------------|\n| Object References| Copied                                              | Not copied (new objects created)                  |\n| Independence     | Not independent (shared objects)                    | Completely independent                            |\n| Use Case         | Fast, but risky if objects are mutable              | Safe, but may be slower and require more coding   |\n\n**In short:**  \n- Shallow copy duplicates the collection structure, but not the objects inside.\n- Deep copy duplicates both the collection and the objects it contains.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252161Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "cb354713-ab4d-4541-badc-2579b6367ac5",
    "question": "Explain how a HashSet ensures uniqueness of its elements.",
    "answer": "```markdown A `HashSet` in C# ensures uniqueness of its elements using the following mechanisms:\n\n1. **Hashing**:  \n   When you add an element to a `HashSet`, it computes the element’s hash code using its `GetHashCode()` method. This hash code determines the bucket in which the element will be stored.\n\n2. **Equality Comparison**:  \n   If two elements have the same hash code (a hash collision), the `HashSet` uses the `Equals()` method to check if the elements are actually equal.\n\n3. **No Duplicates Allowed**:  \n   Before adding a new element, the `HashSet` checks if an element with the same hash code and considered equal (via `Equals()`) already exists in the set. If it does, the new element is not added.\n\n**Summary Table:**\n\n| Step             | Method Used         | Purpose                                  |\n|------------------|--------------------|------------------------------------------|\n| Hashing          | `GetHashCode()`    | Find bucket for element                  |\n| Equality Check   | `Equals()`         | Confirm if elements are truly identical  |\n| Uniqueness Check | -                  | Prevent duplicate entries                |\n\n**Example:**\n```csharp\nHashSet<string> set = new HashSet<string>();\nset.Add(\"apple\");   // Added\nset.Add(\"banana\");  // Added\nset.Add(\"apple\");   // Not added (duplicate)\n```\nAfter these operations, `set` contains only `\"apple\"` and `\"banana\"`.\n\n**Conclusion:**  \nA `HashSet` relies on hashing and equality checks to ensure that each element is unique within the collection.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252174Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "ee6c48a0-e7e0-4cf8-b8f4-63b8c0a7ec20",
    "question": "What is the time complexity of searching for an element in a Dictionary?",
    "answer": "```markdown\nThe time complexity of searching for an element in a `Dictionary` in C# is **O(1)** on average. This is because a `Dictionary` is implemented as a hash table, which allows for constant-time lookup operations under typical circumstances.\n\nHowever, in the worst case—such as when many elements hash to the same bucket—the time complexity can degrade to **O(n)**, where *n* is the number of elements in the dictionary. This situation is rare due to good hash functions and resizing strategies.\n\n**Summary:**\n- **Average case:** O(1)\n- **Worst case:** O(n)\n```",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252187Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "e4ad9803-6934-45e3-a7c6-87228b7a3dce",
    "question": "How do you implement a custom comparer for sorting objects in a collection?",
    "answer": "```markdown To implement a custom comparer for sorting objects in a collection in C#, you can use the IComparer<T> interface. This allows you to define custom sorting logic for your objects. Here’s how you can do it:\n\n### 1. Define Your Class\n\nSuppose you have a simple class:\n\n```csharp\npublic class Person\n{\n    public string Name { get; set; }\n    public int Age { get; set; }\n}\n```\n\n### 2. Implement a Custom Comparer\n\nCreate a class that implements `IComparer<Person>` and define the comparison logic in the `Compare` method:\n\n```csharp\npublic class AgeComparer : IComparer<Person>\n{\n    public int Compare(Person x, Person y)\n    {\n        if (x == null || y == null)\n            throw new ArgumentException(\"Arguments cannot be null.\");\n\n        // Sort by Age in ascending order\n        return x.Age.CompareTo(y.Age);\n    }\n}\n```\n\n### 3. Use the Comparer to Sort a Collection\n\nYou can now use your custom comparer with sorting methods, such as `List<T>.Sort`:\n\n```csharp\nList<Person> people = new List<Person>\n{\n    new Person { Name = \"Alice\", Age = 30 },\n    new Person { Name = \"Bob\", Age = 25 },\n    new Person { Name = \"Charlie\", Age = 35 }\n};\n\npeople.Sort(new AgeComparer());\n\n// The 'people' list is now sorted by Age in ascending order\n```\n\n### 4. Alternative: Using Lambda Expressions\n\nFor simple cases, you can also use a lambda expression with the `Sort` method:\n\n```csharp\npeople.Sort((x, y) => x.Age.CompareTo(y.Age));\n```\n\n---\n\n**Summary:**  \nTo implement a custom comparer, create a class that implements `IComparer<T>`, override the `Compare` method with your custom logic, and use it with collection sorting methods. This approach gives you full control over how objects are compared and sorted.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252199Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "79873fb2-2c3d-4e40-9510-ba28e4e9e1c2",
    "question": "What are the advantages and disadvantages of using arrays in C#?",
    "answer": "```markdown **Advantages of Using Arrays in C#:**\n\n- **Fixed Size:** Arrays have a fixed size, which makes memory allocation efficient and predictable.\n- **Fast Access:** Elements can be accessed directly using their index, resulting in fast retrieval and update operations (O(1) time complexity).\n- **Simple Syntax:** Arrays are easy to declare and use, making them suitable for straightforward data storage needs.\n- **Type Safety:** Arrays are strongly typed, so all elements must be of the same type, reducing runtime errors.\n\n**Disadvantages of Using Arrays in C#:**\n\n- **Fixed Size:** Once created, the size of an array cannot be changed, making it less flexible if the number of elements is not known in advance.\n- **Insertion/Deletion Overhead:** Adding or removing elements (except at the end) requires shifting elements, which can be inefficient (O(n) time complexity).\n- **Wasted Memory:** If the array is not fully utilized, it can lead to wasted memory.\n- **No Built-in Methods:** Arrays lack many built-in methods for common operations (like searching, sorting, or resizing) that are available in other data structures like List<T>.\n\n**Summary Table:**\n\n| Advantage           | Disadvantage           |\n|---------------------|-----------------------|\n| Fast access (O(1))  | Fixed size            |\n| Simple to use       | Costly insert/delete  |\n| Type safe           | Wasted memory         |\n| Efficient memory    | Limited functionality |",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252212Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "e312d903-636a-4c78-addf-e64989c9d6c6",
    "question": "How do you remove duplicate elements from a List in C#?",
    "answer": "```markdown To remove duplicate elements from a List in C#, you can use the Distinct() method provided by LINQ. This method returns a new collection with only unique elements.\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 2, 3, 4, 4, 5 };\n        List<int> uniqueNumbers = numbers.Distinct().ToList();\n\n        Console.WriteLine(string.Join(\", \", uniqueNumbers)); // Output: 1, 2, 3, 4, 5\n    }\n}\n```\n\n**Explanation:**\n- `Distinct()` filters out duplicate elements.\n- `ToList()` converts the result back to a List.\n\n**Note:**  \nIf you are working with custom objects, you may need to implement `IEquatable<T>` or override `Equals()` and `GetHashCode()` for `Distinct()` to work as expected.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252225Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "af3a20d3-ab98-4a09-ac63-e000c516362c",
    "question": "What is the difference between ConcurrentDictionary and Dictionary?",
    "answer": "```markdown\n**Difference between `ConcurrentDictionary` and `Dictionary` in C#:**\n\n| Feature                    | `Dictionary<TKey, TValue>`                         | `ConcurrentDictionary<TKey, TValue>`                |\n|----------------------------|---------------------------------------------------|-----------------------------------------------------|\n| **Thread Safety**          | Not thread-safe. Concurrent read/write operations can cause exceptions or data corruption. | Thread-safe. Designed for concurrent access from multiple threads without external synchronization. |\n| **Performance**            | Faster in single-threaded scenarios due to lack of synchronization overhead. | Slightly slower in single-threaded scenarios due to internal locking, but scales well with multiple threads. |\n| **Locking Mechanism**      | No built-in locking. Developers must implement their own synchronization (e.g., `lock` statements). | Uses fine-grained locking and lock-free techniques internally to allow safe concurrent operations. |\n| **Methods for Atomicity**  | No atomic operations. Composite operations (e.g., check-then-add) are not atomic. | Provides atomic methods like `GetOrAdd`, `AddOrUpdate`, and `TryUpdate` for safe composite operations. |\n| **Use Case**               | Suitable for single-threaded or externally synchronized scenarios. | Ideal for multi-threaded scenarios where multiple threads read/write concurrently. |\n| **Namespace**              | `System.Collections.Generic`                      | `System.Collections.Concurrent`                     |\n\n**Summary:**  \nUse `Dictionary` when thread safety is not a concern or when you handle synchronization externally. Use `ConcurrentDictionary` when you need a thread-safe collection for concurrent read/write operations without manual locking.\n```",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252237Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "15b20261-746c-4981-9c65-7809f5b74258",
    "question": "How does the SortedDictionary differ from Dictionary in C#?",
    "answer": "```markdown **Answer:**\n\nIn C#, both `Dictionary<TKey, TValue>` and `SortedDictionary<TKey, TValue>` are collections that store key-value pairs, but they differ in how they store and access data:\n\n| Feature                | Dictionary<TKey, TValue>                | SortedDictionary<TKey, TValue>           |\n|------------------------|-----------------------------------------|------------------------------------------|\n| **Ordering**           | No guaranteed order of elements         | Elements are sorted by key               |\n| **Underlying Structure** | Hash table                             | Binary search tree (Red-Black tree)      |\n| **Performance (Lookup/Insert/Remove)** | O(1) average case, O(n) worst case | O(log n)                                 |\n| **Key Requirements**   | Keys must be unique and hashable        | Keys must be unique and comparable (IComparable or IComparer) |\n| **Use Case**           | Fast lookups without caring about order | When you need sorted keys                |\n\n**Summary:**  \nUse `Dictionary` for fast, unordered access. Use `SortedDictionary` when you need to maintain the keys in sorted order.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252249Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "c3e1857a-3ea4-431c-909b-c1d2eda34cd5",
    "question": "Explain the internal implementation of a Dictionary in C#.",
    "answer": "```markdown\n### Internal Implementation of a Dictionary in C#\n\nIn C#, the `Dictionary<TKey, TValue>` class is a generic collection that stores key-value pairs and provides fast lookup based on keys. Internally, it is implemented as a **hash table** with separate chaining for collision resolution. Here’s a breakdown of its internal workings:\n\n#### 1. **Data Structures Used**\n- **Buckets Array:** An integer array where each element represents the head index of a linked list (or chain) in the entries array.\n- **Entries Array:** An array of structs, where each struct contains:\n  - `hashCode`: The computed hash code of the key.\n  - `next`: The index of the next entry in the chain (or -1 if it's the end).\n  - `key`: The key itself.\n  - `value`: The value associated with the key.\n\n#### 2. **Hashing and Indexing**\n- When a key is added, its hash code is computed using the key's `GetHashCode()` method.\n- The hash code is then mapped to a bucket index using modulo operation: `index = hashCode % buckets.Length`.\n- If multiple keys map to the same bucket (collision), they are stored in a linked list (chain) within the entries array.\n\n#### 3. **Collision Resolution**\n- **Separate Chaining:** Each bucket points to the first entry in the chain. Each entry has a `next` field pointing to the next entry in the same bucket.\n- When searching for a key, the dictionary traverses the chain, comparing keys using the `Equals()` method.\n\n#### 4. **Insertion**\n- Compute the hash code and bucket index.\n- Traverse the chain to check if the key already exists.\n  - If it does, update the value.\n  - If not, create a new entry and add it to the front of the chain (linked list).\n\n#### 5. **Resizing**\n- When the number of elements exceeds a certain threshold (typically 0.72 * buckets.Length), the dictionary resizes:\n  - A new, larger buckets array and entries array are created.\n  - All existing entries are rehashed and redistributed into the new buckets.\n\n#### 6. **Performance**\n- Average-case time complexity for lookup, insertion, and deletion is **O(1)**.\n- Worst-case time complexity is **O(n)** (when all keys hash to the same bucket), but this is rare with a good hash function.\n\n#### 7. **Example Structure (Simplified)**\n```csharp\nstruct Entry\n{\n    public int hashCode;\n    public int next;\n    public TKey key;\n    public TValue value;\n}\n\nint[] buckets;\nEntry[] entries;\n```\n\n#### 8. **Key Points**\n- Uses hash codes for fast access.\n- Handles collisions via chaining.\n- Automatically resizes to maintain performance.\n- Relies on correct implementations of `GetHashCode()` and `Equals()` for key types.\n\n---\n\n**References:**\n- [Microsoft Docs: Dictionary<TKey,TValue> Class](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2)\n- [Source code: .NET Core Dictionary Implementation](https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs)\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252261Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "23252ffe-4cd6-4aa4-bac7-f3221cc1ed45",
    "question": "What is the role of GetHashCode() and Equals() in hash-based collections?",
    "answer": "```markdown\n### What is the role of `GetHashCode()` and `Equals()` in hash-based collections?\n\nIn C#, hash-based collections such as `Dictionary<TKey, TValue>`, `HashSet<T>`, and `Hashtable` rely on the `GetHashCode()` and `Equals()` methods to efficiently store and retrieve objects.\n\n#### `GetHashCode()`\n- **Purpose:** Returns an integer hash code for the object.\n- **Role:** When an object is added to a hash-based collection, its `GetHashCode()` method is called to determine the bucket in which the object should be placed.\n- **Requirement:** If two objects are considered equal according to `Equals()`, they **must** return the same hash code from `GetHashCode()`. However, different objects can have the same hash code (hash collision).\n\n#### `Equals()`\n- **Purpose:** Determines whether two object instances are considered equal.\n- **Role:** After locating the correct bucket using the hash code, the collection uses `Equals()` to check if the exact object exists (since multiple objects can share the same hash code).\n\n#### Why are both needed?\n- **Efficiency:** `GetHashCode()` quickly narrows down the search to a specific bucket.\n- **Accuracy:** `Equals()` ensures that the correct object is found within that bucket.\n\n#### Example\n\n```csharp\npublic class Person\n{\n    public string Name { get; set; }\n    public override bool Equals(object obj)\n    {\n        if (obj is Person other)\n            return this.Name == other.Name;\n        return false;\n    }\n    public override int GetHashCode()\n    {\n        return Name.GetHashCode();\n    }\n}\n```\n\n#### Summary Table\n\n| Method         | Used For                        | Must Be Consistent With |\n|----------------|--------------------------------|------------------------|\n| `GetHashCode()`| Bucket selection (hashing)      | `Equals()`             |\n| `Equals()`     | Object equality comparison      | `GetHashCode()`        |\n\n#### Key Points\n- Always override both `Equals()` and `GetHashCode()` together.\n- Failing to do so can cause incorrect behavior in hash-based collections (e.g., objects not found or duplicate entries).\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252274Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "2e6dec91-ecff-4528-bb28-2d11af660f92",
    "question": "How do you implement a custom collection in C#?",
    "answer": "```markdown\nTo implement a custom collection in C#, you typically create a class that encapsulates the storage and management of its elements. For advanced usage, you should implement one or more standard collection interfaces such as `IEnumerable<T>`, `ICollection<T>`, or even `IList<T>` depending on the desired functionality.\n\n### Example: Implementing a Custom Collection\n\nBelow is an example of a simple generic custom collection that implements `IEnumerable<T>`:\n\n```csharp\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class MyCustomCollection<T> : IEnumerable<T>\n{\n    private List<T> _items = new List<T>();\n\n    public void Add(T item)\n    {\n        _items.Add(item);\n    }\n\n    public bool Remove(T item)\n    {\n        return _items.Remove(item);\n    }\n\n    public int Count => _items.Count;\n\n    public T this[int index]\n    {\n        get => _items[index];\n        set => _items[index] = value;\n    }\n\n    // Implementation of IEnumerable<T>\n    public IEnumerator<T> GetEnumerator()\n    {\n        return _items.GetEnumerator();\n    }\n\n    // Explicit implementation for non-generic IEnumerable\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n```\n\n### Key Points\n\n- **Encapsulation:** The collection encapsulates a private `List<T>` to store elements.\n- **Interface Implementation:** By implementing `IEnumerable<T>`, the collection supports `foreach` iteration.\n- **Custom Methods:** You can add custom methods (e.g., `Add`, `Remove`) as needed.\n- **Indexer:** Providing an indexer allows array-like access.\n- **Extensibility:** For more advanced features (sorting, searching, etc.), implement additional interfaces like `ICollection<T>`, `IList<T>`, or even thread-safety mechanisms.\n\n### Why Implement Custom Collections?\n\n- To enforce specific business rules or constraints.\n- To optimize for performance or memory usage.\n- To provide additional functionality not present in standard collections.\n\n### Best Practices\n\n- Always implement the appropriate interfaces for maximum compatibility with .NET APIs.\n- Consider inheriting from `Collection<T>` or `List<T>` if you only need to extend existing behavior.\n- Ensure thread safety if the collection will be accessed concurrently.\n\n```\n\nThis approach demonstrates how to create a robust, reusable custom collection in C# suitable for advanced interview discussions.\n```",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252287Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "b34c4f67-a2bc-44ab-8fa7-8f240aefef05",
    "question": "What is the difference between ObservableCollection and List?",
    "answer": "```markdown **Answer:**\n\nThe main differences between `ObservableCollection<T>` and `List<T>` in C# are:\n\n| Feature                    | `List<T>`                                  | `ObservableCollection<T>`                     |\n|----------------------------|--------------------------------------------|-----------------------------------------------|\n| **Namespace**              | `System.Collections.Generic`               | `System.Collections.ObjectModel`              |\n| **Notification Support**   | No built-in notification mechanism         | Notifies when items are added, removed, or the whole list is refreshed via `INotifyCollectionChanged` |\n| **Use Case**               | General-purpose collection                 | Data binding scenarios, especially in WPF, UWP, or Xamarin for UI updates |\n| **Performance**            | Slightly faster due to less overhead       | Slightly slower due to event notification overhead |\n| **Events**                 | None                                       | `CollectionChanged` event                     |\n| **Binding Support**        | Not suitable for data binding              | Designed for data binding in UI frameworks    |\n\n**Summary:**  \nUse `List<T>` for general data storage and manipulation when you don't need to notify other components about changes. Use `ObservableCollection<T>` when you need automatic UI updates or notifications when the collection changes, such as in MVVM patterns in WPF applications.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252301Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "32feda03-90bb-483a-9a41-d4fdf53a96a7",
    "question": "How do you make a collection thread-safe in C#?",
    "answer": "```markdown\nTo make a collection thread-safe in C#, you have several options depending on your requirements:\n\n### 1. Use Built-in Thread-Safe Collections\n\n.NET provides several thread-safe collections in the `System.Collections.Concurrent` namespace, such as:\n\n- `ConcurrentDictionary<TKey, TValue>`\n- `ConcurrentQueue<T>`\n- `ConcurrentStack<T>`\n- `ConcurrentBag<T>`\n- `BlockingCollection<T>`\n\n**Example:**\n```csharp\nvar concurrentDict = new ConcurrentDictionary<int, string>();\nconcurrentDict.TryAdd(1, \"value1\");\n```\n\nThese collections are designed for multi-threaded scenarios and handle synchronization internally.\n\n---\n\n### 2. Locking with `lock` Statement\n\nIf you are using a collection that is not thread-safe (e.g., `List<T>`, `Dictionary<TKey, TValue>`), you can use the `lock` statement to synchronize access:\n\n```csharp\nprivate readonly object _lock = new object();\nprivate List<int> _list = new List<int>();\n\npublic void AddItem(int item)\n{\n    lock (_lock)\n    {\n        _list.Add(item);\n    }\n}\n```\n\nThis ensures that only one thread can access the collection at a time.\n\n---\n\n### 3. Using Synchronized Wrappers\n\nFor legacy collections, you can use synchronized wrappers:\n\n```csharp\nArrayList arrayList = ArrayList.Synchronized(new ArrayList());\n```\n\nHowever, this approach is less common in modern C# code.\n\n---\n\n### 4. Immutable Collections\n\nImmutable collections from `System.Collections.Immutable` namespace are inherently thread-safe because their state cannot be changed after creation.\n\n```csharp\nusing System.Collections.Immutable;\n\nImmutableList<int> immutableList = ImmutableList<int>.Empty.Add(1);\n```\n\n---\n\n### Summary Table\n\n| Approach                        | Thread-Safe | Suitable For       |\n|----------------------------------|-------------|--------------------|\n| Concurrent Collections           | Yes         | High concurrency   |\n| `lock` Statement                 | Yes         | Custom logic       |\n| Synchronized Wrappers            | Yes         | Legacy collections |\n| Immutable Collections            | Yes         | Read-heavy, no mutation |\n\n**Best Practice:**  \nPrefer using concurrent or immutable collections for thread safety. Use `lock` only when you need custom synchronization logic.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252313Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "ab8a35ec-4840-4b8c-8c23-24be00c90e90",
    "question": "What are the differences between ArrayList and List<T>?",
    "answer": "```markdown **Differences between ArrayList and List<T> in C#:**\n\n| Feature              | ArrayList                         | List<T>                                 |\n|----------------------|-----------------------------------|-----------------------------------------|\n| Namespace            | System.Collections                | System.Collections.Generic              |\n| Type Safety          | Not type-safe (stores objects as `object`) | Type-safe (stores specific type `T`)    |\n| Performance          | Slower (boxing/unboxing for value types) | Faster (no boxing/unboxing)             |\n| Generics Support     | No                                | Yes                                     |\n| Usage Recommendation | Legacy, not recommended for new code | Recommended for new code                |\n| Syntax Example       | `ArrayList list = new ArrayList();` | `List<int> list = new List<int>();`     |\n\n**Summary:**  \nUse `List<T>` for type safety, better performance, and modern C# code. `ArrayList` is mainly for backward compatibility.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252326Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "e3f819f8-4bc4-4bc3-bd19-11bc20fb96c1",
    "question": "How do you reverse a collection in C#?",
    "answer": "```markdown\nTo reverse a collection in C#, you can use the `Reverse()` method provided by various collection types. Here are some common ways:\n\n### 1. Using `List<T>.Reverse()`\nIf you have a `List<T>`, you can call its `Reverse()` method, which reverses the list in place:\n\n```csharp\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\nnumbers.Reverse();\n// numbers is now { 5, 4, 3, 2, 1 }\n```\n\n### 2. Using LINQ's `Reverse()` (for any IEnumerable)\nIf you want to reverse any collection without modifying the original, use LINQ's `Reverse()` extension method:\n\n```csharp\nusing System.Linq;\n\nint[] array = { 1, 2, 3, 4, 5 };\nvar reversed = array.Reverse(); // Returns IEnumerable<int>\nforeach (var num in reversed)\n{\n    Console.WriteLine(num); // Prints 5 4 3 2 1\n}\n```\n\n**Note:** LINQ's `Reverse()` does not change the original collection; it returns a new reversed sequence.\n\n### Summary Table\n\n| Collection Type | Method                | In-place? |\n|-----------------|----------------------|-----------|\n| List<T>         | `Reverse()`          | Yes       |\n| Array           | `Array.Reverse()`    | Yes       |\n| Any IEnumerable | `Enumerable.Reverse()`| No        |\n\nChoose the method that best fits your collection type and whether you want to reverse in place or create a new reversed sequence.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252338Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "46c95e2f-2690-4e80-92c2-6ba1c6d92ab6",
    "question": "What is a LinkedList and when would you use it over a List?",
    "answer": "```markdown A **LinkedList** in C# is a linear data structure where each element (called a node) contains a value and a reference (or link) to the next (and optionally previous) node in the sequence. The .NET Framework provides the `LinkedList<T>` class, which implements a doubly linked list, meaning each node has references to both the next and previous nodes.\n\n### Key Characteristics\n\n- **Dynamic Size:** Nodes can be efficiently added or removed without reallocating or shifting elements.\n- **Non-contiguous Storage:** Elements are not stored in contiguous memory locations.\n- **Efficient Insertions/Deletions:** Adding or removing nodes at the beginning, end, or middle is generally O(1) if you have a reference to the node.\n\n### When to Use LinkedList Over List\n\nYou should consider using a `LinkedList<T>` instead of a `List<T>` when:\n\n- **Frequent Insertions/Deletions:** You need to frequently add or remove elements from the beginning or middle of the collection. `LinkedList<T>` can perform these operations in O(1) time if you have a reference to the node, while `List<T>` may require O(n) time due to shifting elements.\n- **Unknown Collection Size:** The size of the collection changes frequently and unpredictably.\n- **No Need for Random Access:** You do not need to access elements by index often, as `LinkedList<T>` does not support efficient random access (O(n) time), whereas `List<T>` provides O(1) access by index.\n\n### When to Prefer List\n\n- **Frequent Random Access:** If you need fast access to elements by index, `List<T>` is more suitable.\n- **Better Memory Locality:** `List<T>` stores elements in contiguous memory, which can be more cache-friendly and efficient for iteration.\n\n### Example\n\n```csharp\n// Using LinkedList\nLinkedList<int> linkedList = new LinkedList<int>();\nlinkedList.AddLast(1);\nlinkedList.AddLast(2);\nlinkedList.AddFirst(0); // Efficient O(1) insertion at the beginning\n\n// Using List\nList<int> list = new List<int>();\nlist.Add(1);\nlist.Add(2);\nlist.Insert(0, 0); // O(n) insertion at the beginning (elements are shifted)\n```\n\n---\n\n**Summary:**  \nUse `LinkedList<T>` when you need efficient insertions and deletions at arbitrary positions and do not require fast random access. Use `List<T>` when you need fast indexed access and insertions/deletions are infrequent or mostly at the end.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252350Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "137e8a71-0779-4eca-9594-3f70dc6adf51",
    "question": "How do you find the intersection of two sets in C#?",
    "answer": "```markdown To find the intersection of two sets in C#, you can use the Intersect method provided by the HashSet<T> or LINQ. Here’s how you can do it using both approaches:\n\n### Using HashSet<T>\n\n```csharp\nvar set1 = new HashSet<int> { 1, 2, 3, 4 };\nvar set2 = new HashSet<int> { 3, 4, 5, 6 };\n\n// Modifies set1 to contain only elements also in set2\nset1.IntersectWith(set2);\n\n// set1 now contains: 3, 4\n```\n\n### Using LINQ\n\n```csharp\nusing System.Linq;\n\nvar set1 = new HashSet<int> { 1, 2, 3, 4 };\nvar set2 = new HashSet<int> { 3, 4, 5, 6 };\n\nvar intersection = set1.Intersect(set2);\n\n// intersection contains: 3, 4\n```\n\n**Note:**  \n- `IntersectWith` modifies the original set.\n- `Intersect` (LINQ) returns a new IEnumerable<T> with the intersection.\n\n**Summary:**  \nUse `IntersectWith` for in-place intersection, or `Intersect` (LINQ) for a new collection containing the intersection of two sets.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252362Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "7b9a9a35-49c9-4afe-9951-106a8f97d1a0",
    "question": "What is the difference between Stack<T> and Queue<T>?",
    "answer": "```markdown **Answer:**\n\nIn C#, both `Stack<T>` and `Queue<T>` are generic collection classes used to store objects, but they differ in the way elements are added and removed:\n\n| Feature         | Stack<T>                          | Queue<T>                          |\n|-----------------|-----------------------------------|-----------------------------------|\n| Data Structure  | Last-In-First-Out (LIFO)          | First-In-First-Out (FIFO)         |\n| Add Element     | `Push(T item)` (to the top)       | `Enqueue(T item)` (to the end)    |\n| Remove Element  | `Pop()` (from the top)            | `Dequeue()` (from the front)      |\n| Peek Element    | `Peek()` (top element)            | `Peek()` (front element)          |\n| Use Case        | Undo operations, backtracking     | Order processing, task scheduling |\n\n**Example:**\n\n```csharp\n// Stack<T> example\nStack<int> stack = new Stack<int>();\nstack.Push(1);\nstack.Push(2);\nint last = stack.Pop(); // last = 2\n\n// Queue<T> example\nQueue<int> queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nint first = queue.Dequeue(); // first = 1\n```\n\n**Summary:**  \n- `Stack<T>` removes the most recently added element first (LIFO).\n- `Queue<T>` removes the oldest added element first (FIFO).",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252374Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "3b4949d7-d416-41da-b35c-2c15043fd61b",
    "question": "How do you convert an array to a List in C#?",
    "answer": "```markdown\nYou can convert an array to a `List` in C# using the `ToList()` extension method from the `System.Linq` namespace. Here’s how you can do it:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] array = { 1, 2, 3, 4, 5 };\n        List<int> list = array.ToList();\n\n        // Output the list\n        foreach (int item in list)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n```\n\nAlternatively, you can use the `List` constructor:\n\n```csharp\nint[] array = { 1, 2, 3, 4, 5 };\nList<int> list = new List<int>(array);\n```\n\nBoth methods will convert the array to a `List<int>`.\n```\n",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252386Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "b9aebecd-54ef-4a58-9b47-420447d7dce4",
    "question": "Explain the use of the yield keyword in C# collections.",
    "answer": "```markdown\n### Explain the use of the `yield` keyword in C# collections\n\nThe `yield` keyword in C# is used to simplify the implementation of iterators for custom collections. It allows you to return elements one at a time, without creating an intermediate collection or explicitly managing the state of the iteration.\n\n#### How it works\n\n- When a method, operator, or accessor contains a `yield return` statement, it becomes an **iterator**.\n- Each time the iterator is called (e.g., in a `foreach` loop), execution resumes from the last `yield return`.\n- You can also use `yield break` to end the iteration early.\n\n#### Example\n\n```csharp\npublic IEnumerable<int> GetEvenNumbers(int[] numbers)\n{\n    foreach (var num in numbers)\n    {\n        if (num % 2 == 0)\n        {\n            yield return num;\n        }\n    }\n}\n```\n\n**Usage:**\n```csharp\nvar evens = GetEvenNumbers(new int[] { 1, 2, 3, 4, 5 });\nforeach (var n in evens)\n{\n    Console.WriteLine(n); // Output: 2, 4\n}\n```\n\n#### Benefits\n\n- **Lazy evaluation:** Elements are generated on demand, saving memory and improving performance for large or infinite sequences.\n- **Simplified code:** No need to maintain complex state or create temporary lists.\n\n#### Common use cases\n\n- Custom collection iteration\n- Filtering or transforming sequences\n- Implementing LINQ-like methods\n\n**In summary:**  \nThe `yield` keyword makes it easy to create efficient, readable, and maintainable iterators for custom collections in C#.\n```",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252398Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "0e445d8f-9e9b-4874-b2c4-6c41d83a6060",
    "question": "What is LINQ and how can it be used with collections?",
    "answer": "```markdown **What is LINQ and how can it be used with collections?**\n\nLINQ (Language Integrated Query) is a powerful feature in C# that allows developers to write queries directly within the C# language to manipulate and retrieve data from various data sources, such as collections, databases, XML documents, and more. LINQ provides a consistent, readable, and type-safe way to query data.\n\n### How LINQ Works with Collections\n\nLINQ can be used with any collection that implements the `IEnumerable<T>` or `IQueryable<T>` interfaces, such as arrays, lists, dictionaries, and other generic collections. It enables developers to perform operations like filtering, sorting, grouping, and projecting data in a declarative manner.\n\n#### Example: Using LINQ with a List\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };\n\n        // LINQ query to select even numbers\n        var evenNumbers = from num in numbers\n                          where num % 2 == 0\n                          select num;\n\n        // Alternatively, using method syntax\n        var evenNumbersMethod = numbers.Where(num => num % 2 == 0);\n\n        foreach (var n in evenNumbers)\n        {\n            Console.WriteLine(n); // Output: 2 4 6\n        }\n    }\n}\n```\n\n### Key Points\n\n- **Query Syntax**: Similar to SQL, uses `from`, `where`, `select`, etc.\n- **Method Syntax**: Uses extension methods like `.Where()`, `.Select()`, `.OrderBy()`, etc.\n- **Type Safety**: LINQ queries are checked at compile time.\n- **Versatility**: Works with in-memory collections, databases (via LINQ to SQL/Entity Framework), XML, and more.\n\n### Benefits\n\n- **Readable and concise code**\n- **Reduces the need for loops and manual filtering**\n- **Consistent querying experience across different data sources**\n\n---\n\n**In summary:** LINQ is a feature in C# that allows querying and manipulating collections in a declarative, type-safe, and readable way, making data operations much simpler and more maintainable.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252411Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "5d5b8f7e-2d04-4d9d-981a-8a51c4b7eac7",
    "question": "How do you remove all elements from a collection that match a condition?",
    "answer": "```markdown To remove all elements from a collection that match a specific condition in C#, you can use the RemoveAll method available on List<T>. This method takes a predicate (a function that returns true for elements to remove) and removes all matching elements from the list.\n\nHere's an example:\n\n```csharp\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };\n\n// Remove all even numbers\nnumbers.RemoveAll(n => n % 2 == 0);\n\n// numbers now contains: 1, 3, 5\n```\n\n**Notes:**\n- RemoveAll is only available for List<T>, not for other collection types like arrays or generic ICollection<T>.\n- For other collections, you may need to use a loop or LINQ to filter elements and create a new collection.\n\n**Example using LINQ to create a new filtered collection:**\n\n```csharp\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };\n\n// Create a new list without even numbers\nvar oddNumbers = numbers.Where(n => n % 2 != 0).ToList();\n```\n\n**Summary:**  \n- Use `RemoveAll(predicate)` for List<T>.\n- For other collections, use LINQ's `Where` to filter and create a new collection.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252423Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "8c418324-4ab0-4ef4-b2a4-a23ee9747b46",
    "question": "What are the differences between a Set and a Dictionary?",
    "answer": "```markdown **Differences Between a Set and a Dictionary in C#:**\n\n| Feature         | Set (`HashSet<T>`)            | Dictionary (`Dictionary<TKey, TValue>`)      |\n|-----------------|------------------------------|----------------------------------------------|\n| Purpose         | Stores unique elements only  | Stores key-value pairs                       |\n| Key             | No keys, only values         | Each value is associated with a unique key   |\n| Value           | Only values                  | Both keys and values                        |\n| Access          | Check for existence of value | Access value by key                          |\n| Duplicates      | Not allowed                  | Keys must be unique; values can duplicate    |\n| Example Usage   | `{1, 2, 3}`                  | `{1: \"A\", 2: \"B\", 3: \"C\"}`                  |\n| Typical Classes | `HashSet<T>`, `SortedSet<T>` | `Dictionary<TKey, TValue>`, `SortedDictionary<TKey, TValue>` |\n\n**Summary:**  \n- Use a Set when you need to store unique values and only care about existence.\n- Use a Dictionary when you need to associate unique keys with specific values.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252435Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "a22e4cc3-8f0e-4c5b-b9b1-5f1c4574c2f0",
    "question": "How would you implement a LRU (Least Recently Used) cache in C#?",
    "answer": "```markdown\nTo implement an LRU (Least Recently Used) cache in C#, you typically use a combination of a `Dictionary` for O(1) access and a `LinkedList` to track the usage order. The `Dictionary` maps keys to linked list nodes, and the `LinkedList` maintains the order from most recently used (head) to least recently used (tail).\n\nHere’s a sample implementation:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class LRUCache<K, V>\n{\n    private readonly int capacity;\n    private readonly Dictionary<K, LinkedListNode<CacheItem>> cacheMap;\n    private readonly LinkedList<CacheItem> usageList;\n\n    private class CacheItem\n    {\n        public K Key { get; }\n        public V Value { get; set; }\n        public CacheItem(K key, V value)\n        {\n            Key = key;\n            Value = value;\n        }\n    }\n\n    public LRUCache(int capacity)\n    {\n        if (capacity <= 0) throw new ArgumentException(\"Capacity must be greater than zero.\");\n        this.capacity = capacity;\n        cacheMap = new Dictionary<K, LinkedListNode<CacheItem>>(capacity);\n        usageList = new LinkedList<CacheItem>();\n    }\n\n    public V Get(K key)\n    {\n        if (!cacheMap.TryGetValue(key, out var node))\n            throw new KeyNotFoundException();\n\n        // Move accessed node to the front (most recently used)\n        usageList.Remove(node);\n        usageList.AddFirst(node);\n        return node.Value.Value;\n    }\n\n    public void Put(K key, V value)\n    {\n        if (cacheMap.TryGetValue(key, out var node))\n        {\n            // Update value and move to front\n            node.Value.Value = value;\n            usageList.Remove(node);\n            usageList.AddFirst(node);\n        }\n        else\n        {\n            if (cacheMap.Count >= capacity)\n            {\n                // Remove least recently used item\n                var lruNode = usageList.Last;\n                if (lruNode != null)\n                {\n                    cacheMap.Remove(lruNode.Value.Key);\n                    usageList.RemoveLast();\n                }\n            }\n            // Insert new item at front\n            var newNode = new LinkedListNode<CacheItem>(new CacheItem(key, value));\n            usageList.AddFirst(newNode);\n            cacheMap[key] = newNode;\n        }\n    }\n}\n```\n\n**Usage Example:**\n```csharp\nvar lru = new LRUCache<int, string>(2);\nlru.Put(1, \"one\");\nlru.Put(2, \"two\");\nConsole.WriteLine(lru.Get(1)); // Outputs: one\nlru.Put(3, \"three\"); // Evicts key 2\n// lru.Get(2); // Throws KeyNotFoundException\n```\n\n**Key Points:**\n- `Dictionary` provides O(1) access to cache items.\n- `LinkedList` maintains the usage order for O(1) updates.\n- On every `Get` or `Put`, the accessed/inserted node is moved to the front.\n- When the cache exceeds capacity, the least recently used item (at the end of the list) is removed.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252447Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "66fc4835-6a61-4a72-85b9-49495d2ffbc2",
    "question": "What is the difference between a value type and a reference type in collections?",
    "answer": "```markdown **Answer:**\n\nIn C#, the difference between a value type and a reference type in collections is:\n\n- **Value Types** (e.g., `int`, `struct`, `bool`):\n  - Store the actual data directly.\n  - When you add a value type to a collection (like a `List<int>`), the value itself is stored.\n  - Assigning a value type to another variable copies the data.\n\n- **Reference Types** (e.g., `class`, `string`, `object`):\n  - Store a reference (pointer) to the actual data in memory.\n  - When you add a reference type to a collection (like a `List<string>`), the reference is stored, not the actual object.\n  - Assigning a reference type to another variable copies the reference, not the object itself.\n\n**Example:**\n\n```csharp\nint a = 5;          // Value type\nint b = a;          // b gets a copy of a's value\n\nstring s1 = \"abc\";  // Reference type\nstring s2 = s1;     // s2 points to the same object as s1\n```\n\n**Summary Table:**\n\n| Feature           | Value Type             | Reference Type           |\n|-------------------|-----------------------|-------------------------|\n| Stored in         | Stack                 | Heap                    |\n| Assignment        | Copies value          | Copies reference        |\n| In Collections    | Stores actual value   | Stores reference        |\n\nUnderstanding this difference is important when working with collections, as it affects how data is stored, accessed, and modified.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252459Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "d087aabb-e6a7-41c7-85a4-3375b64313e3",
    "question": "How do you merge two lists in C#?",
    "answer": "```markdown\nYou can merge two lists in C# using the `AddRange()` method or the LINQ `Concat()` method.\n\n**Example using `AddRange()`:**\n\n```csharp\nList<int> list1 = new List<int> { 1, 2, 3 };\nList<int> list2 = new List<int> { 4, 5, 6 };\n\nlist1.AddRange(list2); // list1 now contains {1, 2, 3, 4, 5, 6}\n```\n\n**Example using LINQ `Concat()`:**\n\n```csharp\nList<int> list1 = new List<int> { 1, 2, 3 };\nList<int> list2 = new List<int> { 4, 5, 6 };\n\nvar mergedList = list1.Concat(list2).ToList(); // mergedList contains {1, 2, 3, 4, 5, 6}\n```\n\n- Use `AddRange()` if you want to modify the first list.\n- Use `Concat()` if you want to create a new merged list without modifying the originals.\n```",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252471Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "0a8c8352-2573-4a03-ba91-e20fd8dd611d",
    "question": "What are extension methods and how can they be used with collections?",
    "answer": "```markdown **Extension methods** in C# are a way to \"add\" new methods to existing types without modifying the original type, recompiling, or using inheritance. They are defined as static methods in a static class, with the first parameter preceded by the this keyword, indicating the type they extend.\n\n### How Extension Methods Work with Collections\n\nCollections in C# (like `List<T>`, `IEnumerable<T>`, etc.) can be enhanced with extension methods. This is commonly used in LINQ, where methods like `Where`, `Select`, and `OrderBy` are extension methods for `IEnumerable<T>`.\n\n#### Example: Creating an Extension Method for Collections\n\nSuppose you want to add a method to all `IEnumerable<T>` collections that returns the count of elements greater than a specified value:\n\n```csharp\npublic static class CollectionExtensions\n{\n    public static int CountGreaterThan<T>(this IEnumerable<T> collection, T value) where T : IComparable<T>\n    {\n        int count = 0;\n        foreach (var item in collection)\n        {\n            if (item.CompareTo(value) > 0)\n                count++;\n        }\n        return count;\n    }\n}\n```\n\n**Usage:**\n\n```csharp\nList<int> numbers = new List<int> { 1, 5, 10, 20 };\nint count = numbers.CountGreaterThan(5); // Returns 2 (10 and 20)\n```\n\n### Key Points\n\n- Extension methods let you add functionality to existing types, including collections, without altering their source code.\n- They are widely used in LINQ to provide powerful querying capabilities on collections.\n- To use an extension method, include its namespace with a using directive.\n\n**Summary:**  \nExtension methods are a powerful feature in C# for enhancing collections with custom or reusable functionality, making code more expressive and modular.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252483Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "0073b7a9-1fc9-45c9-8d21-4f11c981b619",
    "question": "How do you check if a collection is empty in C#?",
    "answer": "```markdown\nTo check if a collection is empty in C#, you can use the `Count` property or the `Any()` method from LINQ. Here are two common ways:\n\n**1. Using the `Count` property:**\n```csharp\nif (myCollection.Count == 0)\n{\n    // The collection is empty\n}\n```\n\n**2. Using LINQ's `Any()` method:**\n```csharp\nusing System.Linq;\n\nif (!myCollection.Any())\n{\n    // The collection is empty\n}\n```\n\n**Note:**  \n- `Count` is available on collections like `List<T>`, `Array`, etc.\n- `Any()` works with any `IEnumerable<T>` and is often more efficient for large collections, as it returns as soon as it finds an element.\n```",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252494Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "ca5206c7-bbd6-472f-ad40-2569fa23d45d",
    "question": "What is the difference between ToArray() and ToList() methods?",
    "answer": "```markdown **Answer:**\n\nIn C#, both `ToArray()` and `ToList()` are extension methods used to convert a collection (like IEnumerable or LINQ query results) into a different type of collection.\n\n- **ToArray()**  \n  - Converts the collection into an array (`T[]`).\n  - Returns a fixed-size array.\n  - Example:\n    ```csharp\n    var numbers = new List<int> { 1, 2, 3 };\n    int[] array = numbers.ToArray();\n    ```\n\n- **ToList()**  \n  - Converts the collection into a `List<T>`.\n  - Returns a dynamic, resizable list.\n  - Example:\n    ```csharp\n    var numbers = new int[] { 1, 2, 3 };\n    List<int> list = numbers.ToList();\n    ```\n\n**Key Differences:**\n- `ToArray()` returns an array, which has a fixed size.\n- `ToList()` returns a `List<T>`, which can be resized (add/remove elements).\n- Choose `ToArray()` when you need a fixed-size collection, and `ToList()` when you need to modify the collection after creation.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:57:09.252506Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "982ef4c2-f944-4030-aee2-5bc9d1ae3bfc",
    "question": "How do you handle duplicates in a Dictionary?",
    "answer": "```markdown\nIn C#, a `Dictionary<TKey, TValue>` does not allow duplicate keys—each key must be unique. If you attempt to add a key that already exists, a `ArgumentException` will be thrown. To handle duplicates, you have several options depending on your requirements:\n\n### 1. Check for Key Existence Before Adding\n\nYou can check if the key already exists using the `ContainsKey` method before adding a new entry:\n\n```csharp\nDictionary<int, string> dict = new Dictionary<int, string>();\n\nint key = 1;\nstring value = \"Value1\";\n\nif (!dict.ContainsKey(key))\n{\n    dict.Add(key, value);\n}\nelse\n{\n    // Handle duplicate key as needed (e.g., update value or ignore)\n    dict[key] = value; // This will update the existing value\n}\n```\n\n### 2. Use the Indexer to Overwrite\n\nAssigning a value using the indexer (`dict[key] = value;`) will add the key if it doesn't exist, or update the value if it does. This way, duplicates are handled by overwriting the existing value:\n\n```csharp\ndict[key] = value; // Adds or updates\n```\n\n### 3. Store Multiple Values per Key\n\nIf you need to store multiple values for the same key, use a collection as the value (e.g., `List<T>`):\n\n```csharp\nDictionary<int, List<string>> dict = new Dictionary<int, List<string>>();\n\nint key = 1;\nstring value = \"Value1\";\n\nif (!dict.ContainsKey(key))\n{\n    dict[key] = new List<string>();\n}\ndict[key].Add(value);\n```\n\n### Summary\n\n- **Duplicate keys are not allowed** in a `Dictionary`.\n- Use `ContainsKey` to check before adding.\n- Use the indexer to overwrite existing values.\n- Use a collection as the value type if you need to associate multiple values with a single key.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252518Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "8ad554b5-97f2-4758-a1ed-31a4918120ac",
    "question": "What is a PriorityQueue and how would you implement one in C#?",
    "answer": "```markdown\n### What is a PriorityQueue and how would you implement one in C#?\n\nA **PriorityQueue** is a data structure where each element is associated with a priority, and elements are served according to their priority (not just their insertion order). The element with the highest (or lowest, depending on implementation) priority is always removed first. This is commonly used in algorithms like Dijkstra's shortest path, A* search, and in scheduling systems.\n\n#### Key Operations\n\n- **Enqueue (Insert):** Add an element with a given priority.\n- **Dequeue (Remove):** Remove and return the element with the highest (or lowest) priority.\n- **Peek:** View the element with the highest (or lowest) priority without removing it.\n\n#### Implementation in C#\n\nThe most efficient way to implement a PriorityQueue is using a **binary heap** (min-heap or max-heap). In .NET 6 and later, there is a built-in `PriorityQueue<TElement, TPriority>` class in `System.Collections.Generic`. For earlier versions, you can implement your own using a heap.\n\n##### Using .NET 6+ Built-in PriorityQueue\n\n```csharp\nusing System.Collections.Generic;\n\nvar pq = new PriorityQueue<string, int>();\n\n// Enqueue elements (element, priority)\npq.Enqueue(\"Task 1\", 3);\npq.Enqueue(\"Task 2\", 1);\npq.Enqueue(\"Task 3\", 2);\n\n// Dequeue elements (lowest priority first)\nwhile (pq.Count > 0)\n{\n    string task = pq.Dequeue();\n    Console.WriteLine(task);\n}\n```\n\n##### Custom Min-Heap Implementation (for .NET < 6)\n\n```csharp\npublic class PriorityQueue<T>\n{\n    private List<(T item, int priority)> heap = new();\n\n    private int Parent(int i) => (i - 1) / 2;\n    private int Left(int i) => 2 * i + 1;\n    private int Right(int i) => 2 * i + 2;\n\n    public void Enqueue(T item, int priority)\n    {\n        heap.Add((item, priority));\n        int i = heap.Count - 1;\n        while (i > 0 && heap[Parent(i)].priority > heap[i].priority)\n        {\n            (heap[Parent(i)], heap[i]) = (heap[i], heap[Parent(i)]);\n            i = Parent(i);\n        }\n    }\n\n    public T Dequeue()\n    {\n        if (heap.Count == 0) throw new InvalidOperationException(\"Empty queue\");\n        T result = heap[0].item;\n        heap[0] = heap[^1];\n        heap.RemoveAt(heap.Count - 1);\n        Heapify(0);\n        return result;\n    }\n\n    private void Heapify(int i)\n    {\n        int smallest = i;\n        int left = Left(i);\n        int right = Right(i);\n\n        if (left < heap.Count && heap[left].priority < heap[smallest].priority)\n            smallest = left;\n        if (right < heap.Count && heap[right].priority < heap[smallest].priority)\n            smallest = right;\n        if (smallest != i)\n        {\n            (heap[i], heap[smallest]) = (heap[smallest], heap[i]);\n            Heapify(smallest);\n        }\n    }\n\n    public int Count => heap.Count;\n}\n```\n\n#### Summary\n\n- **PriorityQueue** serves elements based on priority, not insertion order.\n- Use `PriorityQueue<TElement, TPriority>` in .NET 6+.\n- For earlier versions, implement using a binary heap for efficiency (`O(log n)` for insert and remove).\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252531Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "813b0499-21e3-4ab4-9494-7492a38aa94d",
    "question": "Explain the difference between IEnumerable, ICollection, and IList.",
    "answer": "```markdown ### Difference between `IEnumerable`, `ICollection`, and `IList` in C#\n\n#### 1. `IEnumerable`\n- **Namespace:** `System.Collections`\n- **Purpose:** The base interface for all non-generic collections that can be enumerated.\n- **Key Features:**\n  - Provides a single method: `GetEnumerator()`.\n  - Allows iteration over a collection using `foreach`.\n  - **Read-only**: Does not provide methods to add, remove, or modify elements.\n- **Usage Example:**\n  ```csharp\n  IEnumerable collection = new List<int> { 1, 2, 3 };\n  foreach (var item in collection)\n  {\n      Console.WriteLine(item);\n  }\n  ```\n\n#### 2. `ICollection`\n- **Namespace:** `System.Collections`\n- **Purpose:** Extends `IEnumerable` and is the base interface for all collections.\n- **Key Features:**\n  - Inherits from `IEnumerable`.\n  - Provides methods for **counting** (`Count` property), **adding**, **removing**, and **checking** if an item exists.\n  - Supports **modification** of the collection.\n- **Usage Example:**\n  ```csharp\n  ICollection<int> collection = new List<int>();\n  collection.Add(1);\n  collection.Remove(1);\n  int count = collection.Count;\n  ```\n\n#### 3. `IList`\n- **Namespace:** `System.Collections`\n- **Purpose:** Extends `ICollection` and represents a collection of objects that can be individually accessed by index.\n- **Key Features:**\n  - Inherits from `ICollection` and `IEnumerable`.\n  - Provides **index-based access** (`this[int index]`).\n  - Allows **inserting** and **removing** elements at specific positions.\n  - Supports all functionalities of `ICollection` and `IEnumerable`.\n- **Usage Example:**\n  ```csharp\n  IList<int> list = new List<int>();\n  list.Add(1);\n  list.Insert(0, 2);\n  int value = list[0];\n  list.RemoveAt(1);\n  ```\n\n---\n\n#### **Summary Table**\n\n| Interface     | Inherits         | Key Features                              | Modification | Index Access |\n|---------------|------------------|-------------------------------------------|--------------|--------------|\n| `IEnumerable` | -                | Enumeration (`foreach`)                   | No           | No           |\n| `ICollection` | `IEnumerable`    | Count, Add, Remove, Contains              | Yes          | No           |\n| `IList`       | `ICollection`    | Indexer, Insert, RemoveAt, index access   | Yes          | Yes          |\n\n---\n\n**In short:**  \n- Use `IEnumerable` for simple iteration.\n- Use `ICollection` when you need to modify the collection (add/remove).\n- Use `IList` when you need index-based access and full list functionality.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252544Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "b430d03b-2d76-465b-98da-426ff4c11100",
    "question": "How do you perform a binary search on a collection in C#?",
    "answer": "```markdown\nTo perform a binary search on a collection in C#, you typically use the `Array.BinarySearch` method for arrays or the `List<T>.BinarySearch` method for lists. Binary search requires the collection to be sorted.\n\n**Example using an array:**\n\n```csharp\nint[] numbers = { 1, 3, 5, 7, 9, 11, 13 };\nint index = Array.BinarySearch(numbers, 7);\n\nif (index >= 0)\n{\n    Console.WriteLine($\"Element found at index {index}\");\n}\nelse\n{\n    Console.WriteLine(\"Element not found\");\n}\n```\n\n**Example using a list:**\n\n```csharp\nList<string> names = new List<string> { \"Alice\", \"Bob\", \"Charlie\", \"David\" };\nnames.Sort(); // Ensure the list is sorted\n\nint index = names.BinarySearch(\"Charlie\");\n\nif (index >= 0)\n{\n    Console.WriteLine($\"Element found at index {index}\");\n}\nelse\n{\n    Console.WriteLine(\"Element not found\");\n}\n```\n\n**Key Points:**\n- The collection must be sorted before performing a binary search.\n- The method returns the index of the element if found; otherwise, it returns a negative number.\n- For custom objects, you may need to implement `IComparable<T>` or provide a custom comparer.\n```",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252555Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "9a935818-9466-48d2-b4b0-c328b74702fe",
    "question": "What is the difference between a shallow copy and a deep copy in C# collections?",
    "answer": "```markdown\n**Difference Between Shallow Copy and Deep Copy in C# Collections**\n\n- **Shallow Copy:**\n  - A shallow copy of a collection copies the references of the objects, not the actual objects themselves.\n  - Both the original and the copied collection point to the same objects in memory.\n  - Changes to an object in one collection will reflect in the other.\n  - Example: Using `MemberwiseClone()` or the `Clone()` method of some collections.\n\n- **Deep Copy:**\n  - A deep copy creates a new collection and also creates new instances of the objects within the collection.\n  - The original and the copied collection are completely independent.\n  - Changes to an object in one collection do **not** affect the other.\n  - Deep copy usually requires custom implementation (e.g., by serializing and deserializing the objects).\n\n**Example:**\n\n```csharp\n// Shallow Copy Example\nList<Person> originalList = new List<Person> { new Person(\"Alice\"), new Person(\"Bob\") };\nList<Person> shallowCopy = new List<Person>(originalList); // Only references are copied\n\n// Deep Copy Example\nList<Person> deepCopy = originalList.Select(p => new Person(p.Name)).ToList(); // New objects are created\n```\n\n**Summary Table:**\n\n| Aspect         | Shallow Copy                                | Deep Copy                                   |\n|----------------|---------------------------------------------|---------------------------------------------|\n| Object Copies  | References                                  | New instances                               |\n| Independence   | Not independent (shared objects)            | Completely independent                      |\n| Implementation | Built-in for some collections               | Usually requires manual implementation      |\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:57:09.252567Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "8a609fbd-b621-4fb7-b7fd-006d67098319",
    "question": "How do you remove an item from a collection while iterating through it?",
    "answer": "```markdown\nRemoving an item from a collection while iterating through it in C# requires careful handling to avoid exceptions such as `InvalidOperationException`. Here are the recommended approaches:\n\n### 1. Using a `for` Loop (for List<T>)\n\nWhen working with a `List<T>`, iterate backwards to safely remove items:\n\n```csharp\nList<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\nfor (int i = numbers.Count - 1; i >= 0; i--)\n{\n    if (numbers[i] % 2 == 0)\n    {\n        numbers.RemoveAt(i);\n    }\n}\n```\n\n### 2. Using `RemoveAll` (for List<T>)\n\nFor simple predicates, use the `RemoveAll` method:\n\n```csharp\nnumbers.RemoveAll(n => n % 2 == 0);\n```\n\n### 3. Using a Temporary Collection\n\nFor collections that do not support indexed access (like `HashSet<T>` or `Dictionary<K,V>`), collect items to remove in a temporary list:\n\n```csharp\nvar itemsToRemove = new List<int>();\nforeach (var item in collection)\n{\n    if (ShouldRemove(item))\n    {\n        itemsToRemove.Add(item);\n    }\n}\nforeach (var item in itemsToRemove)\n{\n    collection.Remove(item);\n}\n```\n\n### 4. Using `IEnumerator` with `ICollection<T>.Remove`\n\nIf the collection supports it, you can use the `Remove` method outside the enumerator loop.\n\n### **Important Note**\n- **Never remove items directly from a collection inside a `foreach` loop**; this will throw an `InvalidOperationException` because the collection is being modified during enumeration.\n\n### **Summary Table**\n\n| Collection Type | Safe Removal Approach                |\n|-----------------|-------------------------------------|\n| List<T>         | Iterate backwards or use RemoveAll   |\n| HashSet<T>      | Collect to temp list, then remove    |\n| Dictionary<K,V> | Collect keys to temp list, then remove by key |\n\n**Best Practice:**  \nAlways avoid modifying the collection directly during iteration. Use a safe pattern as shown above to prevent runtime exceptions and ensure correct behavior.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252579Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "0b3d3de5-a59a-42a4-9580-7ae7af21dacb",
    "question": "What are the thread-safe collection types available in .NET?",
    "answer": "```markdown\n### What are the thread-safe collection types available in .NET?\n\n.NET provides several built-in thread-safe collection types within the `System.Collections.Concurrent` namespace, designed to support safe access and modification from multiple threads without requiring external synchronization. Some of the most commonly used thread-safe collections are:\n\n#### 1. `ConcurrentDictionary<TKey, TValue>`\n- A thread-safe implementation of a key-value pair dictionary.\n- Supports atomic operations like `AddOrUpdate`, `GetOrAdd`, and `TryRemove`.\n\n#### 2. `ConcurrentQueue<T>`\n- A thread-safe FIFO (First-In-First-Out) queue.\n- Allows multiple threads to enqueue and dequeue items safely.\n\n#### 3. `ConcurrentStack<T>`\n- A thread-safe LIFO (Last-In-First-Out) stack.\n- Supports safe push and pop operations from multiple threads.\n\n#### 4. `ConcurrentBag<T>`\n- A thread-safe, unordered collection of objects.\n- Optimized for scenarios where the same thread will both add and remove items.\n\n#### 5. `BlockingCollection<T>`\n- Provides blocking and bounding capabilities for thread-safe collections.\n- Can be used with any `IProducerConsumerCollection<T>` (such as `ConcurrentQueue<T>`, `ConcurrentStack<T>`, or `ConcurrentBag<T>`).\n- Supports blocking and bounding operations, making it suitable for producer-consumer scenarios.\n\n#### 6. `Immutable Collections` (in `System.Collections.Immutable`)\n- Collections like `ImmutableList<T>`, `ImmutableDictionary<TKey, TValue>`, etc., are inherently thread-safe because they never change after creation.\n- Any modification returns a new collection instance.\n\n---\n\n**Note:**  \nWhile legacy collections like `Hashtable` and `ArrayList` can be made thread-safe using wrappers (e.g., `Synchronized`), they are not recommended for new development. The concurrent collections listed above are specifically designed for high-performance, thread-safe operations in multi-threaded environments.\n```",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252591Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  },
  {
    "id": "4d9d6a82-bf90-4b03-b601-90fc3b71d5d1",
    "question": "How do you implement a custom iterator for a collection in C#?",
    "answer": "```markdown\nTo implement a custom iterator for a collection in C#, you typically use the `IEnumerable` and `IEnumerator` interfaces, or more conveniently, the `yield return` statement. Here’s how you can do both:\n\n### 1. Using `yield return` (Recommended)\n\nThis is the most concise and idiomatic way in C#.\n\n```csharp\npublic class MyCollection : IEnumerable<int>\n{\n    private int[] _items = { 1, 2, 3, 4, 5 };\n\n    public IEnumerator<int> GetEnumerator()\n    {\n        for (int i = 0; i < _items.Length; i++)\n        {\n            yield return _items[i];\n        }\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n```\n\n**Usage:**\n```csharp\nvar collection = new MyCollection();\nforeach (var item in collection)\n{\n    Console.WriteLine(item);\n}\n```\n\n### 2. Implementing `IEnumerator` Manually\n\nFor more control, implement `IEnumerable` and `IEnumerator` explicitly.\n\n```csharp\npublic class MyCollection : IEnumerable<int>\n{\n    private int[] _items = { 1, 2, 3, 4, 5 };\n\n    public IEnumerator<int> GetEnumerator()\n    {\n        return new MyEnumerator(_items);\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n\n    private class MyEnumerator : IEnumerator<int>\n    {\n        private int[] _items;\n        private int _position = -1;\n\n        public MyEnumerator(int[] items)\n        {\n            _items = items;\n        }\n\n        public int Current => _items[_position];\n\n        object IEnumerator.Current => Current;\n\n        public bool MoveNext()\n        {\n            _position++;\n            return _position < _items.Length;\n        }\n\n        public void Reset()\n        {\n            _position = -1;\n        }\n\n        public void Dispose() { }\n    }\n}\n```\n\n### **Key Points**\n- Implement `IEnumerable<T>` and `IEnumerator<T>` for type safety and LINQ compatibility.\n- Use `yield return` for simpler iterator logic.\n- Implement `IEnumerator` manually if you need more control over iteration state.\n\n**Interview Tip:**  \nExplain both approaches and mention that `yield return` is preferred for most scenarios due to its simplicity and maintainability.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:57:09.252603Z",
    "topic": "fb40198b-9fef-4f79-ac08-629ee12bef49"
  }
]
