[
  {
    "id": "79e2aceb-fb3b-45d1-987a-b791fe275515",
    "question": "How do you reverse a string in C#?",
    "answer": "```markdown **Question:** How do you reverse a string in C#?\n\n**Answer:**\n\nYou can reverse a string in C# by converting it to a character array, using the Array.Reverse method, and then creating a new string from the reversed array.\n\n```csharp\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        string original = \"hello\";\n        char[] charArray = original.ToCharArray();\n        Array.Reverse(charArray);\n        string reversed = new string(charArray);\n\n        Console.WriteLine(reversed); // Output: \"olleh\"\n    }\n}\n```\n\n**Explanation:**\n1. Convert the string to a character array using `ToCharArray()`.\n2. Reverse the array with `Array.Reverse()`.\n3. Create a new string from the reversed array.\n\nThis is a simple and efficient way to reverse a string in C#.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646767Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "0be98f07-5cd0-4282-9b4d-1bdad79f16fa",
    "question": "How do you check if a string is a palindrome?",
    "answer": "```markdown **Question:**  \nHow do you check if a string is a palindrome?\n\n**Answer:**  \nA palindrome is a string that reads the same backward as forward (e.g., \"madam\", \"racecar\"). To check if a string is a palindrome in C#, you can compare characters from the start and end moving towards the center.\n\nHere's a simple C# implementation:\n\n```csharp\nusing System;\n\nclass Program\n{\n    static bool IsPalindrome(string str)\n    {\n        int left = 0;\n        int right = str.Length - 1;\n\n        while (left < right)\n        {\n            if (str[left] != str[right])\n                return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    static void Main()\n    {\n        string input = \"madam\";\n        if (IsPalindrome(input))\n            Console.WriteLine($\"{input} is a palindrome.\");\n        else\n            Console.WriteLine($\"{input} is not a palindrome.\");\n    }\n}\n```\n\n**Explanation:**\n\n- The function `IsPalindrome` takes a string as input.\n- It uses two pointers: one starting from the beginning (`left`) and one from the end (`right`).\n- It compares the characters at these positions. If any pair does not match, it returns `false`.\n- If all pairs match, it returns `true`, indicating the string is a palindrome.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646798Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "d0922a52-1c54-4047-8c0b-6f9abf0d8d46",
    "question": "How do you find the maximum value in an integer array?",
    "answer": "```markdown **Question:**  \nHow do you find the maximum value in an integer array?\n\n**Answer:**  \nTo find the maximum value in an integer array in C#, you can iterate through the array and keep track of the largest value found so far. Here’s a simple example:\n\n```csharp\nint[] numbers = { 5, 3, 9, 1, 7 };\n\nint max = numbers[0]; // Assume first element is the maximum initially\n\nfor (int i = 1; i < numbers.Length; i++)\n{\n    if (numbers[i] > max)\n    {\n        max = numbers[i];\n    }\n}\n\nConsole.WriteLine(\"The maximum value is: \" + max);\n```\n\n**Explanation:**\n- Start by assuming the first element is the maximum.\n- Loop through the rest of the array.\n- If you find a number greater than the current maximum, update the maximum.\n- After the loop, max holds the largest value in the array.\n\n**Note:**  \nAlternatively, you can use the built-in method:\n\n```csharp\nint max = numbers.Max();\n```\nBut understanding the manual approach is important for algorithm interviews!",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646807Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "cfad6bf9-63be-4c5f-98a5-f96fc7aed953",
    "question": "How do you find the minimum value in an integer array?",
    "answer": "```markdown **Question:**  \nHow do you find the minimum value in an integer array?\n\n**Answer:**  \nTo find the minimum value in an integer array in C#, you can iterate through the array and keep track of the smallest value found so far. Here is a simple way to do it:\n\n```csharp\nint[] numbers = { 5, 2, 8, 1, 9 };\n\nint min = numbers[0]; // Assume first element is the minimum\n\nfor (int i = 1; i < numbers.Length; i++)\n{\n    if (numbers[i] < min)\n    {\n        min = numbers[i];\n    }\n}\n\nConsole.WriteLine(\"The minimum value is: \" + min);\n```\n\n**Explanation:**\n- Start by assuming the first element is the minimum.\n- Loop through the rest of the array.\n- If you find a smaller value, update the minimum.\n- After the loop, min will hold the smallest value in the array.\n\n**Alternative (using LINQ):**\n```csharp\nint min = numbers.Min();\nConsole.WriteLine(\"The minimum value is: \" + min);\n```\nThis uses the built-in `Min()` method from LINQ for a more concise solution.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646815Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "3d7d3667-ecd6-4aa3-965b-77e06c005a52",
    "question": "How do you implement binary search on a sorted array?",
    "answer": "```markdown ### How do you implement binary search on a sorted array?\n\nBinary search is an efficient algorithm for finding an item from a sorted array. It works by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half. Repeat until the value is found or the interval is empty.\n\n#### C# Implementation\n\n```csharp\npublic int BinarySearch(int[] array, int target)\n{\n    int left = 0;\n    int right = array.Length - 1;\n\n    while (left <= right)\n    {\n        int mid = left + (right - left) / 2;\n\n        if (array[mid] == target)\n            return mid; // Target found, return index\n\n        if (array[mid] < target)\n            left = mid + 1; // Search right half\n        else\n            right = mid - 1; // Search left half\n    }\n\n    return -1; // Target not found\n}\n```\n\n#### Example Usage\n\n```csharp\nint[] numbers = { 1, 3, 5, 7, 9, 11 };\nint index = BinarySearch(numbers, 7); // Returns 3\n```\n\n#### Key Points\n\n- The array must be sorted.\n- Time complexity: O(log n)\n- Returns the index of the target if found, otherwise -1.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646824Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "15ce9509-2d2e-4b07-9f40-0e1e94a8a925",
    "question": "How do you sort an array using bubble sort?",
    "answer": "```markdown **Question:** How do you sort an array using bubble sort?\n\n**Answer:**\n\nBubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the array is sorted.\n\nHere is how you can implement bubble sort in C#:\n\n```csharp\nusing System;\n\nclass Program\n{\n    static void BubbleSort(int[] arr)\n    {\n        int n = arr.Length;\n        for (int i = 0; i < n - 1; i++)\n        {\n            // Last i elements are already in place\n            for (int j = 0; j < n - i - 1; j++)\n            {\n                if (arr[j] > arr[j + 1])\n                {\n                    // Swap arr[j] and arr[j + 1]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n            }\n        }\n    }\n\n    static void Main()\n    {\n        int[] arr = { 5, 2, 9, 1, 5, 6 };\n        Console.WriteLine(\"Original array: \" + string.Join(\", \", arr));\n        BubbleSort(arr);\n        Console.WriteLine(\"Sorted array: \" + string.Join(\", \", arr));\n    }\n}\n```\n\n**Output:**\n```\nOriginal array: 5, 2, 9, 1, 5, 6\nSorted array: 1, 2, 5, 5, 6, 9\n```\n\n**Explanation:**\n- The outer loop runs for each element in the array.\n- The inner loop compares each pair of adjacent elements and swaps them if they are in the wrong order.\n- After each pass, the largest unsorted element \"bubbles up\" to its correct position at the end of the array.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646834Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "524fdda7-3742-4cd3-8152-6fb6855a3c87",
    "question": "How do you remove duplicates from an array?",
    "answer": "```markdown **Question:**  \nHow do you remove duplicates from an array?\n\n**Answer:**  \nYou can remove duplicates from an array in C# by using a HashSet, which only stores unique elements. Here’s a simple way to do it:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] arrayWithDuplicates = { 1, 2, 3, 2, 4, 1, 5 };\n        \n        // Use HashSet to remove duplicates\n        HashSet<int> uniqueSet = new HashSet<int>(arrayWithDuplicates);\n        \n        // Convert back to array if needed\n        int[] arrayWithoutDuplicates = new int[uniqueSet.Count];\n        uniqueSet.CopyTo(arrayWithoutDuplicates);\n\n        // Print result\n        Console.WriteLine(\"Array without duplicates: \" + string.Join(\", \", arrayWithoutDuplicates));\n    }\n}\n```\n\n**Output:**\n```\nArray without duplicates: 1, 2, 3, 4, 5\n```\n\n**Explanation:**  \n- A `HashSet<T>` automatically ignores duplicate values.\n- You can initialize a `HashSet` with your array, and it will only keep unique elements.\n- If you need the result as an array, use `CopyTo()` or `ToArray()`.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646843Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "9eba73c8-5864-4487-82a8-37de50a36f1c",
    "question": "How do you find the factorial of a number using recursion?",
    "answer": "```markdown **Question:**  \nHow do you find the factorial of a number using recursion?\n\n**Answer:**  \nThe factorial of a number n (written as n!) is the product of all positive integers less than or equal to n. Using recursion in C#, you can define a method that calls itself to compute the factorial.\n\nHere is a simple C# implementation:\n\n```csharp\nint Factorial(int n)\n{\n    // Base case: factorial of 0 or 1 is 1\n    if (n == 0 || n == 1)\n        return 1;\n    // Recursive case\n    return n * Factorial(n - 1);\n}\n```\n\n**Example usage:**\n\n```csharp\nConsole.WriteLine(Factorial(5)); // Output: 120\n```\n\n**Explanation:**\n- If n is 0 or 1, the function returns 1.\n- Otherwise, it multiplies n by the factorial of (n - 1), calling itself recursively until it reaches the base case.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646851Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "6a16aa9a-e67b-4947-96ff-2c509592b385",
    "question": "How do you calculate the nth Fibonacci number iteratively?",
    "answer": "```markdown **Question:**  \nHow do you calculate the nth Fibonacci number iteratively?\n\n**Answer:**  \nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. To calculate the nth Fibonacci number iteratively in C#, you can use a simple loop to update two variables that keep track of the previous two Fibonacci numbers.\n\nHere’s an example implementation in C#:\n\n```csharp\npublic int Fibonacci(int n)\n{\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    int prev = 0;\n    int curr = 1;\n\n    for (int i = 2; i <= n; i++)\n    {\n        int next = prev + curr;\n        prev = curr;\n        curr = next;\n    }\n\n    return curr;\n}\n```\n\n**Explanation:**\n- If n is 0, return 0. If n is 1, return 1.\n- For n > 1, use a loop to calculate each Fibonacci number up to n by summing the previous two numbers.\n- The variables prev and curr keep track of the (i-2)th and (i-1)th Fibonacci numbers, respectively.\n- The final value of curr after the loop is the nth Fibonacci number.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646860Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "7aa57d00-0094-4864-a114-880269431abb",
    "question": "How do you check if two strings are anagrams?",
    "answer": "```markdown **Question:** How do you check if two strings are anagrams?\n\n**Answer:**\n\nTwo strings are anagrams if they contain the same characters in the same frequency, but possibly in a different order. For example, \"listen\" and \"silent\" are anagrams.\n\nHere's a simple way to check if two strings are anagrams in C#:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static bool AreAnagrams(string str1, string str2)\n    {\n        // If lengths are not equal, they can't be anagrams\n        if (str1.Length != str2.Length)\n            return false;\n\n        // Convert strings to character arrays\n        char[] arr1 = str1.ToCharArray();\n        char[] arr2 = str2.ToCharArray();\n\n        // Sort both arrays\n        Array.Sort(arr1);\n        Array.Sort(arr2);\n\n        // Compare sorted arrays\n        for (int i = 0; i < arr1.Length; i++)\n        {\n            if (arr1[i] != arr2[i])\n                return false;\n        }\n\n        return true;\n    }\n\n    public static void Main()\n    {\n        string s1 = \"listen\";\n        string s2 = \"silent\";\n\n        if (AreAnagrams(s1, s2))\n            Console.WriteLine($\"{s1} and {s2} are anagrams.\");\n        else\n            Console.WriteLine($\"{s1} and {s2} are not anagrams.\");\n    }\n}\n```\n\n**Explanation:**\n\n1. Check if the lengths of the strings are equal.\n2. Convert both strings to character arrays.\n3. Sort both arrays.\n4. Compare the sorted arrays character by character.\n5. If all characters match, the strings are anagrams.\n\n**Output:**\n```\nlisten and silent are anagrams.\n```",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646868Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "0d1eb667-73a7-4ad9-a43d-33192d373348",
    "question": "How do you count the number of vowels in a string?",
    "answer": "```markdown **Question:**  \nHow do you count the number of vowels in a string?\n\n**Answer:**  \nTo count the number of vowels in a string in C#, you can loop through each character in the string and check if it is a vowel (a, e, i, o, u, either lowercase or uppercase). If it is, increment a counter.\n\nHere’s a simple example in C#:\n\n```csharp\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        string input = \"Hello World\";\n        int vowelCount = CountVowels(input);\n        Console.WriteLine($\"Number of vowels: {vowelCount}\");\n    }\n\n    static int CountVowels(string str)\n    {\n        int count = 0;\n        string vowels = \"aeiouAEIOU\";\n        foreach (char c in str)\n        {\n            if (vowels.Contains(c))\n            {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n**Explanation:**\n- We define a string vowels containing all vowel characters (both lowercase and uppercase).\n- For each character in the input string, we check if it is in the vowels string.\n- If it is, we increment the count.\n- Finally, we return the total count of vowels found in the string.",
    "level": "Beginner",
    "created_at": "2025-04-21T11:58:37.646879Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "9780ec4c-6b45-47dd-8adf-0ced9f474ec7",
    "question": "How do you reverse a linked list?",
    "answer": "```markdown **How do you reverse a linked list?**\n\nTo reverse a singly linked list, you need to change the direction of the pointers so that each node points to its previous node instead of its next node. This can be done iteratively by keeping track of the previous, current, and next nodes as you traverse the list.\n\n**C# Implementation:**\n\n```csharp\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n    public ListNode(int val = 0, ListNode next = null)\n    {\n        this.val = val;\n        this.next = next;\n    }\n}\n\npublic class Solution\n{\n    public ListNode ReverseList(ListNode head)\n    {\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null)\n        {\n            ListNode nextTemp = current.next; // Store next node\n            current.next = prev;              // Reverse current node's pointer\n            prev = current;                   // Move prev to current\n            current = nextTemp;               // Move to next node\n        }\n        return prev; // New head of the reversed list\n    }\n}\n```\n\n**Explanation:**\n\n1. Initialize `prev` as `null` and `current` as the head of the list.\n2. Iterate through the list:\n    - Store the next node (`nextTemp`).\n    - Reverse the current node's pointer (`current.next = prev`).\n    - Move `prev` and `current` one step forward.\n3. When done, `prev` will be the new head of the reversed list.\n\n**Time Complexity:** O(n)  \n**Space Complexity:** O(1)",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646887Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "ef9a0083-e983-4a25-811c-c06b547d1d57",
    "question": "How do you detect a cycle in a linked list?",
    "answer": "```markdown **Detecting a Cycle in a Linked List (C# Solution)**\n\nTo detect a cycle in a linked list, the most common approach is Floyd’s Cycle-Finding Algorithm, also known as the \"Tortoise and Hare\" algorithm. This method uses two pointers that traverse the list at different speeds.\n\n### Approach\n\n- Initialize two pointers, `slow` and `fast`, both starting at the head of the linked list.\n- Move `slow` by one node and `fast` by two nodes in each iteration.\n- If there is a cycle, `slow` and `fast` will eventually meet.\n- If `fast` reaches the end (`null`), there is no cycle.\n\n### C# Implementation\n\n```csharp\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n    public ListNode(int x) { val = x; next = null; }\n}\n\npublic class Solution\n{\n    public bool HasCycle(ListNode head)\n    {\n        if (head == null || head.next == null)\n            return false;\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if (slow == fast)\n                return true; // Cycle detected\n        }\n\n        return false; // No cycle\n    }\n}\n```\n\n### Explanation\n\n- The `HasCycle` method returns `true` if a cycle is detected, otherwise `false`.\n- The key idea is that if a cycle exists, the fast pointer will eventually \"lap\" the slow pointer.\n\n---\n\n**Time Complexity:** O(n)  \n**Space Complexity:** O(1)",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646895Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "d74ea41b-a653-4485-9e7b-b769ace2aaa2",
    "question": "How do you merge two sorted arrays?",
    "answer": "```markdown ### How do you merge two sorted arrays?\n\nTo merge two sorted arrays into a single sorted array, you can use a two-pointer approach. This method compares the elements of both arrays one by one and adds the smaller element to the result array, ensuring the merged array remains sorted.\n\n#### Steps:\n\n1. Initialize two pointers, one for each array.\n2. Compare the elements at both pointers.\n3. Add the smaller element to the result array and move that pointer forward.\n4. Repeat until one array is exhausted.\n5. Append any remaining elements from the other array.\n\n#### C# Implementation\n\n```csharp\npublic int[] MergeSortedArrays(int[] arr1, int[] arr2)\n{\n    int n1 = arr1.Length, n2 = arr2.Length;\n    int[] merged = new int[n1 + n2];\n    int i = 0, j = 0, k = 0;\n\n    // Traverse both arrays\n    while (i < n1 && j < n2)\n    {\n        if (arr1[i] <= arr2[j])\n        {\n            merged[k++] = arr1[i++];\n        }\n        else\n        {\n            merged[k++] = arr2[j++];\n        }\n    }\n\n    // Copy remaining elements of arr1, if any\n    while (i < n1)\n    {\n        merged[k++] = arr1[i++];\n    }\n\n    // Copy remaining elements of arr2, if any\n    while (j < n2)\n    {\n        merged[k++] = arr2[j++];\n    }\n\n    return merged;\n}\n```\n\n#### Example Usage\n\n```csharp\nint[] arr1 = {1, 3, 5, 7};\nint[] arr2 = {2, 4, 6, 8};\nint[] result = MergeSortedArrays(arr1, arr2);\n// result: {1, 2, 3, 4, 5, 6, 7, 8}\n```\n\nThis approach runs in O(n + m) time, where n and m are the lengths of the two arrays.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646902Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "44bcd3d1-5ed5-45c0-8fb4-e78492d5b2e7",
    "question": "How do you implement quicksort?",
    "answer": "```markdown\n## How do you implement quicksort in C#?\n\nQuicksort is a popular divide-and-conquer sorting algorithm. It works by selecting a \"pivot\" element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\n\nHere's a simple implementation of quicksort in C#:\n\n```csharp\nusing System;\n\nclass Program\n{\n    // Main function to test quicksort\n    static void Main()\n    {\n        int[] arr = { 10, 7, 8, 9, 1, 5 };\n        int n = arr.Length;\n\n        QuickSort(arr, 0, n - 1);\n\n        Console.WriteLine(\"Sorted array:\");\n        Console.WriteLine(string.Join(\" \", arr));\n    }\n\n    // Quicksort function\n    static void QuickSort(int[] arr, int low, int high)\n    {\n        if (low < high)\n        {\n            // pi is partitioning index, arr[pi] is now at right place\n            int pi = Partition(arr, low, high);\n\n            // Recursively sort elements before and after partition\n            QuickSort(arr, low, pi - 1);\n            QuickSort(arr, pi + 1, high);\n        }\n    }\n\n    // Partition function\n    static int Partition(int[] arr, int low, int high)\n    {\n        int pivot = arr[high]; // pivot\n        int i = (low - 1); // Index of smaller element\n\n        for (int j = low; j < high; j++)\n        {\n            // If current element is smaller than or equal to pivot\n            if (arr[j] <= pivot)\n            {\n                i++;\n                // Swap arr[i] and arr[j]\n                Swap(arr, i, j);\n            }\n        }\n\n        // Swap arr[i+1] and arr[high] (or pivot)\n        Swap(arr, i + 1, high);\n        return i + 1;\n    }\n\n    // Swap helper function\n    static void Swap(int[] arr, int i, int j)\n    {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```\n\n**Explanation:**\n- The `QuickSort` function recursively sorts the array.\n- The `Partition` function places the pivot element at its correct position and arranges all smaller elements to the left and greater to the right.\n- The `Swap` function exchanges two elements in the array.\n\n**Time Complexity:**  \n- Average case: O(n log n)\n- Worst case: O(n²) (rare, occurs when the smallest or largest element is always chosen as pivot)\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646910Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "989b99c7-4d92-4e6b-832e-ebb0967d264e",
    "question": "How do you implement mergesort?",
    "answer": "```markdown Certainly! Here’s an explanation and C# implementation of Merge Sort:\n\n## How do you implement Merge Sort?\n\n**Merge Sort** is a classic divide-and-conquer sorting algorithm. It works by recursively splitting the array into halves, sorting each half, and then merging the sorted halves.\n\n### Steps:\n\n1. **Divide:** Split the array into two halves.\n2. **Conquer:** Recursively sort each half.\n3. **Combine:** Merge the two sorted halves into a single sorted array.\n\n### C# Implementation\n\n```csharp\nusing System;\n\nclass MergeSortExample\n{\n    // Main function to sort an array using MergeSort\n    public static void MergeSort(int[] array, int left, int right)\n    {\n        if (left < right)\n        {\n            int mid = (left + right) / 2;\n\n            // Sort first and second halves\n            MergeSort(array, left, mid);\n            MergeSort(array, mid + 1, right);\n\n            // Merge the sorted halves\n            Merge(array, left, mid, right);\n        }\n    }\n\n    // Helper function to merge two sorted subarrays\n    private static void Merge(int[] array, int left, int mid, int right)\n    {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n\n        // Create temporary arrays\n        int[] leftArray = new int[n1];\n        int[] rightArray = new int[n2];\n\n        // Copy data to temp arrays\n        Array.Copy(array, left, leftArray, 0, n1);\n        Array.Copy(array, mid + 1, rightArray, 0, n2);\n\n        int i = 0, j = 0, k = left;\n\n        // Merge the temp arrays back into the original array\n        while (i < n1 && j < n2)\n        {\n            if (leftArray[i] <= rightArray[j])\n            {\n                array[k++] = leftArray[i++];\n            }\n            else\n            {\n                array[k++] = rightArray[j++];\n            }\n        }\n\n        // Copy any remaining elements\n        while (i < n1)\n        {\n            array[k++] = leftArray[i++];\n        }\n        while (j < n2)\n        {\n            array[k++] = rightArray[j++];\n        }\n    }\n\n    // Example usage\n    public static void Main()\n    {\n        int[] arr = { 38, 27, 43, 3, 9, 82, 10 };\n        Console.WriteLine(\"Original array: \" + string.Join(\", \", arr));\n        MergeSort(arr, 0, arr.Length - 1);\n        Console.WriteLine(\"Sorted array: \" + string.Join(\", \", arr));\n    }\n}\n```\n\n### Output\n\n```\nOriginal array: 38, 27, 43, 3, 9, 82, 10\nSorted array: 3, 9, 10, 27, 38, 43, 82\n```\n\n---\n\n**Time Complexity:** O(n log n)  \n**Space Complexity:** O(n) (due to temporary arrays used during merging)",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646917Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "2108976a-fd1b-4dc0-be3b-10635b4d37b6",
    "question": "How do you find the intersection of two arrays?",
    "answer": "```markdown **Question:**  \nHow do you find the intersection of two arrays?\n\n**Answer:**  \nTo find the intersection of two arrays in C#, you can use a HashSet to efficiently check for common elements. Here’s a step-by-step approach:\n\n1. Add all elements of the first array to a HashSet.\n2. Iterate through the second array, and for each element, check if it exists in the HashSet.\n3. If it does, add it to the result set (to avoid duplicates).\n4. Convert the result set to an array if needed.\n\nBelow is a sample implementation:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static int[] Intersect(int[] nums1, int[] nums2)\n    {\n        HashSet<int> set1 = new HashSet<int>(nums1);\n        HashSet<int> result = new HashSet<int>();\n\n        foreach (int num in nums2)\n        {\n            if (set1.Contains(num))\n            {\n                result.Add(num);\n            }\n        }\n\n        // Convert the result set to an array\n        int[] intersection = new int[result.Count];\n        result.CopyTo(intersection);\n        return intersection;\n    }\n\n    static void Main()\n    {\n        int[] array1 = {1, 2, 2, 3, 4};\n        int[] array2 = {2, 2, 3, 5};\n\n        int[] intersection = Intersect(array1, array2);\n\n        Console.WriteLine(\"Intersection: \" + string.Join(\", \", intersection));\n        // Output: Intersection: 2, 3\n    }\n}\n```\n\n**Explanation:**\n- The use of HashSet ensures that each element in the result is unique.\n- This approach has a time complexity of O(n + m), where n and m are the lengths of the two arrays.\n\n**Alternative:**  \nYou can also use LINQ for a more concise solution:\n\n```csharp\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] array1 = {1, 2, 2, 3, 4};\n        int[] array2 = {2, 2, 3, 5};\n\n        var intersection = array1.Intersect(array2);\n\n        Console.WriteLine(\"Intersection: \" + string.Join(\", \", intersection));\n        // Output: Intersection: 2, 3\n    }\n}\n```\n\n**Note:**  \n- `Intersect` in LINQ returns distinct elements that appear in both arrays.  \n- If you need to consider duplicate occurrences (multiset intersection), you would need a different approach.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646925Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "983eb11b-5971-469b-b0e4-b60300b2e869",
    "question": "How do you find the first non-repeated character in a string?",
    "answer": "```markdown **Question:**  \nHow do you find the first non-repeated character in a string?\n\n**Answer:**  \nTo find the first non-repeated character in a string, you can use a dictionary to count the occurrences of each character, then iterate through the string to find the first character with a count of 1.\n\nHere’s how you can do it in C#:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static char? FirstNonRepeatedCharacter(string input)\n    {\n        var charCount = new Dictionary<char, int>();\n\n        // First pass: count each character\n        foreach (char c in input)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        // Second pass: find the first character with count 1\n        foreach (char c in input)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        // If no non-repeated character found\n        return null;\n    }\n\n    public static void Main()\n    {\n        string input = \"swiss\";\n        char? result = FirstNonRepeatedCharacter(input);\n        if (result != null)\n            Console.WriteLine($\"First non-repeated character: {result}\");\n        else\n            Console.WriteLine(\"No non-repeated character found.\");\n    }\n}\n```\n\n**Explanation:**\n1. Use a dictionary to store the count of each character.\n2. Iterate through the string to populate the dictionary.\n3. Iterate again to find the first character with a count of 1.\n4. Return the character if found, otherwise return null.\n\n**Output for input \"swiss\":**\n```\nFirst non-repeated character: w\n```",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646934Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "29733fd9-56ff-44a2-a8f3-dcfcf4e3549c",
    "question": "How do you implement a stack using arrays?",
    "answer": "```markdown\n## How do you implement a stack using arrays in C#?\n\nA stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. You can implement a stack using arrays by maintaining an array to store the elements and an integer variable to track the top of the stack.\n\n### Implementation in C#\n\n```csharp\npublic class Stack\n{\n    private int[] arr;\n    private int top;\n    private int capacity;\n\n    // Constructor to initialize stack\n    public Stack(int size)\n    {\n        arr = new int[size];\n        capacity = size;\n        top = -1;\n    }\n\n    // Add an element to the stack\n    public void Push(int item)\n    {\n        if (IsFull())\n        {\n            Console.WriteLine(\"Stack Overflow\");\n            return;\n        }\n        arr[++top] = item;\n    }\n\n    // Remove and return the top element of the stack\n    public int Pop()\n    {\n        if (IsEmpty())\n        {\n            Console.WriteLine(\"Stack Underflow\");\n            return -1; // Or throw exception\n        }\n        return arr[top--];\n    }\n\n    // Return the top element without removing it\n    public int Peek()\n    {\n        if (IsEmpty())\n        {\n            Console.WriteLine(\"Stack is empty\");\n            return -1; // Or throw exception\n        }\n        return arr[top];\n    }\n\n    // Check if the stack is empty\n    public bool IsEmpty()\n    {\n        return top == -1;\n    }\n\n    // Check if the stack is full\n    public bool IsFull()\n    {\n        return top == capacity - 1;\n    }\n}\n```\n\n### Example Usage\n\n```csharp\nStack stack = new Stack(5);\n\nstack.Push(10);\nstack.Push(20);\nstack.Push(30);\n\nConsole.WriteLine(stack.Pop());   // Output: 30\nConsole.WriteLine(stack.Peek());  // Output: 20\n```\n\n### Explanation\n\n- The `arr` array stores the stack elements.\n- The `top` variable keeps track of the index of the top element.\n- `Push` adds an element to the top of the stack.\n- `Pop` removes and returns the top element.\n- `Peek` returns the top element without removing it.\n- `IsEmpty` and `IsFull` check for underflow and overflow conditions, respectively.\n```\n",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646941Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "42042897-51b3-4f6f-a74a-1dae2327f6f1",
    "question": "How do you implement a queue using linked list?",
    "answer": "```markdown ### How do you implement a queue using a linked list in C#?\n\nA queue is a First-In-First-Out (FIFO) data structure. Using a linked list to implement a queue allows for efficient enqueue (add to rear) and dequeue (remove from front) operations.\n\n#### Implementation\n\n```csharp\n// Node class for the linked list\npublic class Node<T>\n{\n    public T Data;\n    public Node<T> Next;\n\n    public Node(T data)\n    {\n        Data = data;\n        Next = null;\n    }\n}\n\n// Queue class using linked list\npublic class LinkedListQueue<T>\n{\n    private Node<T> front;\n    private Node<T> rear;\n\n    public LinkedListQueue()\n    {\n        front = null;\n        rear = null;\n    }\n\n    // Enqueue: Add item to the rear of the queue\n    public void Enqueue(T item)\n    {\n        Node<T> newNode = new Node<T>(item);\n        if (rear == null)\n        {\n            front = rear = newNode;\n        }\n        else\n        {\n            rear.Next = newNode;\n            rear = newNode;\n        }\n    }\n\n    // Dequeue: Remove item from the front of the queue\n    public T Dequeue()\n    {\n        if (front == null)\n            throw new InvalidOperationException(\"Queue is empty.\");\n\n        T value = front.Data;\n        front = front.Next;\n\n        if (front == null)\n            rear = null;\n\n        return value;\n    }\n\n    // Peek: Get the front item without removing it\n    public T Peek()\n    {\n        if (front == null)\n            throw new InvalidOperationException(\"Queue is empty.\");\n\n        return front.Data;\n    }\n\n    // Check if the queue is empty\n    public bool IsEmpty()\n    {\n        return front == null;\n    }\n}\n```\n\n#### Usage Example\n\n```csharp\nvar queue = new LinkedListQueue<int>();\nqueue.Enqueue(10);\nqueue.Enqueue(20);\nConsole.WriteLine(queue.Dequeue()); // Output: 10\nConsole.WriteLine(queue.Peek());    // Output: 20\n```\n\n#### Explanation\n\n- **Enqueue:** Adds a new node at the end (rear) of the linked list.\n- **Dequeue:** Removes a node from the front of the linked list.\n- Both operations are O(1) time complexity.\n- The queue maintains references to both the front and rear nodes for efficiency.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646950Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "15dfc6b3-69e2-4703-879d-78a8672002d5",
    "question": "How do you find the missing number in an array of 1 to N?",
    "answer": "```markdown **Question:**  \nHow do you find the missing number in an array of 1 to N?\n\n**Answer:**  \nTo find the missing number in an array containing numbers from 1 to N (with one number missing), you can use the formula for the sum of the first N natural numbers:\n\n\\[\n\\text{Sum} = \\frac{N \\times (N + 1)}{2}\n\\]\n\nCalculate the expected sum for numbers 1 to N, then subtract the sum of the array elements from this expected sum. The result is the missing number.\n\n**C# Implementation:**\n\n```csharp\nint FindMissingNumber(int[] arr, int N)\n{\n    int expectedSum = N * (N + 1) / 2;\n    int actualSum = 0;\n    foreach (int num in arr)\n    {\n        actualSum += num;\n    }\n    return expectedSum - actualSum;\n}\n```\n\n**Example Usage:**\n\n```csharp\nint[] arr = {1, 2, 4, 5, 6}; // N = 6, missing number is 3\nint missing = FindMissingNumber(arr, 6);\nConsole.WriteLine(\"Missing number is: \" + missing); // Output: 3\n```\n\n**Time Complexity:** O(N)  \n**Space Complexity:** O(1)",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646957Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "2ebb8191-7970-4f60-80c5-045aee5282bb",
    "question": "How do you find the duplicate number in an array?",
    "answer": "```markdown **Question:**  \nHow do you find the duplicate number in an array?\n\n**Answer:**  \nTo find a duplicate number in an array where numbers are in the range 1 to n and only one duplicate exists, you can use Floyd's Tortoise and Hare (Cycle Detection) algorithm. This approach uses constant space and runs in linear time.\n\nHere's how you can implement it in C#:\n\n```csharp\npublic int FindDuplicate(int[] nums)\n{\n    int slow = nums[0];\n    int fast = nums[0];\n\n    // Phase 1: Finding the intersection point of the two runners.\n    do\n    {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    // Phase 2: Find the entrance to the cycle.\n    slow = nums[0];\n    while (slow != fast)\n    {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n**Explanation:**\n- The algorithm treats the array as a linked list where each index points to the value at that index.\n- The duplicate number forms a cycle.\n- The first loop finds the intersection point inside the cycle.\n- The second loop finds the entrance to the cycle, which is the duplicate number.\n\n**Example:**\n```csharp\nint[] nums = {1, 3, 4, 2, 2};\nint duplicate = FindDuplicate(nums); // Output: 2\n```\n\n**Note:**  \nIf the array may contain multiple duplicates or numbers outside the 1 to n range, you may need to use a HashSet to track seen numbers:\n\n```csharp\npublic int FindDuplicate(int[] nums)\n{\n    HashSet<int> seen = new HashSet<int>();\n    foreach (int num in nums)\n    {\n        if (seen.Contains(num))\n            return num;\n        seen.Add(num);\n    }\n    return -1; // No duplicate found\n}\n```\n\nChoose the method that best fits the constraints of your problem.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646965Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "acbd85b3-12ab-48ca-b868-d27998c1cf16",
    "question": "How do you implement depth-first search (DFS) in a graph?",
    "answer": "```markdown **Question:**  \nHow do you implement depth-first search (DFS) in a graph?\n\n**Answer:**  \n\nDepth-First Search (DFS) is a graph traversal algorithm that explores as far as possible along each branch before backtracking. DFS can be implemented using recursion or an explicit stack.\n\nBelow is a C# implementation of DFS for a graph represented using an adjacency list:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Graph\n{\n    private int vertices;\n    private List<int>[] adjList;\n\n    public Graph(int v)\n    {\n        vertices = v;\n        adjList = new List<int>[v];\n        for (int i = 0; i < v; i++)\n            adjList[i] = new List<int>();\n    }\n\n    public void AddEdge(int src, int dest)\n    {\n        adjList[src].Add(dest);\n        // For undirected graph, uncomment the next line:\n        // adjList[dest].Add(src);\n    }\n\n    // Recursive DFS utility\n    private void DFSUtil(int v, bool[] visited)\n    {\n        visited[v] = true;\n        Console.Write(v + \" \");\n\n        foreach (int neighbor in adjList[v])\n        {\n            if (!visited[neighbor])\n                DFSUtil(neighbor, visited);\n        }\n    }\n\n    // DFS traversal from a given source\n    public void DFS(int start)\n    {\n        bool[] visited = new bool[vertices];\n        DFSUtil(start, visited);\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Graph g = new Graph(5);\n        g.AddEdge(0, 1);\n        g.AddEdge(0, 2);\n        g.AddEdge(1, 3);\n        g.AddEdge(1, 4);\n\n        Console.WriteLine(\"DFS starting from vertex 0:\");\n        g.DFS(0);\n    }\n}\n```\n\n**Output:**\n```\nDFS starting from vertex 0:\n0 1 3 4 2 \n```\n\n**Explanation:**\n- The graph is represented using an adjacency list.\n- DFS is performed recursively, marking each visited node.\n- The traversal starts from the specified node and explores as deep as possible before backtracking.\n\n**Note:**  \nFor disconnected graphs, you should call DFS for every unvisited vertex to ensure all nodes are covered.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646973Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "173f0e1d-9cc4-4e7d-a987-304255806f5c",
    "question": "How do you implement breadth-first search (BFS) in a graph?",
    "answer": "```markdown **Breadth-First Search (BFS) in a Graph - C# Implementation**\n\nBreadth-First Search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at a selected node (source) and explores all its neighbors at the current depth before moving to nodes at the next depth level.\n\nBelow is a C# implementation of BFS for an undirected graph using an adjacency list:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Graph\n{\n    private int vertices;\n    private List<int>[] adjList;\n\n    public Graph(int v)\n    {\n        vertices = v;\n        adjList = new List<int>[v];\n        for (int i = 0; i < v; i++)\n            adjList[i] = new List<int>();\n    }\n\n    public void AddEdge(int u, int v)\n    {\n        adjList[u].Add(v);\n        adjList[v].Add(u); // For undirected graph\n    }\n\n    public void BFS(int start)\n    {\n        bool[] visited = new bool[vertices];\n        Queue<int> queue = new Queue<int>();\n\n        visited[start] = true;\n        queue.Enqueue(start);\n\n        while (queue.Count > 0)\n        {\n            int node = queue.Dequeue();\n            Console.Write(node + \" \");\n\n            foreach (int neighbor in adjList[node])\n            {\n                if (!visited[neighbor])\n                {\n                    visited[neighbor] = true;\n                    queue.Enqueue(neighbor);\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nclass Program\n{\n    static void Main()\n    {\n        Graph g = new Graph(5);\n        g.AddEdge(0, 1);\n        g.AddEdge(0, 2);\n        g.AddEdge(1, 3);\n        g.AddEdge(1, 4);\n\n        Console.WriteLine(\"BFS starting from node 0:\");\n        g.BFS(0);\n    }\n}\n```\n\n**Output:**\n```\nBFS starting from node 0:\n0 1 2 3 4\n```\n\n**Explanation:**\n- The graph is represented using an adjacency list.\n- A boolean array keeps track of visited nodes.\n- A queue is used to process nodes in FIFO order.\n- Starting from the source node, BFS visits all neighbors, then their neighbors, and so on.\n\n**Time Complexity:** O(V + E), where V is the number of vertices and E is the number of edges.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646980Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "a1d11b79-7024-490e-88c1-cc2638edd970",
    "question": "How do you check if a binary tree is balanced?",
    "answer": "```markdown **Question:**  \nHow do you check if a binary tree is balanced?\n\n**Answer:**\n\nA binary tree is considered balanced if, for every node, the height difference between its left and right subtrees is at most 1.\n\nHere's a common C# approach using recursion:\n\n```csharp\npublic class TreeNode\n{\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int x) { val = x; }\n}\n\npublic class Solution\n{\n    public bool IsBalanced(TreeNode root)\n    {\n        return CheckHeight(root) != -1;\n    }\n\n    private int CheckHeight(TreeNode node)\n    {\n        if (node == null)\n            return 0;\n\n        int leftHeight = CheckHeight(node.left);\n        if (leftHeight == -1) return -1; // Left subtree not balanced\n\n        int rightHeight = CheckHeight(node.right);\n        if (rightHeight == -1) return -1; // Right subtree not balanced\n\n        if (Math.Abs(leftHeight - rightHeight) > 1)\n            return -1; // Current node not balanced\n\n        return Math.Max(leftHeight, rightHeight) + 1;\n    }\n}\n```\n\n**Explanation:**\n\n- The `CheckHeight` function returns the height of the subtree if it is balanced, or -1 if it is not.\n- If any subtree is unbalanced, the function propagates -1 up the call stack.\n- The main function `IsBalanced` checks if the result is not -1, indicating the tree is balanced.\n\n**Time Complexity:** O(n), where n is the number of nodes, since each node is visited once.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646988Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "e124150f-2174-4ebf-a15b-2a80a508d473",
    "question": "How do you find the lowest common ancestor in a binary tree?",
    "answer": "```markdown **Question:**  \nHow do you find the lowest common ancestor in a binary tree?\n\n**Answer:**  \nThe Lowest Common Ancestor (LCA) of two nodes in a binary tree is the lowest (deepest) node that has both nodes as descendants (where we allow a node to be a descendant of itself).\n\n**Approach:**  \nA common approach is to use recursion. For each node, check:\n- If the current node is `null`, return `null`.\n- If the current node is either of the two nodes, return the current node.\n- Recursively check the left and right subtrees.\n- If both left and right recursive calls return non-null, the current node is the LCA.\n- If only one side returns non-null, propagate that up.\n\n**C# Implementation:**\n\n```csharp\npublic class TreeNode\n{\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int x) { val = x; }\n}\n\npublic class Solution\n{\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\n    {\n        if (root == null || root == p || root == q)\n            return root;\n\n        TreeNode left = LowestCommonAncestor(root.left, p, q);\n        TreeNode right = LowestCommonAncestor(root.right, p, q);\n\n        if (left != null && right != null)\n            return root;\n\n        return left ?? right;\n    }\n}\n```\n\n**Explanation:**\n- The function recursively traverses the tree.\n- If it finds either `p` or `q`, it returns that node.\n- If both left and right subtrees return non-null, the current node is the LCA.\n- If only one is non-null, that means both `p` and `q` are located in one subtree, so it returns that result.\n\n**Time Complexity:** O(n), where n is the number of nodes in the tree.  \n**Space Complexity:** O(h), where h is the height of the tree (due to recursion stack).",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.646995Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "e73f8c0f-173b-4820-9102-3286f87cbf06",
    "question": "How do you perform inorder traversal of a binary tree?",
    "answer": "```markdown ### How do you perform inorder traversal of a binary tree?\n\n**Inorder traversal** of a binary tree visits nodes in the following order:  \n1. Traverse the left subtree  \n2. Visit the root node  \n3. Traverse the right subtree\n\n#### Recursive Approach\n\n```csharp\npublic class TreeNode\n{\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int x) { val = x; }\n}\n\npublic void InorderTraversal(TreeNode root)\n{\n    if (root == null) return;\n    InorderTraversal(root.left);\n    Console.Write(root.val + \" \");\n    InorderTraversal(root.right);\n}\n```\n\n#### Iterative Approach (using Stack)\n\n```csharp\npublic void InorderTraversalIterative(TreeNode root)\n{\n    Stack<TreeNode> stack = new Stack<TreeNode>();\n    TreeNode current = root;\n\n    while (current != null || stack.Count > 0)\n    {\n        while (current != null)\n        {\n            stack.Push(current);\n            current = current.left;\n        }\n        current = stack.Pop();\n        Console.Write(current.val + \" \");\n        current = current.right;\n    }\n}\n```\n\n**Summary:**  \n- The recursive approach is straightforward and easy to implement.\n- The iterative approach uses a stack to simulate the recursion and is useful for very deep trees to avoid stack overflow.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.647002Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "9cbd1d29-2378-4ec0-aeb9-6a49c8a2cdab",
    "question": "How do you perform preorder traversal of a binary tree?",
    "answer": "```markdown **Question:**  \nHow do you perform preorder traversal of a binary tree?\n\n**Answer:**  \nIn preorder traversal, you visit the nodes of a binary tree in the following order:\n\n1. Visit the root node.\n2. Traverse the left subtree in preorder.\n3. Traverse the right subtree in preorder.\n\nHere's how you can implement preorder traversal in C# using recursion:\n\n```csharp\n// Definition for a binary tree node.\npublic class TreeNode\n{\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int val = 0, TreeNode left = null, TreeNode right = null)\n    {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class Solution\n{\n    public void PreorderTraversal(TreeNode root)\n    {\n        if (root == null)\n            return;\n\n        // Visit the root node\n        Console.WriteLine(root.val);\n\n        // Traverse the left subtree\n        PreorderTraversal(root.left);\n\n        // Traverse the right subtree\n        PreorderTraversal(root.right);\n    }\n}\n```\n\n**Example Usage:**\n```csharp\n// Construct the binary tree:\n//     1\n//    / \\\n//   2   3\n//  / \\\n// 4   5\n\nTreeNode root = new TreeNode(1,\n    new TreeNode(2, new TreeNode(4), new TreeNode(5)),\n    new TreeNode(3)\n);\n\nSolution sol = new Solution();\nsol.PreorderTraversal(root);\n// Output: 1 2 4 5 3\n```\n\n**Explanation:**  \nThe output order is 1 (root), 2 (left), 4 (left of left), 5 (right of left), 3 (right), which follows the preorder traversal sequence.",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.647009Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "11c32283-a3c8-4ef5-84e8-7a56f72f182e",
    "question": "How do you perform postorder traversal of a binary tree?",
    "answer": "```markdown **Question:**  \nHow do you perform postorder traversal of a binary tree?\n\n**Answer:**  \nIn postorder traversal, you visit the nodes of a binary tree in the following order:\n\n1. Traverse the left subtree.\n2. Traverse the right subtree.\n3. Visit the root node.\n\nHere is a C# implementation of postorder traversal using recursion:\n\n```csharp\npublic class TreeNode\n{\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int value)\n    {\n        val = value;\n        left = null;\n        right = null;\n    }\n}\n\npublic class BinaryTree\n{\n    public void PostorderTraversal(TreeNode root)\n    {\n        if (root == null)\n            return;\n\n        // Traverse left subtree\n        PostorderTraversal(root.left);\n\n        // Traverse right subtree\n        PostorderTraversal(root.right);\n\n        // Visit root node\n        Console.Write(root.val + \" \");\n    }\n}\n```\n\n**Usage Example:**\n\n```csharp\nTreeNode root = new TreeNode(1);\nroot.left = new TreeNode(2);\nroot.right = new TreeNode(3);\nroot.left.left = new TreeNode(4);\nroot.left.right = new TreeNode(5);\n\nBinaryTree tree = new BinaryTree();\ntree.PostorderTraversal(root); // Output: 4 5 2 3 1\n```\n\n**Explanation:**  \nThe function recursively traverses the left and right subtrees before processing the current node, ensuring postorder traversal (left, right, root).",
    "level": "Intermediate",
    "created_at": "2025-04-21T11:58:37.647016Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "276bf465-4e1c-4341-b7ea-bec52dd7d184",
    "question": "How do you implement Dijkstra's algorithm?",
    "answer": "```markdown\n## How do you implement Dijkstra's algorithm in C#?\n\nDijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative edge weights.\n\n### Steps:\n1. **Initialize** distances to all vertices as infinity, except the source (distance 0).\n2. Use a **priority queue** (min-heap) to always process the node with the smallest known distance.\n3. For each node, **relax** all adjacent edges: if a shorter path is found, update the distance.\n4. Repeat until all nodes are processed.\n\n### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Dijkstra\n{\n    public class Edge\n    {\n        public int To;\n        public int Weight;\n        public Edge(int to, int weight)\n        {\n            To = to;\n            Weight = weight;\n        }\n    }\n\n    public static int[] DijkstraShortestPaths(List<Edge>[] graph, int source)\n    {\n        int n = graph.Length;\n        int[] dist = new int[n];\n        bool[] visited = new bool[n];\n        for (int i = 0; i < n; i++) dist[i] = int.MaxValue;\n        dist[source] = 0;\n\n        var pq = new SortedSet<(int dist, int node)>();\n        pq.Add((0, source));\n\n        while (pq.Count > 0)\n        {\n            var (currentDist, u) = pq.Min;\n            pq.Remove(pq.Min);\n\n            if (visited[u]) continue;\n            visited[u] = true;\n\n            foreach (var edge in graph[u])\n            {\n                int v = edge.To;\n                int weight = edge.Weight;\n                if (!visited[v] && dist[u] + weight < dist[v])\n                {\n                    pq.Remove((dist[v], v)); // Remove if present\n                    dist[v] = dist[u] + weight;\n                    pq.Add((dist[v], v));\n                }\n            }\n        }\n        return dist;\n    }\n\n    // Example usage\n    public static void Main()\n    {\n        int n = 5;\n        var graph = new List<Edge>[n];\n        for (int i = 0; i < n; i++) graph[i] = new List<Edge>();\n\n        // Add edges: graph[from].Add(new Edge(to, weight));\n        graph[0].Add(new Edge(1, 10));\n        graph[0].Add(new Edge(2, 3));\n        graph[1].Add(new Edge(2, 1));\n        graph[1].Add(new Edge(3, 2));\n        graph[2].Add(new Edge(1, 4));\n        graph[2].Add(new Edge(3, 8));\n        graph[2].Add(new Edge(4, 2));\n        graph[3].Add(new Edge(4, 7));\n        graph[4].Add(new Edge(3, 9));\n\n        int[] distances = DijkstraShortestPaths(graph, 0);\n\n        Console.WriteLine(\"Shortest distances from node 0:\");\n        for (int i = 0; i < n; i++)\n            Console.WriteLine($\"To {i}: {distances[i]}\");\n    }\n}\n```\n\n### Notes:\n- The graph is represented as an adjacency list.\n- `SortedSet` is used as a simple priority queue. For large graphs, consider using a more efficient heap-based priority queue.\n- The algorithm handles graphs with non-negative weights only.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647023Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "400927b2-6ba6-4174-bb5f-502c21fa6f13",
    "question": "How do you implement A* search algorithm?",
    "answer": "```markdown Certainly! Here’s an advanced-level explanation and C# implementation of the A* search algorithm:\n\n---\n\n## A* Search Algorithm in C#\n\n### Overview\n\nA* (A-star) is a popular pathfinding and graph traversal algorithm. It finds the shortest path from a start node to a goal node, using a heuristic to guide its search. It combines features of Dijkstra’s Algorithm and Greedy Best-First-Search.\n\n- **g(n):** Cost from start node to current node n.\n- **h(n):** Heuristic estimate of cost from n to goal.\n- **f(n):** Estimated total cost of path through n: `f(n) = g(n) + h(n)`.\n\n### Steps\n\n1. Initialize open and closed sets.\n2. Add the start node to the open set.\n3. While the open set is not empty:\n    - Get the node with the lowest f(n).\n    - If it is the goal, reconstruct and return the path.\n    - Move it from open to closed set.\n    - For each neighbor:\n        - If in closed set, skip.\n        - If not in open set or found a better path, update path and costs.\n4. If open set is empty, no path exists.\n\n---\n\n### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Node : IComparable<Node>\n{\n    public int X, Y;\n    public double G, H;\n    public Node Parent;\n\n    public double F => G + H;\n\n    public Node(int x, int y)\n    {\n        X = x; Y = y;\n        G = H = 0;\n        Parent = null;\n    }\n\n    public int CompareTo(Node other) => F.CompareTo(other.F);\n\n    public override bool Equals(object obj) =>\n        obj is Node node && X == node.X && Y == node.Y;\n\n    public override int GetHashCode() => (X, Y).GetHashCode();\n}\n\npublic class AStar\n{\n    private readonly int[,] grid;\n    private readonly int rows, cols;\n    private readonly int[] dx = { -1, 1, 0, 0 };\n    private readonly int[] dy = { 0, 0, -1, 1 };\n\n    public AStar(int[,] grid)\n    {\n        this.grid = grid;\n        rows = grid.GetLength(0);\n        cols = grid.GetLength(1);\n    }\n\n    private double Heuristic(Node a, Node b)\n    {\n        // Manhattan distance\n        return Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y);\n    }\n\n    public List<Node> FindPath(Node start, Node goal)\n    {\n        var openSet = new SortedSet<Node>();\n        var openDict = new Dictionary<(int, int), Node>();\n        var closedSet = new HashSet<(int, int)>();\n\n        start.G = 0;\n        start.H = Heuristic(start, goal);\n        openSet.Add(start);\n        openDict[(start.X, start.Y)] = start;\n\n        while (openSet.Count > 0)\n        {\n            Node current = openSet.Min;\n            if (current.X == goal.X && current.Y == goal.Y)\n                return ReconstructPath(current);\n\n            openSet.Remove(current);\n            openDict.Remove((current.X, current.Y));\n            closedSet.Add((current.X, current.Y));\n\n            for (int i = 0; i < 4; i++)\n            {\n                int nx = current.X + dx[i], ny = current.Y + dy[i];\n                if (nx < 0 || ny < 0 || nx >= rows || ny >= cols || grid[nx, ny] == 1)\n                    continue;\n\n                var neighbor = new Node(nx, ny);\n                if (closedSet.Contains((nx, ny)))\n                    continue;\n\n                double tentativeG = current.G + 1; // Assuming cost=1 for adjacent\n\n                if (!openDict.TryGetValue((nx, ny), out var existingNeighbor))\n                {\n                    neighbor.G = tentativeG;\n                    neighbor.H = Heuristic(neighbor, goal);\n                    neighbor.Parent = current;\n                    openSet.Add(neighbor);\n                    openDict[(nx, ny)] = neighbor;\n                }\n                else if (tentativeG < existingNeighbor.G)\n                {\n                    openSet.Remove(existingNeighbor);\n                    existingNeighbor.G = tentativeG;\n                    existingNeighbor.Parent = current;\n                    openSet.Add(existingNeighbor);\n                }\n            }\n        }\n        return null; // No path found\n    }\n\n    private List<Node> ReconstructPath(Node node)\n    {\n        var path = new List<Node>();\n        while (node != null)\n        {\n            path.Add(node);\n            node = node.Parent;\n        }\n        path.Reverse();\n        return path;\n    }\n}\n```\n\n---\n\n### Usage Example\n\n```csharp\nint[,] grid = {\n    { 0, 0, 0, 0 },\n    { 1, 1, 0, 1 },\n    { 0, 0, 0, 0 },\n    { 0, 1, 1, 0 }\n};\n\nvar astar = new AStar(grid);\nvar start = new Node(0, 0);\nvar goal = new Node(3, 3);\n\nvar path = astar.FindPath(start, goal);\n\nif (path != null)\n{\n    foreach (var node in path)\n        Console.WriteLine($\"({node.X}, {node.Y})\");\n}\nelse\n{\n    Console.WriteLine(\"No path found.\");\n}\n```\n\n---\n\n### Notes\n\n- The grid uses 0 for open cells and 1 for obstacles.\n- The heuristic used is Manhattan distance, suitable for 4-directional movement.\n- You can adapt the neighbor generation and heuristic for 8-directional or weighted grids.\n\n---",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647030Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "20491ade-7a02-4b3d-b44f-88d5c802641e",
    "question": "How do you detect and remove a loop in a linked list?",
    "answer": "```markdown\n## Detecting and Removing a Loop in a Linked List in C#\n\n### **Detection (Floyd’s Cycle-Finding Algorithm)**\n\nTo detect a loop in a singly linked list, we use Floyd’s Cycle-Finding Algorithm (also known as the Tortoise and Hare algorithm):\n\n- Use two pointers, `slow` and `fast`.\n- Move `slow` by one node and `fast` by two nodes in each iteration.\n- If there is a loop, `slow` and `fast` will eventually meet.\n- If `fast` or `fast.next` becomes `null`, there is no loop.\n\n### **Removal**\n\nOnce a loop is detected:\n1. Set one pointer to the head and keep the other at the meeting point.\n2. Move both pointers one step at a time; the point where they meet is the start of the loop.\n3. Traverse the loop to find the node just before the start of the loop and set its `next` to `null` to remove the loop.\n\n---\n\n### **C# Implementation**\n\n```csharp\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n    public ListNode(int val = 0, ListNode next = null)\n    {\n        this.val = val;\n        this.next = next;\n    }\n}\n\npublic class LinkedListLoop\n{\n    // Detects and removes loop if present\n    public static void DetectAndRemoveLoop(ListNode head)\n    {\n        if (head == null || head.next == null)\n            return;\n\n        ListNode slow = head, fast = head;\n\n        // Step 1: Detect loop using Floyd’s algorithm\n        bool hasLoop = false;\n        while (fast != null && fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n\n            if (slow == fast)\n            {\n                hasLoop = true;\n                break;\n            }\n        }\n\n        if (!hasLoop)\n            return; // No loop found\n\n        // Step 2: Find the start of the loop\n        slow = head;\n        ListNode prev = null; // To keep track of the node before meeting point\n        while (slow != fast)\n        {\n            prev = fast;\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        // Step 3: Remove loop\n        prev.next = null;\n    }\n}\n```\n\n---\n\n### **Explanation**\n\n- **Detection:** The two-pointer technique efficiently detects a cycle.\n- **Finding Loop Start:** Resetting one pointer to `head` and moving both pointers one step at a time ensures they meet at the start of the loop.\n- **Removal:** By keeping track of the previous node (`prev`), we can set its `next` to `null`, thus breaking the loop.\n\n---\n\n**Time Complexity:** O(n)  \n**Space Complexity:** O(1)\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647037Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "8cf164a2-3ba9-49f2-b621-5479e6ff81cf",
    "question": "How do you implement a LRU (Least Recently Used) cache?",
    "answer": "```markdown\n## How do you implement a LRU (Least Recently Used) cache in C#?\n\nAn **LRU (Least Recently Used) cache** is a data structure that evicts the least recently accessed item when it reaches its capacity. The typical requirements are:\n- `Get(key)`: Retrieve the value of the key if it exists in the cache, otherwise return -1.\n- `Put(key, value)`: Insert or update the value of the key. If the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.\n\n### Approach\n\nTo achieve O(1) time complexity for both `Get` and `Put` operations, we use:\n- A **Dictionary** to store key-node pairs for fast lookup.\n- A **Doubly Linked List** to maintain the order of usage, with the most recently used item at the head and the least at the tail.\n\n### C# Implementation\n\n```csharp\npublic class LRUCache\n{\n    private class Node\n    {\n        public int Key;\n        public int Value;\n        public Node Prev;\n        public Node Next;\n        public Node(int key, int value)\n        {\n            Key = key;\n            Value = value;\n        }\n    }\n\n    private readonly int capacity;\n    private Dictionary<int, Node> cache;\n    private Node head, tail;\n\n    public LRUCache(int capacity)\n    {\n        this.capacity = capacity;\n        cache = new Dictionary<int, Node>(capacity);\n        head = new Node(0, 0); // Dummy head\n        tail = new Node(0, 0); // Dummy tail\n        head.Next = tail;\n        tail.Prev = head;\n    }\n\n    public int Get(int key)\n    {\n        if (!cache.ContainsKey(key))\n            return -1;\n\n        Node node = cache[key];\n        Remove(node);\n        AddToHead(node);\n        return node.Value;\n    }\n\n    public void Put(int key, int value)\n    {\n        if (cache.ContainsKey(key))\n        {\n            Node node = cache[key];\n            node.Value = value;\n            Remove(node);\n            AddToHead(node);\n        }\n        else\n        {\n            if (cache.Count >= capacity)\n            {\n                // Remove LRU\n                Node lru = tail.Prev;\n                Remove(lru);\n                cache.Remove(lru.Key);\n            }\n            Node newNode = new Node(key, value);\n            cache[key] = newNode;\n            AddToHead(newNode);\n        }\n    }\n\n    private void Remove(Node node)\n    {\n        node.Prev.Next = node.Next;\n        node.Next.Prev = node.Prev;\n    }\n\n    private void AddToHead(Node node)\n    {\n        node.Next = head.Next;\n        node.Prev = head;\n        head.Next.Prev = node;\n        head.Next = node;\n    }\n}\n```\n\n### Explanation\n\n- **Dictionary** `cache` maps keys to their corresponding nodes in the linked list.\n- **Doubly Linked List** maintains the usage order. The most recently used node is right after the dummy `head`, and the least recently used is right before the dummy `tail`.\n- On `Get`, if the key exists, move the node to the head (most recently used).\n- On `Put`, if the key exists, update and move to head. If not, insert a new node at the head. If the cache exceeds capacity, remove the node at the tail (least recently used).\n\nThis implementation ensures both `Get` and `Put` operations run in O(1) time.\n```\n",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647044Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "c4c911ba-d6e5-40ae-bd60-fd8f510cb126",
    "question": "How do you find the longest substring without repeating characters?",
    "answer": "```markdown **Question:**  \nHow do you find the longest substring without repeating characters?\n\n**Answer:**  \nTo find the longest substring without repeating characters, you can use the sliding window technique with a hash set or dictionary to track characters and their indices. The idea is to expand the window by moving the right pointer, and if a duplicate character is found, move the left pointer to the right of the previous occurrence of that character.\n\nHere’s a C# implementation:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Solution\n{\n    public int LengthOfLongestSubstring(string s)\n    {\n        if (string.IsNullOrEmpty(s)) return 0;\n\n        Dictionary<char, int> charIndexMap = new Dictionary<char, int>();\n        int maxLength = 0;\n        int left = 0;\n\n        for (int right = 0; right < s.Length; right++)\n        {\n            char currentChar = s[right];\n\n            if (charIndexMap.ContainsKey(currentChar) && charIndexMap[currentChar] >= left)\n            {\n                // Move the left pointer to the right of the previous occurrence\n                left = charIndexMap[currentChar] + 1;\n            }\n\n            charIndexMap[currentChar] = right;\n            maxLength = Math.Max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n}\n\n// Example usage\nclass Program\n{\n    static void Main()\n    {\n        Solution sol = new Solution();\n        string input = \"abcabcbb\";\n        Console.WriteLine(sol.LengthOfLongestSubstring(input)); // Output: 3 (\"abc\")\n    }\n}\n```\n\n**Explanation:**\n- Use a dictionary to store the last index of each character.\n- Iterate through the string with a right pointer.\n- If a character is repeated within the current window, move the left pointer to the right of the previous occurrence.\n- Update the maximum length found so far.\n- The time complexity is O(n), where n is the length of the string.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647051Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "24ce7b9c-3214-4551-8fa4-a8e7273b3b29",
    "question": "How do you find the median of two sorted arrays?",
    "answer": "```markdown ### How do you find the median of two sorted arrays?\n\nTo find the median of two sorted arrays, you want an algorithm faster than simply merging both arrays and finding the median (which is O(m+n)). The optimal solution uses a binary search approach, achieving O(log(min(m, n))) time complexity.\n\n#### Approach\n\n1. **Ensure** the first array (`A`) is the smaller one.\n2. **Binary Search** on the smaller array to partition both arrays such that:\n    - The number of elements on the left equals the number on the right (or differs by one for odd total length).\n    - All elements on the left are less than or equal to all elements on the right.\n3. **Median** is then the average of the max of left elements and min of right elements.\n\n#### C# Implementation\n\n```csharp\npublic double FindMedianSortedArrays(int[] nums1, int[] nums2)\n{\n    if (nums1.Length > nums2.Length)\n        return FindMedianSortedArrays(nums2, nums1); // Ensure nums1 is smaller\n\n    int m = nums1.Length, n = nums2.Length;\n    int imin = 0, imax = m, halfLen = (m + n + 1) / 2;\n\n    while (imin <= imax)\n    {\n        int i = (imin + imax) / 2;\n        int j = halfLen - i;\n\n        if (i < m && nums2[j - 1] > nums1[i])\n        {\n            imin = i + 1; // i is too small\n        }\n        else if (i > 0 && nums1[i - 1] > nums2[j])\n        {\n            imax = i - 1; // i is too big\n        }\n        else\n        {\n            // i is perfect\n            int maxOfLeft;\n            if (i == 0) maxOfLeft = nums2[j - 1];\n            else if (j == 0) maxOfLeft = nums1[i - 1];\n            else maxOfLeft = Math.Max(nums1[i - 1], nums2[j - 1]);\n\n            if ((m + n) % 2 == 1)\n                return maxOfLeft;\n\n            int minOfRight;\n            if (i == m) minOfRight = nums2[j];\n            else if (j == n) minOfRight = nums1[i];\n            else minOfRight = Math.Min(nums1[i], nums2[j]);\n\n            return (maxOfLeft + minOfRight) / 2.0;\n        }\n    }\n    throw new ArgumentException(\"Input arrays are not sorted or empty.\");\n}\n```\n\n#### Example\n\n```csharp\nint[] nums1 = {1, 3};\nint[] nums2 = {2};\ndouble median = FindMedianSortedArrays(nums1, nums2); // Output: 2.0\n```\n\n#### Explanation\n\n- The algorithm partitions both arrays so that the left side contains the same number of elements as the right (or one more for odd total length).\n- It then finds the maximum value on the left and the minimum on the right to compute the median.\n\n---\n\n**Time Complexity:** O(log(min(m, n)))  \n**Space Complexity:** O(1)",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647058Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "4eb6a1ce-1739-4388-978b-e3043a51c0b9",
    "question": "How do you implement a trie (prefix tree)?",
    "answer": "```markdown ### Implementing a Trie (Prefix Tree) in C#\n\nA **Trie** (pronounced \"try\") is a tree-like data structure used to efficiently store and retrieve keys in a dataset of strings, commonly used for autocomplete and spell-checking features.\n\n#### Key Operations\n- **Insert**: Add a word to the trie.\n- **Search**: Check if a word exists in the trie.\n- **StartsWith**: Check if any word in the trie starts with a given prefix.\n\n#### C# Implementation\n\n```csharp\npublic class TrieNode\n{\n    public Dictionary<char, TrieNode> Children { get; } = new Dictionary<char, TrieNode>();\n    public bool IsEndOfWord { get; set; } = false;\n}\n\npublic class Trie\n{\n    private readonly TrieNode root;\n\n    public Trie()\n    {\n        root = new TrieNode();\n    }\n\n    // Insert a word into the trie\n    public void Insert(string word)\n    {\n        TrieNode node = root;\n        foreach (char c in word)\n        {\n            if (!node.Children.ContainsKey(c))\n                node.Children[c] = new TrieNode();\n            node = node.Children[c];\n        }\n        node.IsEndOfWord = true;\n    }\n\n    // Search for a word in the trie\n    public bool Search(string word)\n    {\n        TrieNode node = root;\n        foreach (char c in word)\n        {\n            if (!node.Children.ContainsKey(c))\n                return false;\n            node = node.Children[c];\n        }\n        return node.IsEndOfWord;\n    }\n\n    // Check if there is any word in the trie that starts with the given prefix\n    public bool StartsWith(string prefix)\n    {\n        TrieNode node = root;\n        foreach (char c in prefix)\n        {\n            if (!node.Children.ContainsKey(c))\n                return false;\n            node = node.Children[c];\n        }\n        return true;\n    }\n}\n```\n\n#### Example Usage\n\n```csharp\nvar trie = new Trie();\ntrie.Insert(\"apple\");\nConsole.WriteLine(trie.Search(\"apple\"));   // Output: True\nConsole.WriteLine(trie.Search(\"app\"));     // Output: False\nConsole.WriteLine(trie.StartsWith(\"app\")); // Output: True\ntrie.Insert(\"app\");\nConsole.WriteLine(trie.Search(\"app\"));     // Output: True\n```\n\n#### Notes\n- Each node contains a dictionary mapping characters to child nodes.\n- `IsEndOfWord` marks the end of a valid word.\n- This implementation is case-sensitive and can be extended for case-insensitivity or Unicode support.\n\n---\n\n**Time Complexity:**  \n- Insert/Search/StartsWith: O(L), where L is the length of the word or prefix.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647065Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "8ecf67a5-7772-418a-82d9-62644d247627",
    "question": "How do you implement a min-heap?",
    "answer": "```markdown ### How do you implement a min-heap?\n\nA **min-heap** is a complete binary tree where the value at each node is less than or equal to the values of its children. The smallest element is always at the root. Min-heaps are commonly implemented using arrays.\n\n#### Key Operations\n\n1. **Insert**: Add the new element at the end and \"bubble up\" to restore the heap property.\n2. **ExtractMin**: Remove the root (minimum), replace it with the last element, and \"bubble down\" to restore the heap property.\n3. **Peek**: Return the minimum element (root).\n\n#### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class MinHeap\n{\n    private List<int> heap;\n\n    public MinHeap()\n    {\n        heap = new List<int>();\n    }\n\n    public int Count => heap.Count;\n\n    public void Insert(int val)\n    {\n        heap.Add(val);\n        HeapifyUp(heap.Count - 1);\n    }\n\n    public int ExtractMin()\n    {\n        if (heap.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty.\");\n\n        int min = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        HeapifyDown(0);\n\n        return min;\n    }\n\n    public int Peek()\n    {\n        if (heap.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty.\");\n        return heap[0];\n    }\n\n    private void HeapifyUp(int index)\n    {\n        while (index > 0)\n        {\n            int parent = (index - 1) / 2;\n            if (heap[index] < heap[parent])\n            {\n                Swap(index, parent);\n                index = parent;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    private void HeapifyDown(int index)\n    {\n        int lastIndex = heap.Count - 1;\n        while (true)\n        {\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            int smallest = index;\n\n            if (left <= lastIndex && heap[left] < heap[smallest])\n                smallest = left;\n            if (right <= lastIndex && heap[right] < heap[smallest])\n                smallest = right;\n\n            if (smallest != index)\n            {\n                Swap(index, smallest);\n                index = smallest;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    private void Swap(int i, int j)\n    {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n}\n```\n\n#### Usage Example\n\n```csharp\nvar minHeap = new MinHeap();\nminHeap.Insert(5);\nminHeap.Insert(3);\nminHeap.Insert(8);\nminHeap.Insert(1);\n\nConsole.WriteLine(minHeap.ExtractMin()); // Output: 1\nConsole.WriteLine(minHeap.Peek());       // Output: 3\n```\n\n#### Time Complexity\n\n- **Insert**: O(log n)\n- **ExtractMin**: O(log n)\n- **Peek**: O(1)\n\nThis implementation efficiently maintains the min-heap property using an array-based binary tree structure.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647073Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "b2e3559c-5889-4e15-b942-b4fa1e8d1ca5",
    "question": "How do you implement a max-heap?",
    "answer": "```markdown ### How do you implement a max-heap?\n\nA **max-heap** is a complete binary tree where each parent node is greater than or equal to its child nodes. It is commonly implemented using an array. The key operations are `Insert`, `ExtractMax`, and `Heapify`.\n\nBelow is a C# implementation of a max-heap:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class MaxHeap\n{\n    private List<int> heap;\n\n    public MaxHeap()\n    {\n        heap = new List<int>();\n    }\n\n    public int Count => heap.Count;\n\n    // Insert a new value into the heap\n    public void Insert(int val)\n    {\n        heap.Add(val);\n        HeapifyUp(heap.Count - 1);\n    }\n\n    // Extract the maximum value (root) from the heap\n    public int ExtractMax()\n    {\n        if (heap.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty.\");\n\n        int max = heap[0];\n        heap[0] = heap[heap.Count - 1];\n        heap.RemoveAt(heap.Count - 1);\n        HeapifyDown(0);\n\n        return max;\n    }\n\n    // Heapify up (used after insertion)\n    private void HeapifyUp(int index)\n    {\n        while (index > 0)\n        {\n            int parent = (index - 1) / 2;\n            if (heap[index] > heap[parent])\n            {\n                Swap(index, parent);\n                index = parent;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    // Heapify down (used after extraction)\n    private void HeapifyDown(int index)\n    {\n        int lastIndex = heap.Count - 1;\n        while (index < heap.Count)\n        {\n            int left = 2 * index + 1;\n            int right = 2 * index + 2;\n            int largest = index;\n\n            if (left <= lastIndex && heap[left] > heap[largest])\n                largest = left;\n            if (right <= lastIndex && heap[right] > heap[largest])\n                largest = right;\n\n            if (largest != index)\n            {\n                Swap(index, largest);\n                index = largest;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    private void Swap(int i, int j)\n    {\n        int temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n\n    // Optional: Peek at the maximum value without removing it\n    public int Peek()\n    {\n        if (heap.Count == 0)\n            throw new InvalidOperationException(\"Heap is empty.\");\n        return heap[0];\n    }\n}\n```\n\n#### Example Usage\n\n```csharp\nvar maxHeap = new MaxHeap();\nmaxHeap.Insert(10);\nmaxHeap.Insert(4);\nmaxHeap.Insert(15);\nmaxHeap.Insert(20);\n\nConsole.WriteLine(maxHeap.ExtractMax()); // Output: 20\nConsole.WriteLine(maxHeap.ExtractMax()); // Output: 15\n```\n\n#### Key Points\n\n- The max-heap property is maintained after every insertion and extraction.\n- Both `Insert` and `ExtractMax` operations have O(log n) time complexity.\n- The heap is stored as a list (array), where for any index `i`, its children are at `2*i+1` and `2*i+2`.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647080Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "cd228506-2fef-449f-892d-7166bfe19642",
    "question": "How do you serialize and deserialize a binary tree?",
    "answer": "```markdown ### How do you serialize and deserialize a binary tree?\n\n**Serialization** is the process of converting a binary tree into a string representation so it can be easily stored or transmitted.  \n**Deserialization** is the reverse process: reconstructing the binary tree from its string representation.\n\nA common approach is to use **preorder traversal** (root, left, right) and represent null nodes with a special marker (e.g., `#`).\n\n#### C# Implementation\n\n```csharp\npublic class TreeNode {\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class Codec {\n    // Encodes a tree to a single string.\n    public string Serialize(TreeNode root) {\n        var sb = new StringBuilder();\n        SerializeHelper(root, sb);\n        return sb.ToString();\n    }\n    \n    private void SerializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.Append(\"#,\");\n            return;\n        }\n        sb.Append(node.val).Append(\",\");\n        SerializeHelper(node.left, sb);\n        SerializeHelper(node.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode Deserialize(string data) {\n        var nodes = new Queue<string>(data.Split(',', StringSplitOptions.RemoveEmptyEntries));\n        return DeserializeHelper(nodes);\n    }\n    \n    private TreeNode DeserializeHelper(Queue<string> nodes) {\n        if (nodes.Count == 0) return null;\n        string val = nodes.Dequeue();\n        if (val == \"#\") return null;\n        TreeNode node = new TreeNode(int.Parse(val));\n        node.left = DeserializeHelper(nodes);\n        node.right = DeserializeHelper(nodes);\n        return node;\n    }\n}\n```\n\n#### Usage Example\n\n```csharp\n// Example usage:\nvar codec = new Codec();\nTreeNode root = new TreeNode(1, new TreeNode(2), new TreeNode(3, new TreeNode(4), new TreeNode(5)));\nstring serialized = codec.Serialize(root);\nTreeNode deserialized = codec.Deserialize(serialized);\n```\n\n#### Explanation\n\n- **Serialize:**  \n  - Traverse the tree in preorder.\n  - For each node, append its value to the string. For null nodes, append `#`.\n  - Separate values with commas.\n\n- **Deserialize:**  \n  - Split the string by commas and process each value in order.\n  - If the value is `#`, return null.\n  - Otherwise, create a new node and recursively build its left and right children.\n\nThis approach ensures the tree structure is preserved during serialization and deserialization.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647087Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "51744528-6d03-4653-a788-6b82356af643",
    "question": "How do you find all permutations of a string?",
    "answer": "```markdown **Question:**  \nHow do you find all permutations of a string?\n\n**Answer:**  \nTo find all permutations of a string in C#, you can use recursion and backtracking. The idea is to fix each character at the current position and recursively generate all permutations for the remaining characters.\n\nHere's a C# implementation:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Permute(char[] chars, int start, int end, List<string> result)\n    {\n        if (start == end)\n        {\n            result.Add(new string(chars));\n        }\n        else\n        {\n            for (int i = start; i <= end; i++)\n            {\n                Swap(ref chars[start], ref chars[i]);\n                Permute(chars, start + 1, end, result);\n                Swap(ref chars[start], ref chars[i]); // backtrack\n            }\n        }\n    }\n\n    static void Swap(ref char a, ref char b)\n    {\n        char temp = a;\n        a = b;\n        b = temp;\n    }\n\n    static List<string> GetPermutations(string str)\n    {\n        var result = new List<string>();\n        Permute(str.ToCharArray(), 0, str.Length - 1, result);\n        return result;\n    }\n\n    static void Main()\n    {\n        string input = \"ABC\";\n        List<string> permutations = GetPermutations(input);\n\n        foreach (var perm in permutations)\n        {\n            Console.WriteLine(perm);\n        }\n    }\n}\n```\n\n**Explanation:**\n\n- The `Permute` function recursively generates all permutations by swapping each character with every other character in the string.\n- The `Swap` function exchanges two characters in the character array.\n- The `GetPermutations` function initializes the process and collects all permutations in a list.\n- The `Main` method demonstrates usage with the string \"ABC\".\n\n**Output:**\n```\nABC\nACB\nBAC\nBCA\nCBA\nCAB\n```\n\nThis approach generates all possible orderings (permutations) of the input string.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647094Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "64a06fd3-d725-463f-b05b-536cadb5525c",
    "question": "How do you solve the N-Queens problem?",
    "answer": "```markdown ### N-Queens Problem in C#\n\nThe **N-Queens problem** asks: *How can you place N queens on an N×N chessboard so that no two queens threaten each other?* That is, no two queens share the same row, column, or diagonal.\n\n#### Approach\n\nA common solution uses **backtracking**:\n\n1. Place a queen in a row.\n2. Move to the next row and try placing a queen in a safe column.\n3. If a safe position is found, recurse to the next row.\n4. If all queens are placed, record the solution.\n5. If not possible, backtrack and try a different column.\n\n#### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass NQueensSolver\n{\n    public IList<IList<string>> SolveNQueens(int n)\n    {\n        var results = new List<IList<string>>();\n        var board = new char[n, n];\n\n        // Initialize the board with '.'\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                board[i, j] = '.';\n\n        Solve(0, board, results, n);\n        return results;\n    }\n\n    private void Solve(int row, char[,] board, IList<IList<string>> results, int n)\n    {\n        if (row == n)\n        {\n            var solution = new List<string>();\n            for (int i = 0; i < n; i++)\n            {\n                var rowStr = new char[n];\n                for (int j = 0; j < n; j++)\n                    rowStr[j] = board[i, j];\n                solution.Add(new string(rowStr));\n            }\n            results.Add(solution);\n            return;\n        }\n\n        for (int col = 0; col < n; col++)\n        {\n            if (IsSafe(board, row, col, n))\n            {\n                board[row, col] = 'Q';\n                Solve(row + 1, board, results, n);\n                board[row, col] = '.'; // Backtrack\n            }\n        }\n    }\n\n    private bool IsSafe(char[,] board, int row, int col, int n)\n    {\n        // Check column\n        for (int i = 0; i < row; i++)\n            if (board[i, col] == 'Q')\n                return false;\n\n        // Check upper-left diagonal\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n            if (board[i, j] == 'Q')\n                return false;\n\n        // Check upper-right diagonal\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)\n            if (board[i, j] == 'Q')\n                return false;\n\n        return true;\n    }\n}\n```\n\n#### Usage Example\n\n```csharp\nclass Program\n{\n    static void Main()\n    {\n        var solver = new NQueensSolver();\n        var solutions = solver.SolveNQueens(4);\n\n        foreach (var solution in solutions)\n        {\n            foreach (var row in solution)\n                Console.WriteLine(row);\n            Console.WriteLine();\n        }\n    }\n}\n```\n\n#### Output for N = 4\n\n```\n.Q..\n...Q\nQ...\n..Q.\n\n..Q.\nQ...\n...Q\n.Q..\n```\n\n#### Explanation\n\n- The algorithm tries to place a queen row by row.\n- It checks if the current position is safe (no other queen in the same column or diagonal).\n- If a solution is found (all queens placed), it adds the board configuration to the results.\n- Backtracking ensures all possible solutions are explored.\n\n---\n\n**Time Complexity:** O(N!), as each queen has N choices and the search space reduces as queens are placed.\n**Space Complexity:** O(N^2) for the board and result storage.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647100Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "162aabbe-d20e-4cd4-b588-204e995f2a2c",
    "question": "How do you find the shortest path in a maze?",
    "answer": "```markdown ### How do you find the shortest path in a maze?\n\nTo find the shortest path in a maze, you can use **Breadth-First Search (BFS)**. BFS is ideal for unweighted grids (like a maze) because it explores all possible paths level by level and guarantees the shortest path to the destination.\n\n#### Approach\n\n1. **Represent the Maze:** Use a 2D array where `0` is an open cell and `1` is a wall.\n2. **BFS Traversal:** Use a queue to explore neighbors (up, down, left, right) from the start position.\n3. **Track Visited Cells:** Use a boolean array to avoid revisiting cells.\n4. **Track Path Length:** Store the current path length with each queue entry.\n5. **Terminate on Goal:** When the end cell is reached, return the path length.\n\n#### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class MazeSolver\n{\n    // Directions: up, down, left, right\n    private static readonly int[] dx = { -1, 1, 0, 0 };\n    private static readonly int[] dy = { 0, 0, -1, 1 };\n\n    public int ShortestPath(int[,] maze, (int x, int y) start, (int x, int y) end)\n    {\n        int rows = maze.GetLength(0);\n        int cols = maze.GetLength(1);\n        bool[,] visited = new bool[rows, cols];\n        Queue<(int x, int y, int dist)> queue = new Queue<(int, int, int)>();\n\n        queue.Enqueue((start.x, start.y, 0));\n        visited[start.x, start.y] = true;\n\n        while (queue.Count > 0)\n        {\n            var (x, y, dist) = queue.Dequeue();\n            if (x == end.x && y == end.y)\n                return dist;\n\n            for (int i = 0; i < 4; i++)\n            {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols &&\n                    maze[nx, ny] == 0 && !visited[nx, ny])\n                {\n                    queue.Enqueue((nx, ny, dist + 1));\n                    visited[nx, ny] = true;\n                }\n            }\n        }\n\n        // No path found\n        return -1;\n    }\n}\n```\n\n#### Usage Example\n\n```csharp\nint[,] maze = {\n    { 0, 1, 0, 0, 0 },\n    { 0, 1, 0, 1, 0 },\n    { 0, 0, 0, 1, 0 },\n    { 1, 1, 0, 0, 0 }\n};\n\nMazeSolver solver = new MazeSolver();\nint shortest = solver.ShortestPath(maze, (0, 0), (3, 4));\nConsole.WriteLine(shortest); // Output: 7\n```\n\n#### Key Points\n\n- BFS ensures the shortest path in unweighted grids.\n- Track visited cells to prevent cycles.\n- Can be extended to reconstruct the actual path by storing parent pointers.\n\n---\n\n**Summary:**  \nUse BFS to find the shortest path in a maze. This approach is efficient and guarantees the shortest route in an unweighted grid.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647109Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "eee96a63-0c30-418a-8e83-98bf64ba4ad5",
    "question": "How do you implement topological sort?",
    "answer": "```markdown ### Topological Sort in C#\n\nTopological sort is an algorithm for ordering the vertices of a Directed Acyclic Graph (DAG) such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering.\n\n#### Common Approaches\n\n1. **Kahn’s Algorithm (BFS-based)**\n2. **DFS-based Algorithm**\n\nBelow is the **DFS-based implementation** in C#:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass TopologicalSort\n{\n    private int vertices;\n    private List<int>[] adj;\n\n    public TopologicalSort(int v)\n    {\n        vertices = v;\n        adj = new List<int>[v];\n        for (int i = 0; i < v; i++)\n            adj[i] = new List<int>();\n    }\n\n    public void AddEdge(int v, int w)\n    {\n        adj[v].Add(w);\n    }\n\n    private void DFSUtil(int v, bool[] visited, Stack<int> stack)\n    {\n        visited[v] = true;\n\n        foreach (int neighbor in adj[v])\n        {\n            if (!visited[neighbor])\n                DFSUtil(neighbor, visited, stack);\n        }\n\n        stack.Push(v);\n    }\n\n    public List<int> TopologicalSortDFS()\n    {\n        Stack<int> stack = new Stack<int>();\n        bool[] visited = new bool[vertices];\n\n        for (int i = 0; i < vertices; i++)\n        {\n            if (!visited[i])\n                DFSUtil(i, visited, stack);\n        }\n\n        List<int> result = new List<int>();\n        while (stack.Count > 0)\n            result.Add(stack.Pop());\n\n        return result;\n    }\n}\n\n// Example usage:\nclass Program\n{\n    static void Main()\n    {\n        TopologicalSort g = new TopologicalSort(6);\n        g.AddEdge(5, 2);\n        g.AddEdge(5, 0);\n        g.AddEdge(4, 0);\n        g.AddEdge(4, 1);\n        g.AddEdge(2, 3);\n        g.AddEdge(3, 1);\n\n        List<int> order = g.TopologicalSortDFS();\n        Console.WriteLine(\"Topological Sort:\");\n        Console.WriteLine(string.Join(\" \", order));\n    }\n}\n```\n\n#### Explanation\n\n- **Graph Representation:** The graph is represented using an adjacency list.\n- **DFS Utility:** Recursively visits all vertices, marking them as visited, and pushes them onto a stack after visiting all their neighbors.\n- **Result:** Popping from the stack gives the topological order.\n\n#### Time Complexity\n\n- **O(V + E)**, where V is the number of vertices and E is the number of edges.\n\n---\n\n**Note:** Topological sort is only possible for DAGs. If the graph contains a cycle, topological sorting is not possible.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647116Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "80310aa8-4757-4dd5-bcd1-39a1e5d63a57",
    "question": "How do you find strongly connected components in a graph?",
    "answer": "```markdown ### How do you find strongly connected components in a graph?\n\nA **strongly connected component (SCC)** in a directed graph is a maximal set of vertices such that every vertex is reachable from every other vertex in the set. One of the most popular algorithms to find SCCs is **Kosaraju's algorithm**, which works in O(V + E) time.\n\n#### Kosaraju's Algorithm Steps\n\n1. **Perform DFS** on the original graph, keeping track of the finish times of each node (push nodes onto a stack as they finish).\n2. **Transpose the graph** (reverse the direction of all edges).\n3. **Pop nodes from the stack** and perform DFS on the transposed graph. Each DFS traversal will give you one SCC.\n\n---\n\n#### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nclass Graph\n{\n    private int V; // Number of vertices\n    private List<int>[] adj; // Adjacency List\n\n    public Graph(int v)\n    {\n        V = v;\n        adj = new List<int>[v];\n        for (int i = 0; i < v; ++i)\n            adj[i] = new List<int>();\n    }\n\n    public void AddEdge(int v, int w)\n    {\n        adj[v].Add(w);\n    }\n\n    // Step 1: Fill vertices in stack according to their finishing times\n    private void FillOrder(int v, bool[] visited, Stack<int> stack)\n    {\n        visited[v] = true;\n        foreach (int n in adj[v])\n            if (!visited[n])\n                FillOrder(n, visited, stack);\n        stack.Push(v);\n    }\n\n    // Step 2: Transpose the graph\n    private Graph GetTranspose()\n    {\n        Graph g = new Graph(V);\n        for (int v = 0; v < V; v++)\n            foreach (int n in adj[v])\n                g.adj[n].Add(v);\n        return g;\n    }\n\n    // Step 3: DFS for the transposed graph\n    private void DFSUtil(int v, bool[] visited, List<int> component)\n    {\n        visited[v] = true;\n        component.Add(v);\n        foreach (int n in adj[v])\n            if (!visited[n])\n                DFSUtil(n, visited, component);\n    }\n\n    // Main function to print all SCCs\n    public List<List<int>> GetSCCs()\n    {\n        Stack<int> stack = new Stack<int>();\n        bool[] visited = new bool[V];\n\n        // Fill vertices in stack according to their finishing times\n        for (int i = 0; i < V; i++)\n            if (!visited[i])\n                FillOrder(i, visited, stack);\n\n        // Transpose the graph\n        Graph gr = GetTranspose();\n\n        // Mark all vertices as not visited for the second DFS\n        for (int i = 0; i < V; i++)\n            visited[i] = false;\n\n        List<List<int>> sccs = new List<List<int>>();\n\n        // Now process all vertices in order defined by Stack\n        while (stack.Count > 0)\n        {\n            int v = stack.Pop();\n            if (!visited[v])\n            {\n                List<int> component = new List<int>();\n                gr.DFSUtil(v, visited, component);\n                sccs.Add(component);\n            }\n        }\n        return sccs;\n    }\n}\n\n// Example usage\nclass Program\n{\n    static void Main()\n    {\n        Graph g = new Graph(5);\n        g.AddEdge(1, 0);\n        g.AddEdge(0, 2);\n        g.AddEdge(2, 1);\n        g.AddEdge(0, 3);\n        g.AddEdge(3, 4);\n\n        var sccs = g.GetSCCs();\n        Console.WriteLine(\"Strongly Connected Components:\");\n        foreach (var scc in sccs)\n        {\n            Console.WriteLine(string.Join(\", \", scc));\n        }\n    }\n}\n```\n\n---\n\n#### **Summary**\n- Kosaraju's algorithm is efficient for finding SCCs.\n- It uses two DFS traversals and a graph transpose.\n- The above C# code demonstrates a full implementation.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647130Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "67bad65c-92ef-4904-be86-71b613a70e5e",
    "question": "How do you implement the Knapsack problem (dynamic programming)?",
    "answer": "```markdown Certainly! Here’s an advanced-level answer for implementing the Knapsack problem using dynamic programming in C#:\n\n---\n\n## Knapsack Problem (Dynamic Programming) in C#\n\nThe **0/1 Knapsack Problem** is a classic optimization problem. Given weights and values of `n` items, put these items in a knapsack of capacity `W` to get the maximum total value in the knapsack. Each item can be included **at most once**.\n\n### Dynamic Programming Approach\n\nWe use a 2D array `dp` where `dp[i, w]` represents the maximum value that can be attained with the first `i` items and a knapsack capacity `w`.\n\n#### Steps:\n\n1. Initialize a 2D array `dp` of size `(n+1) x (W+1)` with all zeros.\n2. For each item `i` (from 1 to `n`):\n    - For each capacity `w` (from 1 to `W`):\n        - If the weight of the current item is less than or equal to `w`, set:\n          `dp[i, w] = max(dp[i-1, w], value[i-1] + dp[i-1, w - weight[i-1]])`\n        - Else, set:\n          `dp[i, w] = dp[i-1, w]`\n3. The answer will be in `dp[n, W]`.\n\n### C# Implementation\n\n```csharp\nusing System;\n\nclass KnapsackDP\n{\n    // Returns the maximum value that can be put in a knapsack of capacity W\n    public static int Knapsack(int[] weights, int[] values, int W)\n    {\n        int n = values.Length;\n        int[,] dp = new int[n + 1, W + 1];\n\n        // Build table dp[,] in bottom up manner\n        for (int i = 0; i <= n; i++)\n        {\n            for (int w = 0; w <= W; w++)\n            {\n                if (i == 0 || w == 0)\n                    dp[i, w] = 0;\n                else if (weights[i - 1] <= w)\n                    dp[i, w] = Math.Max(\n                        values[i - 1] + dp[i - 1, w - weights[i - 1]],\n                        dp[i - 1, w]\n                    );\n                else\n                    dp[i, w] = dp[i - 1, w];\n            }\n        }\n\n        return dp[n, W];\n    }\n\n    // Example usage\n    static void Main()\n    {\n        int[] values = { 60, 100, 120 };\n        int[] weights = { 10, 20, 30 };\n        int capacity = 50;\n\n        int maxValue = Knapsack(weights, values, capacity);\n        Console.WriteLine(\"Maximum value in Knapsack = \" + maxValue);\n    }\n}\n```\n\n#### Output\n\n```\nMaximum value in Knapsack = 220\n```\n\n---\n\n**Time Complexity:** O(nW)  \n**Space Complexity:** O(nW) (can be optimized to O(W) using a 1D array)\n\n---\n\n**Note:**  \n- This is the 0/1 Knapsack (each item is either included or not).\n- For the fractional knapsack (where you can take fractions of items), a greedy approach is used instead.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647138Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "ddf7606a-a27e-4217-a4a6-8e8ab363f2c9",
    "question": "How do you implement edit distance (Levenshtein distance)?",
    "answer": "```markdown ## Edit Distance (Levenshtein Distance) in C#\n\nThe **Levenshtein distance** is a classic dynamic programming problem that measures the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into another.\n\n### Algorithm Explanation\n\nGiven two strings, `s1` and `s2`, we build a 2D DP table where `dp[i][j]` represents the edit distance between the first `i` characters of `s1` and the first `j` characters of `s2`.\n\n#### Recurrence Relation\n\n- If `s1[i-1] == s2[j-1]`, then `dp[i][j] = dp[i-1][j-1]`\n- Else,  \n  `dp[i][j] = 1 + min(dp[i-1][j],    // Delete  \n                      dp[i][j-1],    // Insert  \n                      dp[i-1][j-1])  // Replace`\n\n#### Base Cases\n\n- `dp[0][j] = j` (convert empty string to `s2[0..j-1]` by inserting all characters)\n- `dp[i][0] = i` (convert `s1[0..i-1]` to empty string by deleting all characters)\n\n---\n\n### C# Implementation\n\n```csharp\npublic class EditDistance\n{\n    public int LevenshteinDistance(string s1, string s2)\n    {\n        int m = s1.Length;\n        int n = s2.Length;\n        int[,] dp = new int[m + 1, n + 1];\n\n        // Initialize base cases\n        for (int i = 0; i <= m; i++)\n            dp[i, 0] = i;\n        for (int j = 0; j <= n; j++)\n            dp[0, j] = j;\n\n        // Fill DP table\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (s1[i - 1] == s2[j - 1])\n                {\n                    dp[i, j] = dp[i - 1, j - 1];\n                }\n                else\n                {\n                    dp[i, j] = 1 + Math.Min(\n                        Math.Min(dp[i - 1, j],    // Delete\n                                 dp[i, j - 1]),   // Insert\n                        dp[i - 1, j - 1]          // Replace\n                    );\n                }\n            }\n        }\n\n        return dp[m, n];\n    }\n}\n```\n\n---\n\n### Example Usage\n\n```csharp\nvar ed = new EditDistance();\nint distance = ed.LevenshteinDistance(\"kitten\", \"sitting\");\nConsole.WriteLine(distance); // Output: 3\n```\n\n---\n\n### Time and Space Complexity\n\n- **Time Complexity:** O(m * n)\n- **Space Complexity:** O(m * n) (can be optimized to O(min(m, n)) if only previous row is kept)\n\n---\n\n**Summary:**  \nThe Levenshtein distance algorithm uses dynamic programming to efficiently compute the minimum number of edits needed to transform one string into another. The above C# implementation is straightforward and can be optimized further for space if needed.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647145Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "2a326a26-97d3-40a2-baa4-5d081b36989f",
    "question": "How do you implement KMP (Knuth-Morris-Pratt) string matching?",
    "answer": "```markdown ### KMP (Knuth-Morris-Pratt) String Matching Algorithm in C#\n\nThe **KMP algorithm** efficiently searches for occurrences of a \"pattern\" string within a \"text\" string by preprocessing the pattern to create a longest prefix suffix (LPS) array. This avoids unnecessary re-examination of characters.\n\n#### Steps:\n\n1. **Preprocess the Pattern:** Build the LPS array that stores the length of the longest proper prefix which is also a suffix for every prefix of the pattern.\n2. **Search the Pattern:** Use the LPS array to skip characters in the text, reducing redundant comparisons.\n\n---\n\n#### C# Implementation\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class KMP\n{\n    // Preprocess the pattern to create the LPS array\n    private static int[] BuildLPS(string pattern)\n    {\n        int m = pattern.Length;\n        int[] lps = new int[m];\n        int len = 0;\n        int i = 1;\n\n        while (i < m)\n        {\n            if (pattern[i] == pattern[len])\n            {\n                len++;\n                lps[i] = len;\n                i++;\n            }\n            else\n            {\n                if (len != 0)\n                {\n                    len = lps[len - 1];\n                }\n                else\n                {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n\n    // KMP search function\n    public static List<int> KMPSearch(string text, string pattern)\n    {\n        int n = text.Length;\n        int m = pattern.Length;\n        List<int> result = new List<int>();\n\n        int[] lps = BuildLPS(pattern);\n        int i = 0; // index for text\n        int j = 0; // index for pattern\n\n        while (i < n)\n        {\n            if (pattern[j] == text[i])\n            {\n                i++;\n                j++;\n            }\n\n            if (j == m)\n            {\n                result.Add(i - j); // Pattern found at index (i-j)\n                j = lps[j - 1];\n            }\n            else if (i < n && pattern[j] != text[i])\n            {\n                if (j != 0)\n                {\n                    j = lps[j - 1];\n                }\n                else\n                {\n                    i++;\n                }\n            }\n        }\n        return result;\n    }\n}\n\n// Example usage\nclass Program\n{\n    static void Main()\n    {\n        string text = \"ababcabcabababd\";\n        string pattern = \"ababd\";\n        var indices = KMP.KMPSearch(text, pattern);\n\n        Console.WriteLine(\"Pattern found at indices: \" + string.Join(\", \", indices));\n    }\n}\n```\n\n---\n\n#### Output\n\n```\nPattern found at indices: 10\n```\n\n---\n\n#### Explanation\n\n- **BuildLPS:** Computes the LPS array for the pattern.\n- **KMPSearch:** Uses the LPS array to efficiently search for the pattern in the text.\n- **Time Complexity:** O(n + m), where n is the length of the text and m is the length of the pattern.\n\n---\n\n**KMP** is optimal for string matching problems where repeated searches are required, as it avoids redundant comparisons.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647152Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  },
  {
    "id": "e5edbd56-5a15-4eb6-8baf-106ac6491dae",
    "question": "How do you find the maximum subarray sum (Kadane's algorithm)?",
    "answer": "```markdown **Question:**  \nHow do you find the maximum subarray sum (Kadane's algorithm)?\n\n**Answer:**\n\nKadane's algorithm efficiently finds the contiguous subarray within a one-dimensional array of numbers that has the largest sum. It runs in O(n) time.\n\n**Algorithm Steps:**\n1. Initialize two variables:  \n   - `maxSoFar` to the smallest possible integer (to track the maximum sum found so far).\n   - `maxEndingHere` to 0 (to track the maximum sum ending at the current position).\n2. Iterate through the array:\n   - For each element, add it to `maxEndingHere`.\n   - If `maxSoFar` is less than `maxEndingHere`, update `maxSoFar`.\n   - If `maxEndingHere` becomes negative, reset it to 0.\n3. After the loop, `maxSoFar` contains the maximum subarray sum.\n\n**C# Implementation:**\n\n```csharp\npublic int MaxSubArraySum(int[] nums)\n{\n    int maxSoFar = int.MinValue;\n    int maxEndingHere = 0;\n\n    foreach (int num in nums)\n    {\n        maxEndingHere += num;\n        if (maxSoFar < maxEndingHere)\n            maxSoFar = maxEndingHere;\n        if (maxEndingHere < 0)\n            maxEndingHere = 0;\n    }\n\n    return maxSoFar;\n}\n```\n\n**Example Usage:**\n\n```csharp\nint[] arr = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\nint result = MaxSubArraySum(arr); // Output: 6 (subarray [4, -1, 2, 1])\n```\n\n**Explanation:**  \nKadane's algorithm works by keeping track of the current subarray sum and resetting it when it becomes negative, ensuring the maximum sum is always found efficiently.",
    "level": "Advanced",
    "created_at": "2025-04-21T11:58:37.647159Z",
    "topic": "9034fe81-fbe9-4e45-87b6-aae638446eef"
  }
]
