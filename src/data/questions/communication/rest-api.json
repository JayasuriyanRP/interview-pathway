[
    {
        "id": "6557093a-1eae-4cba-b153-f4993aff66bd",
        "question": "What is a REST API?",
        "answer": "```markdown A **REST API** (Representational State Transfer Application Programming Interface) is a way for different software applications to communicate over the internet using standard HTTP methods like GET, POST, PUT, and DELETE. REST APIs follow a set of rules that make them easy to use and understand. They allow clients (such as web or mobile apps) to interact with servers to create, read, update, or delete data.\n\n**Key points about REST APIs:**\n\n- They use standard HTTP methods.\n- Data is usually sent and received in formats like JSON or XML.\n- Each resource (such as a user or product) is identified by a unique URL.\n- REST APIs are stateless, meaning each request contains all the information needed to process it.\n\n**Example:**  \nA REST API endpoint to get a list of users might look like this:\n```\nGET https://api.example.com/users\n```\n\nIn C#, you can use libraries like `HttpClient` to interact with REST APIs.",
        "level": "Beginner"
    },
    {
        "id": "e5d71072-62f7-434c-8f24-fb66a3600a6a",
        "question": "How do you create a simple REST API in C# using ASP.NET Core?",
        "answer": "```markdown To create a simple REST API in C# using ASP.NET Core, follow these steps:\n\n### 1. Create a New ASP.NET Core Web API Project\n\n```bash\ndotnet new webapi -n SimpleApi\ncd SimpleApi\n```\n\n### 2. Define a Model\n\nCreate a new file called `TodoItem.cs` in the `Models` folder:\n\n```csharp\nnamespace SimpleApi.Models\n{\n    public class TodoItem\n    {\n        public long Id { get; set; }\n        public string Name { get; set; }\n        public bool IsComplete { get; set; }\n    }\n}\n```\n\n### 3. Create a Controller\n\nCreate a new file called `TodoController.cs` in the `Controllers` folder:\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing SimpleApi.Models;\nusing System.Collections.Generic;\n\nnamespace SimpleApi.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TodoController : ControllerBase\n    {\n        private static List<TodoItem> items = new List<TodoItem>\n        {\n            new TodoItem { Id = 1, Name = \"Learn ASP.NET Core\", IsComplete = false }\n        };\n\n        [HttpGet]\n        public ActionResult<IEnumerable<TodoItem>> GetAll()\n        {\n            return items;\n        }\n\n        [HttpGet(\"{id}\")]\n        public ActionResult<TodoItem> GetById(long id)\n        {\n            var item = items.Find(x => x.Id == id);\n            if (item == null) return NotFound();\n            return item;\n        }\n\n        [HttpPost]\n        public ActionResult<TodoItem> Create(TodoItem item)\n        {\n            item.Id = items.Count + 1;\n            items.Add(item);\n            return CreatedAtAction(nameof(GetById), new { id = item.Id }, item);\n        }\n    }\n}\n```\n\n### 4. Run the API\n\n```bash\ndotnet run\n```\n\nThe API will be available at `https://localhost:5001/api/todo`.\n\n### 5. Test the API\n\nYou can use tools like [Postman](https://www.postman.com/) or `curl` to test your endpoints:\n\n- **GET all:** `GET https://localhost:5001/api/todo`\n- **GET by id:** `GET https://localhost:5001/api/todo/1`\n- **POST new:**  \n  ```bash\n  curl -X POST https://localhost:5001/api/todo -H \"Content-Type: application/json\" -d '{\"name\":\"Write docs\",\"isComplete\":false}'\n  ```\n\n---\n\n**Summary:**  \nYou’ve created a simple REST API in C# using ASP.NET Core by defining a model, creating a controller, and running the application. This basic structure can be expanded for more complex APIs.",
        "level": "Beginner"
    },
    {
        "id": "deb0d3d4-bae7-4a69-bc41-7c38dc06aaf9",
        "question": "What are HTTP verbs and how are they used in REST APIs?",
        "answer": "```markdown HTTP verbs are methods used in HTTP requests to indicate the desired action to be performed on a resource. In REST APIs, these verbs define the type of operation you want to perform on the data. The most commonly used HTTP verbs are:\n\n- **GET**: Retrieves data from the server. For example, fetching a list of users.\n- **POST**: Creates a new resource on the server. For example, adding a new user.\n- **PUT**: Updates an existing resource entirely. For example, replacing a user's information.\n- **PATCH**: Partially updates an existing resource. For example, updating only the user's email.\n- **DELETE**: Removes a resource from the server. For example, deleting a user.\n\n**Example in C#:**\n\n```csharp\n// Example using HttpClient to send a GET request\nusing (var client = new HttpClient())\n{\n    HttpResponseMessage response = await client.GetAsync(\"https://api.example.com/users\");\n    string responseBody = await response.Content.ReadAsStringAsync();\n}\n```\n\nIn summary, HTTP verbs are essential in REST APIs as they specify what kind of operation you want to perform on the resources exposed by the API.",
        "level": "Beginner"
    },
    {
        "id": "b40e0ce6-7c36-46d3-864d-084c5b66c0ba",
        "question": "What is the difference between GET, POST, PUT, and DELETE methods?",
        "answer": "```markdown **GET, POST, PUT, and DELETE** are HTTP methods commonly used in REST APIs to perform different operations on resources:\n\n| Method  | Purpose                                 | Description                                                                 |\n|---------|-----------------------------------------|-----------------------------------------------------------------------------|\n| GET     | Retrieve data                           | Requests data from a server. Does not modify data.                          |\n| POST    | Create new data                         | Sends data to the server to create a new resource.                          |\n| PUT     | Update existing data (replace)          | Updates or replaces an existing resource with new data.                     |\n| DELETE  | Remove data                             | Deletes a specified resource from the server.                               |\n\n**Example: Managing a list of users**\n\n- `GET /users` — Get the list of users.\n- `POST /users` — Add a new user.\n- `PUT /users/1` — Update user with ID 1.\n- `DELETE /users/1` — Delete user with ID 1.\n\n**Summary Table**\n\n| Method  | Action         | Safe | Idempotent |\n|---------|----------------|------|------------|\n| GET     | Read           | Yes  | Yes        |\n| POST    | Create         | No   | No         |\n| PUT     | Update/Replace | No   | Yes        |\n| DELETE  | Delete         | No   | Yes        |\n\n- **Safe**: Does not change server data.\n- **Idempotent**: Same request can be repeated with the same result.",
        "level": "Beginner"
    },
    {
        "id": "1cd73cf9-af87-4cba-919c-80478f234151",
        "question": "How do you define a route in an ASP.NET Core controller?",
        "answer": "```markdown\nIn ASP.NET Core, you define a route in a controller using attributes. The most common way is to use the `[Route]` attribute at the controller or action method level. Here’s a simple example:\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\n\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class ProductsController : ControllerBase\n{\n    // GET api/products\n    [HttpGet]\n    public IActionResult GetAll()\n    {\n        // Your code here\n        return Ok();\n    }\n\n    // GET api/products/5\n    [HttpGet(\"{id}\")]\n    public IActionResult GetById(int id)\n    {\n        // Your code here\n        return Ok();\n    }\n}\n```\n\n**Explanation:**\n- `[Route(\"api/[controller]\")]` sets the base route for the controller. `[controller]` is replaced by the controller's name (without \"Controller\"), so this becomes `api/products`.\n- `[HttpGet]` and `[HttpGet(\"{id}\")]` define routes for the action methods. The `{id}` is a route parameter.\n\nYou can also define custom routes directly on action methods using the `[Route]` attribute.\n```",
        "level": "Beginner"
    },
    {
        "id": "09d2edf5-d4b6-4286-aa1f-753f559fd914",
        "question": "What is model binding in ASP.NET Core?",
        "answer": "```markdown **Model binding** in ASP.NET Core is the process by which the framework automatically maps data from HTTP requests (such as form fields, query strings, route data, or JSON bodies) to the parameters of your controller action methods or to properties of model objects.\n\nFor example, if you have a controller action like this:\n\n```csharp\npublic IActionResult Create(User user)\n{\n    // The 'user' parameter is automatically populated from the request data\n    // ...\n}\n```\n\nASP.NET Core will automatically create a `User` object and populate its properties with values from the incoming request, such as form fields or JSON data, without you having to manually parse the request.\n\n**Key points:**\n- Simplifies data handling in controllers.\n- Supports binding from various sources (route, query, form, body).\n- Handles complex types and collections.\n\n**Example:**\nIf you send a POST request with JSON body:\n```json\n{\n  \"Name\": \"Alice\",\n  \"Age\": 30\n}\n```\nASP.NET Core will bind this data to a `User` model parameter in your action method.\n\n**In summary:**  \nModel binding makes it easy to work with incoming data by automatically converting request data into .NET objects for you.",
        "level": "Beginner"
    },
    {
        "id": "414daeda-b4f1-471e-9707-3a8ef3c7ea51",
        "question": "How do you return JSON data from a controller action?",
        "answer": "```markdown To return JSON data from a controller action in a C# ASP.NET Core Web API, you typically return an object from your action method. ASP.NET Core automatically serializes the object to JSON.\n\nHere’s a simple example:\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\n\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class SampleController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get()\n    {\n        var data = new { message = \"Hello, World!\", value = 123 };\n        return Ok(data); // Returns JSON by default\n    }\n}\n```\n\n**Explanation:**\n\n- The `Ok(data)` method returns a 200 OK response with the data serialized as JSON.\n- By default, ASP.NET Core uses JSON for response formatting.\n\n**Tip:**  \nYou can also use `return new JsonResult(data);`, but `Ok(data)` is more common and recommended for Web APIs.",
        "level": "Beginner"
    },
    {
        "id": "bd8fb87a-934d-4279-a0e3-45a818a581a6",
        "question": "What is dependency injection and how is it used in ASP.NET Core REST APIs?",
        "answer": "```markdown **Dependency Injection (DI)** is a design pattern used to achieve Inversion of Control (IoC) between classes and their dependencies. Instead of a class creating its own dependencies, they are provided (injected) from the outside, making the code more modular, testable, and maintainable.\n\n### How Dependency Injection Works in ASP.NET Core REST APIs\n\nASP.NET Core has built-in support for dependency injection. Here’s how it’s typically used:\n\n1. **Register Services:**  \n   In the `Startup.cs` (or `Program.cs` in .NET 6+), you register your services with the DI container using methods like `AddSingleton`, `AddScoped`, or `AddTransient`.\n\n   ```csharp\n   services.AddScoped<IMyService, MyService>();\n   ```\n\n2. **Inject Services:**  \n   You request (inject) these services via constructor parameters in your controllers or other classes.\n\n   ```csharp\n   public class MyController : ControllerBase\n   {\n       private readonly IMyService _myService;\n\n       public MyController(IMyService myService)\n       {\n           _myService = myService;\n       }\n\n       // Use _myService in your action methods\n   }\n   ```\n\n### Benefits\n\n- **Loose Coupling:** Classes depend on abstractions (interfaces), not concrete implementations.\n- **Easier Testing:** You can inject mock implementations for unit testing.\n- **Centralized Configuration:** All dependencies are configured in one place.\n\n### Example\n\n```csharp\n// Define an interface\npublic interface IWeatherService\n{\n    string GetForecast();\n}\n\n// Implement the interface\npublic class WeatherService : IWeatherService\n{\n    public string GetForecast() => \"Sunny\";\n}\n\n// Register in Program.cs (for .NET 6+)\nbuilder.Services.AddScoped<IWeatherService, WeatherService>();\n\n// Inject into a controller\npublic class WeatherController : ControllerBase\n{\n    private readonly IWeatherService _weatherService;\n\n    public WeatherController(IWeatherService weatherService)\n    {\n        _weatherService = weatherService;\n    }\n\n    [HttpGet]\n    public string Get()\n    {\n        return _weatherService.GetForecast();\n    }\n}\n```\n\n**In summary:**  \nDependency Injection in ASP.NET Core REST APIs allows you to manage and inject dependencies efficiently, leading to cleaner, more maintainable, and testable code.",
        "level": "Beginner"
    },
    {
        "id": "6be63062-f532-47e2-b594-5f48cfd32090",
        "question": "How do you handle errors and exceptions in a REST API?",
        "answer": "```markdown\nIn a C# REST API (for example, using ASP.NET Core), handling errors and exceptions is important to provide meaningful responses to clients and to avoid exposing sensitive information. Here are some common practices:\n\n### 1. Use Exception Handling Middleware\n\nASP.NET Core provides built-in middleware for handling exceptions globally. You can use the `UseExceptionHandler` middleware in your `Startup.cs`:\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseExceptionHandler(\"/error\"); // Redirects to /error on exceptions\n\n    // Other middleware registrations...\n}\n```\n\nThen, create an error-handling endpoint:\n\n```csharp\n[ApiController]\npublic class ErrorController : ControllerBase\n{\n    [Route(\"error\")]\n    public IActionResult Error()\n    {\n        return Problem(); // Returns a standardized error response\n    }\n}\n```\n\n### 2. Return Appropriate HTTP Status Codes\n\nWhen catching exceptions, return the correct HTTP status code. For example:\n\n- `400 Bad Request` for invalid input\n- `404 Not Found` for missing resources\n- `500 Internal Server Error` for unexpected errors\n\nExample in a controller action:\n\n```csharp\n[HttpGet(\"{id}\")]\npublic IActionResult GetItem(int id)\n{\n    try\n    {\n        var item = _service.GetItem(id);\n        if (item == null)\n            return NotFound(); // 404\n\n        return Ok(item); // 200\n    }\n    catch (ArgumentException)\n    {\n        return BadRequest(); // 400\n    }\n    catch (Exception)\n    {\n        return StatusCode(500, \"An unexpected error occurred.\"); // 500\n    }\n}\n```\n\n### 3. Use Problem Details\n\nASP.NET Core supports [RFC 7807 Problem Details](https://tools.ietf.org/html/rfc7807) for error responses:\n\n```csharp\nreturn Problem(\n    detail: \"The item was not found.\",\n    statusCode: 404,\n    title: \"Not Found\"\n);\n```\n\n### 4. Logging\n\nAlways log exceptions for troubleshooting, but avoid returning stack traces or sensitive details to the client.\n\n### Summary\n\n- Use global exception handling middleware.\n- Return appropriate HTTP status codes.\n- Use standardized error responses (like Problem Details).\n- Log exceptions for diagnostics.\n\nThis approach ensures your API is robust, secure, and user-friendly.\n```\n",
        "level": "Beginner"
    },
    {
        "id": "81845aa2-aa4b-411f-b71e-c111e43b9c3b",
        "question": "What is the purpose of the [ApiController] attribute?",
        "answer": "```markdown The `[ApiController]` attribute in C# is used to indicate that a controller is intended to serve as an API endpoint. When you decorate a controller class with `[ApiController]`, it enables several features that make building RESTful APIs easier and more robust:\n\n- **Automatic Model Validation:** The framework automatically checks if the incoming request data is valid according to your model's validation attributes. If not, it returns a 400 Bad Request response.\n- **Attribute Routing Requirement:** It enforces the use of attribute routing (e.g., `[Route(\"api/[controller]\")]`), which is common in APIs.\n- **Binding Source Parameter Inference:** It automatically infers binding sources for action parameters (e.g., `[FromBody]`, `[FromQuery]`), so you don't always need to specify them explicitly.\n- **Problem Details Responses:** It returns standardized error responses (RFC 7807 Problem Details) for common errors.\n\n**Example:**\n\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult GetAllProducts()\n    {\n        // Implementation\n    }\n}\n```\n\n**In summary:**  \nThe `[ApiController]` attribute simplifies the development of REST APIs by enabling helpful behaviors and conventions in your controller classes.",
        "level": "Beginner"
    },
    {
        "id": "9094a72b-0631-4059-992f-54b3443892c1",
        "question": "How do you test a REST API endpoint in C#?",
        "answer": "```markdown You can test a REST API endpoint in C# using the HttpClient class. Here’s a simple example of how to send a GET request and read the response:\n\n```csharp\nusing System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main()\n    {\n        using (HttpClient client = new HttpClient())\n        {\n            // Replace with your API endpoint\n            string url = \"https://jsonplaceholder.typicode.com/posts/1\";\n\n            HttpResponseMessage response = await client.GetAsync(url);\n\n            if (response.IsSuccessStatusCode)\n            {\n                string responseBody = await response.Content.ReadAsStringAsync();\n                Console.WriteLine(\"Response:\");\n                Console.WriteLine(responseBody);\n            }\n            else\n            {\n                Console.WriteLine($\"Error: {response.StatusCode}\");\n            }\n        }\n    }\n}\n```\n\n**Steps:**\n1. Create an instance of `HttpClient`.\n2. Use methods like `GetAsync`, `PostAsync`, etc., to send requests.\n3. Check the response status and read the content.\n4. Handle errors as needed.\n\n**Tip:** For more advanced testing, consider using testing frameworks like xUnit or NUnit along with mocking libraries such as Moq.",
        "level": "Beginner"
    },
    {
        "id": "e5180b50-4242-4813-a608-abc2b1aecda4",
        "question": "What is Swagger and how do you use it with ASP.NET Core REST APIs?",
        "answer": "```markdown **Swagger** is an open-source framework for designing, building, documenting, and consuming RESTful web services. In the context of ASP.NET Core, Swagger is commonly used through the **Swashbuckle** library to automatically generate interactive API documentation.\n\n### What Does Swagger Do?\n- **Generates interactive documentation** for your REST API.\n- Allows developers and testers to **explore and test endpoints** directly from a web UI.\n- Produces a **machine-readable OpenAPI specification** (formerly known as Swagger specification) for your API.\n\n---\n\n## How to Use Swagger with ASP.NET Core REST APIs\n\n### 1. Install Swashbuckle.AspNetCore\n\nAdd the NuGet package to your project:\n\n```bash\ndotnet add package Swashbuckle.AspNetCore\n```\n\n### 2. Configure Swagger in `Startup.cs` (or `Program.cs` in .NET 6+)\n\n**For .NET 6+ (Minimal API):**\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddControllers();\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\n// Enable middleware to serve generated Swagger as a JSON endpoint.\napp.UseSwagger();\n\n// Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.)\napp.UseSwaggerUI();\n\napp.MapControllers();\n\napp.Run();\n```\n\n### 3. Run Your Application\n\nStart your application and navigate to:\n\n```\nhttps://localhost:<port>/swagger\n```\n\nYou will see the interactive Swagger UI, where you can view and test your API endpoints.\n\n---\n\n## Summary Table\n\n| Feature              | Description                                      |\n|----------------------|--------------------------------------------------|\n| **Swagger**          | Framework for API documentation and testing      |\n| **Swashbuckle**      | Popular .NET library for integrating Swagger     |\n| **Swagger UI**       | Interactive web interface for API exploration    |\n| **OpenAPI Spec**     | Standard format for describing REST APIs         |\n\n---\n\n**In short:**  \nSwagger (via Swashbuckle) makes it easy to document, test, and share your ASP.NET Core REST APIs with minimal setup.",
        "level": "Beginner"
    },
    {
        "id": "b770a3ec-66f0-4e82-8f31-6c39009c644d",
        "question": "How do you secure a REST API in C#?",
        "answer": "```markdown Securing a REST API in C#\n--------------------------\n\nSecuring a REST API in C# typically involves several layers of protection. Here are common approaches and best practices:\n\n### 1. **Authentication**\n\n- **JWT (JSON Web Tokens):**  \n  Use JWTs to authenticate users. After login, the server issues a token, which the client includes in the Authorization header for subsequent requests.\n\n  ```csharp\n  services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n      .AddJwtBearer(options =>\n      {\n          options.TokenValidationParameters = new TokenValidationParameters\n          {\n              ValidateIssuer = true,\n              ValidateAudience = true,\n              ValidateLifetime = true,\n              ValidateIssuerSigningKey = true,\n              // Set Issuer, Audience, and SigningKey\n          };\n      });\n  ```\n\n- **OAuth2/OpenID Connect:**  \n  Integrate with identity providers (e.g., Azure AD, IdentityServer) for more advanced scenarios.\n\n### 2. **Authorization**\n\n- **Role-based Authorization:**  \n  Use `[Authorize]` attributes to restrict access to controllers or actions.\n\n  ```csharp\n  [Authorize(Roles = \"Admin\")]\n  public IActionResult GetAdminData() { ... }\n  ```\n\n- **Policy-based Authorization:**  \n  Define custom policies for more granular control.\n\n### 3. **HTTPS Enforcement**\n\n- **Require HTTPS:**  \n  Redirect all HTTP traffic to HTTPS to encrypt data in transit.\n\n  ```csharp\n  app.UseHttpsRedirection();\n  ```\n\n### 4. **Input Validation & Sanitization**\n\n- Always validate and sanitize incoming data to prevent injection attacks.\n\n### 5. **CORS (Cross-Origin Resource Sharing)**\n\n- Configure CORS to allow only trusted domains.\n\n  ```csharp\n  services.AddCors(options =>\n  {\n      options.AddPolicy(\"AllowSpecificOrigin\",\n          builder => builder.WithOrigins(\"https://trusted.com\")\n                            .AllowAnyHeader()\n                            .AllowAnyMethod());\n  });\n  ```\n\n### 6. **Rate Limiting & Throttling**\n\n- Implement rate limiting to prevent abuse (e.g., using middleware or third-party libraries).\n\n### 7. **Logging & Monitoring**\n\n- Log requests and monitor for suspicious activity.\n\n### 8. **Other Best Practices**\n\n- **Disable directory browsing and unnecessary endpoints.**\n- **Keep dependencies updated.**\n- **Use secure headers (e.g., HSTS, X-Content-Type-Options).**\n\n---\n\n**Example: Secure Controller**\n\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\n[Authorize] // Requires authentication\npublic class ValuesController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get() => Ok(new { Message = \"Secure data\" });\n}\n```\n\n---\n\nBy combining these techniques, you can significantly enhance the security of your REST API in C#.",
        "level": "Intermediate"
    },
    {
        "id": "a1d92fa6-c975-47ee-b82a-1e7bb0c22af1",
        "question": "What is JWT authentication and how is it implemented in ASP.NET Core?",
        "answer": "```markdown **JWT Authentication and Its Implementation in ASP.NET Core**\n\n**What is JWT Authentication?**\n\nJWT (JSON Web Token) authentication is a stateless, token-based authentication mechanism commonly used in REST APIs. It allows secure transmission of information between parties as a JSON object. The token is digitally signed, ensuring data integrity and authenticity.\n\nA typical JWT contains three parts:\n1. **Header**: Specifies the signing algorithm and token type.\n2. **Payload**: Contains claims (user data and metadata).\n3. **Signature**: Verifies the token’s integrity.\n\n**How JWT Authentication Works:**\n1. The client sends credentials (e.g., username/password) to the server.\n2. The server validates credentials and generates a JWT.\n3. The client stores the JWT (usually in local storage) and sends it in the Authorization header with each request.\n4. The server validates the JWT and grants access if valid.\n\n---\n\n**Implementation in ASP.NET Core**\n\n1. **Install Required NuGet Packages**\n   ```bash\n   dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer\n   ```\n\n2. **Configure JWT Authentication in `Program.cs` or `Startup.cs`**\n   ```csharp\n   using Microsoft.AspNetCore.Authentication.JwtBearer;\n   using Microsoft.IdentityModel.Tokens;\n   using System.Text;\n\n   var builder = WebApplication.CreateBuilder(args);\n\n   // Add JWT authentication\n   builder.Services.AddAuthentication(options =>\n   {\n       options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n       options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n   })\n   .AddJwtBearer(options =>\n   {\n       options.TokenValidationParameters = new TokenValidationParameters\n       {\n           ValidateIssuer = true,\n           ValidateAudience = true,\n           ValidateLifetime = true,\n           ValidateIssuerSigningKey = true,\n           ValidIssuer = \"yourIssuer\",\n           ValidAudience = \"yourAudience\",\n           IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"yourSecretKey\"))\n       };\n   });\n\n   var app = builder.Build();\n\n   app.UseAuthentication();\n   app.UseAuthorization();\n   ```\n\n3. **Generating JWT Token**\n   ```csharp\n   using System.IdentityModel.Tokens.Jwt;\n   using System.Security.Claims;\n   using Microsoft.IdentityModel.Tokens;\n\n   public string GenerateJwtToken(string username)\n   {\n       var claims = new[]\n       {\n           new Claim(JwtRegisteredClaimNames.Sub, username),\n           new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())\n       };\n\n       var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"yourSecretKey\"));\n       var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n       var token = new JwtSecurityToken(\n           issuer: \"yourIssuer\",\n           audience: \"yourAudience\",\n           claims: claims,\n           expires: DateTime.Now.AddHours(1),\n           signingCredentials: creds);\n\n       return new JwtSecurityTokenHandler().WriteToken(token);\n   }\n   ```\n\n4. **Protecting Endpoints**\n   ```csharp\n   [Authorize]\n   [ApiController]\n   [Route(\"[controller]\")]\n   public class ValuesController : ControllerBase\n   {\n       [HttpGet]\n       public IActionResult Get()\n       {\n           return Ok(new { message = \"This is a protected endpoint.\" });\n       }\n   }\n   ```\n\n---\n\n**Summary Table**\n\n| Step                  | Description                                              |\n|-----------------------|---------------------------------------------------------|\n| Install Package       | Add `Microsoft.AspNetCore.Authentication.JwtBearer`     |\n| Configure Services    | Set up JWT authentication in the service container      |\n| Generate Token        | Issue JWT upon successful login                         |\n| Protect Endpoints     | Use `[Authorize]` to secure API endpoints               |\n\n**References:**\n- [Microsoft Docs: JWT Bearer Authentication](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/jwt?view=aspnetcore-7.0)\n- [JWT.io Introduction](https://jwt.io/introduction)\n\n---\n\n**In summary:**  \nJWT authentication in ASP.NET Core involves configuring the authentication middleware, generating tokens upon successful login, and securing endpoints using the `[Authorize]` attribute. This approach enables stateless, scalable, and secure API authentication.",
        "level": "Intermediate"
    },
    {
        "id": "81237b3c-f588-49b4-92f5-ff5204eedcdc",
        "question": "How do you implement versioning in a REST API?",
        "answer": "```markdown\nTo implement versioning in a REST API using C#, you can use several common strategies. The most popular approaches are:\n\n### 1. URI Versioning\n\nAdd the version number directly into the URL path.\n\n**Example:**\n```\nGET /api/v1/products\nGET /api/v2/products\n```\n\n**Implementation in ASP.NET Core:**\n```csharp\n[ApiController]\n[Route(\"api/v{version:apiVersion}/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get() { ... }\n}\n```\n\n### 2. Query String Versioning\n\nPass the version as a query parameter.\n\n**Example:**\n```\nGET /api/products?api-version=1.0\n```\n\n**Implementation:**\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get([FromQuery(Name = \"api-version\")] string apiVersion) { ... }\n}\n```\n\n### 3. Header Versioning\n\nSpecify the version in a custom HTTP header.\n\n**Example:**\n```\nGET /api/products\napi-version: 1.0\n```\n\n**Implementation:**\nRead the version from the request headers in your controller or middleware.\n\n### Using Microsoft.AspNetCore.Mvc.Versioning\n\nFor a robust solution, use the [Microsoft.AspNetCore.Mvc.Versioning](https://github.com/dotnet/aspnet-api-versioning) NuGet package.\n\n**Installation:**\n```\ndotnet add package Microsoft.AspNetCore.Mvc.Versioning\n```\n\n**Configuration in `Startup.cs`:**\n```csharp\nservices.AddApiVersioning(options =>\n{\n    options.DefaultApiVersion = new ApiVersion(1, 0);\n    options.AssumeDefaultVersionWhenUnspecified = true;\n    options.ReportApiVersions = true;\n    options.ApiVersionReader = new UrlSegmentApiVersionReader(); // or QueryStringApiVersionReader, HeaderApiVersionReader\n});\n```\n\n**Controller Example:**\n```csharp\n[ApiVersion(\"1.0\")]\n[ApiVersion(\"2.0\")]\n[Route(\"api/v{version:apiVersion}/[controller]\")]\npublic class ProductsController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult GetV1() { ... }\n\n    [HttpGet, MapToApiVersion(\"2.0\")]\n    public IActionResult GetV2() { ... }\n}\n```\n\n---\n\n**Summary:**  \nYou can implement REST API versioning in C# using URI, query string, or header-based approaches. For enterprise-grade solutions, leverage the `Microsoft.AspNetCore.Mvc.Versioning` package to manage versions cleanly and efficiently.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "0bb924fe-c95c-421a-8e9e-f5904a333a06",
        "question": "What is CORS and how do you enable it in ASP.NET Core?",
        "answer": "```markdown **CORS (Cross-Origin Resource Sharing)** is a security feature implemented by browsers to restrict web applications running at one origin from interacting with resources from a different origin. By default, browsers block such cross-origin requests for security reasons. CORS allows servers to specify who can access their resources and which HTTP methods are permitted from external origins.\n\n### Enabling CORS in ASP.NET Core\n\nTo enable CORS in an ASP.NET Core REST API, follow these steps:\n\n1. **Install the CORS Middleware**  \n   The CORS middleware is included by default in ASP.NET Core projects (`Microsoft.AspNetCore.Cors`).\n\n2. **Configure CORS in `Startup.cs` or `Program.cs`**\n\n   - **Define a CORS policy** in the `ConfigureServices` method:\n\n     ```csharp\n     public void ConfigureServices(IServiceCollection services)\n     {\n         services.AddCors(options =>\n         {\n             options.AddPolicy(\"AllowSpecificOrigin\",\n                 builder =>\n                 {\n                     builder.WithOrigins(\"https://example.com\")\n                            .AllowAnyHeader()\n                            .AllowAnyMethod();\n                 });\n         });\n\n         services.AddControllers();\n     }\n     ```\n\n   - **Enable the CORS middleware** in the `Configure` method:\n\n     ```csharp\n     public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n     {\n         app.UseRouting();\n\n         app.UseCors(\"AllowSpecificOrigin\"); // Use the defined CORS policy\n\n         app.UseAuthorization();\n\n         app.UseEndpoints(endpoints =>\n         {\n             endpoints.MapControllers();\n         });\n     }\n     ```\n\n   > **Note:** In .NET 6 and later (minimal hosting model), the configuration is done in `Program.cs`:\n\n   ```csharp\n   var builder = WebApplication.CreateBuilder(args);\n\n   builder.Services.AddCors(options =>\n   {\n       options.AddPolicy(\"AllowSpecificOrigin\",\n           policy => policy.WithOrigins(\"https://example.com\")\n                           .AllowAnyHeader()\n                           .AllowAnyMethod());\n   });\n\n   var app = builder.Build();\n\n   app.UseCors(\"AllowSpecificOrigin\");\n\n   app.MapControllers();\n\n   app.Run();\n   ```\n\n3. **Apply CORS Policy to Controllers or Actions (Optional)**  \n   You can also apply CORS policies at the controller or action level using the `[EnableCors]` attribute:\n\n   ```csharp\n   [ApiController]\n   [Route(\"[controller]\")]\n   [EnableCors(\"AllowSpecificOrigin\")]\n   public class MyController : ControllerBase\n   {\n       // ...\n   }\n   ```\n\n### Summary\n\n- **CORS** controls cross-origin requests in browsers.\n- In ASP.NET Core, enable CORS by configuring a policy in `Startup.cs` or `Program.cs`, and applying it globally or to specific controllers/actions.\n- Use `WithOrigins`, `AllowAnyHeader`, and `AllowAnyMethod` to customize allowed origins, headers, and HTTP methods.\n\n**References:**  \n- [Microsoft Docs: Enable Cross-Origin Requests (CORS) in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/cors)",
        "level": "Intermediate"
    },
    {
        "id": "15e335a2-4bd5-46ae-9db9-a2efbd2f8eb7",
        "question": "How do you validate incoming request data in a REST API?",
        "answer": "```markdown To validate incoming request data in a REST API using C#, you typically use **model validation** with data annotations and, optionally, custom validation logic. Here’s how you can do it:\n\n### 1. Use Data Annotations\n\nDecorate your request models (DTOs) with validation attributes from the `System.ComponentModel.DataAnnotations` namespace:\n\n```csharp\npublic class CreateUserRequest\n{\n    [Required]\n    [StringLength(100, MinimumLength = 3)]\n    public string Username { get; set; }\n\n    [Required]\n    [EmailAddress]\n    public string Email { get; set; }\n}\n```\n\n### 2. Automatic Validation in Controllers\n\nIn ASP.NET Core, model validation is performed automatically when you use `[ApiController]`:\n\n```csharp\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class UsersController : ControllerBase\n{\n    [HttpPost]\n    public IActionResult CreateUser([FromBody] CreateUserRequest request)\n    {\n        // If validation fails, ASP.NET Core returns 400 Bad Request automatically\n        // with validation error details in the response body.\n\n        // Your business logic here...\n        return Ok();\n    }\n}\n```\n\n### 3. Manual Validation (if needed)\n\nIf you need to manually check for validation errors:\n\n```csharp\nif (!ModelState.IsValid)\n{\n    return BadRequest(ModelState);\n}\n```\n\n### 4. Custom Validation\n\nYou can create custom validation attributes by inheriting from `ValidationAttribute`:\n\n```csharp\npublic class NotFutureDateAttribute : ValidationAttribute\n{\n    public override bool IsValid(object value)\n    {\n        if (value is DateTime date)\n        {\n            return date <= DateTime.Now;\n        }\n        return false;\n    }\n}\n```\n\nAnd use it in your model:\n\n```csharp\npublic class EventRequest\n{\n    [NotFutureDate(ErrorMessage = \"Date cannot be in the future.\")]\n    public DateTime EventDate { get; set; }\n}\n```\n\n### 5. FluentValidation (Alternative)\n\nFor more complex scenarios, consider using the [FluentValidation](https://fluentvalidation.net/) library.\n\n---\n\n**Summary:**  \n- Use data annotations for simple validation.\n- ASP.NET Core automatically validates models and returns errors if `[ApiController]` is used.\n- For custom rules, create custom attributes or use FluentValidation.\n- Always validate incoming data to ensure API robustness and security.",
        "level": "Intermediate"
    },
    {
        "id": "4c66d587-ce4c-41b0-9f35-fb3f93434481",
        "question": "What is middleware and how is it used in ASP.NET Core REST APIs?",
        "answer": "```markdown **Middleware** in ASP.NET Core is software that's assembled into an application pipeline to handle requests and responses. Each component (middleware) in the pipeline can:\n\n- Inspect, modify, or short-circuit HTTP requests and responses.\n- Pass control to the next middleware in the pipeline.\n\n### How Middleware Works\n\nWhen an HTTP request comes in:\n\n1. It enters the pipeline and passes through each middleware component in order.\n2. Each middleware can:\n   - Do something before passing the request to the next middleware.\n   - Optionally stop the pipeline and generate a response.\n   - Do something after the next middleware has processed the request (on the way back).\n\n### Common Uses in REST APIs\n\n- **Authentication & Authorization**: Ensuring users are who they say they are and have permission.\n- **Logging**: Recording request and response details.\n- **Error Handling**: Catching and formatting errors.\n- **CORS**: Controlling cross-origin requests.\n- **Routing**: Directing requests to the correct controller/action.\n\n### Example: Adding Middleware in ASP.NET Core\n\nIn `Startup.cs` (or `Program.cs` in .NET 6+):\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    // Custom middleware example\n    app.Use(async (context, next) =>\n    {\n        // Do something with the request\n        Console.WriteLine(\"Request incoming\");\n\n        await next(); // Call the next middleware\n\n        // Do something with the response\n        Console.WriteLine(\"Response outgoing\");\n    });\n\n    app.UseAuthorization();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllers();\n    });\n}\n```\n\n### Key Points\n\n- Middleware is central to request processing in ASP.NET Core.\n- Order matters: Middleware is executed in the order it's added.\n- You can use built-in middleware or create your own.\n\n**In summary:** Middleware in ASP.NET Core REST APIs is a powerful way to handle cross-cutting concerns (like logging, authentication, error handling) for every HTTP request and response.",
        "level": "Intermediate"
    },
    {
        "id": "28c7001f-a1d0-46d8-96eb-e7666c56f569",
        "question": "How do you implement logging in a REST API?",
        "answer": "```markdown\nTo implement logging in a REST API using C#, you typically use a logging framework such as **Serilog**, **NLog**, or **Microsoft.Extensions.Logging**. Here’s a step-by-step guide using the built-in logging in ASP.NET Core:\n\n### 1. Configure Logging in `Program.cs`\n\nASP.NET Core comes with built-in logging support. In your `Program.cs` or `Startup.cs`, logging is usually configured automatically:\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add logging services (default providers: Console, Debug, etc.)\nbuilder.Logging.ClearProviders();\nbuilder.Logging.AddConsole();\n\nvar app = builder.Build();\n```\n\n### 2. Inject `ILogger` into Controllers\n\nYou can inject `ILogger<T>` into your controllers or services:\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\n[ApiController]\n[Route(\"[controller]\")]\npublic class WeatherController : ControllerBase\n{\n    private readonly ILogger<WeatherController> _logger;\n\n    public WeatherController(ILogger<WeatherController> logger)\n    {\n        _logger = logger;\n    }\n\n    [HttpGet]\n    public IActionResult Get()\n    {\n        _logger.LogInformation(\"GET request received at WeatherController.\");\n        try\n        {\n            // Your logic here\n            return Ok(\"Weather data\");\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, \"An error occurred while getting weather data.\");\n            return StatusCode(500, \"Internal server error\");\n        }\n    }\n}\n```\n\n### 3. Log at Different Levels\n\nUse different log levels as appropriate:\n\n- `LogTrace`\n- `LogDebug`\n- `LogInformation`\n- `LogWarning`\n- `LogError`\n- `LogCritical`\n\nExample:\n\n```csharp\n_logger.LogWarning(\"This is a warning message.\");\n_logger.LogError(\"This is an error message.\");\n```\n\n### 4. Logging Middleware (Optional)\n\nFor logging all requests and responses, you can create custom middleware:\n\n```csharp\npublic class RequestLoggingMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogger<RequestLoggingMiddleware> _logger;\n\n    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)\n    {\n        _next = next;\n        _logger = logger;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        _logger.LogInformation(\"Handling request: {Method} {Path}\", context.Request.Method, context.Request.Path);\n        await _next(context);\n        _logger.LogInformation(\"Finished handling request.\");\n    }\n}\n\n// Register middleware in Program.cs\napp.UseMiddleware<RequestLoggingMiddleware>();\n```\n\n### 5. Use Structured Logging (Optional)\n\nWith frameworks like Serilog, you can log structured data for better querying and analysis.\n\n---\n\n**Summary:**  \n- Use built-in or third-party logging frameworks.\n- Inject `ILogger<T>` into controllers/services.\n- Log at appropriate levels.\n- Optionally, implement middleware for request/response logging.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "7d03dbd2-b2dc-4830-aa55-e546192d8032",
        "question": "What are Data Transfer Objects (DTOs) and why are they used?",
        "answer": "```markdown ### What are Data Transfer Objects (DTOs) and Why Are They Used?\n\n**Data Transfer Objects (DTOs)** are simple objects used to transfer data between different layers of an application, especially between the server and client in a REST API. They typically contain only data fields (properties) and lack business logic.\n\n#### Why are DTOs Used?\n\n1. **Encapsulation of Data:**  \n   DTOs help encapsulate the data you want to expose, hiding internal implementation details of your domain models.\n\n2. **Decoupling:**  \n   They decouple your API’s contract from your internal data models, allowing you to change your domain models without affecting the API consumers.\n\n3. **Security:**  \n   By using DTOs, you can prevent sensitive fields from being exposed unintentionally.\n\n4. **Validation:**  \n   DTOs can be tailored to the needs of specific API endpoints, making it easier to validate incoming data.\n\n5. **Performance:**  \n   DTOs can be shaped to include only the necessary data, reducing the payload size and improving performance.\n\n#### Example in C#\n\n```csharp\n// Domain Model\npublic class User\n{\n    public int Id { get; set; }\n    public string Username { get; set; }\n    public string PasswordHash { get; set; }\n    public string Email { get; set; }\n}\n\n// DTO\npublic class UserDto\n{\n    public int Id { get; set; }\n    public string Username { get; set; }\n    public string Email { get; set; }\n}\n```\n\nIn this example, the `UserDto` exposes only the `Id`, `Username`, and `Email` fields, hiding the sensitive `PasswordHash` field from API consumers.\n\n---\n\n**Summary:**  \nDTOs are used in REST APIs to transfer only the necessary data, improve security, decouple internal models from external contracts, and optimize data transfer between client and server.",
        "level": "Intermediate"
    },
    {
        "id": "c9473205-ef58-4297-ab4c-9ed958e64fb6",
        "question": "How do you map between entities and DTOs in C#?",
        "answer": "```markdown To map between entities and DTOs (Data Transfer Objects) in C#, you typically use one of the following approaches:\n\n### 1. Manual Mapping\n\nYou write code to copy properties from the entity to the DTO and vice versa.\n\n```csharp\n// Entity\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\n// DTO\npublic class UserDto\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n}\n\n// Manual mapping\npublic UserDto MapToDto(User user)\n{\n    return new UserDto\n    {\n        Id = user.Id,\n        Name = user.Name\n    };\n}\n\npublic User MapToEntity(UserDto dto)\n{\n    return new User\n    {\n        Id = dto.Id,\n        Name = dto.Name\n    };\n}\n```\n\n### 2. Using AutoMapper\n\n[AutoMapper](https://automapper.org/) is a popular library that automates mapping between objects.\n\n**Install AutoMapper via NuGet:**\n```shell\ndotnet add package AutoMapper\n```\n\n**Configure and use AutoMapper:**\n```csharp\nusing AutoMapper;\n\n// Entity and DTO as above\n\n// Create mapping profile\npublic class MappingProfile : Profile\n{\n    public MappingProfile()\n    {\n        CreateMap<User, UserDto>();\n        CreateMap<UserDto, User>();\n    }\n}\n\n// Configure AutoMapper\nvar config = new MapperConfiguration(cfg => cfg.AddProfile<MappingProfile>());\nvar mapper = config.CreateMapper();\n\n// Mapping\nUser user = new User { Id = 1, Name = \"Alice\" };\nUserDto dto = mapper.Map<UserDto>(user);\n```\n\n### 3. Using LINQ (for collections)\n\nYou can use LINQ to project a list of entities to DTOs:\n\n```csharp\nList<User> users = ...;\nList<UserDto> dtos = users.Select(u => new UserDto\n{\n    Id = u.Id,\n    Name = u.Name\n}).ToList();\n```\n\n---\n\n**Summary:**  \n- Manual mapping gives you full control but can be verbose.\n- AutoMapper reduces boilerplate and is ideal for large projects.\n- LINQ is handy for mapping collections.\n\nChoose the approach that best fits your project's complexity and requirements.",
        "level": "Intermediate"
    },
    {
        "id": "773e7bdd-d3bd-4696-88e2-fc175828600f",
        "question": "How do you handle concurrency in a REST API?",
        "answer": "```markdown Handling Concurrency in a REST API (C#)\n---\n\nConcurrency issues arise when multiple clients attempt to modify the same resource simultaneously. In REST APIs built with C#, common strategies to handle concurrency include:\n\n### 1. Optimistic Concurrency Control\n\nThis approach assumes that conflicts are rare and checks for them before committing changes.\n\n**How to implement:**\n\n- Add a versioning property to your resource (e.g., a `RowVersion` byte array or a timestamp).\n- When a client fetches a resource, include the version value.\n- When updating, require the client to send back the version.\n- On the server, check if the version matches the current value in the database.\n    - If it matches, proceed with the update.\n    - If not, return a `409 Conflict` response.\n\n**Example using Entity Framework Core:**\n\n```csharp\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    [Timestamp]\n    public byte[] RowVersion { get; set; }\n}\n```\n\n```csharp\n[HttpPut(\"{id}\")]\npublic async Task<IActionResult> UpdateProduct(int id, Product updatedProduct)\n{\n    var product = await _context.Products.FindAsync(id);\n    if (product == null) return NotFound();\n\n    // Copy updated fields\n    product.Name = updatedProduct.Name;\n\n    // Set original RowVersion\n    _context.Entry(product).Property(\"RowVersion\").OriginalValue = updatedProduct.RowVersion;\n\n    try\n    {\n        await _context.SaveChangesAsync();\n        return NoContent();\n    }\n    catch (DbUpdateConcurrencyException)\n    {\n        return Conflict(\"The resource was modified by another user.\");\n    }\n}\n```\n\n### 2. ETag and If-Match Headers\n\nHTTP provides ETags (entity tags) to help with concurrency.\n\n- The server returns an ETag header with the resource.\n- The client includes the ETag value in the `If-Match` header when updating.\n- The server compares the ETag with the current version.\n    - If they match, update proceeds.\n    - If not, return `412 Precondition Failed`.\n\n**Example:**\n\n```csharp\n// On GET\nResponse.Headers[\"ETag\"] = $\"\\\"{Convert.ToBase64String(product.RowVersion)}\\\"\";\n\n// On PUT\n[HttpPut(\"{id}\")]\npublic async Task<IActionResult> UpdateProduct(int id, Product updatedProduct)\n{\n    var ifMatch = Request.Headers[\"If-Match\"].FirstOrDefault();\n    var product = await _context.Products.FindAsync(id);\n    if (product == null) return NotFound();\n\n    var currentEtag = $\"\\\"{Convert.ToBase64String(product.RowVersion)}\\\"\";\n    if (ifMatch != currentEtag)\n        return StatusCode(412, \"Resource has been modified.\");\n\n    // Proceed with update...\n}\n```\n\n### 3. Pessimistic Concurrency (Locking)\n\nLess common in REST APIs due to statelessness, but possible:\n\n- Lock the resource for a client (e.g., using a flag in the database).\n- Other clients cannot modify until the lock is released.\n\nThis approach can lead to scalability issues and is generally discouraged in RESTful design.\n\n---\n\n**Summary Table**\n\n| Method                          | Pros                      | Cons                         |\n|----------------------------------|---------------------------|------------------------------|\n| Optimistic Concurrency (version) | Simple, scalable          | May require retry logic      |\n| ETag/If-Match                    | Standards-based, flexible | Requires client cooperation  |\n| Pessimistic Locking              | Prevents all conflicts    | Scalability, complexity      |\n\n---\n\n**Best Practice:**  \nUse optimistic concurrency (versioning or ETag) for most REST APIs in C#. This approach is scalable, aligns with REST principles, and is well-supported by frameworks like Entity Framework Core.",
        "level": "Intermediate"
    },
    {
        "id": "7aeb805f-ab12-4317-aac5-44be0b199feb",
        "question": "What is the difference between synchronous and asynchronous controller actions?",
        "answer": "```markdown **Synchronous vs. Asynchronous Controller Actions in C# (REST API)**\n\nIn ASP.NET Core (and earlier ASP.NET Web API), controller actions can be written as either synchronous or asynchronous methods. Here’s the difference:\n\n### Synchronous Actions\n\n- **Definition:** The method executes in a blocking manner. The thread processing the request waits until the action completes (e.g., database call, file I/O).\n- **Signature Example:**\n  ```csharp\n  public IActionResult GetData()\n  {\n      var data = _service.GetData();\n      return Ok(data);\n  }\n  ```\n- **Behavior:** The thread is occupied for the entire duration of the operation, which can limit scalability under heavy load.\n\n### Asynchronous Actions\n\n- **Definition:** The method executes in a non-blocking manner using the async/await pattern. The thread can be released back to the thread pool while waiting for I/O operations (like database or network calls) to complete.\n- **Signature Example:**\n  ```csharp\n  public async Task<IActionResult> GetDataAsync()\n  {\n      var data = await _service.GetDataAsync();\n      return Ok(data);\n  }\n  ```\n- **Behavior:** Improves scalability by freeing up threads to handle other requests while waiting for I/O operations.\n\n---\n\n### Key Differences\n\n| Aspect            | Synchronous                          | Asynchronous                       |\n|-------------------|--------------------------------------|------------------------------------|\n| Thread Usage      | Blocks thread until completion       | Frees thread during I/O waits      |\n| Scalability       | Less scalable under heavy load       | More scalable, especially for I/O  |\n| Implementation    | Simple, straightforward              | Requires async/await, Task types   |\n| Use Case          | CPU-bound, quick operations          | I/O-bound, long-running operations |\n\n---\n\n**Summary:**  \nUse asynchronous controller actions when your API performs I/O-bound operations (like database or HTTP calls) to improve scalability and responsiveness. Use synchronous actions for simple, quick, CPU-bound tasks.",
        "level": "Intermediate"
    },
    {
        "id": "89addad0-8564-4ae9-9fb0-fa457d2d6027",
        "question": "How do you implement custom middleware in ASP.NET Core?",
        "answer": "```markdown\nTo implement custom middleware in ASP.NET Core, follow these steps:\n\n1. **Create a Middleware Class**\n\nCreate a class with a constructor that takes a `RequestDelegate` and an `Invoke` method that accepts an `HttpContext`.\n\n```csharp\npublic class CustomMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public CustomMiddleware(RequestDelegate next)\n    {\n        _next = next;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        // Custom logic before next middleware\n        Console.WriteLine(\"Custom Middleware: Before\");\n\n        await _next(context); // Call the next middleware\n\n        // Custom logic after next middleware\n        Console.WriteLine(\"Custom Middleware: After\");\n    }\n}\n```\n\n2. **Register Middleware in the Pipeline**\n\nIn your `Startup.cs` (for .NET 5 and earlier) or `Program.cs` (for .NET 6+), add your middleware to the HTTP request pipeline using `UseMiddleware<T>()`:\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseMiddleware<CustomMiddleware>();\n\n    // Other middleware registrations\n    app.UseRouting();\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllers();\n    });\n}\n```\n\nFor .NET 6+ minimal hosting model:\n\n```csharp\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\napp.UseMiddleware<CustomMiddleware>();\n\napp.MapControllers();\napp.Run();\n```\n\n3. **(Optional) Use Extension Method for Cleaner Registration**\n\nYou can create an extension method for cleaner middleware registration:\n\n```csharp\npublic static class CustomMiddlewareExtensions\n{\n    public static IApplicationBuilder UseCustomMiddleware(this IApplicationBuilder builder)\n    {\n        return builder.UseMiddleware<CustomMiddleware>();\n    }\n}\n```\n\nThen register it as:\n\n```csharp\napp.UseCustomMiddleware();\n```\n\n---\n\n**Summary:**  \n- Create a middleware class with an `Invoke` or `InvokeAsync` method.\n- Register it in the pipeline with `UseMiddleware<T>()` or a custom extension.\n- Add your custom logic before or after calling `_next(context)`.\n\n**References:**  \n- [Official Docs: Write custom ASP.NET Core middleware](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write?view=aspnetcore-7.0)\n```",
        "level": "Intermediate"
    },
    {
        "id": "05046790-9bb1-43bf-9d70-74bfcd284198",
        "question": "How do you implement pagination in a REST API?",
        "answer": "```markdown To implement pagination in a REST API using C#, you typically use query parameters to specify which page of results to return and how many items per page. Here’s a step-by-step guide:\n\n### 1. Define Query Parameters\n\nCommon parameters are:\n\n- `page`: The page number to retrieve (e.g., 1, 2, 3, ...)\n- `pageSize`: The number of items per page\n\nExample request:\n```\nGET /api/products?page=2&pageSize=10\n```\n\n### 2. Update Your Controller\n\nAssume you have an `IQueryable<Product>` from your database. Use `Skip` and `Take` to paginate:\n\n```csharp\n[HttpGet]\npublic async Task<IActionResult> GetProducts(int page = 1, int pageSize = 10)\n{\n    if (page <= 0) page = 1;\n    if (pageSize <= 0) pageSize = 10;\n\n    var totalItems = await _context.Products.CountAsync();\n    var products = await _context.Products\n        .Skip((page - 1) * pageSize)\n        .Take(pageSize)\n        .ToListAsync();\n\n    var result = new\n    {\n        Page = page,\n        PageSize = pageSize,\n        TotalItems = totalItems,\n        TotalPages = (int)Math.Ceiling(totalItems / (double)pageSize),\n        Items = products\n    };\n\n    return Ok(result);\n}\n```\n\n### 3. Return Pagination Metadata\n\nInclude metadata such as `TotalItems` and `TotalPages` in your response to help clients navigate.\n\n### 4. Optional: Add Pagination Links\n\nFor better REST compliance, you can add `next`, `prev`, `first`, and `last` links.\n\n### Example Response\n\n```json\n{\n  \"page\": 2,\n  \"pageSize\": 10,\n  \"totalItems\": 45,\n  \"totalPages\": 5,\n  \"items\": [\n    // Array of products\n  ]\n}\n```\n\n---\n\n**Summary:**  \nUse query parameters for `page` and `pageSize`, apply `Skip` and `Take` in your data query, and return pagination metadata in your API response. This approach is standard for implementing pagination in REST APIs with C#.",
        "level": "Intermediate"
    },
    {
        "id": "fe11c5f3-6801-4ee2-81a8-0b94e2ac1330",
        "question": "How do you implement filtering and sorting in REST API endpoints?",
        "answer": "```markdown\nTo implement filtering and sorting in REST API endpoints using C#, you typically use query parameters to allow clients to specify their filtering and sorting preferences. Here’s how you can achieve this in an ASP.NET Core Web API:\n\n### 1. Define Query Parameters\n\nUse query parameters in your endpoint to accept filtering and sorting options. For example:\n\n```\nGET /api/products?category=electronics&minPrice=100&sortBy=price&sortOrder=desc\n```\n\n### 2. Update the Controller Action\n\nModify your controller action to accept these parameters:\n\n```csharp\n[HttpGet]\npublic async Task<IActionResult> GetProducts(\n    [FromQuery] string category,\n    [FromQuery] decimal? minPrice,\n    [FromQuery] string sortBy = \"name\",\n    [FromQuery] string sortOrder = \"asc\")\n{\n    var products = _context.Products.AsQueryable();\n\n    // Filtering\n    if (!string.IsNullOrEmpty(category))\n    {\n        products = products.Where(p => p.Category == category);\n    }\n    if (minPrice.HasValue)\n    {\n        products = products.Where(p => p.Price >= minPrice.Value);\n    }\n\n    // Sorting\n    products = sortBy.ToLower() switch\n    {\n        \"price\" => sortOrder == \"desc\" ? products.OrderByDescending(p => p.Price) : products.OrderBy(p => p.Price),\n        \"name\" => sortOrder == \"desc\" ? products.OrderByDescending(p => p.Name) : products.OrderBy(p => p.Name),\n        _ => products\n    };\n\n    var result = await products.ToListAsync();\n    return Ok(result);\n}\n```\n\n### 3. Best Practices\n\n- **Validate Inputs:** Ensure that the `sortBy` and `sortOrder` parameters are validated to prevent SQL injection or invalid queries.\n- **Use DTOs:** Return Data Transfer Objects (DTOs) instead of entities for better control over the API response.\n- **Paging:** For large datasets, combine filtering and sorting with pagination.\n\n### 4. Summary\n\n- Use query parameters for filtering and sorting.\n- Apply LINQ queries to filter and sort data in the controller.\n- Always validate and sanitize input parameters.\n\nThis approach makes your REST API endpoints flexible and user-friendly for clients needing customized data retrieval.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "9df888d9-953c-481c-8594-9aa8966b3225",
        "question": "How do you consume a REST API from a C# client?",
        "answer": "```markdown To consume a REST API from a C# client, you typically use the HttpClient class. Here’s a step-by-step example:\n\n```csharp\nusing System;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        // Create HttpClient instance\n        using (HttpClient client = new HttpClient())\n        {\n            // Set base address and headers if needed\n            client.BaseAddress = new Uri(\"https://api.example.com/\");\n            client.DefaultRequestHeaders.Accept.Clear();\n            client.DefaultRequestHeaders.Accept.Add(\n                new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n            // Send GET request\n            HttpResponseMessage response = await client.GetAsync(\"endpoint/resource\");\n            if (response.IsSuccessStatusCode)\n            {\n                // Read response as string or deserialize as needed\n                string data = await response.Content.ReadAsStringAsync();\n                Console.WriteLine(data);\n            }\n            else\n            {\n                Console.WriteLine($\"Error: {response.StatusCode}\");\n            }\n        }\n    }\n}\n```\n\n**Key Steps:**\n\n1. **Create an HttpClient instance** (preferably reuse it for multiple requests).\n2. **Set the BaseAddress and headers** as required by the API.\n3. **Send requests** using methods like `GetAsync`, `PostAsync`, etc.\n4. **Read and process the response**, often deserializing JSON using `System.Text.Json` or `Newtonsoft.Json`.\n\n**Example of deserializing JSON:**\n\n```csharp\nusing System.Text.Json;\n\n// Assuming 'data' is the JSON string from the response\nvar result = JsonSerializer.Deserialize<MyModel>(data);\n```\n\n**Note:**  \n- For POST/PUT requests, use `PostAsync` or `PutAsync` and include content (e.g., `StringContent`).\n- Always handle exceptions and consider using `using` or dependency injection for `HttpClient`.\n\n**References:**\n- [Microsoft Docs: HttpClient](https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpclient)\n- [Consuming a Web API in C#](https://learn.microsoft.com/en-us/aspnet/web-api/overview/advanced/calling-a-web-api-from-a-net-client)",
        "level": "Intermediate"
    },
    {
        "id": "7864a110-b136-4648-8226-9472f2342411",
        "question": "What is the role of the IHttpClientFactory in ASP.NET Core?",
        "answer": "```markdown\nThe `IHttpClientFactory` in ASP.NET Core is a built-in factory for creating and managing instances of `HttpClient`. Its primary roles are:\n\n1. **Centralized Configuration**: It allows you to configure and name different `HttpClient` instances with specific settings (like base addresses, headers, or policies).\n\n2. **Resource Management**: It manages the underlying `HttpMessageHandler` lifetimes, preventing common issues such as socket exhaustion that can occur when `HttpClient` is improperly instantiated.\n\n3. **Dependency Injection**: It integrates with ASP.NET Core's dependency injection system, making it easy to inject properly configured `HttpClient` instances into your services.\n\n4. **Resilience and Policies**: It supports adding resilience policies (like retries, circuit breakers) via libraries such as Polly.\n\n**Example Usage:**\n```csharp\n// Register in Startup.cs or Program.cs\nservices.AddHttpClient();\n\n// Inject and use in a service\npublic class MyService\n{\n    private readonly HttpClient _httpClient;\n\n    public MyService(HttpClient httpClient)\n    {\n        _httpClient = httpClient;\n    }\n\n    public async Task<string> GetDataAsync()\n    {\n        return await _httpClient.GetStringAsync(\"https://api.example.com/data\");\n    }\n}\n```\n\n**Summary:**  \n`IHttpClientFactory` helps you efficiently and safely use `HttpClient` in ASP.NET Core applications by handling configuration, lifetime management, and integration with DI and resilience strategies.\n```",
        "level": "Intermediate"
    },
    {
        "id": "b5240a09-8e40-41c3-b7af-55caada59442",
        "question": "How do you handle file uploads in a REST API?",
        "answer": "```markdown To handle file uploads in a REST API using C#, you typically use the IFormFile interface provided by ASP.NET Core. Here’s a step-by-step guide:\n\n### 1. Define the Controller Action\n\nYou can create an endpoint that accepts file uploads using `[FromForm]` and `IFormFile`. For example:\n\n```csharp\n[HttpPost(\"upload\")]\npublic async Task<IActionResult> UploadFile([FromForm] IFormFile file)\n{\n    if (file == null || file.Length == 0)\n        return BadRequest(\"No file uploaded.\");\n\n    var filePath = Path.Combine(\"Uploads\", file.FileName);\n\n    using (var stream = new FileStream(filePath, FileMode.Create))\n    {\n        await file.CopyToAsync(stream);\n    }\n\n    return Ok(new { file.FileName, file.Length });\n}\n```\n\n### 2. Configure the Request\n\n- The client must send the file as `multipart/form-data`.\n- Example using `curl`:\n\n  ```bash\n  curl -F \"file=@path/to/your/file.txt\" https://yourapi.com/upload\n  ```\n\n### 3. Multiple File Uploads\n\nTo handle multiple files:\n\n```csharp\n[HttpPost(\"upload-multiple\")]\npublic async Task<IActionResult> UploadFiles([FromForm] List<IFormFile> files)\n{\n    foreach (var file in files)\n    {\n        var filePath = Path.Combine(\"Uploads\", file.FileName);\n        using (var stream = new FileStream(filePath, FileMode.Create))\n        {\n            await file.CopyToAsync(stream);\n        }\n    }\n    return Ok(new { count = files.Count });\n}\n```\n\n### 4. Additional Considerations\n\n- **Validation:** Check file size, type, and handle exceptions.\n- **Security:** Store files outside the web root, sanitize file names, and validate content.\n- **Configuration:** Set limits in `Startup.cs` if needed:\n\n  ```csharp\n  services.Configure<FormOptions>(options =>\n  {\n      options.MultipartBodyLengthLimit = 104857600; // 100 MB\n  });\n  ```\n\n### Summary\n\nHandling file uploads in a REST API with C# involves:\n- Using `IFormFile` in controller actions.\n- Accepting files via `multipart/form-data`.\n- Saving files securely on the server.\n- Validating and securing the upload process.\n\n**References:**\n- [ASP.NET Core File Upload Documentation](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/file-uploads)",
        "level": "Intermediate"
    },
    {
        "id": "91be8a94-cfc6-4de0-a26f-4771351ce06e",
        "question": "What is HATEOAS and how can it be implemented in a REST API?",
        "answer": "```markdown\n**HATEOAS (Hypermedia As The Engine Of Application State)** is a constraint of the REST application architecture. It means that a client interacts with a REST API entirely through hypermedia provided dynamically by server responses. In other words, the server provides information about what actions are possible next (links), guiding the client through the application.\n\n### Key Concepts\n\n- **Hypermedia**: Data that contains links to other resources or actions.\n- **Discoverability**: Clients do not need to hard-code URIs; they follow links provided in responses.\n- **Decoupling**: Changes to the API structure are easier to manage, as clients rely on links, not fixed endpoints.\n\n### Example Response with HATEOAS\n\n```json\n{\n  \"id\": 1,\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"links\": [\n    { \"rel\": \"self\", \"href\": \"/api/users/1\" },\n    { \"rel\": \"update\", \"href\": \"/api/users/1\", \"method\": \"PUT\" },\n    { \"rel\": \"delete\", \"href\": \"/api/users/1\", \"method\": \"DELETE\" }\n  ]\n}\n```\n\n### Implementing HATEOAS in C# (ASP.NET Core Example)\n\n1. **Define a Link Model**\n\n```csharp\npublic class Link\n{\n    public string Href { get; set; }\n    public string Rel { get; set; }\n    public string Method { get; set; }\n}\n```\n\n2. **Extend Resource Models**\n\n```csharp\npublic class UserResource\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Email { get; set; }\n    public List<Link> Links { get; set; } = new List<Link>();\n}\n```\n\n3. **Add Links in Controller**\n\n```csharp\n[HttpGet(\"{id}\")]\npublic IActionResult GetUser(int id)\n{\n    var user = _userService.GetById(id);\n    if (user == null) return NotFound();\n\n    var resource = new UserResource\n    {\n        Id = user.Id,\n        Name = user.Name,\n        Email = user.Email\n    };\n\n    resource.Links.Add(new Link\n    {\n        Href = Url.Link(\"GetUser\", new { id = user.Id }),\n        Rel = \"self\",\n        Method = \"GET\"\n    });\n    resource.Links.Add(new Link\n    {\n        Href = Url.Link(\"UpdateUser\", new { id = user.Id }),\n        Rel = \"update\",\n        Method = \"PUT\"\n    });\n    resource.Links.Add(new Link\n    {\n        Href = Url.Link(\"DeleteUser\", new { id = user.Id }),\n        Rel = \"delete\",\n        Method = \"DELETE\"\n    });\n\n    return Ok(resource);\n}\n```\n\n### Benefits\n\n- **Self-descriptive responses**: Clients know what actions are available.\n- **Easier evolution**: APIs can change URLs or add new actions without breaking clients.\n- **Improved navigation**: Clients can traverse the API dynamically.\n\n### Summary\n\nHATEOAS enriches REST APIs by embedding actionable links in responses, enabling clients to discover and interact with resources dynamically. In C#, this is typically implemented by including a collection of links in your resource representations and populating them in your controllers.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "561c3b63-1860-48b9-a4d8-74933a77adbe",
        "question": "How do you implement rate limiting in a REST API?",
        "answer": "```markdown\n### Implementing Rate Limiting in a REST API (C#)\n\nRate limiting is crucial for protecting your REST API from abuse and ensuring fair usage among clients. In C#, especially when using ASP.NET Core, you can implement rate limiting in several ways. Below is an advanced approach using middleware and in-memory caching.\n\n#### 1. Using ASP.NET Core Middleware\n\nYou can create custom middleware to track requests per client (e.g., by IP address or API key) and enforce limits.\n\n##### Example: Custom Rate Limiting Middleware\n\n```csharp\npublic class RateLimitingMiddleware\n{\n    private readonly RequestDelegate _next;\n    private static readonly MemoryCache _cache = new MemoryCache(new MemoryCacheOptions());\n    private readonly int _maxRequests;\n    private readonly TimeSpan _period;\n\n    public RateLimitingMiddleware(RequestDelegate next, int maxRequests, TimeSpan period)\n    {\n        _next = next;\n        _maxRequests = maxRequests;\n        _period = period;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        var key = GetClientKey(context);\n        var counter = _cache.GetOrCreate(key, entry =>\n        {\n            entry.AbsoluteExpirationRelativeToNow = _period;\n            return new RequestCounter();\n        });\n\n        lock (counter)\n        {\n            counter.Count++;\n            if (counter.Count > _maxRequests)\n            {\n                context.Response.StatusCode = StatusCodes.Status429TooManyRequests;\n                context.Response.Headers[\"Retry-After\"] = _period.TotalSeconds.ToString();\n                return;\n            }\n        }\n\n        await _next(context);\n    }\n\n    private string GetClientKey(HttpContext context)\n    {\n        // Use IP address or API key for identification\n        return context.Connection.RemoteIpAddress.ToString();\n    }\n\n    private class RequestCounter\n    {\n        public int Count { get; set; } = 0;\n    }\n}\n```\n\n##### Register Middleware in `Startup.cs`\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseMiddleware<RateLimitingMiddleware>(100, TimeSpan.FromMinutes(1)); // 100 requests per minute\n    // ... other middleware\n}\n```\n\n#### 2. Using Third-Party Libraries\n\nLibraries like [AspNetCoreRateLimit](https://github.com/stefanprodan/AspNetCoreRateLimit) provide robust and configurable rate limiting features, including support for distributed caches (e.g., Redis).\n\n##### Example: Using AspNetCoreRateLimit\n\n1. Install the NuGet package:\n   ```\n   dotnet add package AspNetCoreRateLimit\n   ```\n\n2. Configure in `Startup.cs`:\n\n   ```csharp\n   public void ConfigureServices(IServiceCollection services)\n   {\n       services.AddMemoryCache();\n       services.Configure<IpRateLimitOptions>(Configuration.GetSection(\"IpRateLimiting\"));\n       services.AddInMemoryRateLimiting();\n       services.AddSingleton<IRateLimitConfiguration, RateLimitConfiguration>();\n       // ... other services\n   }\n\n   public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n   {\n       app.UseIpRateLimiting();\n       // ... other middleware\n   }\n   ```\n\n3. Add configuration in `appsettings.json`:\n\n   ```json\n   \"IpRateLimiting\": {\n     \"EnableEndpointRateLimiting\": true,\n     \"StackBlockedRequests\": false,\n     \"RealIpHeader\": \"X-Real-IP\",\n     \"ClientIdHeader\": \"X-ClientId\",\n     \"HttpStatusCode\": 429,\n     \"GeneralRules\": [\n       {\n         \"Endpoint\": \"*\",\n         \"Period\": \"1m\",\n         \"Limit\": 100\n       }\n     ]\n   }\n   ```\n\n#### 3. Best Practices\n\n- **Identify clients**: Use API keys, user IDs, or IP addresses.\n- **Store counters**: Use distributed caches (e.g., Redis) for scalability.\n- **Return proper headers**: Inform clients about rate limits and retry times.\n- **Customize per endpoint**: Allow different limits for different API routes.\n\n#### 4. References\n\n- [Microsoft Docs: Middleware in ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/)\n- [AspNetCoreRateLimit GitHub](https://github.com/stefanprodan/AspNetCoreRateLimit)\n\n---\n\n**Summary:**  \nImplement rate limiting in C# REST APIs using custom middleware or third-party libraries like AspNetCoreRateLimit. Always identify clients, store counters efficiently, and inform clients of their limits.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "610ce6cd-e6f4-48cf-9abd-47df533eed46",
        "question": "What are best practices for securing sensitive data in REST API responses?",
        "answer": "```markdown **Best Practices for Securing Sensitive Data in REST API Responses (C#)**\n\n1. **Never Expose Sensitive Fields**\n   - Exclude fields like passwords, tokens, credit card numbers, or internal IDs from API responses.\n   - Use DTOs (Data Transfer Objects) or ViewModels to control exactly what data is serialized and returned.\n\n2. **Use Strong Authentication & Authorization**\n   - Implement OAuth2, JWT, or other secure authentication mechanisms.\n   - Ensure endpoints only return data to authorized users (e.g., using `[Authorize]` attributes in ASP.NET Core).\n\n3. **Encrypt Sensitive Data**\n   - If sensitive data must be transmitted, use HTTPS (TLS) to encrypt data in transit.\n   - For extra protection, encrypt sensitive fields before sending and decrypt on the client as needed.\n\n4. **Data Masking**\n   - Mask sensitive information (e.g., show only last 4 digits of a credit card).\n   - Example:\n     ```csharp\n     public string MaskCardNumber(string cardNumber)\n     {\n         return $\"****-****-****-{cardNumber.Substring(cardNumber.Length - 4)}\";\n     }\n     ```\n\n5. **Avoid Over-Posting and Over-Fetching**\n   - Use explicit models for responses rather than exposing your domain entities directly.\n   - Use tools like AutoMapper to map only required fields.\n\n6. **Implement Output Validation & Filtering**\n   - Validate and sanitize all data before returning it to prevent injection attacks or data leaks.\n   - Use response filters or middleware to inspect and clean outgoing data.\n\n7. **Audit and Log Access**\n   - Log access to sensitive endpoints and data, but never log sensitive data itself.\n   - Monitor logs for suspicious activity.\n\n8. **Version Your API**\n   - Versioning helps you deprecate insecure or outdated endpoints without affecting all clients.\n\n9. **Rate Limiting & Throttling**\n   - Prevent abuse and brute-force attacks by limiting the number of requests per user/IP.\n\n10. **Content Security Policy (CSP) & CORS**\n    - Configure CORS to only allow trusted domains.\n    - Use CSP headers to prevent data exfiltration via malicious scripts.\n\n**Example: Using DTOs in ASP.NET Core**\n\n```csharp\npublic class UserDto\n{\n    public string Username { get; set; }\n    public string Email { get; set; }\n    // Do not include Password or other sensitive fields\n}\n\n// In your controller:\n[HttpGet(\"{id}\")]\npublic async Task<ActionResult<UserDto>> GetUser(int id)\n{\n    var user = await _context.Users.FindAsync(id);\n    if (user == null) return NotFound();\n\n    var userDto = new UserDto\n    {\n        Username = user.Username,\n        Email = user.Email\n    };\n    return Ok(userDto);\n}\n```\n\n**Summary Table**\n\n| Practice                      | Description                                      |\n|-------------------------------|--------------------------------------------------|\n| Exclude sensitive fields      | Use DTOs/ViewModels, never expose raw entities   |\n| Strong authentication         | OAuth2, JWT, ASP.NET `[Authorize]`               |\n| Encrypt data                  | Always use HTTPS, encrypt sensitive fields       |\n| Data masking                  | Mask or partially display sensitive info         |\n| Output validation/filtering   | Sanitize and validate outgoing data              |\n| Logging & auditing            | Log access, not sensitive data                   |\n| API versioning                | Deprecate insecure endpoints                     |\n| Rate limiting                 | Prevent abuse and brute-force attacks            |\n| CORS & CSP                    | Restrict access to trusted domains               |\n\n**References:**\n- [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)\n- [Microsoft Docs: Secure ASP.NET Core Web APIs](https://learn.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-7.0)",
        "level": "Advanced"
    },
    {
        "id": "3dbf95f8-7278-4b01-8d6b-3d68104407c0",
        "question": "How do you implement caching in a REST API?",
        "answer": "```markdown\n### Implementing Caching in a REST API (C#)\n\nCaching is a crucial technique to improve the performance and scalability of REST APIs. In C#, especially when using ASP.NET Core, you can implement caching at various levels:\n\n---\n\n#### 1. **HTTP Cache Headers**\n\nSet appropriate HTTP headers to enable client-side and proxy caching.\n\n```csharp\n[HttpGet]\n[ResponseCache(Duration = 60, Location = ResponseCacheLocation.Client)]\npublic IActionResult GetResource()\n{\n    var data = _service.GetData();\n    return Ok(data);\n}\n```\n- `Duration`: Cache duration in seconds.\n- `Location`: Where the response can be cached (Client, Any, None).\n\n---\n\n#### 2. **In-Memory Caching**\n\nUse `IMemoryCache` for server-side caching of frequently accessed data.\n\n**Register in Startup:**\n```csharp\nservices.AddMemoryCache();\n```\n\n**Usage in Controller:**\n```csharp\nprivate readonly IMemoryCache _cache;\n\npublic MyController(IMemoryCache cache)\n{\n    _cache = cache;\n}\n\n[HttpGet]\npublic IActionResult GetResource()\n{\n    var cacheKey = \"resource_key\";\n    if (!_cache.TryGetValue(cacheKey, out MyResource resource))\n    {\n        resource = _service.GetData();\n        var cacheEntryOptions = new MemoryCacheEntryOptions()\n            .SetSlidingExpiration(TimeSpan.FromMinutes(5));\n        _cache.Set(cacheKey, resource, cacheEntryOptions);\n    }\n    return Ok(resource);\n}\n```\n\n---\n\n#### 3. **Distributed Caching**\n\nFor scalability across multiple servers, use distributed cache (e.g., Redis).\n\n**Register in Startup:**\n```csharp\nservices.AddStackExchangeRedisCache(options =>\n{\n    options.Configuration = \"localhost:6379\";\n});\n```\n\n**Usage in Controller:**\n```csharp\nprivate readonly IDistributedCache _cache;\n\npublic MyController(IDistributedCache cache)\n{\n    _cache = cache;\n}\n\n[HttpGet]\npublic async Task<IActionResult> GetResource()\n{\n    var cacheKey = \"resource_key\";\n    var cachedData = await _cache.GetStringAsync(cacheKey);\n    if (cachedData == null)\n    {\n        var resource = _service.GetData();\n        cachedData = JsonConvert.SerializeObject(resource);\n        await _cache.SetStringAsync(cacheKey, cachedData, new DistributedCacheEntryOptions\n        {\n            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)\n        });\n    }\n    var result = JsonConvert.DeserializeObject<MyResource>(cachedData);\n    return Ok(result);\n}\n```\n\n---\n\n#### 4. **ETag and Conditional Requests**\n\nImplement ETag headers to allow clients to cache and validate resources.\n\n```csharp\n[HttpGet]\npublic IActionResult GetResource()\n{\n    var resource = _service.GetData();\n    var eTag = GenerateETag(resource);\n\n    if (Request.Headers[\"If-None-Match\"] == eTag)\n        return StatusCode(304); // Not Modified\n\n    Response.Headers[\"ETag\"] = eTag;\n    return Ok(resource);\n}\n```\n---\n\n### **Best Practices**\n- Cache only safe (idempotent) GET requests.\n- Invalidate or update cache when underlying data changes.\n- Use appropriate cache durations and eviction policies.\n- Consider security and privacy when caching sensitive data.\n\n---\n\nBy combining these techniques, you can significantly improve the performance and scalability of your REST API in C#.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "ee21751a-82c4-4d03-a192-2e4fdebe2c1f",
        "question": "How do you handle long-running operations in a REST API?",
        "answer": "```markdown\nHandling long-running operations in a REST API (C#)\n\nLong-running operations in REST APIs can cause timeouts and poor user experience if handled synchronously. In C#, the recommended approach is to implement an asynchronous pattern, often called the **\"asynchronous request-response\"** or **\"polling pattern\"**. Here’s how you can handle such scenarios:\n\n### 1. Accept the Request and Return 202 Accepted\n\n- When a client initiates a long-running operation (e.g., POST /process-data), immediately return a `202 Accepted` status code.\n- Include a `Location` header in the response, pointing to a status endpoint (e.g., `/operations/{operationId}`).\n\n```csharp\n[HttpPost(\"process-data\")]\npublic IActionResult ProcessData([FromBody] DataModel model)\n{\n    var operationId = Guid.NewGuid().ToString();\n    // Start background processing (e.g., via a queue or hosted service)\n    _operationService.StartOperation(operationId, model);\n\n    return AcceptedAtAction(nameof(GetOperationStatus), new { operationId }, null);\n}\n```\n\n### 2. Provide a Status Endpoint\n\n- Implement a GET endpoint to check the status of the operation.\n\n```csharp\n[HttpGet(\"operations/{operationId}\")]\npublic IActionResult GetOperationStatus(string operationId)\n{\n    var status = _operationService.GetStatus(operationId);\n    if (status == null)\n        return NotFound();\n\n    return Ok(status); // status can include progress, result, or error info\n}\n```\n\n### 3. Background Processing\n\n- Use background services (e.g., `IHostedService`, queues, or Hangfire) to process the operation asynchronously.\n\n```csharp\npublic class OperationService : IOperationService\n{\n    // Store operation status in a thread-safe store (e.g., ConcurrentDictionary)\n    public void StartOperation(string operationId, DataModel model)\n    {\n        // Enqueue or start background task\n    }\n\n    public OperationStatus GetStatus(string operationId)\n    {\n        // Return current status\n    }\n}\n```\n\n### 4. Notify Client When Done (Optional)\n\n- For advanced scenarios, implement **webhooks** or **SignalR** to notify clients when the operation completes.\n\n### 5. Considerations\n\n- **Timeouts:** Ensure the background task does not block the request thread.\n- **Idempotency:** Make sure repeated requests with the same input do not trigger duplicate processing.\n- **Security:** Validate operation IDs and user permissions.\n\n### References\n\n- [Microsoft REST API Guidelines: Long-Running Operations](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md#1316-long-running-operations)\n- [Asynchronous Request-Reply Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/async-request-reply)\n\n---\n\n**Summary:**  \nHandle long-running operations by returning `202 Accepted` with a status endpoint, processing the task in the background, and allowing clients to poll for completion or receive notifications.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "c2ad3f4e-0a73-48aa-a0c2-a235b3432118",
        "question": "What are the differences between REST and gRPC in C#?",
        "answer": "```markdown\n### Differences Between REST and gRPC in C#\n\n| Aspect                | REST (with C#)                                      | gRPC (with C#)                                   |\n|-----------------------|-----------------------------------------------------|--------------------------------------------------|\n| **Protocol**          | HTTP/HTTPS (usually 1.1)                            | HTTP/2                                           |\n| **Data Format**       | JSON, XML, or other text-based formats              | Protocol Buffers (binary, strongly typed)        |\n| **Performance**       | Slower due to text parsing and larger payloads      | Faster due to binary serialization and HTTP/2    |\n| **Contract**          | No strict contract; uses OpenAPI/Swagger optionally | Strongly typed via .proto files                  |\n| **Streaming**         | Limited (Server-Sent Events, WebSockets)            | Native support for client, server, and bidirectional streaming |\n| **Tooling**           | Mature, widely supported                            | Good tooling, but requires code generation       |\n| **Browser Support**   | Natively supported                                  | Limited (no direct browser support)              |\n| **Error Handling**    | HTTP status codes                                   | gRPC status codes (mapped to exceptions)         |\n| **Use Case**          | Public APIs, web applications                       | Microservices, internal APIs, high-performance needs |\n| **Versioning**        | URL or header-based                                 | Handled via .proto evolution rules               |\n| **C# Implementation** | ASP.NET Core Web API                                | gRPC for .NET (Grpc.AspNetCore)                  |\n\n#### Summary\n\n- **REST** is ideal for interoperability, public APIs, and scenarios where human readability and browser compatibility are important.\n- **gRPC** excels in high-performance, low-latency, and strongly-typed internal service communication, especially in microservices architectures.\n\n**Example:**\n- REST: `[HttpGet(\"/users/{id}\")]` returns JSON.\n- gRPC: `rpc GetUser (GetUserRequest) returns (UserResponse);` uses Protocol Buffers.\n\n> **Note:** In C#, both REST and gRPC can be implemented using ASP.NET Core, but gRPC requires additional setup for .proto files and code generation.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "8ae6c4f9-8d94-4118-a151-cb5bef043909",
        "question": "How do you implement custom authentication schemes in ASP.NET Core?",
        "answer": "```markdown To implement custom authentication schemes in ASP.NET Core, you typically create a custom authentication handler by inheriting from `AuthenticationHandler<TOptions>`, register your scheme in `Startup.cs` (or `Program.cs` in .NET 6+), and configure your authentication logic. Here’s a step-by-step guide:\n\n---\n\n## 1. Create Custom Authentication Options\n\n```csharp\npublic class CustomAuthOptions : AuthenticationSchemeOptions\n{\n    // Add custom options if needed\n}\n```\n\n---\n\n## 2. Implement the Authentication Handler\n\n```csharp\npublic class CustomAuthHandler : AuthenticationHandler<CustomAuthOptions>\n{\n    public CustomAuthHandler(\n        IOptionsMonitor<CustomAuthOptions> options,\n        ILoggerFactory logger,\n        UrlEncoder encoder,\n        ISystemClock clock)\n        : base(options, logger, encoder, clock)\n    { }\n\n    protected override async Task<AuthenticateResult> HandleAuthenticateAsync()\n    {\n        // Example: Extract token from header\n        var authHeader = Request.Headers[\"Authorization\"].FirstOrDefault();\n        if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith(\"CustomScheme \"))\n        {\n            return AuthenticateResult.Fail(\"Invalid Authorization Header\");\n        }\n\n        var token = authHeader.Substring(\"CustomScheme \".Length).Trim();\n\n        // Validate the token (implement your logic)\n        if (token != \"expected-token\")\n        {\n            return AuthenticateResult.Fail(\"Invalid Token\");\n        }\n\n        // Create authenticated user\n        var claims = new[] { new Claim(ClaimTypes.Name, \"CustomUser\") };\n        var identity = new ClaimsIdentity(claims, Scheme.Name);\n        var principal = new ClaimsPrincipal(identity);\n        var ticket = new AuthenticationTicket(principal, Scheme.Name);\n\n        return AuthenticateResult.Success(ticket);\n    }\n}\n```\n\n---\n\n## 3. Register the Custom Scheme\n\n**.NET 6+ (Program.cs):**\n\n```csharp\nbuilder.Services.AddAuthentication(\"CustomScheme\")\n    .AddScheme<CustomAuthOptions, CustomAuthHandler>(\"CustomScheme\", options => { });\n```\n\n**ASP.NET Core 3.1/5 (Startup.cs):**\n\n```csharp\nservices.AddAuthentication(\"CustomScheme\")\n    .AddScheme<CustomAuthOptions, CustomAuthHandler>(\"CustomScheme\", options => { });\n```\n\n---\n\n## 4. Configure Authentication Middleware\n\n```csharp\napp.UseAuthentication();\napp.UseAuthorization();\n```\n\n---\n\n## 5. Protect Endpoints\n\n```csharp\n[Authorize(AuthenticationSchemes = \"CustomScheme\")]\n[ApiController]\n[Route(\"[controller]\")]\npublic class SecureController : ControllerBase\n{\n    [HttpGet]\n    public IActionResult Get() => Ok(\"You are authenticated!\");\n}\n```\n\n---\n\n## Summary\n\n- **Create** custom options and handler.\n- **Register** the scheme in DI.\n- **Configure** authentication middleware.\n- **Protect** endpoints with `[Authorize]`.\n\n**References:**\n- [Microsoft Docs: Custom authentication in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-auth-handler)\n- [Authentication and Authorization in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/)\n\n---\n\n**Note:** Replace the token validation logic with your actual authentication mechanism (e.g., database lookup, external service, etc.).",
        "level": "Advanced"
    },
    {
        "id": "c7831933-a28a-4fb4-8ea5-d51bfe414fa7",
        "question": "How can you ensure idempotency in REST API operations?",
        "answer": "```markdown To ensure **idempotency** in REST API operations using C#, you need to design your API so that making the same request multiple times has the same effect as making it once. This is especially important for operations like POST (typically non-idempotent), where duplicate submissions (e.g., due to network retries) could cause unintended side effects.\n\n### Key Strategies for Ensuring Idempotency\n\n#### 1. Use Idempotent HTTP Methods\n- **GET, PUT, DELETE, and HEAD** are inherently idempotent by HTTP specification.\n- **POST** is not idempotent by default, so extra care is needed.\n\n#### 2. Idempotency Keys for POST Requests\n- Require clients to send a unique `Idempotency-Key` header with each request.\n- On the server, store the result of the first request with that key.\n- For subsequent requests with the same key, return the stored result instead of processing again.\n\n**Example Implementation in C#:**\n\n```csharp\n[HttpPost]\npublic async Task<IActionResult> CreateOrder([FromBody] OrderDto order, [FromHeader(Name = \"Idempotency-Key\")] string idempotencyKey)\n{\n    if (string.IsNullOrEmpty(idempotencyKey))\n        return BadRequest(\"Idempotency-Key header is required.\");\n\n    var existing = await _idempotencyStore.GetResultAsync(idempotencyKey);\n    if (existing != null)\n        return Ok(existing);\n\n    var result = await _orderService.CreateOrderAsync(order);\n\n    await _idempotencyStore.SaveResultAsync(idempotencyKey, result);\n\n    return Ok(result);\n}\n```\n\n#### 3. Resource-Oriented Design\n- Use **PUT** for creating/updating resources at a known URI (e.g., `/users/123`), which is idempotent by nature.\n- Example: Repeatedly sending the same PUT request to `/users/123` with the same data will not create duplicate users.\n\n#### 4. Database Constraints\n- Enforce uniqueness at the database level (e.g., unique indexes) to prevent duplicate records.\n\n#### 5. Safe Retry Logic\n- Ensure that retrying a failed request (due to timeout, etc.) does not cause unintended side effects.\n\n### Summary Table\n\n| HTTP Method | Idempotent by Default? | How to Ensure Idempotency |\n|-------------|-----------------------|---------------------------|\n| GET         | Yes                   | No action needed          |\n| PUT         | Yes                   | Use resource URI          |\n| DELETE      | Yes                   | No action needed          |\n| POST        | No                    | Use Idempotency-Key       |\n\n---\n\n**References:**\n- [Idempotency in REST APIs (Microsoft Docs)](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design#idempotency)\n- [RFC 7231 - HTTP/1.1 Semantics and Content](https://tools.ietf.org/html/rfc7231#section-4.2.2)\n\n---\n\n**In summary:**  \nTo ensure idempotency in REST API operations in C#, use idempotent HTTP methods where possible, implement idempotency keys for POST requests, design your resources carefully, and enforce uniqueness at the data layer. This protects your API from unintended side effects due to duplicate or retried requests.",
        "level": "Advanced"
    },
    {
        "id": "9b6dfd42-654d-4cbb-91a8-6766a571c039",
        "question": "What are the common security vulnerabilities in REST APIs and how do you prevent them?",
        "answer": "```markdown\n## Common Security Vulnerabilities in REST APIs and Their Prevention (C#)\n\nREST APIs are susceptible to various security vulnerabilities. Here are some of the most common ones and strategies to prevent them, particularly in a C# (ASP.NET Core) context:\n\n---\n\n### 1. **Broken Authentication**\n- **Vulnerability:** Attackers can compromise authentication tokens or credentials to impersonate users.\n- **Prevention:**\n  - Use strong authentication mechanisms (e.g., OAuth 2.0, OpenID Connect).\n  - Store passwords securely using hashing algorithms like BCrypt.\n  - Implement token expiration and rotation.\n  - Use HTTPS to protect credentials in transit.\n\n---\n\n### 2. **Sensitive Data Exposure**\n- **Vulnerability:** Sensitive data (e.g., passwords, tokens, personal information) is exposed in requests, responses, or logs.\n- **Prevention:**\n  - Always use HTTPS.\n  - Avoid returning sensitive data in API responses.\n  - Encrypt sensitive data at rest and in transit.\n  - Mask sensitive fields in logs.\n\n---\n\n### 3. **Injection Attacks (e.g., SQL Injection)**\n- **Vulnerability:** Unsanitized input is used in database queries or commands.\n- **Prevention:**\n  - Use parameterized queries or ORM frameworks like Entity Framework.\n  - Validate and sanitize all user inputs.\n  - Avoid dynamic SQL where possible.\n\n---\n\n### 4. **Lack of Rate Limiting**\n- **Vulnerability:** APIs are susceptible to brute-force attacks or denial of service.\n- **Prevention:**\n  - Implement rate limiting using middleware (e.g., [AspNetCoreRateLimit](https://github.com/stefanprodan/AspNetCoreRateLimit)).\n  - Monitor and block suspicious activity.\n\n---\n\n### 5. **Broken Access Control**\n- **Vulnerability:** Users can access or modify resources they shouldn't.\n- **Prevention:**\n  - Enforce authorization checks on every endpoint (e.g., `[Authorize]` attribute in ASP.NET Core).\n  - Use claims-based or role-based access control.\n  - Never rely solely on client-side checks.\n\n---\n\n### 6. **Cross-Site Request Forgery (CSRF)**\n- **Vulnerability:** Attackers trick users into making unwanted requests.\n- **Prevention:**\n  - For APIs intended for browsers, implement anti-CSRF tokens.\n  - Use the `SameSite` cookie attribute.\n\n---\n\n### 7. **Improper Error Handling**\n- **Vulnerability:** Detailed error messages reveal sensitive information.\n- **Prevention:**\n  - Return generic error messages to clients.\n  - Log detailed errors server-side only.\n\n---\n\n### 8. **Insecure Deserialization**\n- **Vulnerability:** Malicious payloads can exploit deserialization logic.\n- **Prevention:**\n  - Avoid deserializing untrusted data.\n  - Use safe serialization libraries.\n  - Validate input before deserialization.\n\n---\n\n### 9. **Security Misconfiguration**\n- **Vulnerability:** Default configurations, unnecessary features, or verbose headers.\n- **Prevention:**\n  - Disable unused HTTP methods (e.g., PUT, DELETE if not needed).\n  - Remove or restrict access to development/debug endpoints.\n  - Set secure HTTP headers (e.g., `X-Content-Type-Options`, `Strict-Transport-Security`).\n\n---\n\n## **Best Practices in C# (ASP.NET Core)**\n- Use `[Authorize]` and `[ValidateAntiForgeryToken]` attributes.\n- Configure CORS policies strictly.\n- Keep dependencies and frameworks up to date.\n- Regularly perform security testing and code reviews.\n\n---\n\n**References:**\n- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)\n- [Microsoft: Secure a Web API](https://learn.microsoft.com/en-us/aspnet/core/security/?view=aspnetcore-7.0)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "1a9235ec-cc0c-482a-a396-41dd56669ebe",
        "question": "How do you implement global exception handling in ASP.NET Core?",
        "answer": "```markdown\n### Implementing Global Exception Handling in ASP.NET Core\n\nGlobal exception handling in ASP.NET Core is typically achieved using **middleware**. This ensures that unhandled exceptions are caught and processed in a consistent way across your entire API.\n\n#### 1. Create a Custom Exception Middleware\n\n```csharp\npublic class ExceptionMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogger<ExceptionMiddleware> _logger;\n    private readonly IHostEnvironment _env;\n\n    public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger, IHostEnvironment env)\n    {\n        _next = next;\n        _logger = logger;\n        _env = env;\n    }\n\n    public async Task InvokeAsync(HttpContext httpContext)\n    {\n        try\n        {\n            await _next(httpContext);\n        }\n        catch (Exception ex)\n        {\n            _logger.LogError(ex, ex.Message);\n            await HandleExceptionAsync(httpContext, ex);\n        }\n    }\n\n    private Task HandleExceptionAsync(HttpContext context, Exception exception)\n    {\n        context.Response.ContentType = \"application/json\";\n        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;\n\n        var response = _env.IsDevelopment()\n            ? new { message = exception.Message, stackTrace = exception.StackTrace }\n            : new { message = \"Internal Server Error\" };\n\n        return context.Response.WriteAsync(JsonSerializer.Serialize(response));\n    }\n}\n```\n\n#### 2. Register the Middleware in the Pipeline\n\nIn your `Startup.cs` (ASP.NET Core 3.1/5) or `Program.cs` (ASP.NET Core 6+):\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseMiddleware<ExceptionMiddleware>();\n    // ... other middleware registrations\n}\n```\n\n#### 3. (Optional) Use Built-in Exception Handler\n\nASP.NET Core also provides a built-in exception handler:\n\n```csharp\napp.UseExceptionHandler(errorApp =>\n{\n    errorApp.Run(async context =>\n    {\n        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;\n        context.Response.ContentType = \"application/json\";\n        var contextFeature = context.Features.Get<IExceptionHandlerFeature>();\n        if (contextFeature != null)\n        {\n            await context.Response.WriteAsync(JsonSerializer.Serialize(new\n            {\n                message = \"Internal Server Error\"\n            }));\n        }\n    });\n});\n```\n\n#### 4. Benefits\n\n- **Centralized error handling**: All unhandled exceptions are processed in one place.\n- **Consistent error responses**: Clients receive uniform error messages.\n- **Logging**: Exceptions can be logged globally.\n\n#### 5. References\n\n- [Official Docs: Exception handling in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "e9bc20dc-dab2-4c20-9bad-3d5640944b16",
        "question": "How do you perform integration testing for REST APIs in C#?",
        "answer": "```markdown\n### Performing Integration Testing for REST APIs in C#\n\nIntegration testing for REST APIs in C# typically involves testing the API endpoints as a whole, including their interaction with databases and other services. Here’s a step-by-step approach using popular tools and frameworks:\n\n#### 1. **Use the Right Testing Frameworks**\n- **xUnit**, **NUnit**, or **MSTest** for test orchestration.\n- **Microsoft.AspNetCore.Mvc.Testing** for bootstrapping the API in-memory.\n- **FluentAssertions** or **Shouldly** for expressive assertions.\n- **HttpClient** for sending HTTP requests.\n\n#### 2. **Set Up the Test Project**\n- Create a separate test project (e.g., `MyApi.IntegrationTests`).\n- Reference your API project and necessary NuGet packages.\n\n```bash\ndotnet add package Microsoft.AspNetCore.Mvc.Testing\ndotnet add package xunit\ndotnet add package FluentAssertions\n```\n\n#### 3. **Configure WebApplicationFactory**\nUse `WebApplicationFactory<TEntryPoint>` to spin up your API in-memory for testing.\n\n```csharp\npublic class CustomWebApplicationFactory<TStartup>\n    : WebApplicationFactory<TStartup> where TStartup : class\n{\n    protected override void ConfigureWebHost(IWebHostBuilder builder)\n    {\n        builder.ConfigureServices(services =>\n        {\n            // Optionally replace services, e.g., use in-memory DB\n        });\n    }\n}\n```\n\n#### 4. **Write Integration Tests**\n\n```csharp\npublic class MyApiIntegrationTests : IClassFixture<CustomWebApplicationFactory<Program>>\n{\n    private readonly HttpClient _client;\n\n    public MyApiIntegrationTests(CustomWebApplicationFactory<Program> factory)\n    {\n        _client = factory.CreateClient();\n    }\n\n    [Fact]\n    public async Task Get_Endpoint_ReturnsSuccessAndExpectedContent()\n    {\n        // Arrange\n        var url = \"/api/values\";\n\n        // Act\n        var response = await _client.GetAsync(url);\n\n        // Assert\n        response.EnsureSuccessStatusCode();\n        var content = await response.Content.ReadAsStringAsync();\n        content.Should().Contain(\"expected value\");\n    }\n}\n```\n\n#### 5. **Mock or Use In-Memory Databases**\n- Use **InMemoryDatabase** (e.g., with Entity Framework Core) to avoid hitting production databases.\n- Override configuration in `ConfigureWebHost`.\n\n#### 6. **Test Various Scenarios**\n- Test all endpoints (GET, POST, PUT, DELETE).\n- Test with valid and invalid data.\n- Test authentication/authorization if applicable.\n\n#### 7. **Run Tests Automatically**\n- Integrate with CI/CD pipelines for automated testing.\n\n---\n\n**References:**\n- [Microsoft Docs: Integration tests in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/test/integration-tests)\n- [xUnit Documentation](https://xunit.net/docs/getting-started/netcore/cmdline)\n\n---\n```",
        "level": "Advanced"
    },
    {
        "id": "0f720820-03be-40e2-8823-d576114554bb",
        "question": "What is OpenAPI and how does it relate to REST APIs in C#?",
        "answer": "```markdown **OpenAPI** is a specification for describing and documenting RESTful APIs in a standardized, machine-readable format (usually YAML or JSON). Formerly known as Swagger, OpenAPI allows developers to define the endpoints, request/response types, authentication methods, and other aspects of an API in a way that both humans and computers can understand.\n\n### How OpenAPI Relates to REST APIs in C#\n\n- **API Documentation:** In C#, especially with ASP.NET Core, you can use tools like [Swashbuckle](https://github.com/domaindrivendev/Swashbuckle.AspNetCore) or [NSwag](https://github.com/RicoSuter/NSwag) to automatically generate OpenAPI (Swagger) documentation from your REST API controllers and models.\n- **Client Generation:** OpenAPI definitions can be used to auto-generate strongly-typed C# client libraries, making it easier to consume APIs with less manual coding.\n- **Contract-First Development:** You can design your API using an OpenAPI specification first, then generate C# server stubs to implement the API, ensuring consistency between documentation and implementation.\n- **Interactive Testing:** Tools like Swagger UI (integrated via Swashbuckle) provide interactive web pages to explore and test your C# REST API endpoints directly from the browser.\n\n### Example Workflow in C#\n\n1. **Annotate Controllers:** Use attributes in your ASP.NET Core controllers and models.\n2. **Generate OpenAPI Spec:** Swashbuckle or NSwag scans your code and produces an OpenAPI document (`swagger.json`).\n3. **Serve Documentation:** The OpenAPI document can be served with Swagger UI for interactive documentation.\n4. **Client/Server Generation:** Use the OpenAPI spec to generate C# clients or server stubs as needed.\n\n### Summary Table\n\n| Feature                | OpenAPI Role in C# REST APIs                  |\n|------------------------|-----------------------------------------------|\n| Documentation          | Auto-generates interactive API docs           |\n| Client Generation      | Produces C# clients from API definitions      |\n| Server Stubs           | Generates C# server code from OpenAPI specs   |\n| Testing                | Enables in-browser testing via Swagger UI     |\n\n**In summary:**  \nOpenAPI is a crucial standard for describing REST APIs, and in C# (especially with ASP.NET Core), it streamlines API documentation, testing, and code generation, improving both developer experience and API reliability.",
        "level": "Advanced"
    },
    {
        "id": "33135de2-6e37-4868-bb4b-0a2216f4dcd3",
        "question": "How do you implement role-based authorization in a REST API?",
        "answer": "```markdown\nTo implement role-based authorization in a REST API using C#, you typically use ASP.NET Core's built-in authentication and authorization features. Here’s a step-by-step approach:\n\n### 1. Define Roles\n\nDecide on the roles your application will use (e.g., `Admin`, `User`, `Manager`).\n\n### 2. Configure Authentication\n\nSet up authentication (e.g., JWT Bearer authentication) in `Startup.cs` or `Program.cs`:\n\n```csharp\nservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n    .AddJwtBearer(options =>\n    {\n        options.TokenValidationParameters = new TokenValidationParameters\n        {\n            // Configure token validation parameters\n        };\n    });\n```\n\n### 3. Add Authorization Policies (Optional)\n\nYou can define policies for more granular control:\n\n```csharp\nservices.AddAuthorization(options =>\n{\n    options.AddPolicy(\"RequireAdminRole\", policy => policy.RequireRole(\"Admin\"));\n});\n```\n\n### 4. Decorate Controllers or Actions with `[Authorize]`\n\nUse the `[Authorize]` attribute to restrict access based on roles:\n\n```csharp\n[Authorize(Roles = \"Admin\")]\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class AdminController : ControllerBase\n{\n    // Only accessible by users with the 'Admin' role\n    [HttpGet]\n    public IActionResult GetAdminData()\n    {\n        return Ok(\"This is admin data.\");\n    }\n}\n```\n\nYou can also use policies:\n\n```csharp\n[Authorize(Policy = \"RequireAdminRole\")]\n[HttpGet(\"secure-data\")]\npublic IActionResult GetSecureData()\n{\n    return Ok(\"Only admins can see this.\");\n}\n```\n\n### 5. Assign Roles to Users\n\nWhen issuing JWT tokens, include the user's roles in the claims:\n\n```csharp\nvar claims = new List<Claim>\n{\n    new Claim(ClaimTypes.Name, user.UserName),\n    new Claim(ClaimTypes.Role, \"Admin\")\n    // Add more roles as needed\n};\n```\n\n### 6. Test the API\n\nWhen a request is made to a role-protected endpoint, ASP.NET Core will automatically check the user's roles from the token and allow or deny access.\n\n---\n\n**Summary Table**\n\n| Step                          | Description                                      |\n|-------------------------------|--------------------------------------------------|\n| Define Roles                  | Decide on roles (e.g., Admin, User)              |\n| Configure Authentication      | Set up JWT or other authentication               |\n| Add Authorization Policies    | (Optional) Define custom policies                |\n| Use `[Authorize]` Attribute   | Restrict controllers/actions by role/policy      |\n| Assign Roles in JWT Claims    | Add roles to user claims in the token            |\n| Test                          | Ensure endpoints are secured as expected         |\n\n---\n\n**References:**\n- [Microsoft Docs: Role-based authorization in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/roles)\n- [Microsoft Docs: Authentication and authorization in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "1991c1d8-27ee-433b-9b09-f90547e23af0",
        "question": "How do you handle circular references in JSON serialization?",
        "answer": "```markdown\n### Handling Circular References in JSON Serialization in C#\n\nCircular references occur when two or more objects reference each other, causing infinite loops during serialization. In C#, this is a common issue when serializing object graphs to JSON, especially with entity relationships (e.g., parent-child).\n\n#### Approaches to Handle Circular References\n\n#### 1. Using `ReferenceHandler.Preserve` (System.Text.Json in .NET 5+)\n\n```csharp\nvar options = new JsonSerializerOptions\n{\n    ReferenceHandler = ReferenceHandler.Preserve,\n    WriteIndented = true\n};\n\nstring json = JsonSerializer.Serialize(yourObject, options);\n```\nThis will serialize references using `$id` and `$ref` properties to handle cycles.\n\n#### 2. Using `[JsonIgnore]` Attribute\n\nYou can prevent serialization of specific properties that cause circular references:\n\n```csharp\npublic class Parent\n{\n    public string Name { get; set; }\n    public Child Child { get; set; }\n}\n\npublic class Child\n{\n    public string Name { get; set; }\n    [JsonIgnore]\n    public Parent Parent { get; set; }\n}\n```\n\n#### 3. Using `JsonSerializerSettings` in Newtonsoft.Json\n\nIf you use Newtonsoft.Json (Json.NET):\n\n```csharp\nvar settings = new JsonSerializerSettings\n{\n    ReferenceLoopHandling = ReferenceLoopHandling.Ignore\n};\n\nstring json = JsonConvert.SerializeObject(yourObject, settings);\n```\nOr, to preserve references:\n\n```csharp\nvar settings = new JsonSerializerSettings\n{\n    PreserveReferencesHandling = PreserveReferencesHandling.Objects\n};\n\nstring json = JsonConvert.SerializeObject(yourObject, settings);\n```\n\n#### 4. DTOs (Data Transfer Objects)\n\nMap your entities to DTOs that do not contain circular references before serialization.\n\n---\n\n**Summary Table**\n\n| Method                          | Library            | Notes                                  |\n|----------------------------------|--------------------|----------------------------------------|\n| `ReferenceHandler.Preserve`      | System.Text.Json   | .NET 5+, preserves object references   |\n| `[JsonIgnore]`                   | Both               | Prevents property serialization        |\n| `ReferenceLoopHandling.Ignore`   | Newtonsoft.Json    | Ignores circular references            |\n| `PreserveReferencesHandling`     | Newtonsoft.Json    | Serializes references with `$id`/`$ref`|\n| DTO Mapping                      | N/A                | Manual mapping, best for APIs          |\n\n**Choose the method that best fits your application's requirements and serialization library.**\n```\n",
        "level": "Advanced"
    },
    {
        "id": "e11beac8-62e5-47d9-99c8-cee098bb27d0",
        "question": "How do you implement health checks for a REST API in ASP.NET Core?",
        "answer": "```markdown\nTo implement health checks for a REST API in ASP.NET Core, you can use the built-in Health Checks middleware. This allows you to monitor the health of your application and its dependencies (like databases, external services, etc.). Here’s how you can set it up:\n\n### 1. Add the Health Checks NuGet Package\n\nIf you’re using ASP.NET Core 2.2 or later, health checks are included by default. For additional checks (like SQL Server, Redis, etc.), you may need to install extra packages:\n\n```bash\ndotnet add package Microsoft.AspNetCore.Diagnostics.HealthChecks\n```\n\n### 2. Register Health Checks in `Startup.cs`\n\nIn the `ConfigureServices` method, add health checks:\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddControllers();\n\n    // Basic health check\n    services.AddHealthChecks();\n\n    // Example: Add a SQL Server health check\n    // services.AddHealthChecks()\n    //         .AddSqlServer(Configuration.GetConnectionString(\"DefaultConnection\"));\n}\n```\n\n### 3. Configure the Health Checks Endpoint\n\nIn the `Configure` method, map the health check endpoint:\n\n```csharp\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseRouting();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllers();\n\n        // Expose the health check endpoint at /health\n        endpoints.MapHealthChecks(\"/health\");\n    });\n}\n```\n\n### 4. Customizing Health Check Responses\n\nTo return a more detailed JSON response, use `HealthCheckOptions`:\n\n```csharp\nusing Microsoft.AspNetCore.Diagnostics.HealthChecks;\nusing System.Text.Json;\n\napp.UseEndpoints(endpoints =>\n{\n    endpoints.MapControllers();\n\n    endpoints.MapHealthChecks(\"/health\", new HealthCheckOptions\n    {\n        ResponseWriter = async (context, report) =>\n        {\n            context.Response.ContentType = \"application/json\";\n            var result = JsonSerializer.Serialize(new\n            {\n                status = report.Status.ToString(),\n                checks = report.Entries.Select(e => new {\n                    name = e.Key,\n                    status = e.Value.Status.ToString(),\n                    description = e.Value.Description\n                })\n            });\n            await context.Response.WriteAsync(result);\n        }\n    });\n});\n```\n\n### 5. Adding Custom Health Checks\n\nYou can implement your own health checks by creating a class that implements `IHealthCheck`:\n\n```csharp\npublic class CustomHealthCheck : IHealthCheck\n{\n    public Task<HealthCheckResult> CheckHealthAsync(\n        HealthCheckContext context,\n        CancellationToken cancellationToken = default)\n    {\n        // Custom logic here\n        bool healthCheckResultHealthy = true;\n\n        if (healthCheckResultHealthy)\n        {\n            return Task.FromResult(HealthCheckResult.Healthy(\"A healthy result.\"));\n        }\n\n        return Task.FromResult(HealthCheckResult.Unhealthy(\"An unhealthy result.\"));\n    }\n}\n```\n\nRegister your custom health check in `ConfigureServices`:\n\n```csharp\nservices.AddHealthChecks()\n        .AddCheck<CustomHealthCheck>(\"custom_health_check\");\n```\n\n---\n\n**Summary:**  \n- Register health checks in `ConfigureServices`.\n- Map a health check endpoint in `Configure`.\n- Optionally customize the response and add checks for dependencies.\n- Implement custom checks as needed.\n\n**References:**  \n- [Microsoft Docs: Health checks in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "f945ac47-1ea1-4e83-a26c-724d2dbf5956",
        "question": "What is OData and how can it be used in REST APIs?",
        "answer": "```markdown **OData (Open Data Protocol)** is a standardized protocol developed by Microsoft for building and consuming RESTful APIs. It enables the creation and consumption of queryable and interoperable REST APIs in a simple and standard way.\n\n### Key Features of OData\n\n- **Query Options:** Supports rich querying capabilities directly via URL, such as `$filter`, `$select`, `$orderby`, `$top`, and `$expand`.\n- **Metadata:** Exposes metadata (via `$metadata` endpoint) describing the data model, which helps clients understand the structure of the API.\n- **Standardization:** Provides conventions for CRUD operations, navigation, and relationships, making APIs more predictable and interoperable.\n- **Data Shaping:** Allows clients to request only the data they need, reducing payload size and improving performance.\n\n### Using OData in C# REST APIs\n\n#### 1. **Setup**\n\nOData can be integrated into ASP.NET Core Web API projects using the `Microsoft.AspNetCore.OData` NuGet package.\n\n```bash\ndotnet add package Microsoft.AspNetCore.OData\n```\n\n#### 2. **Configuration**\n\nIn `Startup.cs` or `Program.cs`, configure OData in the service container and define the OData route and model:\n\n```csharp\nusing Microsoft.AspNetCore.OData;\nusing Microsoft.OData.ModelBuilder;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddControllers()\n    .AddOData(opt => opt.AddRouteComponents(\"odata\", GetEdmModel()).Select().Filter().OrderBy().Expand().Count().SetMaxTop(100));\n\nstatic IEdmModel GetEdmModel()\n{\n    var odataBuilder = new ODataConventionModelBuilder();\n    odataBuilder.EntitySet<Product>(\"Products\");\n    return odataBuilder.GetEdmModel();\n}\n```\n\n#### 3. **Controller Example**\n\nCreate an OData controller that inherits from `ODataController`:\n\n```csharp\nusing Microsoft.AspNetCore.OData.Routing.Controllers;\n\npublic class ProductsController : ODataController\n{\n    private readonly List<Product> _products = new List<Product>\n    {\n        new Product { Id = 1, Name = \"Laptop\", Price = 1200 },\n        new Product { Id = 2, Name = \"Phone\", Price = 800 }\n    };\n\n    [EnableQuery]\n    public IActionResult Get()\n    {\n        return Ok(_products.AsQueryable());\n    }\n}\n```\n\n#### 4. **Querying the API**\n\nClients can use OData query options in the URL:\n\n- `/odata/Products?$filter=Price gt 1000`\n- `/odata/Products?$select=Name`\n- `/odata/Products?$orderby=Price desc&$top=1`\n\n#### 5. **Benefits**\n\n- **Flexibility:** Clients can shape the data they receive.\n- **Discoverability:** Metadata endpoint helps clients understand the API.\n- **Interoperability:** Standardized protocol eases integration with various tools and platforms.\n\n---\n\n**In summary:**  \nOData is a protocol for building REST APIs that supports advanced querying, metadata exposure, and standardization. In C#, it can be easily integrated using ASP.NET Core and the OData libraries, enabling powerful and flexible APIs.",
        "level": "Advanced"
    },
    {
        "id": "f3402893-b485-4262-b47a-b05b02cf7c9a",
        "question": "How do you deploy a REST API built with C# to Azure?",
        "answer": "```markdown To deploy a REST API built with C# (commonly using ASP.NET Core) to Azure, follow these steps:\n\n## 1. Prerequisites\n\n- **Azure account** ([Sign up](https://azure.microsoft.com/free/))\n- **.NET SDK** installed ([Download](https://dotnet.microsoft.com/download))\n- **Visual Studio** or **VS Code** (optional, but recommended)\n- **Azure CLI** ([Install](https://docs.microsoft.com/cli/azure/install-azure-cli))\n\n---\n\n## 2. Prepare Your API\n\nEnsure your API is working locally:\n\n```bash\ndotnet build\ndotnet run\n```\n\n---\n\n## 3. Publish the API\n\nGenerate a publish-ready folder:\n\n```bash\ndotnet publish -c Release -o ./publish\n```\n\n---\n\n## 4. Create an Azure App Service\n\nYou can use the Azure Portal or Azure CLI. Here’s how to do it with the CLI:\n\n```bash\n# Log in to Azure\naz login\n\n# Create a resource group (if needed)\naz group create --name MyResourceGroup --location \"EastUS\"\n\n# Create an App Service plan\naz appservice plan create --name MyAppServicePlan --resource-group MyResourceGroup --sku FREE\n\n# Create a Web App\naz webapp create --resource-group MyResourceGroup --plan MyAppServicePlan --name <YourUniqueAppName>\n```\n\n---\n\n## 5. Deploy the API\n\n### Option 1: Deploy via Azure CLI\n\n```bash\naz webapp deploy --resource-group MyResourceGroup --name <YourUniqueAppName> --src-path ./publish\n```\n\n### Option 2: Deploy via Visual Studio\n\n1. Right-click your project > **Publish**.\n2. Select **Azure** > **Azure App Service (Windows/Linux)**.\n3. Follow the prompts to create/select the App Service and publish.\n\n---\n\n## 6. Configure Application Settings (Optional)\n\nSet environment variables or connection strings in the Azure Portal under **Configuration**.\n\n---\n\n## 7. Test Your API\n\nVisit `https://<YourUniqueAppName>.azurewebsites.net/api/your-endpoint` to verify deployment.\n\n---\n\n## 8. Monitor and Scale\n\nUse Azure Portal to monitor logs, set up scaling, and manage your API.\n\n---\n\n**References:**\n- [Deploy ASP.NET Core app to Azure App Service](https://learn.microsoft.com/azure/app-service/quickstart-dotnetcore)\n- [Azure CLI documentation](https://learn.microsoft.com/cli/azure/webapp)\n\n---\n\n**Tip:** For CI/CD, consider using [GitHub Actions](https://learn.microsoft.com/azure/app-service/deploy-github-actions) or [Azure DevOps](https://learn.microsoft.com/azure/devops/pipelines/targets/webapp).",
        "level": "Advanced"
    },
    {
        "id": "3d80e6ff-4bbb-4426-94e3-af071d4d883f",
        "question": "How do you monitor and log performance metrics in a REST API?",
        "answer": "```markdown To monitor and log performance metrics in a REST API built with C#, you can leverage middleware, logging frameworks, and performance monitoring tools. Here’s how you can approach this:\n\n## 1. Middleware for Request Timing\n\nImplement custom middleware to measure the time taken to process each request.\n\n```csharp\npublic class RequestTimingMiddleware\n{\n    private readonly RequestDelegate _next;\n    private readonly ILogger<RequestTimingMiddleware> _logger;\n\n    public RequestTimingMiddleware(RequestDelegate next, ILogger<RequestTimingMiddleware> logger)\n    {\n        _next = next;\n        _logger = logger;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        var stopwatch = Stopwatch.StartNew();\n        await _next(context);\n        stopwatch.Stop();\n\n        var elapsedMs = stopwatch.ElapsedMilliseconds;\n        _logger.LogInformation(\"Request {method} {url} => {statusCode} took {elapsed} ms\",\n            context.Request.Method,\n            context.Request.Path,\n            context.Response.StatusCode,\n            elapsedMs);\n    }\n}\n```\n\nRegister the middleware in `Startup.cs` or `Program.cs`:\n\n```csharp\napp.UseMiddleware<RequestTimingMiddleware>();\n```\n\n## 2. Structured Logging\n\nUse a logging framework like [Serilog](https://serilog.net/) or [NLog](https://nlog-project.org/) for structured, queryable logs.\n\nExample with Serilog:\n\n```csharp\nLog.Logger = new LoggerConfiguration()\n    .WriteTo.Console()\n    .WriteTo.File(\"logs/api-log.txt\", rollingInterval: RollingInterval.Day)\n    .CreateLogger();\n\nbuilder.Host.UseSerilog();\n```\n\n## 3. Application Insights or Prometheus\n\nIntegrate with monitoring tools for advanced metrics:\n\n- **Azure Application Insights**: Provides automatic collection of request rates, response times, failure rates, dependencies, and more.\n  \n  ```csharp\n  builder.Services.AddApplicationInsightsTelemetry();\n  ```\n\n- **Prometheus & Grafana**: Use [prometheus-net](https://github.com/prometheus-net/prometheus-net) to expose metrics endpoints.\n\n  ```csharp\n  builder.Services.AddSingleton<IMetricServer>(_ => new KestrelMetricServer(port: 1234));\n  ```\n\n## 4. Health Checks\n\nAdd health checks to monitor the health and dependencies of your API.\n\n```csharp\nbuilder.Services.AddHealthChecks();\napp.MapHealthChecks(\"/health\");\n```\n\n## 5. Example Metrics to Log\n\n- Request/response time\n- HTTP status codes\n- Exception details\n- Throughput (requests per second)\n- Resource usage (CPU, memory)\n\n## 6. Sample Log Output\n\n```\nRequest GET /api/products => 200 took 45 ms\nRequest POST /api/orders => 500 took 120 ms\n```\n\n## 7. Visualization\n\nUse dashboards (e.g., Azure Portal, Grafana) to visualize and analyze metrics over time.\n\n---\n\n**Summary:**  \nMonitor and log performance metrics in a C# REST API by implementing timing middleware, using structured logging frameworks, integrating with monitoring tools like Application Insights or Prometheus, and exposing health check endpoints. This enables real-time monitoring, troubleshooting, and performance optimization.",
        "level": "Advanced"
    },
    {
        "id": "1a157832-4c17-4aba-892b-dd11dc4ddda1",
        "question": "How do you implement multi-tenancy in a REST API?",
        "answer": "```markdown\n### Implementing Multi-Tenancy in a REST API (C#)\n\nMulti-tenancy allows a single REST API to serve multiple clients (tenants), isolating their data and configurations. In C#, especially with ASP.NET Core, you can implement multi-tenancy using several strategies:\n\n#### 1. Tenant Identification\n\n**Common Approaches:**\n- **URL Path:** `https://api.example.com/{tenantId}/resource`\n- **Subdomain:** `https://{tenant}.api.example.com/resource`\n- **HTTP Header:** Custom header like `X-Tenant-ID: tenant1`\n- **Token Claims:** Tenant info embedded in JWT tokens\n\n**Example (Header-based):**\n```csharp\npublic class TenantMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public TenantMiddleware(RequestDelegate next) => _next = next;\n\n    public async Task InvokeAsync(HttpContext context, ITenantProvider tenantProvider)\n    {\n        var tenantId = context.Request.Headers[\"X-Tenant-ID\"].FirstOrDefault();\n        if (string.IsNullOrEmpty(tenantId))\n        {\n            context.Response.StatusCode = StatusCodes.Status400BadRequest;\n            await context.Response.WriteAsync(\"Tenant ID is missing.\");\n            return;\n        }\n\n        tenantProvider.SetTenant(tenantId);\n        await _next(context);\n    }\n}\n```\n\n#### 2. Tenant Context Management\n\nCreate a service to hold the current tenant's context for each request.\n\n```csharp\npublic interface ITenantProvider\n{\n    string TenantId { get; }\n    void SetTenant(string tenantId);\n}\n\npublic class TenantProvider : ITenantProvider\n{\n    private string _tenantId;\n    public string TenantId => _tenantId;\n    public void SetTenant(string tenantId) => _tenantId = tenantId;\n}\n```\n\nRegister `TenantProvider` as a scoped service in `Startup.cs` or `Program.cs`.\n\n#### 3. Data Isolation Strategies\n\n- **Separate Databases:** Each tenant has its own database.\n- **Shared Database, Separate Schemas:** One database, different schemas per tenant.\n- **Shared Database, Shared Schema:** Tenant ID column in all tables.\n\n**Example (EF Core, Shared Schema):**\n```csharp\npublic class ApplicationDbContext : DbContext\n{\n    private readonly ITenantProvider _tenantProvider;\n\n    public ApplicationDbContext(DbContextOptions options, ITenantProvider tenantProvider)\n        : base(options) => _tenantProvider = tenantProvider;\n\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        modelBuilder.Entity<Customer>().HasQueryFilter(\n            c => c.TenantId == _tenantProvider.TenantId);\n    }\n}\n```\n\n#### 4. Authorization and Validation\n\nEnsure all API endpoints validate the tenant context and restrict access to tenant-specific data.\n\n#### 5. Dependency Injection and Middleware Registration\n\n```csharp\nservices.AddScoped<ITenantProvider, TenantProvider>();\napp.UseMiddleware<TenantMiddleware>();\n```\n\n#### 6. Additional Considerations\n\n- **Caching:** Cache per tenant to avoid data leaks.\n- **Logging & Auditing:** Include tenant info in logs.\n- **Rate Limiting:** Apply limits per tenant.\n\n---\n\n**Summary:**  \nImplementing multi-tenancy in a C# REST API involves identifying tenants (via URL, header, etc.), managing tenant context per request, isolating tenant data (database or schema strategies), and enforcing tenant-specific authorization. Middleware and dependency injection are key to integrating multi-tenancy cleanly into your API architecture.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "ea5a7037-aec8-457e-8d4d-40a8d7dd9db8",
        "question": "How do you handle API deprecation and backward compatibility?",
        "answer": "```markdown Handling API Deprecation and Backward Compatibility in C#\n=========================================================\n\nWhen developing and maintaining REST APIs in C#, ensuring backward compatibility and managing API deprecation are crucial for a smooth client experience. Here’s how you can approach these challenges:\n\n### 1. **Versioning Your API**\n\n- **URL Versioning:**  \n  Example: `/api/v1/products`, `/api/v2/products`\n- **Header Versioning:**  \n  Clients specify the version in the request header (e.g., `api-version: 2.0`).\n- **Query String Versioning:**  \n  Example: `/api/products?api-version=2.0`\n\n**ASP.NET Core Example:**\n```csharp\nservices.AddApiVersioning(options =>\n{\n    options.DefaultApiVersion = new ApiVersion(1, 0);\n    options.AssumeDefaultVersionWhenUnspecified = true;\n    options.ReportApiVersions = true;\n});\n```\n\n### 2. **Deprecating Endpoints**\n\n- **Mark Deprecated Endpoints:**  \n  Use attributes or documentation to indicate deprecated endpoints.\n- **Custom Response Headers:**  \n  Add headers like `Deprecation` or `Sunset` to responses.\n- **Provide Alternatives:**  \n  In documentation and responses, suggest the preferred new endpoints.\n\n**Example:**\n```csharp\n[Obsolete(\"This endpoint is deprecated. Use /api/v2/products instead.\")]\n[HttpGet(\"api/v1/products\")]\npublic IActionResult GetProductsV1() { ... }\n```\n\n### 3. **Graceful Deprecation Strategy**\n\n- **Announce Deprecation Early:**  \n  Communicate with clients via changelogs, documentation, and headers.\n- **Support Old Versions Temporarily:**  \n  Maintain old versions for a defined period.\n- **Monitor Usage:**  \n  Track usage of deprecated endpoints to inform clients and plan removal.\n- **Remove Deprecated Endpoints:**  \n  After the deprecation period, remove outdated endpoints.\n\n### 4. **Backward Compatibility Practices**\n\n- **Avoid Breaking Changes:**  \n  - Only add new fields (never remove or rename existing ones).\n  - Make new fields optional.\n  - Don’t change existing response formats.\n- **Use Feature Flags:**  \n  Toggle new features for specific clients.\n- **Contract Testing:**  \n  Use tools like Swagger/OpenAPI to ensure contracts remain compatible.\n\n### 5. **Documentation**\n\n- Clearly document deprecated endpoints and their alternatives.\n- Use OpenAPI/Swagger annotations to indicate deprecation.\n\n**Swagger Example:**\n```csharp\n[ApiExplorerSettings(IgnoreApi = false)]\n[Obsolete(\"This endpoint is deprecated.\")]\n[HttpGet(\"api/v1/products\")]\npublic IActionResult GetProductsV1() { ... }\n```\n\n---\n\n**Summary Table**\n\n| Practice                | Description                                      |\n|-------------------------|--------------------------------------------------|\n| API Versioning          | Isolate breaking changes in new versions         |\n| Deprecation Notices     | Mark endpoints as deprecated in code/docs        |\n| Graceful Removal        | Announce, monitor, and eventually remove         |\n| Backward Compatibility  | Avoid breaking changes, use additive changes     |\n| Documentation           | Clearly communicate changes and alternatives     |\n\n---\n\nBy following these practices, you can manage API deprecation and maintain backward compatibility, ensuring a stable and predictable experience for your API consumers.",
        "level": "Advanced"
    }
]