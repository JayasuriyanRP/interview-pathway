[
  {
      "id": "c4fe3d9c-c403-4950-8f52-07869ebd8eaf",
      "question": "What is a synthetic event in React?",
      "answer": "A **synthetic event** in React is a wrapper around the browser’s native event system. React creates its own event system to ensure events work consistently across all browsers. When you handle events in React (like onClick, onChange, etc.), you’re working with these synthetic events, not the raw browser events.\n\n**Key Points:**\n- Synthetic events normalize events so they have the same properties across different browsers.\n- They wrap the native browser event, providing the same interface.\n- They are part of React’s event delegation system, which improves performance.\n\n**Example:**\n\n```jsx\nfunction MyButton() {\n  function handleClick(event) {\n    // event is a SyntheticEvent\n    alert('Button clicked!');\n  }\n\n  return <button onClick={handleClick}>Click Me</button>;\n}\n```\n\nIn this example, the event passed to handleClick is a synthetic event, not the native browser event.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225313Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "7f07d65e-26a6-4496-96e7-48bbeefd1769",
      "question": "How do you persist a synthetic event for asynchronous use?",
      "answer": "To persist a React synthetic event for asynchronous use, you need to call the persist() method on the event object. By default, React reuses (pools) synthetic events for performance reasons, which means the event properties may be nullified after the event callback finishes. Calling persist() removes the event from the pool, allowing you to access its properties asynchronously.\n\n**Example:**\n\n```jsx\nfunction MyComponent() {\n  function handleClick(event) {\n    event.persist(); // Persist the event for async use\n\n    setTimeout(() => {\n      // You can safely access event properties here\n      alert('Button clicked: ' + event.type);\n    }, 1000);\n  }\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Summary:**\n- Use event.persist() to retain the event object for asynchronous operations.\n- Without persist(), event properties may be cleared after the synchronous event handler finishes.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225626Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "bd920c91-c152-4df6-b4f5-f382496b6d51",
      "question": "What are some common synthetic event types provided by React?",
      "answer": "Some common synthetic event types provided by React include:\n\n- **Mouse Events**\n  - onClick\n  - onDoubleClick\n  - onMouseEnter\n  - onMouseLeave\n  - onMouseDown\n  - onMouseUp\n  - onMouseMove\n\n- **Keyboard Events**\n  - onKeyDown\n  - onKeyUp\n  - onKeyPress\n\n- **Form Events**\n  - onChange\n  - onInput\n  - onSubmit\n  - onFocus\n  - onBlur\n\n- **Touch Events**\n  - onTouchStart\n  - onTouchMove\n  - onTouchEnd\n\n- **Clipboard Events**\n  - onCopy\n  - onCut\n  - onPaste\n\nReact normalizes these events so they work consistently across different browsers. You can use them just like regular DOM events, but with camelCase naming.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225645Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "9480a7df-a937-49c8-84fd-142d7eec0b58",
      "question": "How do you handle keyboard events in React?",
      "answer": "You can handle keyboard events in React by attaching event handlers like onKeyDown, onKeyUp, or onKeyPress to your elements. These handlers receive a SyntheticEvent object, which contains information about the keyboard event.\n\nHere's a simple example:\n\n```jsx\nimport React from 'react';\n\nfunction MyComponent() {\n  const handleKeyDown = (event) => {\n    if (event.key === 'Enter') {\n      alert('Enter key pressed!');\n    }\n  };\n\n  return (\n    <input\n      type=\"text\"\n      onKeyDown={handleKeyDown}\n      placeholder=\"Press Enter\"\n    />\n  );\n}\n\nexport default MyComponent;\n```\n\n**Key points:**\n- Use event handlers like `onKeyDown`, `onKeyUp`, or `onKeyPress`.\n- The event object provides properties such as `event.key` and `event.code` to identify which key was pressed.\n- Attach the handler to the element you want to listen for keyboard events on (e.g., `<input>`, `<div>`, etc.).",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225661Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "b985713e-f399-4ffa-abcd-257fd154d680",
      "question": "How do you handle form submission events in React?",
      "answer": "To handle form submission events in React, you typically use the onSubmit event on the <form> element. You define a handler function that receives the event object and call event.preventDefault() to prevent the default browser behavior (which would reload the page). Here’s a simple example:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction MyForm() {\n  const [inputValue, setInputValue] = useState('');\n\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevents page reload\n    alert('Form submitted with value: ' + inputValue);\n    // You can add more logic here, such as sending data to a server\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        value={inputValue}\n        onChange={e => setInputValue(e.target.value)}\n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n\nexport default MyForm;\n```\n\n**Key points:**\n- Attach your handler to the form’s `onSubmit` prop.\n- Use `event.preventDefault()` to stop the default form submission.\n- Access form data via state or refs as needed.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225676Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "75d28640-500a-4099-9a09-e235ed4aaf57",
      "question": "How does React's synthetic event system differ from native DOM events?",
      "answer": "React’s synthetic event system wraps native DOM events to provide a consistent and cross-browser interface. Here’s how it differs from native DOM events:\n\n- **Cross-browser compatibility:** Synthetic events normalize event properties and behavior, so you don’t have to worry about browser inconsistencies.\n- **Event pooling:** React reuses SyntheticEvent objects for performance, which means event properties may be nullified after the event callback finishes. (Note: As of React 17+, event pooling is deprecated.)\n- **Consistent API:** Synthetic events have the same interface as native events, but work identically across all browsers.\n- **Delegation:** React attaches a single event listener at the root of the DOM (using event delegation), rather than adding listeners directly to each element. This improves performance and memory usage.\n\n**Example:**\n\n```jsx\nfunction MyButton() {\n  function handleClick(event) {\n    // event is a SyntheticEvent\n    console.log(event.type); // 'click'\n  }\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Summary Table:**\n\n| Feature                | Native DOM Event         | React Synthetic Event      |\n|------------------------|-------------------------|---------------------------|\n| Browser consistency    | Varies                  | Consistent                |\n| Event pooling          | No                      | Yes (pre-React 17)        |\n| API                    | Varies by browser       | Standardized              |\n| Event delegation       | Manual                  | Automatic (by React)      |\n\n**In short:** React’s synthetic events make event handling easier and more reliable across different browsers by abstracting away inconsistencies and optimizing performance.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225384Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "980c2608-bc5b-49bb-8dac-b3ae80284be8",
      "question": "How do you attach an event handler to a button in React?",
      "answer": "```markdown\nIn React, you attach an event handler to a button by passing a function to the button's event prop, such as onClick. Here's an example:\n\n```jsx\nimport React from 'react';\n\nfunction MyComponent() {\n  function handleClick() {\n    alert('Button was clicked!');\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click Me\n    </button>\n  );\n}\n\nexport default MyComponent;\n```\n\nIn this example, the handleClick function will run whenever the button is clicked.\n```\n",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225404Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "b9bbfe3e-a24a-44dd-881b-14cfd43e252c",
      "question": "What is the purpose of the 'onClick' prop in React components?",
      "answer": "The onClick prop in React is used to specify a function that should be called when a component is clicked. It allows you to handle click events in your React components, similar to how you would use addEventListener in plain JavaScript, but in a more declarative way.\n\n**Example:**\n\n```jsx\nfunction MyButton() {\n  function handleClick() {\n    alert('Button was clicked!');\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click Me\n    </button>\n  );\n}\n```\n\n**Purpose:**  \nThe onClick prop lets you respond to user interactions (like mouse clicks) and perform actions such as updating state, showing messages, or triggering other functions in your application.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225421Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "d1ca8bb1-4425-4504-89dd-5f866984dcc3",
      "question": "How do you prevent the default behavior of an event in React?",
      "answer": "To prevent the default behavior of an event in React, you use the preventDefault() method on the event object. Here’s an example with a form submission:\n\n```jsx\nfunction MyForm() {\n  function handleSubmit(event) {\n    event.preventDefault(); // Prevents the default form submission\n    // Your custom logic here\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n**Explanation:**  \nWhen the form is submitted, handleSubmit is called. Calling event.preventDefault() stops the browser from performing the default action (like reloading the page). This lets you handle the event with your own logic.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225441Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "2b307f26-ea1e-43ee-a2da-0b8ebb7d4d07",
      "question": "How do you stop event propagation in React?",
      "answer": "To stop event propagation in React, you can call the stopPropagation() method on the event object inside your event handler. Here’s an example:\n\n```jsx\nfunction MyComponent() {\n  function handleClick(event) {\n    event.stopPropagation();\n    // Your logic here\n  }\n\n  return (\n    <div onClick={() => alert('Parent clicked!')}>\n      <button onClick={handleClick}>\n        Click me (event will not bubble to parent)\n      </button>\n    </div>\n  );\n}\n```\n\n**Explanation:**\n- event.stopPropagation() prevents the event from bubbling up to parent elements.\n- In the example above, clicking the button will not trigger the parent div's onClick handler.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225462Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "be1ead5a-5839-4fd3-9913-5c0cedc80b98",
      "question": "What is the difference between 'event.preventDefault()' and 'event.stopPropagation()'?",
      "answer": "```markdown\n**event.preventDefault()** and **event.stopPropagation()** are two different methods used in React (and plain JavaScript) to control how events behave:\n\n- **event.preventDefault()**  \n  This method prevents the default action that belongs to the event from occurring.  \n  *Example:* If used in a form's `onSubmit` handler, it prevents the form from submitting and reloading the page.\n\n- **event.stopPropagation()**  \n  This method stops the event from bubbling up (or propagating) to parent elements.  \n  *Example:* If you have a click event on a button inside a div, and both have click handlers, calling `stopPropagation()` in the button's handler will prevent the div's handler from firing.\n\n**Summary Table:**\n\n| Method                  | What it does                                    |\n|-------------------------|-------------------------------------------------|\n| `event.preventDefault()`| Stops default browser behavior                  |\n| `event.stopPropagation()`| Stops event from bubbling to parent elements   |\n```\n",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225487Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "72716e2f-c400-4bad-bd31-7573d853e376",
      "question": "Why should you avoid using inline arrow functions in JSX event handlers?",
      "answer": "**Answer:**\n\nUsing inline arrow functions in JSX event handlers (e.g., `<button onClick={() => handleClick()}>Click</button>`) should generally be avoided for the following reasons:\n\n1. **Performance Issues**:  \n   Every time a component re-renders, a new function instance is created for each inline arrow function. This can lead to unnecessary re-renders of child components, especially if those handlers are passed as props, and can negatively impact performance in large or frequently updating components.\n\n2. **Component Reconciliation**:  \n   React uses reference equality to determine if props have changed. If you use an inline arrow function, the handler prop will always be a new function, causing React to think the prop has changed and potentially triggering unnecessary updates.\n\n3. **Harder to Test and Debug**:  \n   Inline functions can make it more difficult to test and debug your code, as they are anonymous and do not have a name in stack traces.\n\n**Best Practice:**  \nDefine your event handler as a class method or a function outside of the render method, and reference it directly in your JSX:\n\n```jsx\nfunction MyComponent() {\n  const handleClick = () => {\n    // handle click\n  };\n\n  return <button onClick={handleClick}>Click</button>;\n}\n```\n\nThis approach improves performance, makes your code more readable, and avoids unnecessary re-renders.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225505Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "1cb7e27d-6d78-454e-b249-eb4df3c3b929",
      "question": "How does React handle event delegation?",
      "answer": "React handles event delegation by attaching a single event listener at the root of the DOM (typically the document or the root DOM node). Instead of attaching event listeners directly to each individual DOM element, React uses a centralized event system to manage all events.\n\n### How It Works\n\n- **Single Listener:** When you add an event handler (like `onClick`) to a React component, React does not attach that handler directly to the DOM node. Instead, it registers the handler internally.\n- **Event Pooling:** React creates a synthetic event that wraps the native browser event, providing a consistent API across browsers.\n- **Event Bubbling:** When an event occurs, it bubbles up to the root, where React's single event listener catches it.\n- **Dispatching:** React determines which component(s) should receive the event based on the event's target and the registered handlers, then calls the appropriate handler(s).\n\n### Benefits\n\n- **Performance:** Fewer event listeners mean less memory usage and better performance, especially in large applications.\n- **Consistency:** Synthetic events normalize event properties and behavior across different browsers.\n- **Cleanup:** React can efficiently manage and clean up event listeners when components unmount.\n\n### Example\n\n```jsx\nfunction MyButton() {\n  function handleClick(event) {\n    alert('Button clicked!');\n  }\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\nEven though it looks like the event handler is attached to the `<button>`, React manages it internally and uses event delegation to handle the click.\n\n---\n\n**In summary:**  \nReact uses event delegation by attaching a single event listener at the root and dispatching events to components using its synthetic event system, improving performance and consistency.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225523Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "70061a65-8270-4102-b4e1-fbf691f0cced",
      "question": "What are the benefits of using synthetic events in React?",
      "answer": "**Benefits of Using Synthetic Events in React**\n\nReact’s Synthetic Events offer several advantages over directly handling native browser events:\n\n1. **Cross-Browser Compatibility**  \n   Synthetic events normalize event properties and behavior across different browsers, ensuring consistent event handling regardless of the user’s environment.\n\n2. **Performance Optimization**  \n   React uses event delegation by attaching a single event listener at the root of the DOM. This reduces memory usage and improves performance, especially in applications with many interactive elements.\n\n3. **Consistent API**  \n   Synthetic events provide a consistent interface that matches the W3C spec, making it easier to work with events without worrying about browser inconsistencies.\n\n4. **Automatic Cleanup**  \n   React manages the lifecycle of event listeners, automatically cleaning them up when components unmount, which helps prevent memory leaks.\n\n5. **Integration with React’s Lifecycle**  \n   Synthetic events are integrated with React’s batching and update mechanisms, ensuring that state updates and re-renders happen efficiently and predictably.\n\n**Example:**\n\n```jsx\nfunction MyButton() {\n  function handleClick(event) {\n    // event is a SyntheticEvent\n    alert('Button clicked!');\n  }\n\n  return <button onClick={handleClick}>Click Me</button>;\n}\n```\n\n**Summary Table**\n\n| Benefit                   | Description                                                      |\n|---------------------------|------------------------------------------------------------------|\n| Cross-browser support     | Normalizes events for all browsers                               |\n| Performance               | Uses event delegation for efficiency                             |\n| Consistent API            | Uniform event properties and methods                             |\n| Automatic cleanup         | Prevents memory leaks by managing listeners                      |\n| React integration         | Works seamlessly with React’s update and lifecycle system        |",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225542Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "551e0f21-b37d-470c-be43-8aaa1930500f",
      "question": "How can you access the value of an input field in an event handler?",
      "answer": "You can access the value of an input field in an event handler by using event.target.value. Here’s a simple example:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction MyComponent() {\n  const [inputValue, setInputValue] = useState('');\n\n  function handleChange(event) {\n    setInputValue(event.target.value);\n  }\n\n  return (\n    <input\n      type=\"text\"\n      value={inputValue}\n      onChange={handleChange}\n    />\n  );\n}\n```\n\n**Explanation:**\n\n- The event handler (handleChange) receives a synthetic event object.\n- `event.target` refers to the input element.\n- `event.target.value` gives you the current value of the input field.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225558Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "876d78ff-63ad-4954-aed6-72a87088ea70",
      "question": "What is event pooling in React synthetic events?",
      "answer": "**Event pooling** in React refers to the optimization technique used by React’s SyntheticEvent system to reuse event objects for performance reasons. When an event handler is triggered in React, a SyntheticEvent object is created and passed to the handler. Instead of creating a new event object for every event, React reuses (or \"pools\") these objects to reduce memory overhead and improve performance.\n\n### Key Points\n\n- **SyntheticEvent objects are reused:** After your event handler finishes executing, the SyntheticEvent object’s properties are cleared and the object is put back into a pool for future use.\n- **Accessing event properties asynchronously:** Because of pooling, you cannot reliably access event properties asynchronously (e.g., inside a setTimeout or after a promise resolves), as the properties may have been cleared.\n- **Solution:** If you need to access the event properties asynchronously, you should call `event.persist()` to remove the event from the pool, or copy the properties you need into a variable.\n\n### Example\n\n```jsx\nfunction MyComponent() {\n  function handleClick(event) {\n    // This will work\n    console.log(event.type);\n\n    setTimeout(() => {\n      // This may not work as expected due to event pooling\n      console.log(event.type); // Might log 'undefined'\n    }, 1000);\n\n    // To fix, use event.persist() or copy the property\n    // event.persist();\n    // OR\n    // const eventType = event.type;\n  }\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n### Summary Table\n\n| Aspect                | Description                                  |\n|-----------------------|----------------------------------------------|\n| What is pooled?       | SyntheticEvent objects                       |\n| Why pool events?      | Performance and memory optimization          |\n| How to avoid issues?  | Use `event.persist()` or copy properties     |\n\n**Note:** As of React 17 and later, event pooling has been removed, but understanding it is still important for legacy codebases.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225575Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "d215228b-f777-4cdb-b941-fd37aa52b413",
      "question": "How can you access the native event from a synthetic event?",
      "answer": "To access the native event from a React SyntheticEvent, use the nativeEvent property provided by the SyntheticEvent object. For example:\n\n```jsx\nfunction handleClick(e) {\n  // e is the SyntheticEvent\n  console.log(e.nativeEvent); // Access the native browser event\n}\n\n<button onClick={handleClick}>Click me</button>\n```\n\n**Note:**  \n- The nativeEvent property gives you direct access to the underlying browser event object.\n- Use this only if you need functionality not provided by the SyntheticEvent API.  \n- Be aware that React pools SyntheticEvent objects for performance, so if you need to access the event asynchronously, call e.persist() first.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225591Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "c33e6404-8284-4138-a340-af51b7321f69",
      "question": "What happens if you use a synthetic event after the event handler has finished executing?",
      "answer": "In React, synthetic events are pooled for performance reasons. This means that after your event handler has finished executing, the SyntheticEvent object is returned to a pool and its properties are nulled out. If you try to access the event's properties asynchronously (for example, inside a setTimeout or a Promise), you'll find that they are no longer available and may get an error or see that their values are null.\n\n**Example:**\n\n```jsx\nfunction handleClick(event) {\n  setTimeout(() => {\n    // This will not work as expected!\n    console.log(event.type); // Might log null or throw an error\n  }, 1000);\n}\n```\n\n**How to fix:**\n\nIf you need to access the event properties asynchronously, you should call event.persist() to remove the event from the pool, or copy the needed properties to a variable:\n\n```jsx\nfunction handleClick(event) {\n  event.persist(); // Prevents React from pooling the event\n  setTimeout(() => {\n    console.log(event.type); // Works as expected\n  }, 1000);\n}\n\n// OR\n\nfunction handleClick(event) {\n  const eventType = event.type;\n  setTimeout(() => {\n    console.log(eventType); // Works as expected\n  }, 1000);\n}\n```\n\n**Summary:**  \nIf you use a synthetic event after the handler has finished, its properties will be unavailable unless you persist the event or copy the needed values.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225609Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "9cd98db7-7ad6-4813-8efc-884f77b20e5b",
      "question": "How do you pass arguments to event handlers in React?",
      "answer": "```markdown\nTo pass arguments to event handlers in React, you can use an inline arrow function or the Function.prototype.bind method. This allows you to pass custom arguments along with the event object.\n\n### Example using an arrow function\n\n```jsx\nfunction MyButton({ id }) {\n  function handleClick(customArg, event) {\n    console.log('Button ID:', customArg);\n    console.log('Event:', event.type);\n  }\n\n  return (\n    <button onClick={(event) => handleClick(id, event)}>\n      Click me\n    </button>\n  );\n}\n```\n\n### Example using `bind`\n\n```jsx\nfunction MyButton({ id }) {\n  function handleClick(customArg, event) {\n    console.log('Button ID:', customArg);\n    console.log('Event:', event.type);\n  }\n\n  return (\n    <button onClick={handleClick.bind(null, id)}>\n      Click me\n    </button>\n  );\n}\n```\n\n**Note:**  \n- The first argument passed to the handler will be your custom argument (e.g., `id`), and the event object will be passed as the last argument.\n- Using arrow functions is generally preferred for readability and performance in most cases.\n\n---\n**Summary:**  \nPass arguments to event handlers in React by using inline arrow functions or `bind`, ensuring your handler receives both custom arguments and the event object.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225695Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "8b73ad75-8eed-49d8-b1bb-63682edd7e0d",
      "question": "What is the difference between 'onChange' and 'onInput' in React?",
      "answer": "```markdown\n**Difference between `onChange` and `onInput` in React:**\n\n- **`onChange`:**\n  - In React, the `onChange` event handler is triggered when the value of an input element changes and the element loses focus (for most input types), or after each keystroke for text inputs.\n  - For `<input type=\"text\">` and `<textarea>`, `onChange` fires on every change (i.e., every keystroke), which is different from the native DOM behavior where `change` fires only on blur.\n  - For other input types (like checkboxes, radios, selects), it fires when the value changes.\n\n- **`onInput`:**\n  - The `onInput` event handler is triggered immediately after the value of an input element changes, on every keystroke or input event, before the value is committed.\n  - This closely mirrors the native DOM `input` event.\n  - It can be useful for scenarios where you need to respond to every input event, including those not caused by keyboard (e.g., voice input, drag-and-drop).\n\n**Summary Table:**\n\n| Event      | When it Fires (React)                                   | Typical Use Cases                |\n|------------|--------------------------------------------------------|----------------------------------|\n| `onChange` | On every value change for text inputs; on blur for others | Form handling, validation        |\n| `onInput`  | On every input event (keystroke, paste, etc.)           | Live feedback, instant updates   |\n\n**Example:**\n\n```jsx\n<input\n  type=\"text\"\n  onChange={e => console.log('onChange:', e.target.value)}\n  onInput={e => console.log('onInput:', e.target.value)}\n/>\n```\n\n**Key Point:**  \nIn React, `onChange` for text inputs behaves more like the native `input` event, but `onInput` can still be used for more immediate or lower-level input handling.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225712Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "0fdb6ffe-541f-4262-9429-8ae1949f3653",
      "question": "How can you handle events on dynamically generated elements in React?",
      "answer": "```markdown\nIn React, you can handle events on dynamically generated elements by attaching event handlers directly to the elements as you render them. Since React uses a virtual DOM and synthetic events, you don't need to manually delegate events like in vanilla JavaScript.\n\nHere's how you can do it:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction DynamicList() {\n  const [items, setItems] = useState(['Apple', 'Banana', 'Cherry']);\n\n  const handleClick = (item) => {\n    alert(`You clicked on ${item}`);\n  };\n\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index} onClick={() => handleClick(item)}>\n          {item}\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Explanation:**\n- The `onClick` event handler is attached directly to each `<li>` as it is rendered.\n- The handler receives the specific item as an argument, so you know which element was clicked.\n- React's synthetic event system ensures that events work seamlessly, even for elements generated dynamically.\n\n**Key Points:**\n- Attach event handlers directly in your JSX when rendering dynamic lists.\n- Use arrow functions or bind to pass parameters to event handlers.\n- No need for manual event delegation; React handles event propagation efficiently.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225730Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "35ff1623-df0d-4294-a6b8-849f658ee673",
      "question": "What is the purpose of the 'event.target' property in React synthetic events?",
      "answer": "The event.target property in React synthetic events refers to the DOM element that triggered the event. It allows you to access properties or values of the element that initiated the event, such as the value of an input field.\n\n**Example:**\n\n```jsx\nfunction handleChange(event) {\n  console.log(event.target.value); // Logs the current value of the input\n}\n\n<input type=\"text\" onChange={handleChange} />\n```\n\n**Purpose:**  \nevent.target helps you identify and interact with the specific element that caused the event, making it useful for handling user input and dynamic UI updates.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225745Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "b1c120d5-9396-4ac0-888f-abbaebe5436e",
      "question": "How do you handle mouse events in React?",
      "answer": "You can handle mouse events in React by adding event handler props (such as onClick, onMouseEnter, onMouseLeave, etc.) to your JSX elements. These handlers receive a SyntheticEvent object as an argument.\n\nHere's a simple example:\n\n```jsx\nimport React from 'react';\n\nfunction MyButton() {\n  function handleClick(event) {\n    alert('Button was clicked!');\n    // You can access event properties, e.g. event.type\n    console.log(event.type); // \"click\"\n  }\n\n  return (\n    <button onClick={handleClick}>\n      Click Me\n    </button>\n  );\n}\n\nexport default MyButton;\n```\n\n**Common mouse events in React:**\n\n- `onClick`\n- `onDoubleClick`\n- `onMouseEnter`\n- `onMouseLeave`\n- `onMouseDown`\n- `onMouseUp`\n- `onMouseMove`\n\n**Note:**  \nReact's event handlers use camelCase (e.g., onClick) instead of lowercase (e.g., onclick) as in plain HTML.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225768Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "43c98cae-b89d-453f-b7b4-936fe7c7db34",
      "question": "How do you handle touch events in React?",
      "answer": "To handle touch events in React, you use the built-in synthetic event handlers that correspond to native touch events. React provides several touch event handlers, such as:\n\n- onTouchStart\n- onTouchMove\n- onTouchEnd\n- onTouchCancel\n\nThese handlers receive a SyntheticTouchEvent object, which contains information about the touch interaction.\n\n**Example:**\n\n```jsx\nimport React from 'react';\n\nfunction TouchComponent() {\n  const handleTouchStart = (event) => {\n    console.log('Touch started', event.touches);\n  };\n\n  const handleTouchMove = (event) => {\n    console.log('Touch moved', event.touches);\n  };\n\n  const handleTouchEnd = (event) => {\n    console.log('Touch ended');\n  };\n\n  return (\n    <div\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n      style={{\n        width: 200,\n        height: 200,\n        backgroundColor: '#eee',\n        textAlign: 'center',\n        lineHeight: '200px',\n      }}\n    >\n      Touch Me!\n    </div>\n  );\n}\n\nexport default TouchComponent;\n```\n\n**Key Points:**\n- Attach touch event handlers directly to React elements.\n- Use the event object to access touch data (e.g., `event.touches`, `event.changedTouches`).\n- React normalizes these events across browsers for consistency.\n\n**References:**\n- [React Docs: Handling Events](https://react.dev/reference/react-dom/components/common#handling-events)\n- [MDN: Touch events](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events)",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225785Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "cbcdf000-0d09-4ea9-95b5-476f71cf4f0e",
      "question": "What are the differences between 'onBlur' and 'onFocus' events in React?",
      "answer": "```markdown\n**Differences between `onBlur` and `onFocus` events in React:**\n\n| Aspect         | `onFocus`                                        | `onBlur`                                         |\n|----------------|--------------------------------------------------|--------------------------------------------------|\n| Triggered When | An element gains focus (e.g., user clicks into an input or tabs into it) | An element loses focus (e.g., user clicks away or tabs out) |\n| Common Usage   | Start highlighting, show tooltips, or open dropdowns | Validate input, hide tooltips, or close dropdowns |\n| Event Propagation | In React, both use event bubbling (unlike native DOM, where `focus` and `blur` do not bubble) | In React, both use event bubbling |\n| Example        | `<input onFocus={handleFocus} />`                | `<input onBlur={handleBlur} />`                  |\n\n**Summary:**  \n- `onFocus` is used to handle actions when an element becomes active or selected.\n- `onBlur` is used to handle actions when an element loses its active state.\n- In React, both events bubble up the component tree, allowing parent components to handle them.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225803Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "d3c84d05-90b4-4536-8a15-93592bafc780",
      "question": "How do you handle custom events in React?",
      "answer": "```markdown\n### Handling Custom Events in React\n\nReact's SyntheticEvent system is designed to handle standard DOM events (like `onClick`, `onChange`, etc.), but sometimes you need to communicate between components using custom events. While React doesn't natively support custom DOM events in the same way as the browser's `CustomEvent`, you can handle custom events in React using a few different patterns:\n\n#### 1. **Callback Props (Recommended for Parent-Child Communication)**\n\nThe most common React pattern is to pass callback functions as props:\n\n```jsx\n// Parent Component\nfunction Parent() {\n  const handleCustomEvent = (data) => {\n    console.log('Custom event received:', data);\n  };\n\n  return <Child onCustomEvent={handleCustomEvent} />;\n}\n\n// Child Component\nfunction Child({ onCustomEvent }) {\n  return (\n    <button onClick={() => onCustomEvent('Hello from child!')}>\n      Trigger Custom Event\n    </button>\n  );\n}\n```\n\n#### 2. **Context API (For Deeply Nested Components)**\n\nIf you need to handle custom events across deeply nested components, use React Context:\n\n```jsx\nconst CustomEventContext = React.createContext();\n\nfunction Parent() {\n  const handleCustomEvent = (data) => { /* ... */ };\n\n  return (\n    <CustomEventContext.Provider value={handleCustomEvent}>\n      <DeepChild />\n    </CustomEventContext.Provider>\n  );\n}\n\nfunction DeepChild() {\n  const handleCustomEvent = React.useContext(CustomEventContext);\n\n  return <button onClick={() => handleCustomEvent('data')}>Fire Event</button>;\n}\n```\n\n#### 3. **Event Emitter (For Sibling or Unrelated Components)**\n\nFor more complex scenarios, you can use an event emitter library (like `mitt` or `eventemitter3`):\n\n```js\n// eventBus.js\nimport mitt from 'mitt';\nexport const eventBus = mitt();\n```\n\n```jsx\n// Component A\nimport { eventBus } from './eventBus';\neventBus.emit('customEvent', { foo: 'bar' });\n\n// Component B\nimport { eventBus } from './eventBus';\nReact.useEffect(() => {\n  const handler = (data) => { /* ... */ };\n  eventBus.on('customEvent', handler);\n  return () => eventBus.off('customEvent', handler);\n}, []);\n```\n\n#### 4. **Custom DOM Events (Rarely Needed in React)**\n\nIf you need to interact with third-party libraries that dispatch custom DOM events, you can use `ref` and native event listeners:\n\n```jsx\nfunction MyComponent() {\n  const ref = React.useRef();\n\n  React.useEffect(() => {\n    const handler = (e) => { /* ... */ };\n    ref.current.addEventListener('mycustomevent', handler);\n    return () => ref.current.removeEventListener('mycustomevent', handler);\n  }, []);\n\n  return <div ref={ref}>Listen for custom DOM events</div>;\n}\n```\n\n---\n\n**Summary:**  \nReact encourages handling custom events through props, context, or event emitters, rather than the DOM's `CustomEvent`. Choose the pattern that best fits your component hierarchy and communication needs.\n```\n",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.225821Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "5f10d538-5e78-434e-ac63-477cc013fc56",
      "question": "Can you use event capturing phase in React synthetic events?",
      "answer": "Yes, you can use the event capturing phase in React synthetic events.\n\nBy default, React event handlers listen during the bubbling phase. However, to listen during the capturing phase, you can add the Capture suffix to the event handler prop. For example:\n\n```jsx\n<div onClickCapture={handleClick}>\n  {/* ... */}\n</div>\n```\n\nIn this example, handleClick will be invoked during the capturing phase, before bubbling event handlers (onClick) are called.\n\n**Summary Table:**\n\n| Phase      | React Prop         | Example                |\n|------------|--------------------|------------------------|\n| Bubbling   | onClick            | onClick={fn}           |\n| Capturing  | onClickCapture     | onClickCapture={fn}    |\n\n**References:**\n- [React Docs: SyntheticEvent](https://react.dev/reference/react-dom/components/common#event-propagation)\n- [React Docs: Event Propagation](https://react.dev/learn/responding-to-events#event-propagation)",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.225836Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "f419b791-fcab-4b4e-88f3-310f4e7600b6",
      "question": "How does React handle event propagation across component boundaries?",
      "answer": "React handles event propagation using its own event system called Synthetic Events, which is a cross-browser wrapper around the browser’s native events. Here’s how React manages event propagation across component boundaries:\n\n## 1. Event Delegation\n\nReact does **not** attach event listeners directly to individual DOM nodes. Instead, it attaches a single event listener at the root of the DOM tree (usually the document or root container). When an event occurs, React’s event system captures it at the root and then determines which component(s) should receive the event.\n\n## 2. Synthetic Event System\n\nReact wraps native events in a `SyntheticEvent` object, which normalizes event properties and behavior across browsers. This object mimics the native event but adds extra features, such as consistent event properties and pooling for performance.\n\n## 3. Propagation Across Component Boundaries\n\n- **Bubbling:** By default, events bubble up through the React component tree, similar to how they bubble in the DOM. If you have nested components, an event triggered in a child component will bubble up to its parent components unless `event.stopPropagation()` is called.\n- **Component Boundaries:** Even though components are abstractions, React’s synthetic event system ensures that event bubbling works seamlessly across component boundaries. This means a parent component can listen for events that originate from its child components.\n- **Stopping Propagation:** You can call `event.stopPropagation()` on the SyntheticEvent to prevent further propagation up the component tree, just like with native events.\n\n## 4. Example\n\n```jsx\nfunction Parent() {\n  const handleClick = () => {\n    alert('Parent clicked!');\n  };\n\n  return (\n    <div onClick={handleClick}>\n      <Child />\n    </div>\n  );\n}\n\nfunction Child() {\n  const handleClick = (e) => {\n    alert('Child clicked!');\n    // e.stopPropagation(); // Uncomment to stop event from bubbling to Parent\n  };\n\n  return <button onClick={handleClick}>Click Me</button>;\n}\n```\n\n- Clicking the button will trigger both the `Child` and `Parent` handlers due to bubbling.\n- If you uncomment `e.stopPropagation()`, the event will not bubble to the parent.\n\n## 5. Summary Table\n\n| Feature                   | React Synthetic Events           | Native DOM Events         |\n|---------------------------|----------------------------------|--------------------------|\n| Event Delegation          | Yes (at root)                    | No (per node)            |\n| Cross-browser Consistency | Yes                              | No                       |\n| Bubbling                  | Yes (across components)          | Yes (across DOM nodes)   |\n| stopPropagation           | Supported                        | Supported                |\n\n---\n\n**In summary:**  \nReact’s synthetic event system ensures that event propagation (bubbling and capturing) works consistently across component boundaries, allowing parent components to handle events from their children, unless propagation is explicitly stopped. This is achieved through event delegation and the SyntheticEvent wrapper.",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.225852Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "cd003b69-51e9-43a8-b4c2-623f83f6548a",
      "question": "What is the impact of React synthetic events on performance?",
      "answer": "### Impact of React Synthetic Events on Performance\n\nReact synthetic events are part of React’s event system, which wraps the browser’s native events to provide a consistent API across different browsers. Here’s how they impact performance:\n\n#### 1. **Event Delegation**\n- **How it works:** React attaches a single event listener at the root of the DOM (e.g., `document`) for each event type, rather than adding listeners to every individual element.\n- **Performance Benefit:** This reduces the number of event listeners in the DOM, lowering memory usage and improving event handling efficiency, especially in large applications with many interactive elements.\n\n#### 2. **Pooling of Event Objects**\n- **How it works:** SyntheticEvent objects are reused (pooled) for performance reasons. After the event callback executes, the event object’s properties are cleared and reused for the next event.\n- **Performance Benefit:** Reduces the overhead of creating and garbage-collecting many event objects.\n- **Potential Pitfall:** Accessing event properties asynchronously (e.g., in a `setTimeout`) can lead to bugs, as the event object may have been reused. Use `event.persist()` to opt out of pooling if needed.\n\n#### 3. **Cross-Browser Consistency**\n- **How it works:** Synthetic events normalize event properties and behavior across browsers.\n- **Performance Impact:** The normalization logic adds a small overhead, but this is generally negligible compared to the benefits of consistent behavior and easier debugging.\n\n#### 4. **Batching and Updates**\n- **How it works:** React batches state updates triggered by event handlers, reducing unnecessary re-renders.\n- **Performance Benefit:** Improves rendering performance by minimizing the number of updates and reflows.\n\n---\n\n#### **Summary Table**\n\n| Feature                  | Performance Impact                        |\n|--------------------------|-------------------------------------------|\n| Event Delegation         | Fewer listeners, lower memory usage       |\n| Event Object Pooling     | Less GC overhead, but beware async access |\n| Cross-Browser Consistency| Minor overhead, major developer benefit   |\n| Batching Updates         | Fewer re-renders, better responsiveness   |\n\n---\n\n**In conclusion:**  \nReact’s synthetic event system is generally optimized for performance, especially in large-scale applications. The main benefits come from event delegation and batching, while the minor overhead from normalization is usually outweighed by the advantages in consistency and maintainability. Developers should be aware of event pooling to avoid bugs when accessing event properties asynchronously.",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.225866Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "a842a090-cff4-49fa-bd0d-6e91a731ba3f",
      "question": "How do you handle global events (e.g., window resize) in React?",
      "answer": "To handle global events (such as window resize) in React, you typically use the useEffect hook to add and clean up event listeners when your component mounts and unmounts. Here's a step-by-step example:\n\n```jsx\nimport React, { useState, useEffect } from 'react';\n\nfunction WindowResizeComponent() {\n  const [windowWidth, setWindowWidth] = useState(window.innerWidth);\n\n  useEffect(() => {\n    // Handler function for the resize event\n    const handleResize = () => {\n      setWindowWidth(window.innerWidth);\n    };\n\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Clean up the event listener on unmount\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Empty dependency array ensures this runs once on mount and cleanup on unmount\n\n  return (\n    <div>\n      <p>Window width: {windowWidth}px</p>\n    </div>\n  );\n}\n\nexport default WindowResizeComponent;\n```\n\n**Key Points:**\n- Use useEffect to manage adding and removing global event listeners.\n- Always clean up the event listener in the return function of useEffect to avoid memory leaks.\n- React synthetic events only cover events attached to React elements. For global objects (window, document), use native event listeners as shown above.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225881Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "c7ada480-212e-492c-92f1-3c8a55e35142",
      "question": "How do you clean up event listeners in class and function components?",
      "answer": "```markdown\nIn React, cleaning up event listeners is important to prevent memory leaks and unexpected behavior. The approach differs between class components and function components (with hooks):\n\n### Class Components\n\nIn class components, you typically add event listeners in `componentDidMount` and remove them in `componentWillUnmount`.\n\n```jsx\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleResize = () => {\n    // handle the resize event\n  };\n\n  render() {\n    return <div>My Component</div>;\n  }\n}\n```\n\n### Function Components (with Hooks)\n\nIn function components, you use the `useEffect` hook. The cleanup is done by returning a function from `useEffect`.\n\n```jsx\nimport React, { useEffect } from 'react';\n\nfunction MyComponent() {\n  useEffect(() => {\n    const handleResize = () => {\n      // handle the resize event\n    };\n\n    window.addEventListener('resize', handleResize);\n\n    // Cleanup function\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []); // Empty dependency array means this runs once on mount and cleanup on unmount\n\n  return <div>My Component</div>;\n}\n```\n\n### Key Points\n\n- **Always clean up** event listeners you add to avoid memory leaks.\n- In **class components**, use `componentWillUnmount`.\n- In **function components**, return a cleanup function from `useEffect`.\n- For **React synthetic events** (like `onClick` on JSX elements), React handles cleanup automatically. Manual cleanup is only needed for listeners attached directly to DOM elements or global objects (like `window` or `document`).\n\n```",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225896Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "0e421a7f-c07b-4d7d-8cfc-d7cbb407fb3e",
      "question": "How do you test React synthetic events in unit tests?",
      "answer": "To test React synthetic events in unit tests, you typically use a testing library like React Testing Library or Enzyme. The general approach is to render the component, simulate the event, and assert the expected outcome.\n\nHere's an example using **React Testing Library**:\n\n```jsx\n// Button.js\nimport React from 'react';\n\nfunction Button({ onClick }) {\n  return <button onClick={onClick}>Click me</button>;\n}\n\nexport default Button;\n```\n\n```jsx\n// Button.test.js\nimport React from 'react';\nimport { render, fireEvent } from '@testing-library/react';\nimport Button from './Button';\n\ntest('calls onClick when button is clicked', () => {\n  const handleClick = jest.fn();\n  const { getByText } = render(<Button onClick={handleClick} />);\n  \n  fireEvent.click(getByText('Click me'));\n  \n  expect(handleClick).toHaveBeenCalledTimes(1);\n});\n```\n\n**Key Points:**\n\n- Use `fireEvent` (or `userEvent` for more realistic interactions) to simulate synthetic events like `click`, `change`, etc.\n- Pass a mock function (e.g., `jest.fn()`) as the event handler prop.\n- Assert that the handler was called as expected using Jest assertions.\n\n**References:**\n- [React Testing Library Docs: Events](https://testing-library.com/docs/dom-testing-library/api-events/)\n- [Jest Docs: Mock Functions](https://jestjs.io/docs/mock-functions)",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225912Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "01e7400f-8193-4ddd-ba3e-c956a5bbc8b2",
      "question": "What is the difference between 'event.currentTarget' and 'event.target' in React?",
      "answer": "```markdown\nIn React (and in the underlying DOM), `event.currentTarget` and `event.target` refer to different elements involved in an event:\n\n- **event.target**: This is the element on which the event originally occurred. It represents the deepest element in the DOM that triggered the event.\n\n- **event.currentTarget**: This is the element on which the event handler is currently attached. In React, this is usually the element you specified the event handler on.\n\n**Example:**\n\n```jsx\nfunction Example() {\n  return (\n    <div onClick={(event) => {\n      console.log('currentTarget:', event.currentTarget);\n      console.log('target:', event.target);\n    }}>\n      <button>Click Me</button>\n    </div>\n  );\n}\n```\n\n- If you click on the `<button>`, `event.target` will be the `<button>`, but `event.currentTarget` will be the `<div>`, since that's where the handler is attached.\n\n**Summary Table:**\n\n| Property           | Description                                           |\n|--------------------|------------------------------------------------------|\n| event.target       | Element where the event originated                   |\n| event.currentTarget| Element where the handler is attached (listener)     |\n\n**In short:**  \n- Use `event.target` to find out which element was interacted with.\n- Use `event.currentTarget` to refer to the element handling the event.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225928Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "2c95ca02-e9a7-4b22-bf81-ad7cf973f8b5",
      "question": "How do you handle multiple events on the same element in React?",
      "answer": "You can handle multiple events on the same element in React by adding multiple event handler props to the element. Each event (like onClick, onMouseOver, onChange, etc.) can have its own handler function. Here’s an example:\n\n```jsx\nimport React from 'react';\n\nfunction MyComponent() {\n  const handleClick = () => {\n    alert('Button clicked!');\n  };\n\n  const handleMouseOver = () => {\n    console.log('Mouse is over the button!');\n  };\n\n  return (\n    <button\n      onClick={handleClick}\n      onMouseOver={handleMouseOver}\n    >\n      Hover or Click Me\n    </button>\n  );\n}\n\nexport default MyComponent;\n```\n\n**Explanation:**\n- `onClick={handleClick}` handles click events.\n- `onMouseOver={handleMouseOver}` handles mouse over events.\n\nYou can add as many event handlers as needed, each for a different event type.",
      "level": "Beginner",
      "created_at": "2025-05-06T15:54:16.225951Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "ebaf828f-a828-4230-8df9-d3de5319bc11",
      "question": "How do you debounce or throttle event handlers in React?",
      "answer": "```markdown\nTo debounce or throttle event handlers in React, you typically use utility functions like `debounce` or `throttle` from libraries such as **lodash** or implement your own. This is especially useful for performance optimization when handling events that can fire rapidly (e.g., `onChange`, `onScroll`, `onResize`).\n\n### Debouncing in React\n\n**Debouncing** ensures that a function is only called after a certain period has elapsed since the last time it was invoked.\n\n**Example using lodash.debounce:**\n\n```jsx\nimport React, { useCallback } from 'react';\nimport debounce from 'lodash.debounce';\n\nfunction SearchInput() {\n  // useCallback ensures the debounced function is not recreated on every render\n  const handleChange = useCallback(\n    debounce((event) => {\n      console.log('Search:', event.target.value);\n    }, 300), // 300ms debounce\n    []\n  );\n\n  // React pools SyntheticEvent, so persist the event or use event.target.value directly\n  const onChange = (event) => {\n    event.persist();\n    handleChange(event);\n  };\n\n  return <input type=\"text\" onChange={onChange} />;\n}\n```\n\n### Throttling in React\n\n**Throttling** ensures that a function is only called at most once in a specified time interval.\n\n**Example using lodash.throttle:**\n\n```jsx\nimport React, { useCallback } from 'react';\nimport throttle from 'lodash.throttle';\n\nfunction ScrollComponent() {\n  const handleScroll = useCallback(\n    throttle((event) => {\n      console.log('Scroll position:', window.scrollY);\n    }, 200), // 200ms throttle\n    []\n  );\n\n  React.useEffect(() => {\n    window.addEventListener('scroll', handleScroll);\n    return () => window.removeEventListener('scroll', handleScroll);\n  }, [handleScroll]);\n\n  return <div style={{ height: '200vh' }}>Scroll down!</div>;\n}\n```\n\n### Key Points\n\n- **Synthetic Events** in React are pooled, so if you need to access the event asynchronously (as in debounced/throttled handlers), call `event.persist()` or extract needed values before passing.\n- Use `useCallback` to memoize the debounced/throttled handler to avoid creating a new function on every render.\n- For simple cases, you can implement your own debounce/throttle logic, but using a library like lodash is recommended for reliability.\n\n**References:**\n- [React Docs: SyntheticEvent](https://react.dev/reference/react-dom/components/common#syntheticevent)\n- [Lodash debounce](https://lodash.com/docs/4.17.15#debounce)\n- [Lodash throttle](https://lodash.com/docs/4.17.15#throttle)\n```\n",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.225967Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "252f1be7-6cf6-4226-b7f9-bc9ec566bb3d",
      "question": "What are pointer events in React and how do you use them?",
      "answer": "```markdown\n## What are Pointer Events in React and How Do You Use Them?\n\n**Pointer events** in React are a set of synthetic events that handle interactions from various input devices such as a mouse, pen, or touch. They provide a unified way to handle user interactions across different device types, making it easier to write device-agnostic event handlers.\n\n### Common Pointer Events in React\n\n- `onPointerDown`\n- `onPointerMove`\n- `onPointerUp`\n- `onPointerEnter`\n- `onPointerLeave`\n- `onPointerOver`\n- `onPointerOut`\n- `onPointerCancel`\n\nThese events correspond to the [Pointer Events API](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events) in the browser.\n\n### Why Use Pointer Events?\n\n- **Unified Handling:** One handler for mouse, touch, and pen input.\n- **Rich Event Data:** Access to properties like `pointerType`, `pressure`, `isPrimary`, etc.\n- **Better for Modern Devices:** Especially useful for touch screens and styluses.\n\n### Example Usage\n\n```jsx\nimport React from 'react';\n\nfunction PointerExample() {\n  const handlePointerDown = (event) => {\n    console.log('Pointer down:', event.pointerType);\n  };\n\n  const handlePointerMove = (event) => {\n    console.log('Pointer move at:', event.clientX, event.clientY);\n  };\n\n  const handlePointerUp = (event) => {\n    console.log('Pointer up');\n  };\n\n  return (\n    <div\n      style={{ width: 200, height: 200, background: '#eee' }}\n      onPointerDown={handlePointerDown}\n      onPointerMove={handlePointerMove}\n      onPointerUp={handlePointerUp}\n    >\n      Interact with me!\n    </div>\n  );\n}\n\nexport default PointerExample;\n```\n\n### Notes\n\n- Pointer events are supported in React 16.4 and above.\n- They work similarly to other React synthetic events.\n- Always check browser compatibility if you need to support older browsers.\n\n**In summary:** Pointer events in React let you handle input from mouse, touch, and pen devices in a unified way, making your components more flexible and future-proof.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225982Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "93aade8f-fac9-4722-bfd4-ccc24e77f0af",
      "question": "How do you handle drag and drop events in React?",
      "answer": "To handle drag and drop events in React, you use the Synthetic Event system, which wraps the browser’s native drag and drop events. The most commonly used events are:\n\n- onDragStart\n- onDragOver\n- onDrop\n- onDragEnter\n- onDragLeave\n- onDragEnd\n\nHere’s a basic example of implementing drag and drop in React:\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction DragAndDropExample() {\n  const [dropped, setDropped] = useState(false);\n\n  // Handler for drag start\n  const handleDragStart = (e) => {\n    e.dataTransfer.setData('text/plain', 'This is a draggable item');\n  };\n\n  // Handler for drag over (must prevent default to allow drop)\n  const handleDragOver = (e) => {\n    e.preventDefault();\n  };\n\n  // Handler for drop\n  const handleDrop = (e) => {\n    e.preventDefault();\n    setDropped(true);\n    // You can access data with e.dataTransfer.getData('text')\n  };\n\n  return (\n    <div>\n      <div\n        draggable\n        onDragStart={handleDragStart}\n        style={{\n          width: '150px',\n          height: '50px',\n          backgroundColor: '#90caf9',\n          marginBottom: '20px',\n          textAlign: 'center',\n          lineHeight: '50px',\n          cursor: 'grab'\n        }}\n      >\n        Drag me!\n      </div>\n      <div\n        onDragOver={handleDragOver}\n        onDrop={handleDrop}\n        style={{\n          width: '200px',\n          height: '100px',\n          backgroundColor: dropped ? '#a5d6a7' : '#eeeeee',\n          border: '2px dashed #90caf9',\n          textAlign: 'center',\n          lineHeight: '100px'\n        }}\n      >\n        {dropped ? 'Dropped!' : 'Drop here'}\n      </div>\n    </div>\n  );\n}\n\nexport default DragAndDropExample;\n```\n\n**Key Points:**\n- Use the draggable attribute on the element you want to drag.\n- Use onDragStart to initiate the drag and set data if needed.\n- Use onDragOver on the drop target and call e.preventDefault() to allow dropping.\n- Use onDrop to handle the drop logic.\n- Optionally, use onDragEnter, onDragLeave, and onDragEnd for additional UI feedback.\n\nReact’s Synthetic Events ensure cross-browser compatibility and consistent event handling.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.225996Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "48914bbf-9d47-4846-83e5-76e869a3ccc0",
      "question": "How do you distinguish between synthetic and native events in React?",
      "answer": "```markdown\nIn React, **synthetic events** are React's cross-browser wrapper around the browser's native events. They normalize events so that they have consistent properties across different browsers.\n\n### Distinguishing Between Synthetic and Native Events\n\n1. **Accessing the Event Object:**\n   - In a React event handler, the event object you receive is a **SyntheticEvent**.\n   - Example:\n     ```jsx\n     function handleClick(event) {\n       // event is a SyntheticEvent\n     }\n     ```\n\n2. **Accessing the Native Event:**\n   - Every SyntheticEvent has a `nativeEvent` property that references the underlying browser event.\n   - Example:\n     ```jsx\n     function handleClick(event) {\n       // Synthetic event\n       console.log(event); // SyntheticEvent\n       // Native event\n       console.log(event.nativeEvent); // Native browser event\n     }\n     ```\n\n3. **Instance Type:**\n   - You can check the type of the event:\n     ```jsx\n     function handleClick(event) {\n       console.log(event instanceof SyntheticEvent); // true\n       console.log(event.nativeEvent instanceof MouseEvent); // true for mouse events\n     }\n     ```\n   - Note: You may need to import `SyntheticEvent` from `react` for type checking in TypeScript.\n\n4. **Event Pooling (React < 17):**\n   - In React versions before 17, SyntheticEvents were pooled and reused for performance. Accessing properties asynchronously could lead to unexpected results. Native events are not pooled.\n   - In React 17+, event pooling is removed.\n\n5. **Properties:**\n   - SyntheticEvent mimics the native event interface, but may have additional React-specific properties (e.g., `persist()` method).\n\n### Summary Table\n\n|                | Synthetic Event (`event`) | Native Event (`event.nativeEvent`) |\n|----------------|--------------------------|------------------------------------|\n| Origin         | React                    | Browser                            |\n| Consistency    | Cross-browser            | Browser-specific                   |\n| Extra Methods  | `persist()`              | No                                 |\n| Access         | Handler param            | `event.nativeEvent`                |\n\n### Example\n\n```jsx\nfunction MyButton() {\n  function handleClick(e) {\n    // Synthetic event\n    console.log('Synthetic:', e);\n    // Native event\n    console.log('Native:', e.nativeEvent);\n  }\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**In summary:**  \n- The event object passed to React event handlers is a SyntheticEvent.\n- The native browser event is accessible via the `nativeEvent` property of the SyntheticEvent.\n```\n",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226012Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "ef3e5c2a-3127-445c-9ebf-c6c93e7ba519",
      "question": "How do you use React synthetic events with portals?",
      "answer": "### Using React Synthetic Events with Portals\n\nReact’s [portals](https://react.dev/reference/react-dom/createPortal) allow you to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This can raise questions about event handling, especially with React’s [synthetic event system](https://react.dev/reference/react/SyntheticEvent).\n\n#### How Synthetic Events Work with Portals\n\nReact’s synthetic event system uses event delegation: it attaches a single event listener to the root of the React tree (typically the element where you call `ReactDOM.render`). When an event occurs, React creates a synthetic event and calls the appropriate handlers.\n\n**With portals:**\n- Even though the portal’s DOM nodes are outside the parent component’s DOM hierarchy, events from portal children still propagate through the React component tree as if they were descendants.\n- This means you can handle events from portal content in parent components using React’s synthetic event system.\n\n#### Example\n\n```jsx\nimport React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction Modal({ onClose }) {\n  return ReactDOM.createPortal(\n    <div className=\"modal\" onClick={onClose}>\n      <p>Click anywhere in this modal to close it.</p>\n    </div>,\n    document.getElementById('modal-root')\n  );\n}\n\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n\n  const handleModalClose = (e) => {\n    alert('Modal clicked!');\n    setShowModal(false);\n  };\n\n  return (\n    <div onClick={() => alert('App clicked!')}>\n      <button onClick={() => setShowModal(true)}>Open Modal</button>\n      {showModal && <Modal onClose={handleModalClose} />}\n    </div>\n  );\n}\n```\n\n#### Key Points\n\n- **Event Bubbling:** Events from portal children bubble up to React parents as if the portal content was part of the parent’s DOM subtree.\n- **Synthetic Events:** You can use React’s synthetic event handlers (`onClick`, `onChange`, etc.) on portal content, and they’ll work as expected.\n- **Native Event Listeners:** If you add native event listeners (e.g., with `addEventListener`), they follow the DOM hierarchy, not the React component tree.\n\n#### Caveats\n\n- **Stop Propagation:** Calling `e.stopPropagation()` in a portal child’s event handler will prevent the event from bubbling up to React parents, just as in normal React trees.\n- **Event Target:** The event target will be the actual DOM node where the event occurred, even if it’s outside the parent’s DOM subtree.\n\n#### References\n\n- [React Docs: Portals](https://react.dev/reference/react-dom/createPortal)\n- [React Docs: SyntheticEvent](https://react.dev/reference/react/SyntheticEvent)\n\n---\n\n**Summary:**  \nReact synthetic events work seamlessly with portals. Events from portal content bubble through the React component tree, allowing parent components to handle them as if the portal content was a direct child. This maintains a consistent event handling model across your app, even when using portals.",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226034Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "30226e5d-00cb-4e35-91e8-f68b90097a33",
      "question": "How does React handle event listeners in strict mode or concurrent mode?",
      "answer": "React handles event listeners differently in Strict Mode and Concurrent Mode to ensure consistency, performance, and reliability, especially as it prepares for features like time-slicing and interruptible rendering.\n\n### 1. Event Delegation\n\nReact uses a **single event listener** at the root of the document for most events (like `click`, `input`, etc.). When an event occurs, React's synthetic event system determines which component(s) should receive the event, and then calls the appropriate event handlers.\n\n### 2. Strict Mode\n\n- **Double Invocations:** In React Strict Mode (development only), React intentionally double-invokes certain lifecycle methods and effects (including event handlers in some cases) to help identify side effects and ensure code is resilient.\n- **Event Listeners:** The way event listeners are attached and managed does not fundamentally change in Strict Mode, but you may see handlers invoked more than once during development to surface potential issues.\n\n### 3. Concurrent Mode\n\n- **Event Batching:** In Concurrent Mode, React can pause, abort, or restart renders. To maintain consistency, React batches updates triggered by events, ensuring state updates are processed together.\n- **Event Replay:** If a user interacts with the UI during an interrupted render, React can \"replay\" the event after the render is complete, ensuring the event is handled with the latest state.\n- **Non-blocking Events:** React may delay or interrupt event processing to keep the UI responsive. This means event handlers might not run immediately but are guaranteed to run in the correct order with the correct state.\n\n### 4. Summary Table\n\n| Mode             | Event Listener Attachment | Handler Invocation | Special Behaviors                      |\n|------------------|--------------------------|-------------------|----------------------------------------|\n| Normal           | Delegated at root        | Once per event    | Standard synthetic event system        |\n| Strict Mode      | Delegated at root        | May be double-invoked in dev | Helps detect side effects      |\n| Concurrent Mode  | Delegated at root        | Batched, may be replayed     | Supports interruptible rendering, event replay |\n\n### 5. Key Takeaways\n\n- **React manages event listeners centrally** for performance and consistency.\n- **Strict Mode** may invoke handlers more than once to help catch bugs.\n- **Concurrent Mode** enables advanced features like event replay and batching to support interruptible rendering and maintain UI consistency.\n\n**References:**\n- [React Docs: Synthetic Events](https://react.dev/reference/react-dom/components/common#synthetic-events)\n- [React Docs: Strict Mode](https://react.dev/reference/react/StrictMode)\n- [React Docs: Concurrent Rendering](https://react.dev/learn/synchronizing-with-effects#concurrent-rendering)",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226050Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "1011517e-dc2f-41a3-8d3a-55eecb29a687",
      "question": "How can you optimize event handler performance in large React applications?",
      "answer": "Optimizing Event Handler Performance in Large React Applications\n----------------------------------------------------------------\n\nWhen building large React applications, inefficient event handling can lead to unnecessary re-renders, memory leaks, and sluggish UI performance. Here are advanced strategies to optimize event handler performance:\n\n### 1. Use `useCallback` to Memoize Handlers\n\nReact components re-create functions on every render. Use the `useCallback` hook to memoize event handlers and prevent unnecessary re-renders, especially when passing handlers to child components.\n\n```jsx\nconst handleClick = useCallback(() => {\n  // handler logic\n}, [/* dependencies */]);\n```\n\n### 2. Avoid Inline Functions in JSX\n\nDefining handlers inline (e.g., `<button onClick={() => doSomething()}>`) creates a new function on every render. Instead, define handlers outside of JSX or use `useCallback`.\n\n```jsx\n// Bad\n<button onClick={() => doSomething()} />\n\n// Good\n<button onClick={handleClick} />\n```\n\n### 3. Delegate Events When Appropriate\n\nFor lists or large DOM trees, use event delegation by attaching a single event handler to a parent element and determining the target in the handler. This reduces the number of event listeners.\n\n```jsx\nfunction List({ items }) {\n  const handleClick = (e) => {\n    const id = e.target.getAttribute('data-id');\n    // handle item click\n  };\n\n  return (\n    <ul onClick={handleClick}>\n      {items.map(item => (\n        <li key={item.id} data-id={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### 4. Use Stable References for Handlers Passed to Memoized Components\n\nIf you use `React.memo` or `PureComponent`, ensure event handler references are stable to prevent unnecessary re-renders.\n\n```jsx\nconst MemoizedButton = React.memo(({ onClick }) => (\n  <button onClick={onClick}>Click</button>\n));\n\n// In parent:\nconst handleClick = useCallback(() => { /* ... */ }, []);\n<MemoizedButton onClick={handleClick} />\n```\n\n### 5. Remove Unnecessary Listeners\n\nClean up event listeners in `useEffect` or component lifecycle methods to prevent memory leaks.\n\n```jsx\nuseEffect(() => {\n  window.addEventListener('resize', handleResize);\n  return () => window.removeEventListener('resize', handleResize);\n}, []);\n```\n\n### 6. Throttle or Debounce High-Frequency Events\n\nFor events like `scroll` or `resize`, use throttling or debouncing to limit handler execution frequency.\n\n```jsx\nconst throttledHandler = useMemo(() => throttle(handleScroll, 200), []);\n```\n\n### 7. Prefer Functional Updates for State\n\nWhen updating state based on the previous state in event handlers, use functional updates to avoid stale closures.\n\n```jsx\nsetCount(prevCount => prevCount + 1);\n```\n\n---\n\n**Summary Table**\n\n| Technique                | Benefit                                      |\n|--------------------------|----------------------------------------------|\n| `useCallback`            | Prevents unnecessary re-renders              |\n| Avoid inline handlers    | Reduces function re-creation                 |\n| Event delegation         | Fewer event listeners, better performance    |\n| Stable handler refs      | Works with memoized components               |\n| Cleanup listeners        | Prevents memory leaks                        |\n| Throttle/debounce        | Optimizes high-frequency events              |\n| Functional state updates | Avoids stale closures                        |\n\n---\n\n**References:**\n- [React Docs: Optimizing Performance](https://react.dev/learn/optimizing-performance)\n- [React Docs: Synthetic Events](https://react.dev/reference/react-dom/components/common#events)\n- [Kent C. Dodds: How to optimize your React app performance](https://kentcdodds.com/blog/how-to-optimize-your-react-app-performance)",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226066Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "68225348-d6d5-4eb1-8bb0-0314710fa5d5",
      "question": "What are the security considerations when handling events in React?",
      "answer": "### Security Considerations When Handling Events in React\n\nWhen handling events in React using Synthetic Events, it's crucial to be aware of several security considerations to prevent vulnerabilities such as Cross-Site Scripting (XSS), data leaks, and privilege escalation. Here are the key points:\n\n#### 1. **Avoid Direct DOM Manipulation**\n- **Risk:** Bypassing React's virtual DOM and manipulating the DOM directly (e.g., via `document.getElementById`) can introduce XSS vulnerabilities and make your application harder to audit.\n- **Best Practice:** Always use React's state and props to update the UI.\n\n#### 2. **Sanitize User Input**\n- **Risk:** Event handlers often process user input (e.g., from forms). Unsanitized input can be used to inject malicious scripts.\n- **Best Practice:** Always sanitize and validate user input before using it, especially if rendering it as HTML or sending it to a server.\n\n#### 3. **Avoid Using `dangerouslySetInnerHTML`**\n- **Risk:** Using `dangerouslySetInnerHTML` in event handlers can expose your app to XSS if the HTML is not properly sanitized.\n- **Best Practice:** Only use `dangerouslySetInnerHTML` with trusted, sanitized content.\n\n#### 4. **Do Not Trust Event Data**\n- **Risk:** Event objects (e.g., `event.target.value`) can be manipulated by malicious users.\n- **Best Practice:** Treat all event data as untrusted and validate it before processing.\n\n#### 5. **Prevent Event Bubbling When Necessary**\n- **Risk:** Sensitive actions (like delete or update) can be unintentionally triggered by event bubbling.\n- **Best Practice:** Use `event.stopPropagation()` or `event.preventDefault()` judiciously to control event flow.\n\n#### 6. **Avoid Inline Event Handlers with User Data**\n- **Risk:** Inline event handlers that interpolate user data can introduce XSS vulnerabilities.\n- **Best Practice:** Do not inject user data directly into event handler attributes.\n\n#### 7. **Least Privilege Principle**\n- **Risk:** Event handlers that perform privileged actions (e.g., admin operations) can be abused if not properly protected.\n- **Best Practice:** Ensure that sensitive event handlers check for proper authentication and authorization.\n\n#### 8. **Beware of Third-Party Libraries**\n- **Risk:** Third-party event handlers or components may not follow best security practices.\n- **Best Practice:** Audit third-party code and keep dependencies up to date.\n\n---\n\n#### **Summary Table**\n\n| Risk Area                        | Best Practice                                  |\n|-----------------------------------|------------------------------------------------|\n| Direct DOM Manipulation           | Use React state/props                          |\n| Unsanitized User Input            | Sanitize and validate input                    |\n| `dangerouslySetInnerHTML`         | Avoid or sanitize content                      |\n| Trusting Event Data               | Always validate event data                     |\n| Event Bubbling                    | Control with stopPropagation/preventDefault    |\n| Inline Handlers with User Data    | Never interpolate user data directly           |\n| Privileged Actions                | Check authentication/authorization             |\n| Third-Party Libraries             | Audit and update dependencies                  |\n\n---\n\n**In summary:**  \nAlways treat event data as untrusted, avoid direct DOM manipulation, and ensure all user input is sanitized and validated. Follow the principle of least privilege and be cautious with third-party code to maintain a secure React application.",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226081Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "0fa73e54-0df0-47d1-a0a9-78d56c5d951e",
      "question": "How do you handle accessibility-related events in React?",
      "answer": "Handling Accessibility-Related Events in React\n---\n\nIn React, ensuring your application is accessible involves more than just handling standard mouse and keyboard events. You should consider accessibility-related events and best practices to make your components usable by everyone, including those using assistive technologies.\n\n### Common Accessibility-Related Events\n\n- **onFocus / onBlur**: Triggered when an element gains or loses focus. Useful for managing focus indicators or announcing changes to screen readers.\n- **onKeyDown / onKeyUp / onKeyPress**: Capture keyboard interactions, which are crucial for users who navigate via keyboard.\n- **onMouseEnter / onMouseLeave**: Can be used, but should always have keyboard-accessible alternatives.\n- **onChange**: For form elements, to notify assistive tech of value changes.\n\n### Example: Accessible Button Component\n\n```jsx\nfunction AccessibleButton({ onClick, children }) {\n  // Handles both click and keyboard activation (Enter/Space)\n  const handleKeyDown = (event) => {\n    if (event.key === 'Enter' || event.key === ' ') {\n      onClick(event);\n    }\n  };\n\n  return (\n    <div\n      role=\"button\"\n      tabIndex={0}\n      onClick={onClick}\n      onKeyDown={handleKeyDown}\n      onFocus={() => console.log('Button focused')}\n      onBlur={() => console.log('Button blurred')}\n      aria-pressed=\"false\"\n      style={{ cursor: 'pointer', padding: '8px', border: '1px solid #ccc' }}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n### Best Practices\n\n- **Use Semantic HTML**: Prefer `<button>`, `<a>`, and other semantic elements when possible, as they have built-in accessibility.\n- **Keyboard Support**: Always ensure interactive elements are accessible via keyboard.\n- **ARIA Attributes**: Use ARIA roles and properties (like `aria-pressed`, `aria-label`) to provide additional context.\n- **Announce Changes**: Use `aria-live` regions or similar techniques to announce dynamic content changes.\n\n### Resources\n\n- [React Accessibility Docs](https://react.dev/reference/react-dom/components/common#accessibility)\n- [MDN: ARIA roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles)\n\nBy thoughtfully handling events and following accessibility best practices, you can create React applications that are inclusive and usable by all users.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.226098Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "0d55371e-193f-4685-998f-68914639738b",
      "question": "Can you use passive event listeners with React synthetic events?",
      "answer": "No, you cannot use passive event listeners with React synthetic events.\n\nReact's synthetic event system wraps native browser events in a cross-browser wrapper and manages event delegation internally. When you attach an event handler in React (e.g., onScroll, onWheel), React does not expose an API to specify options like { passive: true } on these synthetic events.\n\nIf you need to use passive event listeners (for example, to improve scroll performance), you must attach the event listener directly to the DOM node using addEventListener:\n\n```jsx\nimport { useEffect, useRef } from \"react\";\n\nfunction MyComponent() {\n  const divRef = useRef(null);\n\n  useEffect(() => {\n    const node = divRef.current;\n    const handler = (e) => {\n      // handle scroll\n    };\n    node.addEventListener(\"scroll\", handler, { passive: true });\n\n    return () => {\n      node.removeEventListener(\"scroll\", handler);\n    };\n  }, []);\n\n  return <div ref={divRef}>Scrollable content</div>;\n}\n```\n\n**Summary:**  \nReact synthetic events do not support passive event listeners. Use native DOM event listeners if you need passive: true.",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226114Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "ffe852f8-d8b7-484b-98f8-43a84d9071a0",
      "question": "How do you handle clipboard events in React?",
      "answer": "To handle clipboard events in React, you use the onCopy, onCut, and onPaste event handlers provided by React’s SyntheticEvent system. These handlers can be attached to input fields, textareas, or other elements that support clipboard operations.\n\nHere’s an example of handling clipboard events in a React component:\n\n```jsx\nimport React from 'react';\n\nfunction ClipboardExample() {\n  const handleCopy = (event) => {\n    alert('Text copied!');\n    // You can access the copied text with event.clipboardData\n  };\n\n  const handleCut = (event) => {\n    alert('Text cut!');\n    // You can access the cut text with event.clipboardData\n  };\n\n  const handlePaste = (event) => {\n    const pastedText = event.clipboardData.getData('text');\n    alert(`Pasted text: ${pastedText}`);\n    // You can manipulate the pasted text or prevent the default paste\n    // event.preventDefault();\n  };\n\n  return (\n    <textarea\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onPaste={handlePaste}\n      placeholder=\"Try copying, cutting, or pasting here\"\n      rows={4}\n      cols={40}\n    />\n  );\n}\n\nexport default ClipboardExample;\n```\n\n**Key Points:**\n- React normalizes clipboard events as SyntheticEvents.\n- The event object provides access to clipboard data via event.clipboardData.\n- You can use event.preventDefault() to override the default clipboard behavior if needed.\n\n**Supported Clipboard Events in React:**\n- `onCopy`\n- `onCut`\n- `onPaste`",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.226130Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "d5e92722-e7e1-40d7-8e26-beaea51fc7e2",
      "question": "How do you handle composition events for input methods in React?",
      "answer": "```markdown\n### Handling Composition Events for Input Methods in React\n\nWhen dealing with input methods such as Chinese, Japanese, or Korean IMEs (Input Method Editors), React's standard `onChange` event can fire before the user has finished composing their input. This can lead to issues like prematurely updating state or validating incomplete input.\n\n#### Key Composition Events in React\n\nReact supports the following composition events:\n\n- `onCompositionStart`: Fired when composition starts.\n- `onCompositionUpdate`: Fired when the composition is updated.\n- `onCompositionEnd`: Fired when composition ends.\n\n#### Best Practice: Deferring `onChange` Handling\n\nTo handle input correctly, you should track whether composition is in progress and only process the `onChange` event when composition has ended.\n\n#### Example Implementation\n\n```jsx\nimport React, { useState, useRef } from 'react';\n\nfunction InputWithIME() {\n  const [value, setValue] = useState('');\n  const isComposing = useRef(false);\n\n  const handleComposition = (e) => {\n    if (e.type === 'compositionstart') {\n      isComposing.current = true;\n    }\n    if (e.type === 'compositionend') {\n      isComposing.current = false;\n      // After composition ends, handle the final input value\n      setValue(e.target.value);\n    }\n  };\n\n  const handleChange = (e) => {\n    if (!isComposing.current) {\n      setValue(e.target.value);\n    }\n    // If composing, do not update state yet\n  };\n\n  return (\n    <input\n      value={value}\n      onChange={handleChange}\n      onCompositionStart={handleComposition}\n      onCompositionUpdate={handleComposition}\n      onCompositionEnd={handleComposition}\n    />\n  );\n}\n```\n\n#### Explanation\n\n- **Track composition state:** Use a ref (`isComposing`) to track whether the user is currently composing input.\n- **Defer state updates:** Only update the state (`setValue`) when not composing, or when composition ends.\n- **Why this matters:** This prevents issues such as incomplete or invalid input being processed during IME composition.\n\n#### References\n\n- [React Docs: SyntheticEvent](https://react.dev/reference/react-dom/components/input#handling-composition-events)\n- [MDN: Composition Events](https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event)\n```\n",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226146Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "1bdd45d9-4a4d-4a12-a678-8fd4f47be1f7",
      "question": "What happens to synthetic events when a component unmounts?",
      "answer": "When a React component unmounts, all synthetic events attached to elements within that component are automatically cleaned up by React. This means:\n\n- **Event listeners are removed:** React detaches any event handlers associated with the unmounted component’s DOM nodes.\n- **Memory leaks are prevented:** Since event handlers are cleaned up, there’s no risk of memory leaks due to lingering references.\n- **No further event handling:** Synthetic events will not fire for unmounted components, even if the DOM nodes still exist temporarily.\n\n**Example:**\n\n```jsx\nfunction Example() {\n  useEffect(() => {\n    // Setup logic\n    return () => {\n      // Cleanup logic runs on unmount\n    };\n  }, []);\n\n  function handleClick(e) {\n    // Synthetic event handler\n    console.log('Clicked!');\n  }\n\n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\nWhen the `Example` component unmounts, React ensures that `handleClick` is no longer attached to the button, and the synthetic event system will not process events for it.\n\n**Summary Table**\n\n| Action                   | React’s Behavior                   |\n|--------------------------|------------------------------------|\n| Component unmounts       | Synthetic events are cleaned up    |\n| Event handler references | Automatically removed              |\n| Memory leaks             | Prevented by React’s cleanup       |\n\n**Note:** If you attach native DOM event listeners manually (e.g., `element.addEventListener`), you must clean those up yourself in `useEffect` cleanup functions.",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.226165Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "e7fc7812-dd56-4ed6-917e-d7dc8a37d0a1",
      "question": "How do you handle event bubbling in nested React components?",
      "answer": "```markdown\nIn React, event bubbling occurs when an event triggered on a child element propagates up to its parent elements. To handle event bubbling in nested components, you can:\n\n1. **Stop Propagation:**  \n   Use `event.stopPropagation()` in your event handler to prevent the event from bubbling up to parent components.\n\n   ```jsx\n   function ChildComponent() {\n     const handleClick = (event) => {\n       event.stopPropagation();\n       // Child-specific logic\n     };\n\n     return <button onClick={handleClick}>Click Me</button>;\n   }\n   ```\n\n2. **Conditional Logic in Parent:**  \n   In the parent component, you can check the source of the event or use flags to determine if the event should be handled.\n\n   ```jsx\n   function ParentComponent() {\n     const handleParentClick = (event) => {\n       // Parent-specific logic\n     };\n\n     return (\n       <div onClick={handleParentClick}>\n         <ChildComponent />\n       </div>\n     );\n   }\n   ```\n\n3. **Event Delegation:**  \n   Sometimes, you might want to allow bubbling for certain cases. In such scenarios, you can use event delegation and inspect `event.target` or `event.currentTarget` to decide how to handle the event.\n\n**Summary:**  \nTo control event bubbling in nested React components, use `event.stopPropagation()` in child handlers or add conditional logic in parent handlers to manage how events are processed.\n```\n",
      "level": "Intermediate",
      "created_at": "2025-05-06T15:54:16.226180Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  },
  {
      "id": "a903cb73-90b4-4834-bfae-fdcb575f8416",
      "question": "How do you use event modifiers (like once, capture) in React?",
      "answer": "In React, you don't use event modifiers like once or capture as you might in Vue or plain HTML. Instead, React provides a declarative way to handle events using props, and you can achieve similar behaviors programmatically.\n\n### 1. **Handling `once` (Run Handler Only Once)**\n\nReact doesn't have a built-in `once` modifier, but you can implement it yourself:\n\n```jsx\nimport { useState } from 'react';\n\nfunction OnceButton() {\n  const [clicked, setClicked] = useState(false);\n\n  function handleClick() {\n    if (!clicked) {\n      alert('Button clicked!');\n      setClicked(true);\n    }\n  }\n\n  return (\n    <button onClick={handleClick} disabled={clicked}>\n      Click me once\n    </button>\n  );\n}\n```\n\nOr, for a one-off event, you can remove the handler after the first call:\n\n```jsx\nfunction OnceButton() {\n  function handleClick(e) {\n    alert('Clicked once!');\n    e.target.onclick = null; // Removes the handler\n  }\n\n  return <button onClick={handleClick}>Click me once</button>;\n}\n```\n\n### 2. **Handling `capture` (Event Capturing Phase)**\n\nReact supports the capture phase by using the `Capture` suffix in event prop names:\n\n```jsx\nfunction CaptureExample() {\n  function handleClickCapture() {\n    console.log('Captured on parent');\n  }\n\n  function handleClick() {\n    console.log('Bubbled on child');\n  }\n\n  return (\n    <div onClickCapture={handleClickCapture}>\n      <button onClick={handleClick}>Click me</button>\n    </div>\n  );\n}\n```\n\n- `onClickCapture` fires during the capture phase.\n- `onClick` fires during the bubble phase.\n\n### 3. **Summary Table**\n\n| Modifier | React Equivalent                |\n|----------|---------------------------------|\n| `once`   | Custom logic in handler/state   |\n| `capture`| Use `onEventCapture` prop       |\n\n### 4. **References**\n\n- [React Docs: SyntheticEvent](https://react.dev/reference/react-dom/components/common#events)\n- [React Docs: Event Delegation](https://react.dev/learn/responding-to-events#event-propagation)\n\n---\n\n**In summary:**  \nReact does not use event modifiers in the template. Use `onEventCapture` for capture phase, and implement `once` behavior with state or custom logic.",
      "level": "Advanced",
      "created_at": "2025-05-06T15:54:16.226195Z",
      "topic": "cdb2d752-18d5-4337-81d3-111ac74d3c44"
  }
]
