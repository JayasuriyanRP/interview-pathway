[
    {
        "id": "c622488e-3856-495a-a0e0-5e0390471907",
        "question": "What is a syntax error in C programming?",
        "answer": "A **syntax error** in C programming occurs when the code violates the rules and structure defined by the C language. These errors are detected by the compiler and prevent the program from compiling successfully.\n\n**Examples of syntax errors:**\n```c\nint main() {\n    printf(\"Hello, world!\") // Missing semicolon\n    return 0;\n}\n```\n\n**Explanation:**  \nIn the example above, the missing semicolon (`;`) after the `printf` statement is a syntax error. The compiler will generate an error message indicating the mistake.\n\n**Key Points:**\n- Syntax errors must be fixed before the program can run.\n- Common causes include missing semicolons, unmatched parentheses or braces, misspelled keywords, and incorrect use of operators.",
        "level": "Beginner"
    },
    {
        "id": "105720a1-db5f-4d19-b834-d3e0e083321f",
        "question": "How do you declare and initialize an array in C?",
        "answer": "To declare and initialize an array in C, you specify the data type, the array name, and the number of elements in square brackets. You can also assign initial values using curly braces.\n\n**Syntax:**\n\n```c\n// Declaration only (uninitialized)\nint numbers[5];\n\n// Declaration with initialization\nint numbers[5] = {1, 2, 3, 4, 5};\n```\n\n**Example:**\n\n```c\n#include <stdio.h>\n\nint main() {\n    // Declare and initialize an array of 3 integers\n    int values[3] = {10, 20, 30};\n\n    // Print array elements\n    for(int i = 0; i < 3; i++) {\n        printf(\"%d\\n\", values[i]);\n    }\n\n    return 0;\n}\n```\n\n**Notes:**\n- If you initialize fewer elements than the size, the remaining elements are set to zero.\n- You can omit the size if you provide the initial values:  \n  ```c\n  int numbers[] = {1, 2, 3};\n  ```",
        "level": "Beginner"
    },
    {
        "id": "d4d8c189-32a0-4a04-99e2-c471bece3693",
        "question": "What is the purpose of the return statement in C?",
        "answer": "The **return** statement in C is used to:\n\n- **Exit a function:** When the return statement is executed, the function terminates immediately.\n- **Send a value back:** If the function is designed to return a value (for example, int, float, etc.), the return statement specifies what value should be sent back to the calling code.\n\n**Example:**\n\n```c\nint add(int a, int b) {\n    return a + b; // returns the sum of a and b\n}\n```\n\nIn the example above, the return statement sends the result of a + b back to wherever the add function was called. If a function has a void return type, return can be used without a value just to exit the function early.",
        "level": "Beginner"
    },
    {
        "id": "5a62ecbc-b7e7-4df8-a592-ed659075a218",
        "question": "How do you write a for loop in C?",
        "answer": "Here's how you write a for loop in C:\n\n```c\n#include <stdio.h>\n\nint main() {\n    int i;\n    // This for loop prints numbers from 1 to 5\n    for (i = 1; i <= 5; i++) {\n        printf(\"%d\\n\", i);\n    }\n    return 0;\n}\n```\n\n**Explanation:**\n\n- The for loop has three parts: initialization (`i = 1`), condition (`i <= 5`), and increment (`i++`).\n- The loop will run as long as the condition is true.\n- Each time the loop runs, `i` increases by 1.\n- The code inside the loop (`printf(\"%d\\n\", i);`) is executed each time.",
        "level": "Beginner"
    },
    {
        "id": "73d493ee-efa7-4e7c-9304-56a103e8ca3e",
        "question": "How do you define a function in C?",
        "answer": "In C, a function is defined using the following syntax:\n\n```c\nreturn_type function_name(parameter_list) {\n    // function body\n    // statements\n    return value; // if return_type is not void\n}\n```\n\n**Example:**\n\n```c\n#include <stdio.h>\n\n// Function definition\nint add(int a, int b) {\n    int sum = a + b;\n    return sum;\n}\n\nint main() {\n    int result = add(5, 3);\n    printf(\"Sum: %d\\n\", result);\n    return 0;\n}\n```\n\n**Explanation:**\n\n- **return_type**: The type of value the function returns (e.g., int, void, float).\n- **function_name**: The name you give to the function.\n- **parameter_list**: The variables passed to the function (can be empty).\n- **function body**: The block of code that defines what the function does.\n\n**Note:** If the function does not return a value, use void as the return type.",
        "level": "Intermediate"
    },
    {
        "id": "4aaf9d13-e6d4-4ad1-8a8c-c4b5c3db25dc",
        "question": "What is the scope of a variable declared inside a function?",
        "answer": "In C, a variable declared inside a function is called a **local variable**. The scope of a local variable is limited to the block (usually the function body) in which it is declared. This means:\n\n- The variable can only be accessed and used within that function.\n- It is created (allocated) when the function is called and destroyed (deallocated) when the function exits.\n- It cannot be accessed outside the function.\n\n**Example:**\n\n```c\n#include <stdio.h>\n\nvoid myFunction() {\n    int localVar = 10; // localVar is only accessible within myFunction\n    printf(\"%d\\n\", localVar);\n}\n\nint main() {\n    // printf(\"%d\\n\", localVar); // Error: localVar is not visible here\n    myFunction();\n    return 0;\n}\n```\n\n**Summary:**  \nA variable declared inside a function has **local scope**—it is only accessible within that function.",
        "level": "Intermediate"
    },
    {
        "id": "40f6f53e-b37c-40d3-83f2-eced9f172810",
        "question": "What is the difference between pre-increment and post-increment operators?",
        "answer": "```markdown\n**Difference between Pre-increment and Post-increment Operators in C**\n\nIn C, the increment operator (`++`) can be used in two ways: **pre-increment** and **post-increment**.\n\n### Pre-increment (`++variable`)\n- The variable is **incremented first**, then its value is used in the expression.\n- Example:\n  ```c\n  int a = 5;\n  int b = ++a; // a becomes 6, then b is assigned 6\n  ```\n\n### Post-increment (`variable++`)\n- The variable's **current value is used first**, then it is incremented.\n- Example:\n  ```c\n  int a = 5;\n  int b = a++; // b is assigned 5, then a becomes 6\n  ```\n\n### Summary Table\n\n| Operator    | When is increment done? | Value used in expression |\n|-------------|------------------------|-------------------------|\n| ++variable  | Before expression      | New (incremented) value |\n| variable++  | After expression       | Original value          |\n\n**In short:**  \n- **Pre-increment:** Increment, then use.\n- **Post-increment:** Use, then increment.\n```",
        "level": "Beginner"
    },
    {
        "id": "31519e22-3253-4a7c-954c-2919a8e7498c",
        "question": "What is the purpose of the main() function in a C program?",
        "answer": "The `main()` function is the entry point of every C program. When a C program is executed, the execution starts from the `main()` function. It is where the program begins and typically contains the instructions that define what the program does.\n\n**Example:**\n```c\n#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n```\n\n**Key Points:**\n- Every C program must have a `main()` function.\n- The `main()` function can return an integer value (commonly `0` to indicate successful execution).\n- Without a `main()` function, the program will not run.",
        "level": "Beginner"
    },
    {
        "id": "ed111965-278d-44a2-8c07-86462013eba7",
        "question": "How do you declare an integer variable in C?",
        "answer": "To declare an integer variable in C, use the int keyword followed by the variable name and a semicolon. For example:\n\n```c\nint number;\n```\n\nThis statement declares a variable named number that can store integer values.",
        "level": "Beginner"
    },
    {
        "id": "a9394e6b-c816-43fc-80fe-b4f5d7761a43",
        "question": "What is the difference between printf() and scanf() functions?",
        "answer": "```markdown\nThe `printf()` and `scanf()` functions are both standard input/output functions in C, but they serve different purposes:\n\n- **printf()**: This function is used to display (print) output to the screen. You use it to show messages, numbers, or results to the user.\n\n  **Example:**\n  ```c\n  printf(\"Hello, World!\\n\");\n  ```\n\n- **scanf()**: This function is used to read (scan) input from the user. You use it to get values from the keyboard and store them in variables.\n\n  **Example:**\n  ```c\n  int number;\n  scanf(\"%d\", &number);\n  ```\n\n**Summary Table:**\n\n| Function   | Purpose          | Direction | Example Usage             |\n|------------|------------------|-----------|--------------------------|\n| printf()   | Output to screen | Output    | printf(\"Hello\");         |\n| scanf()    | Input from user  | Input     | scanf(\"%d\", &number);    |\n```\n",
        "level": "Beginner"
    },
    {
        "id": "5186fa4c-a2b3-49cb-93dd-fa9251648dd5",
        "question": "How do you write a single-line comment in C?",
        "answer": "You can write a single-line comment in C by using two forward slashes //. Everything after // on that line will be treated as a comment and ignored by the compiler.\n\n```c\n// This is a single-line comment in C\nprintf(\"Hello, World!\\n\"); // This prints a message to the screen\n```",
        "level": "Beginner"
    },
    {
        "id": "93c53d8f-2b73-4010-88ca-1036dd538cce",
        "question": "What is the use of #include <stdio.h> in a C program?",
        "answer": "```markdown\nThe line `#include <stdio.h>` is a preprocessor directive in C. It tells the compiler to include the Standard Input Output header file (`stdio.h`) before compiling the program. This header file contains declarations for standard input and output functions, such as `printf()` for printing output to the screen and `scanf()` for reading input from the user. Without including `stdio.h`, you cannot use these standard I/O functions in your C program.\n```",
        "level": "Beginner"
    },
    {
        "id": "b707548e-06a9-4094-8e30-37a4cb20a6a3",
        "question": "Explain the difference between = and == operators in C.",
        "answer": "In C, = and == are two different operators with distinct purposes:\n\n| Operator | Name              | Purpose                                              | Example           |\n|----------|-------------------|------------------------------------------------------|-------------------|\n| =        | Assignment        | Assigns a value to a variable                        | x = 5;            |\n| ==       | Equality check    | Compares two values for equality (returns true/false)| if (x == 5) {...} |\n\n**Explanation:**\n\n- = (Assignment Operator):  \n  Used to assign the value on the right to the variable on the left.\n  ```c\n  int a;\n  a = 10; // assigns 10 to variable a\n  ```\n\n- == (Equality Operator):  \n  Used to compare two values. Returns 1 (true) if they are equal, 0 (false) otherwise.\n  ```c\n  if (a == 10) {\n      // This block runs if a is equal to 10\n  }\n  ```\n\n**Common Mistake:**  \nUsing = instead of == in conditions can lead to bugs. For example:\n```c\nif (a = 10) { // This assigns 10 to a, not compares!\n    // Always true, because a is now 10 (non-zero)\n}\n```\n\n**Summary:**  \n- Use = for assignment.\n- Use == for comparison.",
        "level": "Beginner"
    },
    {
        "id": "d02c11de-4bc5-4a31-a2d1-b3ddee1e397b",
        "question": "What is a pointer in C?",
        "answer": "A pointer in C is a variable that stores the memory address of another variable. Instead of holding a direct value like an integer or a character, a pointer holds the location in memory where a value is stored. Pointers are powerful tools in C that allow for dynamic memory allocation, efficient array handling, and the creation of complex data structures like linked lists and trees.\n\n### Syntax\n\n```c\ntype *pointer_name;\n```\n\nFor example:\n\n```c\nint *ptr; // ptr is a pointer to an integer\n```\n\n### Example Usage\n\n```c\nint num = 10;\nint *ptr = &num; // ptr now holds the address of num\n\nprintf(\"Value of num: %d\\n\", num);         // Output: 10\nprintf(\"Address of num: %p\\n\", &num);      // Output: (some address)\nprintf(\"Value stored in ptr: %p\\n\", ptr);  // Output: (same address as above)\nprintf(\"Value pointed to by ptr: %d\\n\", *ptr); // Output: 10\n```\n\n### Key Points\n\n- The `*` operator is used to declare a pointer and to dereference it (access the value at the address).\n- The `&` operator is used to get the address of a variable.\n- Pointers are essential for dynamic memory management and for passing large structures or arrays efficiently to functions.\n\nPointers are a fundamental concept in C and mastering them is crucial for effective C programming.",
        "level": "Intermediate"
    },
    {
        "id": "f7ff1a3f-9d97-4886-a267-5d6a29bc3704",
        "question": "How do you pass an array to a function in C?",
        "answer": "To pass an array to a function in C, you pass the address of its first element. In the function parameter list, you can specify the array as either an array or a pointer. Here’s an example:\n\n```c\n#include <stdio.h>\n\n// Function that takes an array and its size as parameters\nvoid printArray(int arr[], int size) {\n    for(int i = 0; i < size; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int length = sizeof(numbers) / sizeof(numbers[0]);\n    printArray(numbers, length); // Passing array to function\n    return 0;\n}\n```\n\n**Key Points:**\n- When you pass an array to a function, what actually gets passed is a pointer to its first element.\n- The function does not know the size of the array, so you should also pass the array size as a separate argument.\n- The parameter can be written as `int arr[]`, `int arr[5]`, or `int *arr`—all are equivalent in the function parameter list.\n\n**Example function signatures:**\n```c\nvoid func(int arr[], int size);\nvoid func(int *arr, int size);\n```\n\n**Note:** Modifying the array inside the function will affect the original array, since you are working with the same memory.",
        "level": "Intermediate"
    },
    {
        "id": "221d5db2-1c59-4c97-9cf7-a2380c7defe6",
        "question": "What is the difference between call by value and call by reference in C?",
        "answer": "**Call by Value vs Call by Reference in C**\n\nIn C programming, functions can receive arguments in two ways: **call by value** and **call by reference**. Here’s the difference:\n\n### Call by Value\n\n- **Definition:** The actual value of the argument is passed to the function.\n- **Behavior:** Changes made to the parameter inside the function do **not** affect the original argument.\n- **Example:**\n\n  ```c\n  void modify(int x) {\n      x = 10;\n  }\n\n  int main() {\n      int a = 5;\n      modify(a);\n      // a is still 5 here\n  }\n  ```\n\n### Call by Reference\n\n- **Definition:** The address of the argument is passed to the function (using pointers).\n- **Behavior:** Changes made to the parameter inside the function **do** affect the original argument.\n- **Example:**\n\n  ```c\n  void modify(int *x) {\n      *x = 10;\n  }\n\n  int main() {\n      int a = 5;\n      modify(&a);\n      // a is now 10 here\n  }\n  ```\n\n### Summary Table\n\n| Feature            | Call by Value         | Call by Reference      |\n|--------------------|----------------------|-----------------------|\n| What is passed     | Value (copy)         | Address (pointer)     |\n| Original affected? | No                   | Yes                   |\n| Syntax             | Normal variable      | Pointer (&, *)        |\n\n**Note:**  \nC does not support call by reference directly, but it can be achieved using pointers.",
        "level": "Intermediate"
    },
    {
        "id": "a8c710e5-def8-442a-9bbf-9cdd7d58e3fe",
        "question": "Explain the use of the malloc() function.",
        "answer": "```markdown\n### Use of the `malloc()` Function in C\n\nThe `malloc()` function in C is used for dynamic memory allocation. It stands for \"memory allocation\" and is defined in the `<stdlib.h>` header file.\n\n#### Purpose\n\n- Allocates a specified number of bytes in the heap (dynamic memory).\n- Returns a pointer to the first byte of the allocated memory block.\n- If the allocation fails, it returns `NULL`.\n\n#### Syntax\n\n```c\nvoid *malloc(size_t size);\n```\n- `size`: The number of bytes to allocate.\n\n#### Example\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int *arr;\n    int n = 5;\n\n    // Allocate memory for 5 integers\n    arr = (int *)malloc(n * sizeof(int));\n\n    if (arr == NULL) {\n        printf(\"Memory allocation failed!\\n\");\n        return 1;\n    }\n\n    // Use the allocated memory\n    for (int i = 0; i < n; i++) {\n        arr[i] = i * 10;\n        printf(\"%d \", arr[i]);\n    }\n\n    // Free the allocated memory\n    free(arr);\n\n    return 0;\n}\n```\n\n#### Key Points\n\n- **Typecasting:** The pointer returned by `malloc()` is of type `void*`. It is often typecast to the appropriate pointer type.\n- **Uninitialized Memory:** The memory allocated by `malloc()` contains garbage values (not initialized).\n- **Freeing Memory:** Always use `free()` to release memory allocated by `malloc()` to avoid memory leaks.\n\n#### Summary Table\n\n| Function | Purpose                | Returns         | Initializes Memory? |\n|----------|------------------------|-----------------|---------------------|\n| malloc() | Allocate memory block  | Pointer/NULL    | No                  |\n\n---\n**Note:** For zero-initialized memory, use `calloc()` instead.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "9855cc8e-594e-44e3-9f5c-19a26f0f6e48",
        "question": "What is a structure in C and how is it different from an array?",
        "answer": "A **structure** in C is a user-defined data type that allows you to group variables of different data types under a single name. Structures are useful for representing a record, such as a student with a name, roll number, and marks.\n\n### Example of a Structure\n\n```c\nstruct Student {\n    char name[50];\n    int rollNumber;\n    float marks;\n};\n```\n\nYou can create variables of this structure type:\n\n```c\nstruct Student student1;\n```\n\n### Differences Between Structure and Array\n\n| Structure                                   | Array                                         |\n|----------------------------------------------|-----------------------------------------------|\n| Can contain variables of different data types| Contains elements of the same data type       |\n| Each member is accessed by its name          | Elements are accessed using an index          |\n| Used to represent a record                   | Used to store a collection of similar items   |\n| Memory allocation can be non-contiguous      | Memory allocation is always contiguous        |\n\n#### Example\n\n- **Structure:**  \n  ```c\n  struct Point {\n      int x;\n      float y;\n  };\n  ```\n- **Array:**  \n  ```c\n  int numbers[5]; // All elements are of type int\n  ```\n\n### Summary\n\n- **Structure:** Groups variables of different types.\n- **Array:** Stores multiple values of the same type.\n\nStructures provide a way to combine data of different types, while arrays are used for collections of the same type.",
        "level": "Intermediate"
    },
    {
        "id": "32ba6b8e-d44a-4869-9e0f-94a05f00bfff",
        "question": "How do you handle file input and output in C?",
        "answer": "To handle file input and output (I/O) in C, you use the standard library functions provided in the `<stdio.h>` header. The basic steps are:\n\n1. **Open a File:**  \n   Use `fopen()` to open a file. It returns a pointer to a `FILE` object.\n\n   ```c\n   FILE *fp = fopen(\"filename.txt\", \"r\"); // \"r\" for reading, \"w\" for writing, \"a\" for appending\n   if (fp == NULL) {\n       // Handle error\n   }\n   ```\n\n2. **Read or Write Data:**  \n   - Use `fprintf()` or `fputs()` to write text, or `fread()` for binary data.\n   - Use `fscanf()` or `fgets()` to read text, or `fread()` for binary data.\n\n   **Writing Example:**\n   ```c\n   fprintf(fp, \"Hello, World!\\n\");\n   ```\n\n   **Reading Example:**\n   ```c\n   char buffer[100];\n   if (fgets(buffer, 100, fp) != NULL) {\n       // Use buffer\n   }\n   ```\n\n3. **Close the File:**  \n   Always close the file using `fclose()` to free resources.\n\n   ```c\n   fclose(fp);\n   ```\n\n### Example: Writing and Reading a File\n\n```c\n#include <stdio.h>\n\nint main() {\n    FILE *fp;\n\n    // Writing to a file\n    fp = fopen(\"example.txt\", \"w\");\n    if (fp == NULL) {\n        printf(\"Error opening file for writing.\\n\");\n        return 1;\n    }\n    fprintf(fp, \"This is a test.\\n\");\n    fclose(fp);\n\n    // Reading from a file\n    fp = fopen(\"example.txt\", \"r\");\n    if (fp == NULL) {\n        printf(\"Error opening file for reading.\\n\");\n        return 1;\n    }\n    char line[100];\n    while (fgets(line, sizeof(line), fp)) {\n        printf(\"%s\", line);\n    }\n    fclose(fp);\n\n    return 0;\n}\n```\n\n### Notes\n\n- Always check if the file was opened successfully.\n- Use appropriate modes: `\"r\"` (read), `\"w\"` (write), `\"a\"` (append), and their binary versions (`\"rb\"`, `\"wb\"`, etc.).\n- Remember to close files to prevent memory leaks and data corruption.\n\nFor more advanced operations, you can use `fseek()`, `ftell()`, and `rewind()` to manipulate the file pointer.",
        "level": "Intermediate"
    },
    {
        "id": "63f868b0-7962-451d-b4fc-ee2014a12fd3",
        "question": "What is a segmentation fault in C?",
        "answer": "A **segmentation fault** in C is a specific kind of error that occurs when a program tries to access a memory location that it is not allowed to access. This typically happens due to:\n\n- Dereferencing a null or uninitialized pointer\n- Accessing memory outside the bounds of an array\n- Writing to read-only memory\n- Using a pointer after the memory it points to has been freed (dangling pointer)\n\nWhen a segmentation fault occurs, the operating system stops the program to prevent it from corrupting or interfering with other processes.\n\n**Example:**\n\n```c\n#include <stdio.h>\n\nint main() {\n    int *ptr = NULL;\n    *ptr = 10; // This will cause a segmentation fault\n    return 0;\n}\n```\n\n**Explanation:**  \nIn the example above, `ptr` is a null pointer. Attempting to write to the memory location it points to (`*ptr = 10;`) results in a segmentation fault because the program does not have permission to access address 0 (NULL).\n\n**Summary:**  \nA segmentation fault is a runtime error indicating illegal access to memory, and it is often a sign of bugs related to pointer misuse in C programs.",
        "level": "Intermediate"
    },
    {
        "id": "065df3b0-ea95-4f14-9cb8-8f25edb75f92",
        "question": "Explain the difference between global and local variables.",
        "answer": "**Difference Between Global and Local Variables in C**\n\nIn C programming, variables can be declared either globally or locally, and their scope and lifetime differ:\n\n| Aspect              | Global Variable                                    | Local Variable                                  |\n|---------------------|---------------------------------------------------|-------------------------------------------------|\n| **Declaration**     | Outside all functions, usually at the top of file | Inside a function or a block (e.g., `{}`)       |\n| **Scope**           | Accessible from any function in the file (and possibly other files with extern) | Accessible only within the function or block where declared |\n| **Lifetime**        | Exists for the entire duration of the program      | Exists only while the function/block is executing|\n| **Default Value**   | Initialized to zero (if not explicitly initialized)| Contains garbage value (if not explicitly initialized) |\n| **Usage Example**   | `int count = 0;`                                  | `int i = 0;` inside a function                  |\n\n**Example:**\n\n```c\n#include <stdio.h>\n\nint globalVar = 10; // Global variable\n\nvoid func() {\n    int localVar = 5; // Local variable\n    printf(\"Inside func: globalVar = %d, localVar = %d\\n\", globalVar, localVar);\n}\n\nint main() {\n    func();\n    // printf(\"%d\", localVar); // Error: localVar not accessible here\n    printf(\"Inside main: globalVar = %d\\n\", globalVar);\n    return 0;\n}\n```\n\n**Summary:**\n- **Global variables** have program-wide scope and lifetime.\n- **Local variables** are limited in scope and exist only within the function or block where they are declared.",
        "level": "Intermediate"
    },
    {
        "id": "dd042551-fc56-4374-98ce-61b0a3e3c2a5",
        "question": "What are header files and why are they used?",
        "answer": "Header files in C are files with a `.h` extension that contain declarations of functions, macros, constants, and data types. They do not contain the actual implementation of functions, but rather their prototypes and definitions that can be shared across multiple source files.\n\n### Why Header Files Are Used\n\n- **Code Reusability:** Header files allow you to declare functions and variables once and use them in multiple source files, promoting code reuse.\n- **Separation of Interface and Implementation:** By placing declarations in header files and implementations in `.c` files, you separate the interface from the implementation, making code easier to manage and maintain.\n- **Avoiding Redundancy:** Instead of rewriting function prototypes or macro definitions in every source file, you include the header file using `#include`.\n- **Standard Library Support:** Standard C libraries (like `stdio.h`, `stdlib.h`, etc.) provide function and macro declarations through header files.\n\n### Example\n\n```c\n// math_utils.h\n#ifndef MATH_UTILS_H\n#define MATH_UTILS_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif\n```\n\n```c\n// main.c\n#include <stdio.h>\n#include \"math_utils.h\"\n\nint main() {\n    printf(\"%d\\n\", add(3, 4));\n    return 0;\n}\n```\n\nIn this example, `math_utils.h` contains the function declarations, which are then included in `main.c` for use.\n\n**In summary:** Header files help organize code, promote reuse, and make large C programs easier to develop and maintain.",
        "level": "Intermediate"
    },
    {
        "id": "aa5ed428-6867-4d2c-b4bb-211fbde320f1",
        "question": "What is a dangling pointer?",
        "answer": "A **dangling pointer** in C is a pointer that continues to reference a memory location after the object it points to has been deallocated or gone out of scope. Using a dangling pointer leads to undefined behavior, as the memory it points to may now be used for other purposes or may be inaccessible.\n\n### Example\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint* createPointer() {\n    int a = 10;\n    return &a; // Returning address of local variable (dangerous)\n}\n\nint main() {\n    int *ptr = createPointer();\n    // 'a' is out of scope here; 'ptr' is now a dangling pointer\n    printf(\"%d\\n\", *ptr); // Undefined behavior\n    return 0;\n}\n```\n\nOr, after freeing memory:\n\n```c\nint *ptr = (int*)malloc(sizeof(int));\n*ptr = 42;\nfree(ptr); // Memory is deallocated\n// 'ptr' is now a dangling pointer\n```\n\n### How to Avoid Dangling Pointers\n\n- Set pointers to `NULL` after freeing them:\n  ```c\n  free(ptr);\n  ptr = NULL;\n  ```\n- Avoid returning addresses of local variables from functions.\n- Be careful with pointer assignments and object lifetimes.\n\n### Summary\n\nA dangling pointer is a pointer that points to memory that has been freed or is otherwise invalid. Accessing or dereferencing such pointers can cause unpredictable program behavior, crashes, or security vulnerabilities.",
        "level": "Advanced"
    },
    {
        "id": "f762b9c5-0100-44ad-9d2f-72733ddfebe7",
        "question": "Explain the difference between static and dynamic memory allocation.",
        "answer": "```markdown\n### Difference Between Static and Dynamic Memory Allocation in C\n\n#### 1. **Static Memory Allocation**\n- **Definition:** Memory for variables is allocated at compile time.\n- **How:** Done using data type declarations (e.g., `int arr[10];`).\n- **Memory Lifetime:** The allocated memory exists throughout the program's execution (for global/static variables) or until the function exits (for local variables).\n- **Size:** Must be known at compile time and cannot be changed during runtime.\n- **Allocation/Deallocation:** Managed automatically by the compiler; programmer does not explicitly allocate or free memory.\n- **Example:**\n  ```c\n  int arr[100]; // Static allocation of 100 integers\n  ```\n\n#### 2. **Dynamic Memory Allocation**\n- **Definition:** Memory is allocated at runtime as needed.\n- **How:** Done using library functions like `malloc()`, `calloc()`, `realloc()`, and freed with `free()`.\n- **Memory Lifetime:** The allocated memory exists until it is explicitly deallocated using `free()`.\n- **Size:** Can be determined and changed at runtime, offering flexibility.\n- **Allocation/Deallocation:** Programmer is responsible for both allocating and freeing memory.\n- **Example:**\n  ```c\n  int *arr = (int *)malloc(100 * sizeof(int)); // Dynamic allocation of 100 integers\n  if (arr != NULL) {\n      // Use the array\n      free(arr); // Free the allocated memory\n  }\n  ```\n\n#### 3. **Key Differences Table**\n\n| Aspect                | Static Allocation                | Dynamic Allocation                |\n|-----------------------|----------------------------------|-----------------------------------|\n| Allocation Time       | Compile time                     | Run time                          |\n| Memory Size           | Fixed                            | Flexible                          |\n| Lifetime              | Automatic (scope-based)          | Manual (until `free()` is called) |\n| Allocation Function   | Compiler                         | `malloc()`, `calloc()`, etc.      |\n| Deallocation          | Automatic                        | Manual (`free()`)                 |\n| Efficiency            | Faster (no runtime overhead)     | Slower (runtime overhead)         |\n| Example               | `int arr[10];`                   | `int *arr = malloc(10 * sizeof(int));` |\n\n#### 4. **Summary**\n- **Static allocation** is simple and fast but inflexible.\n- **Dynamic allocation** is flexible and powerful but requires careful memory management to avoid leaks and errors.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "990585d4-d8db-43ec-ad7e-00c8514dfe39",
        "question": "What is pointer arithmetic?",
        "answer": "### Pointer Arithmetic in C\n\nPointer arithmetic refers to performing arithmetic operations on pointers in C, such as addition, subtraction, increment, and decrement. Since pointers store memory addresses, pointer arithmetic allows you to navigate through arrays and data structures efficiently.\n\n#### Key Points\n\n- **Increment/Decrement:** When you increment (`ptr++`) or decrement (`ptr--`) a pointer, it moves to the next or previous element of its type, not just the next byte. For example, incrementing an `int*` advances the pointer by `sizeof(int)` bytes.\n- **Addition/Subtraction:** You can add or subtract an integer value to/from a pointer (`ptr + n`, `ptr - n`). This moves the pointer forward or backward by `n` elements of the pointer's type.\n- **Pointer Difference:** Subtracting two pointers of the same type gives the number of elements between them.\n\n#### Example\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n\n    printf(\"First element: %d\\n\", *ptr);       // 10\n    ptr++;                                     // Move to next int\n    printf(\"Second element: %d\\n\", *ptr);      // 20\n\n    ptr = ptr + 2;                             // Move two ints ahead\n    printf(\"Fourth element: %d\\n\", *ptr);      // 40\n\n    int diff = ptr - arr;                      // Difference in elements\n    printf(\"Index of ptr: %d\\n\", diff);        // 3\n\n    return 0;\n}\n```\n\n#### Notes\n\n- Pointer arithmetic is only valid within arrays or memory blocks allocated for the same data type.\n- Performing arithmetic on `void*` pointers is not allowed in standard C, as the size of `void` is undefined.\n\n#### Summary\n\nPointer arithmetic is a powerful feature in C that allows efficient traversal and manipulation of arrays and data structures by leveraging the type and size information associated with pointers.",
        "level": "Advanced"
    },
    {
        "id": "68a43176-a07e-4207-b7d9-d5b4b0c98caa",
        "question": "How do you prevent buffer overflow in C?",
        "answer": "```markdown\n### Preventing Buffer Overflow in C\n\nBuffer overflow occurs when a program writes more data to a buffer than it can hold, potentially overwriting adjacent memory and leading to unpredictable behavior or security vulnerabilities. Here are advanced strategies to prevent buffer overflow in C:\n\n#### 1. **Use Safe Library Functions**\n- Prefer safer alternatives to standard functions:\n  - Use `strncpy()` instead of `strcpy()`\n  - Use `snprintf()` instead of `sprintf()`\n  - Use `fgets()` instead of `gets()`\n- Example:\n  ```c\n  char dest[10];\n  strncpy(dest, src, sizeof(dest) - 1);\n  dest[sizeof(dest) - 1] = '\\0'; // Ensure null-termination\n  ```\n\n#### 2. **Explicit Bounds Checking**\n- Always check the size of buffers before writing or copying data.\n- Example:\n  ```c\n  if (input_length < sizeof(buffer)) {\n      memcpy(buffer, input, input_length);\n  }\n  ```\n\n#### 3. **Dynamic Memory Allocation**\n- Allocate memory dynamically based on the actual size needed.\n- Example:\n  ```c\n  char *buffer = malloc(input_length + 1);\n  if (buffer) {\n      strcpy(buffer, input);\n      // ...\n      free(buffer);\n  }\n  ```\n\n#### 4. **Compiler Security Features**\n- Enable stack protection flags:\n  - Use `-fstack-protector` or `-fstack-protector-all` with GCC.\n  - Enable AddressSanitizer (`-fsanitize=address`) during development.\n- Example:\n  ```\n  gcc -fstack-protector-all -o myprog myprog.c\n  ```\n\n#### 5. **Use Modern C Standards**\n- Use functions introduced in C11, such as `strncpy_s()` and `memcpy_s()`, which require explicit buffer sizes and return error codes.\n\n#### 6. **Code Reviews and Static Analysis**\n- Regularly review code for unsafe practices.\n- Use static analysis tools (e.g., `splint`, `clang-analyzer`) to detect potential buffer overflows.\n\n#### 7. **Avoid Dangerous Functions**\n- Avoid using inherently unsafe functions like `gets()`, `scanf()` with `%s`, `strcpy()`, and `sprintf()`.\n\n---\n\n**Summary Table**\n\n| Unsafe Function | Safer Alternative      |\n|-----------------|-----------------------|\n| gets()          | fgets()               |\n| strcpy()        | strncpy(), strcpy_s() |\n| strcat()        | strncat(), strcat_s() |\n| sprintf()       | snprintf(), sprintf_s() |\n\n---\n\n**Key Takeaway:**  \nAlways validate buffer sizes, prefer safe functions, enable compiler protections, and use static analysis to prevent buffer overflows in C.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "37df085e-9f62-45fb-9f80-5ce60175a132",
        "question": "What is the use of the const keyword with pointers?",
        "answer": "### Use of the `const` Keyword with Pointers in C\n\nThe `const` keyword in C is used to indicate that the value of a variable should not be modified after its initialization. When used with pointers, `const` can be applied in different ways to control what can or cannot be changed: the pointer itself, the data it points to, or both.\n\n#### 1. Pointer to Constant Data\n\n```c\nconst int *ptr;\n```\nor\n```c\nint const *ptr;\n```\n\n- **Meaning:** The data pointed to by `ptr` cannot be changed through `ptr`, but the pointer itself can point to different locations.\n- **Example:**\n  ```c\n  int x = 10, y = 20;\n  const int *ptr = &x;\n  *ptr = 15;    // Error: cannot modify value through ptr\n  ptr = &y;     // OK: can change what ptr points to\n  ```\n\n#### 2. Constant Pointer to Data\n\n```c\nint *const ptr = &x;\n```\n\n- **Meaning:** The pointer `ptr` cannot point to another location after initialization, but the data it points to can be changed.\n- **Example:**\n  ```c\n  int x = 10;\n  int *const ptr = &x;\n  *ptr = 15;    // OK: can modify value through ptr\n  int y = 20;\n  ptr = &y;     // Error: cannot change what ptr points to\n  ```\n\n#### 3. Constant Pointer to Constant Data\n\n```c\nconst int *const ptr = &x;\n```\nor\n```c\nint const *const ptr = &x;\n```\n\n- **Meaning:** Neither the pointer can point to another location, nor can the data it points to be changed through the pointer.\n- **Example:**\n  ```c\n  int x = 10;\n  const int *const ptr = &x;\n  *ptr = 15;    // Error: cannot modify value through ptr\n  int y = 20;\n  ptr = &y;     // Error: cannot change what ptr points to\n  ```\n\n---\n\n### Summary Table\n\n| Declaration             | Can modify data? | Can change pointer? |\n|-------------------------|:---------------:|:------------------:|\n| `const int *ptr`        |       No        |        Yes         |\n| `int *const ptr`        |      Yes        |        No          |\n| `const int *const ptr`  |       No        |        No          |\n\n---\n\n### **Why Use `const` with Pointers?**\n\n- **Safety:** Prevents accidental modification of data or pointer addresses.\n- **Self-documenting code:** Makes it clear what is intended to be constant.\n- **Optimization:** Allows the compiler to optimize code better in some cases.\n- **Interface contracts:** Useful in function parameters to indicate that a function will not modify the data pointed to.\n\n---\n\n**Example in Function Parameter:**\n\n```c\nvoid printArray(const int *arr, int size) {\n    for (int i = 0; i < size; ++i) {\n        printf(\"%d \", arr[i]);\n        // arr[i] = 10; // Error: cannot modify value\n    }\n}\n```\n\nThis ensures that `printArray` cannot modify the contents of the array passed to it.",
        "level": "Advanced"
    },
    {
        "id": "71012632-1bd4-4996-aca0-849c363fd011",
        "question": "What is the volatile keyword and when should it be used?",
        "answer": "```markdown\n## What is the `volatile` keyword and when should it be used?\n\nThe `volatile` keyword in C is a type qualifier that tells the compiler that a variable's value may be changed at any time—without any action being taken by the code the compiler finds nearby. This prevents the compiler from applying certain optimizations that assume values of variables cannot change \"unexpectedly.\"\n\n### Purpose\n\nWhen a variable is declared as `volatile`, the compiler will always read its value from memory each time it is accessed, rather than caching it in a register. This ensures that the program always sees the most up-to-date value.\n\n### Typical Use Cases\n\nYou should use `volatile` in the following scenarios:\n\n1. **Hardware Registers in Embedded Systems**  \n   When accessing memory-mapped hardware registers, their values can change independently of the program flow.\n\n   ```c\n   volatile int *status_register = (int *)0x40021000;\n   while (!(*status_register & 0x01)) {\n       // Wait for hardware event\n   }\n   ```\n\n2. **Variables Modified by an Interrupt Service Routine (ISR)**  \n   If a variable is modified both in the main code and in an ISR, it should be declared `volatile`.\n\n   ```c\n   volatile int flag = 0;\n\n   void ISR() {\n       flag = 1;\n   }\n\n   int main() {\n       while (!flag) {\n           // Wait for interrupt\n       }\n   }\n   ```\n\n3. **Variables Shared Between Threads (in some cases)**  \n   In multi-threaded programs, if a variable is shared between threads without proper synchronization, `volatile` may be used, but note that it does **not** guarantee atomicity or memory ordering—use proper synchronization primitives for thread safety.\n\n### What `volatile` Does **Not** Do\n\n- It does **not** make operations on the variable atomic.\n- It does **not** provide memory barriers or synchronization between threads.\n- It does **not** prevent all compiler optimizations—only those related to caching the variable's value.\n\n### Summary Table\n\n| Use Case                        | Should Use `volatile`? |\n|----------------------------------|:---------------------:|\n| Hardware registers               | Yes                   |\n| Variables modified by ISRs       | Yes                   |\n| Shared variables between threads | Sometimes\\*           |\n\n\\* For thread synchronization, prefer atomic types and synchronization primitives.\n\n### Example\n\n```c\nvolatile int counter;\n```\n\nThis tells the compiler that `counter` can change at any time, so every access must read from memory.\n\n---\n\n**In summary:**  \nUse `volatile` for variables that can be changed outside the normal program flow, such as by hardware, interrupts, or (rarely) other threads. It prevents the compiler from optimizing away necessary reads/writes, ensuring correct program behavior in these special cases.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "51d4eb32-3c03-4347-9d53-50b7dcc5a825",
        "question": "Explain the concept of memory leaks and how to avoid them.",
        "answer": "```markdown\n## Memory Leaks in C and How to Avoid Them\n\n### What is a Memory Leak?\n\nA **memory leak** in C occurs when a program allocates memory on the heap (using functions like `malloc`, `calloc`, or `realloc`) but fails to release it using `free` after the memory is no longer needed. As a result, the allocated memory remains inaccessible (no pointer references it), but is not returned to the system, leading to wasted resources. Over time, especially in long-running programs, memory leaks can cause the program to consume excessive memory, degrade performance, or even crash.\n\n#### Example of a Memory Leak\n\n```c\n#include <stdlib.h>\n\nvoid leak_example() {\n    int *ptr = malloc(sizeof(int) * 100);\n    // ... use ptr\n    // forgot to free(ptr);\n}\n```\n\nIn this example, the memory allocated for `ptr` is never freed, resulting in a memory leak.\n\n---\n\n### How to Avoid Memory Leaks\n\n1. **Always Free Allocated Memory**\n   - For every `malloc`, `calloc`, or `realloc`, ensure there is a corresponding `free` when the memory is no longer needed.\n\n   ```c\n   int *arr = malloc(10 * sizeof(int));\n   // ... use arr\n   free(arr); // release memory\n   ```\n\n2. **Set Pointers to NULL After Freeing**\n   - After freeing a pointer, set it to `NULL` to avoid accidental use (dangling pointer) and to make double-free errors easier to detect.\n\n   ```c\n   free(arr);\n   arr = NULL;\n   ```\n\n3. **Avoid Losing References**\n   - Do not overwrite pointers to allocated memory before freeing them.\n\n   ```c\n   int *ptr = malloc(sizeof(int));\n   ptr = malloc(sizeof(int)); // memory from first malloc is leaked!\n   ```\n\n4. **Track Allocations and Deallocations**\n   - In complex programs, keep track of all allocations and ensure each is freed. Use data structures or comments to document ownership and responsibility for freeing memory.\n\n5. **Use Tools for Detection**\n   - Use tools like **Valgrind** (Linux), **Dr. Memory** (Windows), or compiler sanitizers (e.g., `-fsanitize=address` with GCC/Clang) to detect memory leaks during development and testing.\n\n   ```bash\n   valgrind --leak-check=full ./your_program\n   ```\n\n6. **Follow Ownership Conventions**\n   - Clearly define which function/module is responsible for freeing memory, especially when passing pointers between functions.\n\n---\n\n### Summary Table\n\n| Practice                        | Purpose                                 |\n|----------------------------------|-----------------------------------------|\n| Free every allocated block       | Prevent leaks                           |\n| Set pointers to NULL after free  | Avoid dangling pointers                 |\n| Avoid overwriting pointers       | Prevent losing references to memory     |\n| Use memory checking tools        | Detect leaks and improper usage         |\n| Document ownership               | Clarify responsibility for freeing      |\n\n---\n\n### Conclusion\n\nMemory leaks are a common source of bugs in C programs due to manual memory management. By following best practices—always freeing memory, using tools, and maintaining clear ownership—you can minimize the risk of leaks and write more robust, efficient C code.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "e5a5568f-7434-427d-b32c-cb957e3dc8b9",
        "question": "What is the difference between malloc() and calloc()?",
        "answer": "```markdown\n### Difference between `malloc()` and `calloc()` in C\n\nBoth `malloc()` and `calloc()` are used for dynamic memory allocation in C, but they have key differences:\n\n| Feature                | `malloc()`                                        | `calloc()`                                         |\n|------------------------|--------------------------------------------------|----------------------------------------------------|\n| **Syntax**             | `void* malloc(size_t size);`                     | `void* calloc(size_t num, size_t size);`           |\n| **Memory Initialization** | Does **not** initialize the allocated memory (contains garbage values). | Initializes all allocated memory to **zero**.      |\n| **Parameters**         | Takes a **single** argument: total number of bytes to allocate. | Takes **two** arguments: number of elements and size of each element. |\n| **Return Value**       | Returns a pointer to the allocated memory block, or `NULL` if allocation fails. | Same as `malloc()`.                                |\n| **Use Case Example**   | `int *arr = (int*)malloc(10 * sizeof(int));`     | `int *arr = (int*)calloc(10, sizeof(int));`        |\n\n#### Example\n\n```c\n// Using malloc\nint *a = (int*)malloc(5 * sizeof(int)); // Memory not initialized\n\n// Using calloc\nint *b = (int*)calloc(5, sizeof(int));  // Memory initialized to zero\n```\n\n#### Summary\n\n- Use `malloc()` when you do **not** need the memory to be initialized.\n- Use `calloc()` when you want the allocated memory to be **zero-initialized**.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "457ce20e-c5eb-437b-a3d0-32ff3589ca37",
        "question": "How can you implement a linked list in C?",
        "answer": "Certainly! Here’s an advanced-level answer in markdown format on how to implement a linked list in C:\n\n---\n\n## Implementing a Linked List in C\n\nA **linked list** is a dynamic data structure where each element (node) contains data and a pointer to the next node. Below is an example of how to implement a singly linked list in C, including functions to insert, delete, and traverse the list.\n\n### 1. Define the Node Structure\n\n```c\ntypedef struct Node {\n    int data;\n    struct Node* next;\n} Node;\n```\n\n### 2. Insert at the Beginning\n\n```c\nvoid insertAtBeginning(Node** head, int newData) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = newData;\n    newNode->next = *head;\n    *head = newNode;\n}\n```\n\n### 3. Insert at the End\n\n```c\nvoid insertAtEnd(Node** head, int newData) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->data = newData;\n    newNode->next = NULL;\n    if (*head == NULL) {\n        *head = newNode;\n        return;\n    }\n    Node* temp = *head;\n    while (temp->next != NULL)\n        temp = temp->next;\n    temp->next = newNode;\n}\n```\n\n### 4. Delete a Node\n\n```c\nvoid deleteNode(Node** head, int key) {\n    Node* temp = *head;\n    Node* prev = NULL;\n    // If head node holds the key\n    if (temp != NULL && temp->data == key) {\n        *head = temp->next;\n        free(temp);\n        return;\n    }\n    // Search for the key\n    while (temp != NULL && temp->data != key) {\n        prev = temp;\n        temp = temp->next;\n    }\n    if (temp == NULL) return; // Key not found\n    prev->next = temp->next;\n    free(temp);\n}\n```\n\n### 5. Traverse and Print the List\n\n```c\nvoid printList(Node* head) {\n    Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d -> \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"NULL\\n\");\n}\n```\n\n### 6. Free the List\n\n```c\nvoid freeList(Node* head) {\n    Node* temp;\n    while (head != NULL) {\n        temp = head;\n        head = head->next;\n        free(temp);\n    }\n}\n```\n\n### 7. Example Usage\n\n```c\nint main() {\n    Node* head = NULL;\n    insertAtBeginning(&head, 10);\n    insertAtEnd(&head, 20);\n    insertAtBeginning(&head, 5);\n    printList(head); // Output: 5 -> 10 -> 20 -> NULL\n    deleteNode(&head, 10);\n    printList(head); // Output: 5 -> 20 -> NULL\n    freeList(head);\n    return 0;\n}\n```\n\n---\n\n**Key Points:**\n- Dynamic memory allocation (`malloc`/`free`) is used for node management.\n- The head pointer is often passed by reference (`Node**`) to allow modification.\n- Proper memory management is crucial to avoid leaks.\n\nThis is a basic singly linked list. For advanced usage, you can implement doubly linked lists, circular lists, or add more complex operations (like sorting, reversing, etc.).",
        "level": "Advanced"
    },
    {
        "id": "451e3fb9-3727-4f4c-bfaf-281055c5ea6c",
        "question": "What are function pointers and how are they used?",
        "answer": "```markdown\n## Function Pointers in C\n\nA **function pointer** in C is a variable that stores the address of a function. Just like pointers to data, function pointers can be used to call functions indirectly, pass functions as arguments, or store arrays of functions for dynamic invocation.\n\n### Declaration\n\nTo declare a function pointer, use the following syntax:\n\n```c\nreturn_type (*pointer_name)(parameter_types);\n```\n\n**Example:** Pointer to a function taking two `int` arguments and returning `int`:\n\n```c\nint (*func_ptr)(int, int);\n```\n\n### Assigning a Function to a Pointer\n\nYou can assign a function to a function pointer by simply using the function's name (without parentheses):\n\n```c\nint add(int a, int b) {\n    return a + b;\n}\n\nfunc_ptr = add;\n```\n\n### Calling a Function via Pointer\n\nYou can call the function using the pointer:\n\n```c\nint result = func_ptr(2, 3); // result = 5\n```\n\nOr, equivalently:\n\n```c\nint result = (*func_ptr)(2, 3);\n```\n\n### Use Cases\n\n1. **Callback Functions:**  \n   Function pointers are commonly used to implement callbacks, where a function is passed as an argument to another function.\n\n   ```c\n   void process(int x, int y, int (*operation)(int, int)) {\n       printf(\"%d\\n\", operation(x, y));\n   }\n   ```\n\n2. **Arrays of Functions:**  \n   You can create arrays of function pointers to select and call functions dynamically.\n\n   ```c\n   int (*operations[2])(int, int) = { add, subtract };\n   int result = operations[0](5, 3); // Calls add\n   ```\n\n3. **Implementing Polymorphism:**  \n   Function pointers can be used to simulate polymorphism in C, especially in structures.\n\n   ```c\n   typedef struct {\n       void (*speak)(void);\n   } Animal;\n   ```\n\n### Example\n\n```c\n#include <stdio.h>\n\nvoid greet() {\n    printf(\"Hello, World!\\n\");\n}\n\nint main() {\n    void (*func_ptr)() = greet;\n    func_ptr(); // Calls greet()\n    return 0;\n}\n```\n\n### Summary\n\nFunction pointers are powerful tools in C for achieving flexible and dynamic function invocation, enabling callbacks, event handling, and more advanced programming techniques.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "1ad8ff31-e615-4156-a149-349e44067216",
        "question": "What is the purpose of the sizeof operator?",
        "answer": "The sizeof operator in C is used to determine the size, in bytes, of a data type or a variable. It is evaluated at compile time and returns a value of type size_t. This operator is particularly useful for:\n\n- Allocating memory dynamically (e.g., with malloc)\n- Determining the size of arrays or structures\n- Writing portable code that works across different platforms and architectures\n\n**Example:**\n\n```c\nint a;\nprintf(\"Size of int: %zu bytes\\n\", sizeof(a));      // Output: Size of int: 4 bytes (typically)\nprintf(\"Size of double: %zu bytes\\n\", sizeof(double)); // Output: Size of double: 8 bytes (typically)\n```\n\n**Key Points:**\n- sizeof can be used with variables, data types, and structures.\n- Parentheses are optional when using sizeof with a variable, but required with a type (e.g., sizeof(int)).\n- The result may vary depending on the system and compiler.\n\n**Summary:**  \nThe sizeof operator helps you write safer and more portable C programs by allowing you to query the memory requirements of data types and variables.",
        "level": "Intermediate"
    },
    {
        "id": "a7b91e79-71f5-47d3-bb88-07489caa3bbd",
        "question": "How do you use typedef in C?",
        "answer": "### Using `typedef` in C\n\nThe `typedef` keyword in C is used to create an alias (alternative name) for existing data types. This can make complex type declarations easier to read and manage, and can also improve code portability and clarity.\n\n#### Basic Syntax\n\n```c\ntypedef existing_type new_type_name;\n```\n\n#### Examples\n\n1. **Simple Type Alias**\n\n   ```c\n   typedef unsigned long ulong;\n   \n   ulong a = 1000; // Equivalent to: unsigned long a = 1000;\n   ```\n\n2. **Struct Alias**\n\n   ```c\n   struct Point {\n       int x;\n       int y;\n   };\n   \n   typedef struct Point Point;\n   \n   // Now you can declare:\n   Point p1;\n   ```\n\n   Or more concisely:\n\n   ```c\n   typedef struct {\n       int x;\n       int y;\n   } Point;\n   \n   Point p2;\n   ```\n\n3. **Pointer Type Alias**\n\n   ```c\n   typedef int* IntPtr;\n   \n   IntPtr p, q; // Both p and q are of type int*\n   ```\n\n4. **Function Pointer Alias**\n\n   ```c\n   typedef int (*CompareFunc)(const void*, const void*);\n   \n   int compare(const void* a, const void* b) { /*...*/ }\n   CompareFunc cmp = compare;\n   ```\n\n#### Use Cases\n\n- Simplifying complex declarations (e.g., function pointers, structures).\n- Improving code readability.\n- Enhancing portability (e.g., defining platform-specific types).\n\n#### Notes\n\n- `typedef` does **not** create a new type; it only creates an alias.\n- It is commonly used in header files to abstract implementation details.\n\n---\n\n**Example:**\n\n```c\n#include <stdio.h>\n\ntypedef struct {\n    char name[50];\n    int age;\n} Person;\n\nint main() {\n    Person p = {\"Alice\", 30};\n    printf(\"%s is %d years old.\\n\", p.name, p.age);\n    return 0;\n}\n```\n\n**Output:**\n```\nAlice is 30 years old.\n```\n\n---\n\n**Summary:**  \nUse `typedef` in C to create type aliases, making your code more readable and maintainable, especially when dealing with complex types.",
        "level": "Advanced"
    },
    {
        "id": "744720e2-6525-417b-9d80-d07a3acbf05a",
        "question": "What is recursion? Give an example in C.",
        "answer": "Recursion in C\n\n**Recursion** is a programming technique where a function calls itself directly or indirectly to solve a problem. Recursive functions typically solve a problem by breaking it down into smaller subproblems, each of which is solved by a recursive call, until a base case is reached.\n\n### Example: Calculating Factorial Using Recursion\n\n```c\n#include <stdio.h>\n\n// Recursive function to calculate factorial\nint factorial(int n) {\n    if (n == 0) // Base case\n        return 1;\n    else\n        return n * factorial(n - 1); // Recursive call\n}\n\nint main() {\n    int num = 5;\n    printf(\"Factorial of %d is %d\\n\", num, factorial(num));\n    return 0;\n}\n```\n\n**Output:**\n```\nFactorial of 5 is 120\n```\n\n**Explanation:**  \n- The `factorial` function calls itself with a smaller value (`n - 1`) until it reaches the base case (`n == 0`).\n- Each recursive call multiplies `n` by the factorial of `n - 1`, building up the result as the recursion unwinds.",
        "level": "Intermediate"
    },
    {
        "id": "7ae82ff9-ea19-4f90-b2a8-8fb10ad12ff2",
        "question": "How does the switch statement work in C?",
        "answer": "```markdown\nThe `switch` statement in C is used to perform different actions based on the value of an expression. It is an alternative to using multiple `if-else` statements when you need to compare the same variable or expression against different constant values.\n\n**Syntax:**\n```c\nswitch(expression) {\n    case constant1:\n        // code to execute if expression == constant1\n        break;\n    case constant2:\n        // code to execute if expression == constant2\n        break;\n    // more cases...\n    default:\n        // code to execute if expression doesn't match any case\n}\n```\n\n**How it works:**\n1. The `expression` inside the `switch` is evaluated.\n2. The value of `expression` is compared with each `case` label.\n3. If a match is found, the code under that `case` runs.\n4. The `break` statement ends the switch block. If `break` is omitted, execution continues to the next case (\"fall-through\").\n5. The `default` case is optional and runs if no other case matches.\n\n**Example:**\n```c\nint num = 2;\nswitch(num) {\n    case 1:\n        printf(\"One\\n\");\n        break;\n    case 2:\n        printf(\"Two\\n\");\n        break;\n    case 3:\n        printf(\"Three\\n\");\n        break;\n    default:\n        printf(\"Other number\\n\");\n}\n```\n**Output:**\n```\nTwo\n```\n\n**Key Points:**\n- Only integer and character constants are allowed in `case` labels.\n- The `break` statement is important to prevent fall-through.\n- The `default` case is optional but useful for handling unexpected values.\n```\n",
        "level": "Beginner"
    },
    {
        "id": "db3d92c3-a296-4f32-80db-e94507ba07cd",
        "question": "What is the difference between break and continue statements?",
        "answer": "**Answer:**\n\nIn C programming, both `break` and `continue` are control statements used inside loops, but they behave differently:\n\n- **break:**  \n  - Immediately exits the nearest enclosing loop (`for`, `while`, or `do-while`) or `switch` statement.\n  - The program continues execution with the statement following the loop or `switch`.\n  - Example:\n    ```c\n    for (int i = 0; i < 5; i++) {\n        if (i == 3) {\n            break; // Loop stops when i is 3\n        }\n        printf(\"%d \", i);\n    }\n    // Output: 0 1 2\n    ```\n\n- **continue:**  \n  - Skips the remaining statements in the current iteration of the loop.\n  - The loop proceeds with the next iteration.\n  - Example:\n    ```c\n    for (int i = 0; i < 5; i++) {\n        if (i == 3) {\n            continue; // Skip printing when i is 3\n        }\n        printf(\"%d \", i);\n    }\n    // Output: 0 1 2 4\n    ```\n\n**Summary Table:**\n\n| Statement | Effect                                                |\n|-----------|------------------------------------------------------|\n| break     | Exits the loop or switch entirely                    |\n| continue  | Skips to the next iteration of the loop              |",
        "level": "Beginner"
    },
    {
        "id": "fa545e4f-b880-4dbd-87db-d295182b2065",
        "question": "How do you define and use enums in C?",
        "answer": "```markdown\n### Defining and Using Enums in C\n\nIn C, an **enum** (short for *enumeration*) is a user-defined data type that consists of a set of named integer constants. Enums make code more readable and maintainable by giving meaningful names to integer values.\n\n#### Defining an Enum\n\nYou define an enum using the `enum` keyword:\n\n```c\nenum Day {\n    SUNDAY,\n    MONDAY,\n    TUESDAY,\n    WEDNESDAY,\n    THURSDAY,\n    FRIDAY,\n    SATURDAY\n};\n```\n\nBy default, the first name in the enum has the value `0`, the next `1`, and so on. You can also assign specific values:\n\n```c\nenum Status {\n    SUCCESS = 1,\n    FAILURE = 0,\n    PENDING = 2\n};\n```\n\n#### Declaring Enum Variables\n\nYou can declare variables of the enum type:\n\n```c\nenum Day today;\ntoday = WEDNESDAY;\n```\n\nOr combine definition and variable declaration:\n\n```c\nenum Color { RED, GREEN, BLUE } favoriteColor;\nfavoriteColor = GREEN;\n```\n\n#### Using Enums\n\nYou can use enums in switch statements, comparisons, and assignments:\n\n```c\n#include <stdio.h>\n\nenum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY };\n\nint main() {\n    enum Day today = FRIDAY;\n\n    if (today == FRIDAY) {\n        printf(\"It's Friday!\\n\");\n    }\n\n    switch (today) {\n        case MONDAY:\n            printf(\"Start of the week.\\n\");\n            break;\n        case FRIDAY:\n            printf(\"Weekend is coming!\\n\");\n            break;\n        default:\n            printf(\"It's a regular day.\\n\");\n    }\n\n    return 0;\n}\n```\n\n#### Summary\n\n- Enums assign names to integer values, improving code clarity.\n- By default, values start from 0, but you can specify custom values.\n- Use enums for variables that can take one out of a small set of possible values.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "49f441c0-86a9-47d4-b153-2177e5d548ce",
        "question": "How do you handle command-line arguments in C?",
        "answer": "In C, command-line arguments are handled using the parameters of the main function:\n\n```c\nint main(int argc, char *argv[])\n```\n\n- **argc** (argument count): An integer representing the number of command-line arguments passed, including the program name itself.\n- **argv** (argument vector): An array of strings (character pointers) listing all the arguments. `argv[0]` is the program name, and `argv[1]` to `argv[argc-1]` are the additional arguments.\n\n### Example\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    printf(\"Number of arguments: %d\\n\", argc);\n    for (int i = 0; i < argc; i++) {\n        printf(\"Argument %d: %s\\n\", i, argv[i]);\n    }\n    return 0;\n}\n```\n\n**Sample Output:**\n```\n$ ./myprogram hello world\nNumber of arguments: 3\nArgument 0: ./myprogram\nArgument 1: hello\nArgument 2: world\n```\n\n### Notes\n\n- Arguments are always passed as strings. If you need numeric values, use functions like `atoi()` or `strtol()` to convert them.\n- Always check `argc` before accessing `argv` elements to avoid out-of-bounds errors.\n\n**Summary:**  \nUse `int main(int argc, char *argv[])` to access command-line arguments in C, where `argc` is the count and `argv` is the array of arguments.",
        "level": "Intermediate"
    },
    {
        "id": "3bc8c766-8306-428a-a246-598120796558",
        "question": "What is a union in C and how is it different from a structure?",
        "answer": "```markdown\n### What is a union in C and how is it different from a structure?\n\nA **union** in C is a user-defined data type similar to a structure, but with a key difference in how memory is allocated for its members.\n\n#### Definition of Union\n\nA union allows you to define a variable that can hold data of different types, but **only one member can contain a value at any given time**. All members of a union share the same memory location.\n\n```c\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n```\n\n#### Memory Allocation\n\n- **Union:** Allocates enough memory to hold the largest member only. All members share this memory.\n- **Structure:** Allocates enough memory to hold all members; each member has its own storage.\n\n#### Example\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int i;\n    float f;\n    char str[20];\n};\n\nint main() {\n    union Data data;\n\n    data.i = 10;\n    printf(\"data.i: %d\\n\", data.i);\n\n    data.f = 220.5;\n    printf(\"data.f: %f\\n\", data.f);\n\n    // Now, data.i is likely overwritten\n    printf(\"data.i after data.f: %d\\n\", data.i);\n\n    return 0;\n}\n```\n\n#### Key Differences\n\n| Feature      | Structure (`struct`)                | Union (`union`)                          |\n|--------------|------------------------------------|------------------------------------------|\n| Memory       | Sum of all members' sizes          | Size of the largest member               |\n| Storage      | Each member has its own storage    | All members share the same storage       |\n| Usage        | Can store multiple values at once  | Can store only one value at a time       |\n| Modification | Changing one member doesn't affect others | Changing one member affects others |\n\n#### When to Use\n\n- **Structure:** When you need to store values of different types simultaneously.\n- **Union:** When you need to store one of several types, but never more than one at a time, saving memory.\n\n---\n**Summary:**  \nA union is a special data type in C that allows storing different data types in the same memory location, but only one at a time. Unlike a structure, which can store multiple values simultaneously, a union is memory-efficient when only one value is needed at any moment.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "74e6b11c-0b27-4a29-a67b-ee0dd4d7e7af",
        "question": "Explain the concept of bitwise operators in C.",
        "answer": "### Bitwise Operators in C\n\nBitwise operators in C are special operators used to perform operations directly on the binary representations of integers. They manipulate individual bits within an integer value, allowing for efficient low-level programming, such as hardware interfacing, cryptography, and performance-critical code.\n\n#### Types of Bitwise Operators\n\n| Operator | Name              | Description                                 |\n|----------|-------------------|---------------------------------------------|\n| `&`      | Bitwise AND       | Sets each bit to 1 if both bits are 1       |\n| `|`      | Bitwise OR        | Sets each bit to 1 if at least one bit is 1 |\n| `^`      | Bitwise XOR       | Sets each bit to 1 if only one bit is 1     |\n| `~`      | Bitwise NOT       | Inverts all the bits                        |\n| `<<`     | Left Shift        | Shifts bits to the left                     |\n| `>>`     | Right Shift       | Shifts bits to the right                    |\n\n#### Example\n\n```c\n#include <stdio.h>\n\nint main() {\n    unsigned int a = 5;    // 0000 0101 in binary\n    unsigned int b = 9;    // 0000 1001 in binary\n\n    printf(\"a & b = %d\\n\", a & b);   // 0000 0001 = 1\n    printf(\"a | b = %d\\n\", a | b);   // 0000 1101 = 13\n    printf(\"a ^ b = %d\\n\", a ^ b);   // 0000 1100 = 12\n    printf(\"~a = %d\\n\", ~a);         // 1111 1010 (in 8 bits) = -6 (in 2's complement)\n    printf(\"b << 1 = %d\\n\", b << 1); // 0001 0010 = 18\n    printf(\"b >> 1 = %d\\n\", b >> 1); // 0000 0100 = 4\n\n    return 0;\n}\n```\n\n#### Key Points\n\n- Bitwise operators only work with integer types (`int`, `char`, `short`, `long`, etc.).\n- They are often used for setting, clearing, toggling, or testing individual bits.\n- Bitwise operations are generally faster than arithmetic operations.\n\n#### Use Cases\n\n- Setting or clearing specific bits in a register.\n- Packing multiple values into a single integer.\n- Implementing efficient algorithms for cryptography or graphics.\n\nBitwise operators are a powerful tool in C for manipulating data at the bit level, enabling efficient and concise code for certain types of problems.",
        "level": "Intermediate"
    },
    {
        "id": "58019613-613e-4f7b-8309-e76e2295e6ec",
        "question": "What is the purpose of the extern keyword?",
        "answer": "The extern keyword in C is used to declare a variable or function that is defined in another file or translation unit. It tells the compiler that the variable or function exists, but its memory allocation or definition is elsewhere. This enables sharing of variables and functions across multiple source files in a program.\n\n**Key Points:**\n\n- **Variable Declaration:** extern is commonly used to declare global variables that are defined in another source file.\n- **Function Declaration:** By default, function declarations are treated as extern, so explicitly using extern is optional for functions.\n- **No Memory Allocation:** Using extern does not allocate memory for the variable; it only provides a reference.\n\n**Example:**\n\nSuppose you have two files: `file1.c` and `file2.c`.\n\nfile1.c\n```c\nint count = 10; // Definition and allocation\n```\n\nfile2.c\n```c\n#include <stdio.h>\n\nextern int count; // Declaration, no allocation\n\nint main() {\n    printf(\"%d\\n\", count); // Accesses the variable defined in file1.c\n    return 0;\n}\n```\n\n**Summary Table:**\n\n| Usage                  | extern int x; | int x;          |\n|------------------------|---------------|-----------------|\n| Declaration only       | Yes           | Yes             |\n| Definition (allocates) | No            | Yes             |\n\n**Purpose:**  \nThe extern keyword is essential for managing scope and linkage in multi-file C programs, enabling variables and functions to be shared across files without multiple definitions.",
        "level": "Advanced"
    },
    {
        "id": "620803ce-aa84-4dbb-8c84-70efa25e34d3",
        "question": "How do you prevent multiple inclusions of a header file?",
        "answer": "To prevent multiple inclusions of a header file in C, you use **include guards**. These are preprocessor directives that ensure the contents of a header file are included only once, even if the file is included multiple times in a project.\n\nHere’s how you implement include guards:\n\n```c\n#ifndef HEADER_FILE_NAME_H\n#define HEADER_FILE_NAME_H\n\n// Header file contents go here\n\n#endif // HEADER_FILE_NAME_H\n```\n\n**Explanation:**\n\n- `#ifndef HEADER_FILE_NAME_H`: Checks if the macro `HEADER_FILE_NAME_H` is not defined.\n- `#define HEADER_FILE_NAME_H`: Defines the macro if it hasn’t been defined yet.\n- The actual contents of the header file are placed between these directives.\n- `#endif`: Ends the conditional.\n\n**Example:**\n\nSuppose your header file is named `myheader.h`:\n\n```c\n#ifndef MYHEADER_H\n#define MYHEADER_H\n\nvoid myFunction();\n\n#endif // MYHEADER_H\n```\n\n**Why use include guards?**\n\n- Prevents redefinition errors.\n- Ensures declarations and definitions in the header are processed only once per translation unit.\n\n**Alternative (C11 and later):**\n\nThe `#pragma once` directive can also be used, but it is not part of the C standard (though widely supported):\n\n```c\n#pragma once\n\n// Header file contents\n```\n\n**Best Practice:**  \nUse traditional include guards for maximum portability.",
        "level": "Advanced"
    },
    {
        "id": "abd50d90-03ef-4d83-8db3-ebe4bf1ad8f7",
        "question": "How do you dynamically allocate a 2D array in C?",
        "answer": "To dynamically allocate a 2D array in C, you typically use pointers and the malloc function. There are two common approaches:\n\n### 1. Array of Pointers (Jagged Array)\n\nThis method allocates an array of pointers, then allocates each row separately.\n\n```c\nint rows = 5, cols = 10;\nint **arr = malloc(rows * sizeof(int *));\nfor (int i = 0; i < rows; i++) {\n    arr[i] = malloc(cols * sizeof(int));\n}\n\n// Usage: arr[row][col] = value;\n\n// Free memory\nfor (int i = 0; i < rows; i++) {\n    free(arr[i]);\n}\nfree(arr);\n```\n\n**Pros:** Each row can have a different length (jagged arrays possible).  \n**Cons:** Non-contiguous memory allocation; slightly slower access.\n\n---\n\n### 2. Single Block Allocation (Contiguous 2D Array)\n\nThis method allocates a single block for all elements and sets up pointers for each row.\n\n```c\nint rows = 5, cols = 10;\nint *data = malloc(rows * cols * sizeof(int));\nint **arr = malloc(rows * sizeof(int *));\nfor (int i = 0; i < rows; i++) {\n    arr[i] = data + i * cols;\n}\n\n// Usage: arr[row][col] = value;\n\n// Free memory\nfree(arr);\nfree(data);\n```\n\n**Pros:** All elements are in contiguous memory (better cache performance).  \n**Cons:** All rows must have the same length.\n\n---\n\n### Notes\n\n- Always check the result of malloc for NULL to ensure allocation succeeded.\n- Remember to free all allocated memory to avoid memory leaks.\n- For multi-dimensional arrays beyond 2D, similar principles apply.\n\n---\n\n**Example Usage:**\n\n```c\narr[2][3] = 42; // Sets the element at row 2, column 3 to 42\n```\n\n---\n\n**Summary Table:**\n\n| Method                 | Memory Layout   | Flexibility | Performance |\n|------------------------|----------------|-------------|-------------|\n| Array of Pointers      | Non-contiguous | High        | Moderate    |\n| Single Block Allocation| Contiguous     | Low         | High        |",
        "level": "Advanced"
    },
    {
        "id": "fc3495dc-4ec5-46ac-a0a0-b2d037fc701e",
        "question": "What are macros and how are they defined in C?",
        "answer": "**Macros in C**\n\nMacros are preprocessor directives in C that allow you to define symbolic names or code fragments that are replaced by the preprocessor before compilation. They are commonly used to define constants, inline functions, or code snippets to improve code readability and maintainability.\n\n### Defining Macros\n\nMacros are defined using the `#define` directive. There are two main types:\n\n#### 1. Object-like Macros\n\nThese are simple replacements, often used for constants.\n\n```c\n#define PI 3.14159\n#define MAX_SIZE 100\n```\n\nWhenever `PI` or `MAX_SIZE` appears in the code, the preprocessor replaces them with `3.14159` and `100`, respectively.\n\n#### 2. Function-like Macros\n\nThese macros take arguments and can be used like functions, but the code is replaced inline.\n\n```c\n#define SQUARE(x) ((x) * (x))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n```\n\nWhen you use `SQUARE(5)`, it gets replaced with `((5) * (5))`.\n\n### Example Usage\n\n```c\n#include <stdio.h>\n\n#define PI 3.14159\n#define SQUARE(x) ((x) * (x))\n\nint main() {\n    double r = 2.0;\n    double area = PI * SQUARE(r);\n    printf(\"Area: %f\\n\", area);\n    return 0;\n}\n```\n\n### Notes\n\n- Macros do not perform type checking.\n- Parentheses should be used carefully in macro definitions to avoid unexpected results.\n- Macros are replaced before compilation, so they do not consume memory at runtime.\n\n**Summary:**  \nMacros in C are powerful tools for code substitution and are defined using the `#define` directive. They can represent constants or code fragments, and their usage can make code more readable and maintainable when used appropriately.",
        "level": "Intermediate"
    },
    {
        "id": "37e8aae6-179f-4c04-9656-916df27095f0",
        "question": "What is the difference between a shallow copy and a deep copy?",
        "answer": "### Difference Between Shallow Copy and Deep Copy in C\n\nIn C programming, **shallow copy** and **deep copy** refer to two different ways of copying data structures (like arrays, structs, or objects containing pointers).\n\n---\n\n#### **Shallow Copy**\n\n- **Definition:** A shallow copy copies the immediate values of the data structure (including pointer values), but does **not** copy the data pointed to by those pointers.\n- **Effect:** Both the original and the copy share the same referenced memory (e.g., heap-allocated memory).\n- **Implication:** Changes made through one pointer affect the other, leading to potential bugs (like double-free errors or unintended data modification).\n\n**Example:**\n```c\ntypedef struct {\n    int *data;\n} MyStruct;\n\nMyStruct a, b;\na.data = malloc(sizeof(int));\n*a.data = 42;\n\n// Shallow copy: just copies the pointer\nb = a;\n\n// Both a.data and b.data point to the same memory\n```\n\n---\n\n#### **Deep Copy**\n\n- **Definition:** A deep copy duplicates not only the immediate values but also the data referenced by any pointers. This means all dynamically allocated memory is also copied.\n- **Effect:** The original and the copy are completely independent; changes to one do not affect the other.\n- **Implication:** Prevents issues like double-free or unintended data sharing, but requires manual implementation.\n\n**Example:**\n```c\nb.data = malloc(sizeof(int));\n*b.data = *a.data; // Deep copy of the data\n\n// Now a.data and b.data point to different memory locations\n```\n\n---\n\n#### **Summary Table**\n\n| Aspect         | Shallow Copy                        | Deep Copy                           |\n|----------------|------------------------------------|-------------------------------------|\n| Pointer Data   | Copied as pointer values            | Copied as new allocations           |\n| Independence   | Not independent (shared memory)     | Fully independent                   |\n| Implementation | Default assignment                  | Manual (custom function needed)     |\n| Use Cases      | When sharing is intended            | When full independence is required  |\n\n---\n\n**In summary:**  \n- Use a **shallow copy** for simple structures without pointers or when shared data is acceptable.\n- Use a **deep copy** when you need independent copies of complex structures containing pointers.",
        "level": "Advanced"
    },
    {
        "id": "b37e2777-5163-473f-b0ca-97bf0c6642ee",
        "question": "How do you implement error handling in C?",
        "answer": "```markdown\n## How to Implement Error Handling in C\n\nC does not have built-in exception handling like some other languages (e.g., `try-catch` in Java or C++). Instead, error handling in C is typically done using:\n\n1. **Return Codes**\n2. **`errno` Variable**\n3. **`perror()` and `strerror()` Functions**\n4. **Custom Error Handling**\n\n### 1. Return Codes\n\nMost C library functions return a value indicating success or failure. For example, `fopen()` returns `NULL` on failure.\n\n```c\nFILE *fp = fopen(\"file.txt\", \"r\");\nif (fp == NULL) {\n    // Handle error\n    printf(\"Error opening file!\\n\");\n}\n```\n\n### 2. `errno` Variable\n\nThe global variable `errno` is set by system calls and some library functions in the event of an error to indicate what went wrong.\n\n```c\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n\nFILE *fp = fopen(\"file.txt\", \"r\");\nif (fp == NULL) {\n    printf(\"Error opening file: %s\\n\", strerror(errno));\n}\n```\n\n### 3. `perror()` and `strerror()`\n\n- `perror()` prints a description of the last error that occurred.\n- `strerror(errno)` returns a string describing the error code.\n\n```c\nif (fp == NULL) {\n    perror(\"fopen failed\");\n}\n```\n\n### 4. Custom Error Handling\n\nYou can define your own error codes and handle them as needed.\n\n```c\n#define SUCCESS 0\n#define ERROR_FILE_NOT_FOUND 1\n\nint open_file(const char *filename) {\n    FILE *fp = fopen(filename, \"r\");\n    if (fp == NULL) {\n        return ERROR_FILE_NOT_FOUND;\n    }\n    // ... use the file\n    fclose(fp);\n    return SUCCESS;\n}\n\nint main() {\n    int status = open_file(\"file.txt\");\n    if (status != SUCCESS) {\n        printf(\"Custom error: File not found.\\n\");\n    }\n    return 0;\n}\n```\n\n### Summary\n\n- Check return values of functions.\n- Use `errno`, `perror()`, and `strerror()` for detailed error information.\n- Define and use custom error codes for your own functions.\n\nThis approach helps you detect and respond to errors effectively in C programs.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "9c2476fe-6ba3-4c00-9a0d-9aba72346377",
        "question": "Explain the process of compiling and linking in C.",
        "answer": "Certainly! Here’s an explanation in markdown format:\n\n---\n\n## Compiling and Linking in C\n\nThe process of turning C source code into an executable program involves two main steps: **compiling** and **linking**.\n\n### 1. Compiling\n\n- **Source Code to Object Code:**  \n  The C compiler (like `gcc` or `clang`) takes your `.c` source files and translates them into **object files** (`.o` or `.obj`).  \n- **Syntax Checking:**  \n  During compilation, the compiler checks for syntax errors and ensures the code follows the C language rules.\n- **Intermediate Code Generation:**  \n  The compiler converts the code into machine code instructions, but references to external functions or variables are left unresolved.\n\n**Example:**\n```bash\ngcc -c main.c    # Produces main.o\n```\n\n### 2. Linking\n\n- **Combining Object Files:**  \n  The linker takes one or more object files and combines them into a single executable file.\n- **Resolving References:**  \n  It resolves references to functions and variables that are declared in different files or libraries (like the C standard library).\n- **Producing Executable:**  \n  The final output is an executable file (like `a.out` on Unix or `.exe` on Windows).\n\n**Example:**\n```bash\ngcc main.o utils.o -o myprogram\n```\n\n### Summary Diagram\n\n```\nmain.c + utils.c\n      |   (compile)\n      v\nmain.o + utils.o\n      |   (link)\n      v\n   myprogram (executable)\n```\n\n---\n\n**In short:**  \n- **Compiling** translates source code to object code.\n- **Linking** combines object code and libraries to create an executable.",
        "level": "Intermediate"
    },
    {
        "id": "f2244566-94c0-4d98-ad4e-08f19cbebe7f",
        "question": "What are storage classes in C and name them.",
        "answer": "**Storage classes** in C define the scope (visibility), lifetime, and linkage of variables and/or functions within a C program. They determine where a variable is stored, its default initial value, and how long it exists during program execution.\n\nThe four storage classes in C are:\n\n1. **auto**  \n   - Default for local variables inside functions.\n   - Scope: Local to the block.\n   - Lifetime: Created on entry, destroyed on exit.\n\n2. **register**  \n   - Suggests storing the variable in a CPU register for faster access.\n   - Scope: Local to the block.\n   - Lifetime: Created on entry, destroyed on exit.\n\n3. **static**  \n   - Retains the value of a variable between function calls.\n   - Scope: Local to the block (if declared inside a function) or global (if outside).\n   - Lifetime: Entire program execution.\n\n4. **extern**  \n   - Declares a variable defined elsewhere (usually in another file).\n   - Scope: Global.\n   - Lifetime: Entire program execution.\n\n**Summary Table:**\n\n| Storage Class | Scope         | Lifetime           | Default Value | Linkage      |\n|---------------|--------------|--------------------|---------------|--------------|\n| auto          | Local        | Block execution    | Garbage       | None         |\n| register      | Local        | Block execution    | Garbage       | None         |\n| static        | Local/Global | Entire program     | Zero          | Internal     |\n| extern        | Global       | Entire program     | Zero          | External     |",
        "level": "Intermediate"
    }
]