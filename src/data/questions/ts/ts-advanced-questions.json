{
    "questions": [
        {
            "id": "ed0331a3-d4b2-401a-9637-a057fd37bcd4",
            "question": "What is the purpose of the 'readonly' modifier in TypeScript?",
            "answer": "```markdown\nThe `readonly` modifier in TypeScript is used to make properties of an object immutable after their initial assignment. Once a property is marked as `readonly`, its value cannot be changed. This is particularly useful for creating objects with properties that should not be modified after they are initialized, ensuring immutability and reducing the risk of unintended side effects.\n\nFor example:\n\n```typescript\nclass Example {\n  readonly id: number;\n\n  constructor(id: number) {\n    this.id = id; // Allowed: Initial assignment\n  }\n\n  updateId(newId: number) {\n    // this.id = newId; // Error: Cannot assign to 'id' because it is a read-only property\n  }\n}\n\nconst example = new Example(1);\nconsole.log(example.id); // Output: 1\n// example.id = 2; // Error: Cannot assign to 'id' because it is a read-only property\n```\n\nIn addition to classes, the `readonly` modifier can also be applied to interfaces and type aliases to enforce immutability for object properties.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418325Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "5e008a07-f931-42aa-a6e1-851779d29217",
            "question": "How do you enforce immutability in TypeScript?",
            "answer": "```markdown\nIn TypeScript, immutability can be enforced using the following techniques:\n\n1. **Readonly Properties**:\n   Use the `readonly` modifier for class properties or object types to ensure that their values cannot be reassigned after initialization.\n   ```typescript\n   class Person {\n       readonly name: string;\n\n       constructor(name: string) {\n           this.name = name;\n       }\n   }\n\n   const person = new Person(\"John\");\n   // person.name = \"Doe\"; // Error: Cannot assign to 'name' because it is a read-only property.\n   ```\n\n2. **Readonly Utility Type**:\n   Use the `Readonly<T>` utility type to make all properties of an object type immutable.\n   ```typescript\n   interface User {\n       id: number;\n       name: string;\n   }\n\n   const user: Readonly<User> = { id: 1, name: \"Alice\" };\n   // user.name = \"Bob\"; // Error: Cannot assign to 'name' because it is a read-only property.\n   ```\n\n3. **Readonly Arrays**:\n   Use the `readonly` modifier for arrays to prevent modifications to the array's contents.\n   ```typescript\n   const numbers: readonly number[] = [1, 2, 3];\n   // numbers.push(4); // Error: Property 'push' does not exist on type 'readonly number[]'.\n   ```\n\n4. **Immutability Libraries**:\n   Use libraries like `Immutable.js` or `Immer` to enforce immutability in complex data structures. These libraries provide immutable data structures and utilities for working with them.\n\n5. **Deep Readonly**:\n   For deeply nested objects, you can create or use a utility type to recursively make all properties readonly.\n   ```typescript\n   type DeepReadonly<T> = {\n       readonly [K in keyof T]: T[K] extends object ? DeepReadonly<T[K]> : T[K];\n   };\n\n   interface Config {\n       settings: {\n           theme: string;\n           language: string;\n       };\n   }\n\n   const config: DeepReadonly<Config> = {\n       settings: {\n           theme: \"dark\",\n           language: \"en\",\n       },\n   };\n\n   // config.settings.theme = \"light\"; // Error: Cannot assign to 'theme' because it is a read-only property.\n   ```\n\nBy combining these techniques, you can enforce immutability in TypeScript effectively, ensuring that your data structures remain consistent and unmodifiable.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418430Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "dea08a72-5205-4b4e-994c-3a762e8c338d",
            "question": "What is TypeScript, and how does it differ from JavaScript?",
            "answer": "```markdown\nTypeScript is a strongly typed superset of JavaScript that compiles to plain JavaScript. It adds optional static typing, interfaces, and other features to enhance the development experience and catch errors during development. \n\nThe key differences between TypeScript and JavaScript are:\n\n1. **Static Typing**: TypeScript allows developers to define types for variables, function parameters, and return values, enabling type checking at compile time. JavaScript is dynamically typed, meaning types are determined at runtime.\n\n2. **Compilation**: TypeScript code needs to be compiled (or transpiled) into JavaScript before it can be executed in a browser or Node.js environment. JavaScript, on the other hand, runs directly without compilation.\n\n3. **Enhanced Tooling**: TypeScript provides better support for IDEs and text editors, offering features like autocompletion, refactoring, and type checking, which improve developer productivity.\n\n4. **Advanced Features**: TypeScript introduces features like interfaces, enums, generics, and access modifiers, which are not available in plain JavaScript.\n\n5. **Backward Compatibility**: TypeScript is fully compatible with JavaScript, meaning any valid JavaScript code is also valid TypeScript code.\n\nIn summary, TypeScript builds upon JavaScript by adding static typing and other features, making it a powerful tool for developing large-scale, maintainable applications.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418200Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "ac65ba82-fd62-4c07-9f74-bd44245121e8",
            "question": "How do you define and use interfaces in TypeScript?",
            "answer": "```markdown\nIn TypeScript, interfaces are used to define the structure of an object. They act as a contract that specifies the properties and methods an object must have. Interfaces are particularly useful for type-checking and ensuring consistency in your code.\n\n### Defining an Interface\nYou can define an interface using the `interface` keyword. Here's an example:\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n  greet(): string;\n}\n```\n\nIn this example:\n- `name` is a string property.\n- `age` is a number property.\n- `greet` is a method that returns a string.\n\n### Using an Interface\nYou can use an interface to type-check objects or function parameters:\n\n```typescript\nconst person: Person = {\n  name: \"John\",\n  age: 30,\n  greet() {\n    return `Hello, my name is ${this.name}`;\n  },\n};\n\nconsole.log(person.greet());\n```\n\n### Optional Properties\nYou can make properties optional by adding a `?` after the property name:\n\n```typescript\ninterface Person {\n  name: string;\n  age?: number; // Optional property\n}\n```\n\n### Readonly Properties\nYou can make properties read-only using the `readonly` modifier:\n\n```typescript\ninterface Person {\n  readonly id: number;\n  name: string;\n}\n```\n\n### Extending Interfaces\nInterfaces can extend other interfaces to inherit their properties:\n\n```typescript\ninterface Employee extends Person {\n  position: string;\n}\n```\n\n### Function Interfaces\nYou can define the structure of a function using an interface:\n\n```typescript\ninterface Add {\n  (a: number, b: number): number;\n}\n\nconst add: Add = (a, b) => a + b;\n```\n\n### Conclusion\nInterfaces in TypeScript provide a powerful way to define and enforce the shape of objects, ensuring your code is robust and maintainable.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418242Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "aa4bbfd8-2d60-4cc2-b48c-74b30338f3d2",
            "question": "What are the benefits of using TypeScript in a project?",
            "answer": "```markdown\n### Benefits of Using TypeScript in a Project\n\n1. **Static Typing**: TypeScript provides static typing, which helps catch errors at compile time rather than runtime, leading to more robust and error-free code.\n\n2. **Improved Developer Experience**: With features like IntelliSense, autocompletion, and type checking, TypeScript enhances productivity and makes it easier to work with large codebases.\n\n3. **Better Code Maintainability**: TypeScript enforces strict typing and clear interfaces, making the code easier to read, understand, and maintain over time.\n\n4. **Enhanced Collaboration**: Strong typing and explicit contracts between components make it easier for teams to collaborate, as the code becomes more predictable and self-documenting.\n\n5. **Early Bug Detection**: By catching type-related errors during development, TypeScript reduces the likelihood of runtime errors in production.\n\n6. **Seamless Integration with JavaScript**: TypeScript is a superset of JavaScript, allowing developers to gradually adopt it in existing projects without rewriting the entire codebase.\n\n7. **Support for Modern JavaScript Features**: TypeScript supports ES6+ features and compiles them down to compatible JavaScript for older environments.\n\n8. **Rich Ecosystem and Tooling**: TypeScript has excellent support in IDEs, build tools, and frameworks, making it easy to integrate into modern development workflows.\n\n9. **Improved Refactoring**: The strong typing system makes refactoring safer and more efficient, as the compiler ensures that changes are consistent throughout the codebase.\n\n10. **Community and Ecosystem**: TypeScript has a large and active community, providing extensive resources, libraries, and support for developers.\n\nBy using TypeScript, developers can create more reliable, maintainable, and scalable applications while reducing development time and debugging efforts.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418254Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "0be107ec-0555-48e6-96eb-70b3533e8a0b",
            "question": "How do you declare a variable with a specific type in TypeScript?",
            "answer": "```markdown\nIn TypeScript, you can declare a variable with a specific type by using a colon (`:`) followed by the type after the variable name. For example:\n\n```typescript\nlet myVariable: string = \"Hello, TypeScript!\";\n```\n\nIn this example, `myVariable` is explicitly declared as a `string` type. This ensures that the variable can only hold string values, and TypeScript will throw an error if you try to assign a value of a different type.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418265Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "ef9118a5-05b4-4bca-899a-df8ae61e3951",
            "question": "What is the purpose of the 'Omit' utility type in TypeScript?",
            "answer": "```markdown\nThe `Omit` utility type in TypeScript is used to create a new type by excluding one or more properties from an existing type. It is particularly useful when you want to work with a subset of an existing type but need to exclude specific fields.\n\n### Syntax:\n```typescript\nOmit<Type, Keys>\n```\n\n- `Type`: The original type from which properties will be omitted.\n- `Keys`: The keys (property names) to exclude from the original type.\n\n### Example:\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  password: string;\n}\n\ntype PublicUser = Omit<User, 'password'>;\n\n// PublicUser will be:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n// }\n```\n\nIn this example, the `Omit` utility removes the `password` property from the `User` type, creating a new `PublicUser` type that excludes sensitive information.\n\n### Purpose:\nThe primary purpose of `Omit` is to simplify type manipulation by allowing developers to exclude specific properties from a type without having to redefine the entire structure manually.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418532Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "42336965-ee88-44e6-9a4f-af305496dcad",
            "question": "What are type annotations, and how are they used in TypeScript?",
            "answer": "```markdown\n### What are Type Annotations, and How Are They Used in TypeScript?\n\nType annotations in TypeScript are a way to explicitly declare the types of variables, function parameters, return values, or object properties. They help ensure type safety by allowing the TypeScript compiler to catch type-related errors during development.\n\n#### Syntax\nType annotations are added using a colon (`:`) followed by the type.\n\n#### Examples\n\n1. **Variable Type Annotation**:\n   ```typescript\n   let age: number = 25; // `age` must be a number\n   let name: string = \"John\"; // `name` must be a string\n   ```\n\n2. **Function Parameter and Return Type Annotation**:\n   ```typescript\n   function add(a: number, b: number): number {\n       return a + b; // The function must return a number\n   }\n   ```\n\n3. **Object Type Annotation**:\n   ```typescript\n   let person: { name: string; age: number } = {\n       name: \"Alice\",\n       age: 30\n   };\n   ```\n\n4. **Array Type Annotation**:\n   ```typescript\n   let numbers: number[] = [1, 2, 3]; // Array of numbers\n   ```\n\n#### Benefits of Type Annotations\n- **Improved Code Safety**: Prevents unintended type errors.\n- **Better Tooling Support**: Enables features like autocompletion and type inference in IDEs.\n- **Documentation**: Makes the code more readable and self-explanatory.\n\nWhile TypeScript can infer types in many cases, using type annotations explicitly can make the code more robust and easier to understand.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418275Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "a05bb8f0-115e-4808-b100-aa1128dd0c0e",
            "question": "What is the difference between 'any' and 'unknown' types in TypeScript?",
            "answer": "```markdown\nIn TypeScript, both `any` and `unknown` are top types, meaning they can represent any value. However, they have significant differences in terms of safety and usage:\n\n### `any`\n- The `any` type disables type checking entirely. Once a value is typed as `any`, you can perform any operation on it without the compiler raising errors.\n- It is considered unsafe because it bypasses TypeScript's type-checking system, potentially leading to runtime errors.\n- Example:\n  ```typescript\n  let value: any;\n  value = 42;\n  value.toUpperCase(); // No error, but this will fail at runtime if `value` is not a string.\n  ```\n\n### `unknown`\n- The `unknown` type is safer than `any` because it enforces type checking. You cannot perform operations on a value of type `unknown` without first narrowing its type (e.g., using type guards).\n- It is useful when you want to represent a value that could be of any type but still want to ensure type safety.\n- Example:\n  ```typescript\n  let value: unknown;\n  value = 42;\n\n  // value.toUpperCase(); // Error: Object is of type 'unknown'.\n\n  if (typeof value === \"string\") {\n    value.toUpperCase(); // Safe, as the type is narrowed to 'string'.\n  }\n  ```\n\n### Key Differences\n| Feature                | `any`                          | `unknown`                       |\n|------------------------|--------------------------------|---------------------------------|\n| Type Safety           | Unsafe                        | Safe                           |\n| Type Checking         | Disabled                      | Enforced                       |\n| Operations Allowed    | Any operation is allowed      | Requires type narrowing first  |\n| Use Case              | Quick prototyping or migration| Representing unknown values safely |\n\nIn summary, prefer `unknown` over `any` when you need to handle values of unknown types but want to maintain type safety.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418286Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "0bc4dc2f-0457-49eb-afbb-664d883563e6",
            "question": "How does TypeScript handle null and undefined types?",
            "answer": "```markdown\nTypeScript provides robust handling for `null` and `undefined` types, allowing developers to manage these values explicitly. Here's how TypeScript deals with them:\n\n1. **Strict Null Checks (`strictNullChecks`):**\n   - When the `strictNullChecks` compiler option is enabled (which is recommended), `null` and `undefined` are treated as distinct types. This means variables of a specific type (e.g., `string`) cannot be assigned `null` or `undefined` unless explicitly allowed.\n   - Example:\n     ```typescript\n     let name: string = \"John\";\n     name = null; // Error: Type 'null' is not assignable to type 'string'.\n     ```\n\n2. **Union Types for Null and Undefined:**\n   - To allow `null` or `undefined` as valid values for a variable, you can use union types.\n   - Example:\n     ```typescript\n     let name: string | null = \"John\";\n     name = null; // Valid\n     ```\n\n3. **Default Behavior Without `strictNullChecks`:**\n   - If `strictNullChecks` is disabled, `null` and `undefined` are treated as valid values for all types. This can lead to potential runtime errors, as TypeScript won't enforce strict type safety.\n\n4. **Optional Properties and Parameters:**\n   - TypeScript uses `undefined` to represent the absence of a value for optional properties or parameters.\n   - Example:\n     ```typescript\n     interface User {\n       name: string;\n       age?: number; // age is optional and can be undefined\n     }\n     ```\n\n5. **Non-Nullable Types:**\n   - TypeScript provides the `NonNullable` utility type to exclude `null` and `undefined` from a type.\n   - Example:\n     ```typescript\n     type NonNullableString = NonNullable<string | null | undefined>; // Result: string\n     ```\n\n6. **Nullish Coalescing (`??`) and Optional Chaining (`?.`):**\n   - TypeScript supports modern JavaScript features like nullish coalescing and optional chaining to handle `null` and `undefined` values more gracefully.\n   - Example:\n     ```typescript\n     const value = null ?? \"default\"; // Result: \"default\"\n     const user = { name: \"John\" };\n     console.log(user?.age); // Safely accesses age, outputs undefined if not present\n     ```\n\nBy leveraging these features, TypeScript ensures better type safety and helps prevent common issues related to `null` and `undefined` values.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418298Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "3bc8b8dc-2582-4b62-99e3-a37ba0c5b5f8",
            "question": "What are generics in TypeScript, and how do you use them?",
            "answer": "```markdown\nGenerics in TypeScript are a powerful feature that allows you to create reusable, type-safe components, functions, and classes. They enable you to define a component or function with a placeholder type that can be specified later when the component or function is used. This provides flexibility while maintaining type safety.\n\n### Why Use Generics?\nGenerics are useful when:\n- You want to write code that works with multiple types without sacrificing type safety.\n- You want to avoid duplicating code for different types.\n- You want to enforce constraints on the types that can be used.\n\n### Syntax and Usage\n\n#### Generic Functions\nA generic function allows you to define a placeholder type using angle brackets (`<T>`), where `T` is a type variable that can represent any type.\n\n```typescript\nfunction identity<T>(value: T): T {\n  return value;\n}\n\n// Usage\nconst numberValue = identity<number>(42); // T is inferred as number\nconst stringValue = identity<string>(\"Hello\"); // T is inferred as string\n```\n\n#### Generic Classes\nGeneric classes allow you to define a class with a type parameter.\n\n```typescript\nclass Box<T> {\n  private content: T;\n\n  constructor(content: T) {\n    this.content = content;\n  }\n\n  getContent(): T {\n    return this.content;\n  }\n}\n\n// Usage\nconst numberBox = new Box<number>(123);\nconsole.log(numberBox.getContent()); // Output: 123\n\nconst stringBox = new Box<string>(\"TypeScript\");\nconsole.log(stringBox.getContent()); // Output: TypeScript\n```\n\n#### Generic Interfaces\nGeneric interfaces allow you to define the structure of an object with a type parameter.\n\n```typescript\ninterface Pair<T, U> {\n  first: T;\n  second: U;\n}\n\nconst pair: Pair<string, number> = {\n  first: \"Hello\",\n  second: 42,\n};\n```\n\n#### Generic Constraints\nYou can constrain the type parameter to ensure it meets certain requirements using the `extends` keyword.\n\n```typescript\nfunction logLength<T extends { length: number }>(value: T): void {\n  console.log(value.length);\n}\n\n// Usage\nlogLength(\"Hello\"); // Works because string has a length property\nlogLength([1, 2, 3]); // Works because arrays have a length property\n// logLength(42); // Error: number does not have a length property\n```\n\n### Benefits of Generics\n- **Reusability**: Write code that works with different types.\n- **Type Safety**: Catch errors at compile time.\n- **Flexibility**: Allow users to specify the type they need.\n\nGenerics are a cornerstone of TypeScript's type system, enabling developers to write robust, reusable, and maintainable code.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418308Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "9085b8d4-a6c7-4e8b-9abf-773e5d639f33",
            "question": "How do you create and use a union type in TypeScript?",
            "answer": "```markdown\nIn TypeScript, a union type allows a variable to hold values of multiple types. You can create a union type using the `|` (pipe) symbol to combine two or more types. Here's how you can create and use a union type:\n\n### Creating a Union Type\n```typescript\ntype StringOrNumber = string | number;\n```\n\nIn this example, the `StringOrNumber` type can hold either a `string` or a `number`.\n\n### Using a Union Type\nYou can use the union type in variables, function parameters, or return types:\n\n#### Example 1: Variable with Union Type\n```typescript\nlet value: StringOrNumber;\n\nvalue = \"Hello\"; // valid\nvalue = 42;      // valid\n// value = true; // Error: Type 'boolean' is not assignable to type 'string | number'.\n```\n\n#### Example 2: Function with Union Type Parameter\n```typescript\nfunction printValue(value: StringOrNumber): void {\n  if (typeof value === \"string\") {\n    console.log(`String value: ${value}`);\n  } else {\n    console.log(`Number value: ${value}`);\n  }\n}\n\nprintValue(\"Hello\"); // Output: String value: Hello\nprintValue(123);     // Output: Number value: 123\n```\n\n#### Example 3: Union Type in Function Return\n```typescript\nfunction getValue(isString: boolean): StringOrNumber {\n  return isString ? \"A string\" : 100;\n}\n\nconst result = getValue(true); // result is of type StringOrNumber\nconsole.log(result);\n```\n\n### Key Points\n- Use type guards (e.g., `typeof`, `instanceof`) to narrow down the type when working with union types.\n- Union types are helpful for scenarios where a value can belong to multiple types, improving flexibility while maintaining type safety.\n\nBy leveraging union types, you can write more robust and type-safe TypeScript code.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418316Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "4345f544-bdb8-45f3-bf1e-473d0653123e",
            "question": "What are mapped types in TypeScript, and how are they used?",
            "answer": "```markdown\n### Mapped Types in TypeScript\n\nMapped types in TypeScript are a powerful feature that allows you to create new types by transforming the properties of an existing type. They are particularly useful for creating variations of a given type, such as making all properties optional, readonly, or applying other transformations.\n\n#### Syntax\nMapped types use the `keyof` operator to iterate over the keys of an existing type and apply a transformation. The basic syntax is:\n\n```typescript\ntype MappedType<T> = {\n  [Key in keyof T]: Transformation;\n};\n```\n\n- `T` is the original type.\n- `keyof T` represents the keys of the type `T`.\n- `Key` is a placeholder for each key in `T`.\n- `Transformation` is the operation applied to each property.\n\n#### Common Use Cases\n\n1. **Making All Properties Optional**\n   ```typescript\n   type Partial<T> = {\n     [Key in keyof T]?: T[Key];\n   };\n\n   interface User {\n     id: number;\n     name: string;\n   }\n\n   type OptionalUser = Partial<User>;\n   // Equivalent to:\n   // type OptionalUser = {\n   //   id?: number;\n   //   name?: string;\n   // };\n   ```\n\n2. **Making All Properties Readonly**\n   ```typescript\n   type Readonly<T> = {\n     readonly [Key in keyof T]: T[Key];\n   };\n\n   interface User {\n     id: number;\n     name: string;\n   }\n\n   type ReadonlyUser = Readonly<User>;\n   // Equivalent to:\n   // type ReadonlyUser = {\n   //   readonly id: number;\n   //   readonly name: string;\n   // };\n   ```\n\n3. **Mapping Property Types**\n   ```typescript\n   type Record<K extends keyof any, T> = {\n     [P in K]: T;\n   };\n\n   type StringRecord = Record<'a' | 'b' | 'c', string>;\n   // Equivalent to:\n   // type StringRecord = {\n   //   a: string;\n   //   b: string;\n   //   c: string;\n   // };\n   ```\n\n4. **Applying Custom Transformations**\n   ```typescript\n   type Nullable<T> = {\n     [Key in keyof T]: T[Key] | null;\n   };\n\n   interface User {\n     id: number;\n     name: string;\n   }\n\n   type NullableUser = Nullable<User>;\n   // Equivalent to:\n   // type NullableUser = {\n   //   id: number | null;\n   //   name: string | null;\n   // };\n   ```\n\n#### Built-in Mapped Types\nTypeScript provides several built-in mapped types, such as:\n- `Partial<T>`: Makes all properties optional.\n- `Required<T>`: Makes all properties required.\n- `Readonly<T>`: Makes all properties readonly.\n- `Pick<T, K>`: Picks a subset of properties from a type.\n- `Record<K, T>`: Creates a type with a set of keys `K` and values of type `T`.\n\n#### Benefits\n- **Reusability**: Mapped types allow you to create reusable and flexible type transformations.\n- **Type Safety**: They ensure that transformations are applied consistently across all properties of a type.\n- **Dynamic Type Creation**: They enable dynamic creation of types based on existing ones, reducing redundancy.\n\n#### Example\n```typescript\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\ntype ReadonlyProduct = Readonly<Product>;\nconst product: ReadonlyProduct = {\n  id: 1,\n  name: \"Laptop\",\n  price: 1000,\n};\n\n// The following line will cause an error because the properties are readonly\n// product.price = 1200;\n```\n\nMapped types are a cornerstone of TypeScript's type system, enabling developers to write more expressive, concise, and maintainable code.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418335Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "2a74a223-906b-4e24-8146-89bc54a321c0",
            "question": "How does TypeScript's type inference work?",
            "answer": "```markdown\nTypeScript's type inference is a feature that allows the compiler to automatically determine the type of a variable, function, or expression without explicit type annotations. This makes code more concise while still maintaining type safety. Type inference works in several scenarios:\n\n1. **Variable Initialization**:\n   When a variable is initialized, TypeScript infers its type based on the assigned value.\n   ```typescript\n   let message = \"Hello, TypeScript\"; // Inferred as string\n   let count = 42; // Inferred as number\n   ```\n\n2. **Function Return Types**:\n   TypeScript infers the return type of a function based on its implementation.\n   ```typescript\n   function add(a: number, b: number) {\n       return a + b; // Return type inferred as number\n   }\n   ```\n\n3. **Contextual Typing**:\n   TypeScript uses the context in which a value is used to infer its type. This is common in functions, callbacks, and event handlers.\n   ```typescript\n   const numbers = [1, 2, 3];\n   numbers.forEach((num) => {\n       console.log(num); // num is inferred as number\n   });\n   ```\n\n4. **Best Common Type**:\n   When inferring the type of an array or union, TypeScript determines the \"best common type\" from the elements.\n   ```typescript\n   const mixedArray = [1, \"text\", true]; // Inferred as (string | number | boolean)[]\n   ```\n\n5. **Generics**:\n   TypeScript can infer generic types based on the arguments passed to a function or class.\n   ```typescript\n   function identity<T>(value: T): T {\n       return value;\n   }\n   const result = identity(42); // T inferred as number\n   ```\n\nType inference simplifies code while still leveraging TypeScript's strong type system. However, for complex scenarios or when clarity is needed, explicit type annotations can still be used.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418344Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "e40bcfb8-1223-47ae-b278-e5f14b574745",
            "question": "What is the difference between 'interface' and 'type' in TypeScript?",
            "answer": "```markdown\nIn TypeScript, both `interface` and `type` are used to define the shape of objects, but there are some key differences between the two:\n\n### 1. **Declaration Merging**\n   - **Interface**: Supports declaration merging. Multiple declarations of the same interface are merged into a single definition.\n     ```typescript\n     interface User {\n       name: string;\n     }\n\n     interface User {\n       age: number;\n     }\n\n     // Merged interface\n     const user: User = { name: \"Alice\", age: 25 };\n     ```\n   - **Type**: Does not support declaration merging. If you try to define the same type multiple times, it will result in a compilation error.\n\n### 2. **Extensibility**\n   - **Interface**: Can be extended using the `extends` keyword.\n     ```typescript\n     interface Person {\n       name: string;\n     }\n\n     interface Employee extends Person {\n       employeeId: number;\n     }\n\n     const employee: Employee = { name: \"Bob\", employeeId: 123 };\n     ```\n   - **Type**: Can also be extended using intersections (`&`).\n     ```typescript\n     type Person = {\n       name: string;\n     };\n\n     type Employee = Person & {\n       employeeId: number;\n     };\n\n     const employee: Employee = { name: \"Bob\", employeeId: 123 };\n     ```\n\n### 3. **Usage with Primitives and Other Types**\n   - **Interface**: Can only describe the shape of objects (including functions and arrays).\n   - **Type**: Can describe primitives, unions, intersections, and other more complex types.\n     ```typescript\n     type StringOrNumber = string | number; // Valid with type\n     ```\n\n### 4. **Performance**\n   - **Interface**: Generally preferred for defining object shapes because it is slightly more performant in terms of type-checking.\n   - **Type**: May have a slight performance overhead when used for complex types.\n\n### 5. **Key Use Cases**\n   - Use **interface** when defining the structure of objects, especially when you expect the structure to be extended or merged.\n   - Use **type** for more complex type definitions, such as unions, intersections, or when working with primitives.\n\n### Summary\n| Feature                  | Interface          | Type                     |\n|--------------------------|--------------------|--------------------------|\n| Declaration Merging      | Supported          | Not Supported            |\n| Extensibility            | `extends`          | Intersections (`&`)      |\n| Primitives and Unions    | Not Supported      | Supported                |\n| Performance              | Slightly better    | Slightly slower          |\n\nIn general, both `interface` and `type` are powerful tools, and the choice between them often comes down to specific use cases and personal/team preferences.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418354Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "8dfd63c8-f70e-4e89-8215-104c7fe5cb17",
            "question": "How do you create a custom type guard in TypeScript?",
            "answer": "```markdown\nIn TypeScript, a custom type guard is a function that allows you to narrow down the type of a variable within a conditional block. To create a custom type guard, you define a function that returns a boolean value and uses a type predicate (`parameterName is Type`) in its return type. Here's how you can create and use a custom type guard:\n\n### Steps to Create a Custom Type Guard\n\n1. Define a function that takes a parameter of a broader type (e.g., `unknown`, `any`, or a union type).\n2. Use runtime checks (e.g., `typeof`, `instanceof`, or property existence) to determine if the parameter matches the desired type.\n3. Return `true` if the type matches and `false` otherwise.\n4. Use the `parameterName is Type` syntax as the return type to indicate the type guard.\n\n### Example: Custom Type Guard\n\n```typescript\n// Define a type\ninterface User {\n  name: string;\n  age: number;\n}\n\n// Create a custom type guard function\nfunction isUser(obj: unknown): obj is User {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"name\" in obj &&\n    \"age\" in obj &&\n    typeof (obj as User).name === \"string\" &&\n    typeof (obj as User).age === \"number\"\n  );\n}\n\n// Usage of the custom type guard\nconst data: unknown = { name: \"Alice\", age: 25 };\n\nif (isUser(data)) {\n  // TypeScript now knows `data` is of type `User` within this block\n  console.log(`User's name is ${data.name} and age is ${data.age}`);\n} else {\n  console.log(\"Data is not a User\");\n}\n```\n\n### Explanation\n\n1. The `isUser` function checks if the input `obj` has the required properties (`name` and `age`) and ensures they are of the correct types.\n2. The return type `obj is User` tells TypeScript that if the function returns `true`, the input `obj` can be safely treated as a `User`.\n3. This allows TypeScript to narrow the type of `obj` within the `if` block, enabling type-safe access to its properties.\n\nCustom type guards are a powerful feature in TypeScript for working with complex types and ensuring type safety at runtime.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418363Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "f49a3ede-cee7-4707-919c-34cd98f59b7c",
            "question": "What is the 'keyof' operator in TypeScript, and how is it used?",
            "answer": "```markdown\nThe `keyof` operator in TypeScript is used to obtain a union of the keys of a given type. It is particularly useful when working with object types, as it allows you to create types that are constrained to the keys of another type.\n\n### Syntax\n```typescript\nkeyof Type\n```\n\n### How It Works\nWhen applied to a type, `keyof` produces a string or numeric literal union of its keys. For example:\n\n```typescript\ntype Person = {\n  name: string;\n  age: number;\n  location: string;\n};\n\ntype PersonKeys = keyof Person; // \"name\" | \"age\" | \"location\"\n```\n\nHere, `PersonKeys` will be a union type of the keys `\"name\" | \"age\" | \"location\"`.\n\n### Common Use Cases\n1. **Constraining Function Parameters**:\n   You can use `keyof` to restrict function parameters to valid keys of an object.\n\n   ```typescript\n   function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n     return obj[key];\n   }\n\n   const person: Person = { name: \"Alice\", age: 30, location: \"NYC\" };\n   const name = getProperty(person, \"name\"); // Valid\n   // const invalid = getProperty(person, \"height\"); // Error: Argument of type '\"height\"' is not assignable to parameter of type '\"name\" | \"age\" | \"location\"'.\n   ```\n\n2. **Mapping Over Object Keys**:\n   You can use `keyof` in conjunction with mapped types to create new types based on the keys of an existing type.\n\n   ```typescript\n   type ReadOnly<T> = {\n     readonly [K in keyof T]: T[K];\n   };\n\n   type ReadOnlyPerson = ReadOnly<Person>;\n   ```\n\n3. **Dynamic Object Access**:\n   It allows you to dynamically access object properties while maintaining type safety.\n\n   ```typescript\n   function updateProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]): void {\n     obj[key] = value;\n   }\n\n   updateProperty(person, \"age\", 31); // Valid\n   ```\n\n### Summary\nThe `keyof` operator is a powerful tool in TypeScript for working with object types. It enables type-safe operations on object keys, dynamic property access, and the creation of utility types. By leveraging `keyof`, developers can write more robust and maintainable code.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418374Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "c90ebf3c-c6c6-4b2e-9449-8faace0988d7",
            "question": "How do you handle function overloading in TypeScript?",
            "answer": "```markdown\nIn TypeScript, function overloading is handled by defining multiple function signatures for the same function. These signatures specify the different combinations of parameter types and return types the function can accept. The actual implementation of the function is written once, and it must handle all the defined overloads.\n\n### Steps to Handle Function Overloading:\n\n1. **Define Overload Signatures**: Write multiple function signatures with different parameter and return type combinations.\n2. **Provide a Single Implementation**: Write one implementation of the function that can handle all the overload cases. The implementation should use type guards or conditional logic to differentiate between the overloads.\n\n### Example:\n\n```typescript\n// Overload signatures\nfunction add(a: number, b: number): number;\nfunction add(a: string, b: string): string;\n\n// Implementation\nfunction add(a: number | string, b: number | string): number | string {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a + b; // Handles number addition\n  }\n  if (typeof a === \"string\" && typeof b === \"string\") {\n    return a + b; // Handles string concatenation\n  }\n  throw new Error(\"Invalid arguments\");\n}\n\n// Usage\nconst result1 = add(10, 20); // Returns 30\nconst result2 = add(\"Hello, \", \"World!\"); // Returns \"Hello, World!\"\n```\n\n### Key Points:\n- The implementation must be compatible with all the overload signatures.\n- TypeScript will use the overload signatures for type checking, not the implementation.\n- The implementation should include logic to handle all possible cases defined in the overloads.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418384Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "6268aa51-fdf0-4636-90e6-9c33c58d3c9e",
            "question": "What are utility types in TypeScript, and can you provide examples?",
            "answer": "```markdown\nUtility types in TypeScript are predefined types that help transform or manipulate other types. They are provided by TypeScript to make it easier to work with common type transformations, such as making properties optional, readonly, or picking specific properties from a type. These utility types save time and reduce boilerplate code when working with complex type definitions.\n\nHere are some commonly used utility types with examples:\n\n### 1. `Partial<Type>`\nThe `Partial` utility type makes all properties of a given type optional.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nconst updateUser: Partial<User> = {\n  name: \"Alice\",\n};\n```\n\n### 2. `Required<Type>`\nThe `Required` utility type makes all properties of a given type required.\n\n```typescript\ninterface User {\n  id?: number;\n  name?: string;\n}\n\nconst user: Required<User> = {\n  id: 1,\n  name: \"Bob\",\n};\n```\n\n### 3. `Readonly<Type>`\nThe `Readonly` utility type makes all properties of a given type immutable.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst user: Readonly<User> = {\n  id: 1,\n  name: \"Charlie\",\n};\n\n// user.id = 2; // Error: Cannot assign to 'id' because it is a read-only property.\n```\n\n### 4. `Pick<Type, Keys>`\nThe `Pick` utility type creates a new type by selecting specific properties from an existing type.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nconst user: Pick<User, \"id\" | \"name\"> = {\n  id: 1,\n  name: \"Diana\",\n};\n```\n\n### 5. `Omit<Type, Keys>`\nThe `Omit` utility type creates a new type by excluding specific properties from an existing type.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  age: number;\n}\n\nconst user: Omit<User, \"age\"> = {\n  id: 1,\n  name: \"Eve\",\n};\n```\n\n### 6. `Record<Keys, Type>`\nThe `Record` utility type creates an object type with specified keys and values of a specific type.\n\n```typescript\nconst userRoles: Record<string, string> = {\n  admin: \"Admin\",\n  editor: \"Editor\",\n};\n\nconst userAges: Record<number, string> = {\n  1: \"20 years\",\n  2: \"25 years\",\n};\n```\n\n### 7. `Exclude<Type, ExcludedUnion>`\nThe `Exclude` utility type removes specific types from a union.\n\n```typescript\ntype Status = \"active\" | \"inactive\" | \"pending\";\ntype ActiveStatus = Exclude<Status, \"inactive\">;\n\n// ActiveStatus is \"active\" | \"pending\"\n```\n\n### 8. `Extract<Type, Union>`\nThe `Extract` utility type selects only the types that are assignable to a given union.\n\n```typescript\ntype Status = \"active\" | \"inactive\" | \"pending\";\ntype ActiveStatus = Extract<Status, \"active\" | \"pending\">;\n\n// ActiveStatus is \"active\" | \"pending\"\n```\n\n### 9. `NonNullable<Type>`\nThe `NonNullable` utility type removes `null` and `undefined` from a type.\n\n```typescript\ntype User = string | null | undefined;\ntype ValidUser = NonNullable<User>;\n\n// ValidUser is string\n```\n\n### 10. `ReturnType<Type>`\nThe `ReturnType` utility type extracts the return type of a function.\n\n```typescript\nfunction getUser() {\n  return { id: 1, name: \"Frank\" };\n}\n\ntype User = ReturnType<typeof getUser>;\n\n// User is { id: number; name: string; }\n```\n\n### 11. `Parameters<Type>`\nThe `Parameters` utility type extracts the parameter types of a function as a tuple.\n\n```typescript\nfunction createUser(id: number, name: string) {\n  return { id, name };\n}\n\ntype CreateUserParams = Parameters<typeof createUser>;\n\n// CreateUserParams is [number, string]\n```\n\n### 12. `InstanceType<Type>`\nThe `InstanceType` utility type extracts the instance type of a class.\n\n```typescript\nclass User {\n  id: number;\n  name: string;\n\n  constructor(id: number, name: string) {\n    this.id = id;\n    this.name = name;\n  }\n}\n\ntype UserInstance = InstanceType<typeof User>;\n\n// UserInstance is User\n```\n\nThese utility types are powerful tools for creating flexible and reusable type definitions in TypeScript.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418394Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "64453534-86b4-4c05-abe6-554628d86d4d",
            "question": "What is the difference between 'extends' and 'implements' in TypeScript?",
            "answer": "```markdown\nIn TypeScript, `extends` and `implements` are used to establish relationships between classes, interfaces, and other types, but they serve different purposes:\n\n### `extends`\n- The `extends` keyword is used for inheritance.\n- A class can extend another class, inheriting its properties and methods.\n- An interface can extend another interface or multiple interfaces, combining their definitions.\n- Example with classes:\n  ```typescript\n  class Animal {\n    eat() {\n      console.log(\"Eating...\");\n    }\n  }\n\n  class Dog extends Animal {\n    bark() {\n      console.log(\"Barking...\");\n    }\n  }\n\n  const dog = new Dog();\n  dog.eat(); // Inherited from Animal\n  dog.bark(); // Defined in Dog\n  ```\n- Example with interfaces:\n  ```typescript\n  interface Shape {\n    area: number;\n  }\n\n  interface Circle extends Shape {\n    radius: number;\n  }\n\n  const circle: Circle = {\n    area: 78.5,\n    radius: 5,\n  };\n  ```\n\n### `implements`\n- The `implements` keyword is used to enforce that a class adheres to the structure defined by an interface.\n- A class can implement one or more interfaces, ensuring it provides the required properties and methods.\n- Unlike `extends`, `implements` does not provide inheritance of behavior (methods or properties); it only enforces a contract.\n- Example:\n  ```typescript\n  interface Flyable {\n    fly(): void;\n  }\n\n  class Bird implements Flyable {\n    fly() {\n      console.log(\"Flying...\");\n    }\n  }\n\n  const bird = new Bird();\n  bird.fly(); // Implements the Flyable interface\n  ```\n\n### Key Differences\n| Feature         | `extends`                               | `implements`                           |\n|-----------------|-----------------------------------------|----------------------------------------|\n| Purpose         | Inheritance of behavior and structure  | Enforcing a contract                  |\n| Usage           | Between classes or interfaces          | Between a class and an interface      |\n| Multiple Types  | A class can extend only one class, but an interface can extend multiple interfaces | A class can implement multiple interfaces |\n\nIn summary, `extends` is used for inheritance, while `implements` is used to ensure a class adheres to a specific structure defined by an interface.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418403Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "673842ac-b3d1-426f-833d-4a5244b9aa95",
            "question": "How do you use decorators in TypeScript?",
            "answer": "```markdown\n### Using Decorators in TypeScript\n\nDecorators in TypeScript are a special kind of declaration that can be attached to classes, methods, accessors, properties, or parameters. They allow you to modify the behavior of these elements at runtime. To use decorators, you need to enable the `experimentalDecorators` compiler option in your `tsconfig.json` file:\n\n```json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n#### Types of Decorators\n\n1. **Class Decorators**  \n   A class decorator is applied to a class constructor. It can be used to modify or replace the class definition.\n\n   ```typescript\n   function Logger(target: Function) {\n     console.log(`Class ${target.name} is being created.`);\n   }\n\n   @Logger\n   class ExampleClass {\n     constructor() {\n       console.log('ExampleClass instance created.');\n     }\n   }\n   ```\n\n2. **Method Decorators**  \n   A method decorator is applied to a method of a class. It can be used to modify the method's behavior.\n\n   ```typescript\n   function LogMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n     const originalMethod = descriptor.value;\n     descriptor.value = function (...args: any[]) {\n       console.log(`Method ${propertyKey} called with arguments:`, args);\n       return originalMethod.apply(this, args);\n     };\n   }\n\n   class ExampleClass {\n     @LogMethod\n     greet(name: string) {\n       return `Hello, ${name}!`;\n     }\n   }\n\n   const example = new ExampleClass();\n   example.greet('John'); // Logs method call and arguments\n   ```\n\n3. **Property Decorators**  \n   A property decorator is applied to a property of a class. It can be used to observe or modify the property metadata.\n\n   ```typescript\n   function ReadOnly(target: any, propertyKey: string) {\n     Object.defineProperty(target, propertyKey, {\n       writable: false,\n     });\n   }\n\n   class ExampleClass {\n     @ReadOnly\n     name: string = 'Default Name';\n   }\n\n   const example = new ExampleClass();\n   example.name = 'New Name'; // Error: Cannot assign to read-only property\n   ```\n\n4. **Accessor Decorators**  \n   An accessor decorator is applied to a getter or setter of a class. It can modify the behavior of the accessor.\n\n   ```typescript\n   function LogAccessor(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n     const originalGetter = descriptor.get;\n     descriptor.get = function () {\n       console.log(`Getter for ${propertyKey} is called.`);\n       return originalGetter?.apply(this);\n     };\n   }\n\n   class ExampleClass {\n     private _value: number = 0;\n\n     @LogAccessor\n     get value() {\n       return this._value;\n     }\n\n     set value(val: number) {\n       this._value = val;\n     }\n   }\n\n   const example = new ExampleClass();\n   console.log(example.value); // Logs the getter call\n   ```\n\n5. **Parameter Decorators**  \n   A parameter decorator is applied to a parameter of a method. It can be used to observe or modify metadata about the parameter.\n\n   ```typescript\n   function LogParameter(target: any, propertyKey: string, parameterIndex: number) {\n     console.log(`Parameter at index ${parameterIndex} in method ${propertyKey} is being decorated.`);\n   }\n\n   class ExampleClass {\n     greet(@LogParameter name: string) {\n       console.log(`Hello, ${name}!`);\n     }\n   }\n\n   const example = new ExampleClass();\n   example.greet('John'); // Logs parameter decoration\n   ```\n\n#### Key Points\n- Decorators are functions that are invoked at runtime.\n- They can be used to modify or enhance classes, methods, properties, accessors, or parameters.\n- The order of decorator execution is **top-to-bottom** for class elements and **bottom-to-top** for nested decorators.\n\nDecorators are a powerful feature in TypeScript, often used in frameworks like Angular for dependency injection, metadata handling, and more.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418412Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "c6c2ae21-c313-43ff-ae82-b0e6a5985de7",
            "question": "What is the purpose of the 'Partial' utility type in TypeScript?",
            "answer": "```markdown\nThe `Partial` utility type in TypeScript is used to create a new type based on an existing type, where all the properties of the original type are made optional. This is particularly useful when you want to work with objects that may only have a subset of the properties defined.\n\n### Syntax:\n```typescript\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n### Purpose:\n- To allow flexibility when working with objects that don't need all properties to be defined.\n- Useful in scenarios like updating a subset of an object or initializing an object incrementally.\n\n### Example:\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst updateUser = (id: number, userUpdates: Partial<User>) => {\n  // userUpdates can have any combination of User properties\n  console.log(`Updating user ${id} with`, userUpdates);\n};\n\n// Example usage:\nupdateUser(1, { name: \"Alice\" }); // Only updating the name\nupdateUser(2, { email: \"bob@example.com\", name: \"Bob\" }); // Updating name and email\n```\n\nIn this example, the `Partial<User>` type allows the `updateUser` function to accept an object with any subset of the `User` properties, making it more flexible and convenient to use.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418421Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "7fd52fa1-adab-43e7-ba51-60d7aa76a35b",
            "question": "What are conditional types in TypeScript, and how do they work?",
            "answer": "```markdown\n### Conditional Types in TypeScript\n\nConditional types in TypeScript allow for type expressions that depend on a condition. They enable more dynamic and flexible type definitions by evaluating a condition at the type level and returning one of two possible types based on the result.\n\nThe basic syntax for a conditional type is:\n\n```typescript\nT extends U ? X : Y\n```\n\n- `T` is the type being checked.\n- `U` is the type to check against.\n- `X` is the type returned if the condition `T extends U` is true.\n- `Y` is the type returned if the condition `T extends U` is false.\n\n### How Conditional Types Work\n\n1. **Type Checking**: The `extends` keyword is used to test whether `T` is assignable to `U`.\n2. **Branching**: If the condition evaluates to `true`, the type resolves to `X`. Otherwise, it resolves to `Y`.\n\n### Example\n\n```typescript\ntype IsString<T> = T extends string ? \"Yes\" : \"No\";\n\ntype Result1 = IsString<string>; // \"Yes\"\ntype Result2 = IsString<number>; // \"No\"\n```\n\nIn this example:\n- If `T` is a `string`, the type resolves to `\"Yes\"`.\n- Otherwise, it resolves to `\"No\"`.\n\n### Distributive Conditional Types\n\nWhen the type `T` is a union, conditional types are applied to each member of the union individually. This is known as distributive behavior.\n\nExample:\n\n```typescript\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype Result = ToArray<string | number>; // string[] | number[]\n```\n\nHere, the conditional type is applied to both `string` and `number` separately, resulting in a union of `string[] | number[]`.\n\n### Practical Use Cases\n\n1. **Type Filtering**:\n   ```typescript\n   type Exclude<T, U> = T extends U ? never : T;\n\n   type Result = Exclude<\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\"\n   ```\n\n2. **Inferring Types**:\n   ```typescript\n   type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\n   type Result = GetReturnType<() => string>; // string\n   ```\n\n3. **Mapping Types**:\n   ```typescript\n   type Nullable<T> = T extends object ? T | null : T;\n\n   type Result = Nullable<{ name: string }>; // { name: string } | null\n   ```\n\n### Summary\n\nConditional types in TypeScript provide a powerful way to create flexible and reusable type logic. They are particularly useful for type transformations, filtering, and inference, making TypeScript a highly expressive and robust type system.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418440Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "42b8b02a-86c9-4d02-a88c-cbc784ffa921",
            "question": "How do you define a tuple in TypeScript, and when would you use one?",
            "answer": "```markdown\nIn TypeScript, a tuple is defined as a fixed-length array where each element has a specific type. You can define a tuple using square brackets `[]` and specifying the types of its elements in order.\n\n### Syntax:\n```typescript\nlet tupleName: [type1, type2, type3] = [value1, value2, value3];\n```\n\n### Example:\n```typescript\nlet user: [number, string, boolean] = [1, \"John Doe\", true];\n```\n\nIn this example:\n- The first element must be a `number`.\n- The second element must be a `string`.\n- The third element must be a `boolean`.\n\n### When to Use Tuples:\nYou would use a tuple when you need to represent a fixed structure with a known number of elements, where each element has a specific type. For example:\n1. **Returning multiple values from a function**:\n   ```typescript\n   function getUser(): [number, string] {\n       return [1, \"John Doe\"];\n   }\n   ```\n2. **Representing a structured data point**:\n   ```typescript\n   let coordinates: [number, number] = [10, 20];\n   ```\n\nTuples are particularly useful when working with data where the position and type of each element are strictly defined.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418450Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "2b6165da-2568-46be-92dc-87103b164502",
            "question": "What is the purpose of the 'never' type in TypeScript?",
            "answer": "```markdown\nThe `never` type in TypeScript represents a value that never occurs. It is used in scenarios where a function or expression cannot return a value, such as when a function throws an error or enters an infinite loop. The `never` type is also useful for exhaustive type checking in switch statements or conditional logic, ensuring that all possible cases are handled.\n\n### Key Use Cases:\n1. **Functions that never return:**\n   ```typescript\n   function throwError(message: string): never {\n       throw new Error(message);\n   }\n   ```\n\n2. **Exhaustive type checking:**\n   ```typescript\n   type Shape = 'circle' | 'square';\n\n   function getArea(shape: Shape): number {\n       switch (shape) {\n           case 'circle':\n               return Math.PI * 1; // Example calculation\n           case 'square':\n               return 4; // Example calculation\n           default:\n               const _exhaustiveCheck: never = shape;\n               throw new Error(`Unhandled shape: ${_exhaustiveCheck}`);\n       }\n   }\n   ```\n\nIn the example above, the `never` type ensures that all possible values of `Shape` are handled, and any unhandled case will result in a compile-time error.\n\n### Summary:\nThe `never` type is a powerful tool for ensuring type safety and correctness in TypeScript, particularly in functions that cannot return or when performing exhaustive checks.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418459Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "95d22eca-84ac-4a76-ac2b-6716d4d37536",
            "question": "How do you handle asynchronous code in TypeScript?",
            "answer": "```markdown\nTo handle asynchronous code in TypeScript, you can use features like `Promises`, `async/await`, and callback functions. TypeScript enhances these features by providing type safety, ensuring that the data being handled is correctly typed.\n\n### 1. Using Promises\nPromises are used to handle asynchronous operations. You can define the type of the data the promise resolves to:\n\n```typescript\nfunction fetchData(): Promise<string> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(\"Data fetched successfully\");\n    }, 1000);\n  });\n}\n\nfetchData().then((data) => {\n  console.log(data); // Output: Data fetched successfully\n});\n```\n\n### 2. Using `async/await`\nThe `async/await` syntax simplifies working with promises, making asynchronous code look more like synchronous code. TypeScript ensures proper typing of the resolved value.\n\n```typescript\nasync function fetchData(): Promise<string> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(\"Data fetched successfully\");\n    }, 1000);\n  });\n}\n\nasync function getData() {\n  try {\n    const data: string = await fetchData();\n    console.log(data); // Output: Data fetched successfully\n  } catch (error) {\n    console.error(\"Error fetching data:\", error);\n  }\n}\n\ngetData();\n```\n\n### 3. Typing Asynchronous Functions\nWhen defining asynchronous functions, you can explicitly specify the return type as a `Promise` of the resolved value type:\n\n```typescript\nasync function fetchNumber(): Promise<number> {\n  return 42;\n}\n\nfetchNumber().then((num) => {\n  console.log(num); // Output: 42\n});\n```\n\n### 4. Handling Errors\nTypeScript allows you to type errors explicitly when handling asynchronous code:\n\n```typescript\nasync function fetchWithError(): Promise<string> {\n  throw new Error(\"Something went wrong\");\n}\n\nasync function handleError() {\n  try {\n    const result = await fetchWithError();\n    console.log(result);\n  } catch (error: unknown) {\n    if (error instanceof Error) {\n      console.error(\"Error:\", error.message);\n    }\n  }\n}\n\nhandleError();\n```\n\n### Summary\n- Use `Promise` and `async/await` for handling asynchronous operations.\n- Explicitly type the resolved value of promises for better type safety.\n- Handle errors using `try/catch` and ensure proper error typing.\nTypeScript's type system ensures that asynchronous code is robust and less prone to runtime errors.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418468Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "2efc56c6-abe4-4090-b4c5-8d944c320435",
            "question": "What are index signatures in TypeScript, and how are they used?",
            "answer": "```markdown\n### Index Signatures in TypeScript\n\nIndex signatures in TypeScript are a way to define the shape of objects where the keys and values follow specific patterns. They allow you to specify the type of keys and the type of values an object can have when the exact keys are not known in advance.\n\n#### Syntax\nAn index signature is defined using the following syntax:\n\n```typescript\ninterface Example {\n  [key: string]: valueType;\n}\n```\n\n- `key: string` specifies that the keys must be of type `string` (or another type like `number`).\n- `valueType` defines the type of the values associated with those keys.\n\n#### Example Usage\nHeres an example of an index signature:\n\n```typescript\ninterface StringDictionary {\n  [key: string]: string;\n}\n\nconst dictionary: StringDictionary = {\n  name: \"John\",\n  city: \"New York\",\n  country: \"USA\",\n};\n```\n\nIn this example:\n- The `StringDictionary` interface allows any number of string keys, each associated with a string value.\n- The `dictionary` object adheres to this structure.\n\n#### Number Index Signatures\nYou can also use `number` as the key type:\n\n```typescript\ninterface NumberArray {\n  [index: number]: string;\n}\n\nconst myArray: NumberArray = [\"apple\", \"banana\", \"cherry\"];\n```\n\nHere, the `NumberArray` interface ensures that the object behaves like an array with numeric indices and string values.\n\n#### Use Cases\nIndex signatures are commonly used when:\n1. You need to represent objects with dynamic keys.\n2. You are working with maps, dictionaries, or arrays.\n3. The exact keys are not known at compile time.\n\n#### Limitations\n1. Index signatures enforce uniformity, meaning all keys must have the same value type.\n2. They cannot coexist with properties of a different type unless explicitly defined.\n\n```typescript\ninterface MixedObject {\n  [key: string]: number;\n  fixedKey: string; // Error: Type 'string' is not assignable to type 'number'.\n}\n```\n\nTo fix this, you can explicitly define exceptions:\n\n```typescript\ninterface MixedObject {\n  [key: string]: number | string;\n  fixedKey: string;\n}\n```\n\nIndex signatures are a powerful feature in TypeScript for working with dynamic or flexible object structures while maintaining type safety.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418478Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "958dd828-a74d-46ca-b958-2202c305c86b",
            "question": "What is the purpose of the 'infer' keyword in TypeScript?",
            "answer": "```markdown\nThe `infer` keyword in TypeScript is used in conditional types to infer and extract a type from another type. It allows you to capture a type within a conditional type and assign it to a type variable for further use. This is particularly useful when working with complex types, such as extracting the return type of a function, the element type of an array, or other derived types.\n\nFor example:\n\n```typescript\ntype GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype ExampleFunction = () => string;\ntype Result = GetReturnType<ExampleFunction>; // Result is inferred as 'string'\n```\n\nIn this example, the `infer` keyword is used to extract the return type (`R`) of the function type `T`. If `T` matches the function signature, the return type is inferred and assigned to `R`.\n\nThe `infer` keyword is a powerful tool for creating reusable and dynamic type utilities in TypeScript.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418585Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "70262e03-b90a-4f93-88b9-86eb39d90361",
            "question": "How do you use the 'Record' utility type in TypeScript?",
            "answer": "```markdown\nThe `Record` utility type in TypeScript is used to construct an object type with a specific set of keys and their corresponding value types. It is defined as:\n\n```typescript\nRecord<Keys, Type>\n```\n\n- `Keys`: The set of keys for the object (can be a union of string or number literals, or `string`/`number`).\n- `Type`: The type of the values associated with those keys.\n\n### Example Usage:\n\n```typescript\n// Example 1: Basic usage\ntype UserRoles = Record<string, string>;\n\nconst roles: UserRoles = {\n  admin: \"Admin User\",\n  editor: \"Editor User\",\n};\n\n// Example 2: Using specific keys\ntype UserPermissions = Record<\"read\" | \"write\" | \"delete\", boolean>;\n\nconst permissions: UserPermissions = {\n  read: true,\n  write: false,\n  delete: true,\n};\n\n// Example 3: Nested Record\ntype NestedRecord = Record<string, Record<string, number>>;\n\nconst nested: NestedRecord = {\n  group1: {\n    item1: 10,\n    item2: 20,\n  },\n  group2: {\n    item1: 30,\n    item2: 40,\n  },\n};\n```\n\n### Key Benefits:\n1. Ensures type safety by enforcing specific key-value structures.\n2. Useful for mapping a set of keys to a consistent value type.\n3. Simplifies the creation of complex object types.\n\nThe `Record` utility type is particularly helpful when you need to define objects with a predictable structure and consistent value types.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418487Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "6858639d-7108-44ab-b4b6-7cd4b5017fb5",
            "question": "What is the purpose of the 'Exclude' utility type in TypeScript?",
            "answer": "```markdown\nThe `Exclude` utility type in TypeScript is used to construct a new type by excluding specific types from a union type. Its purpose is to filter out unwanted types from a union, leaving only the types that are not excluded.\n\nThe syntax for `Exclude` is:\n\n```typescript\nExclude<T, U>\n```\n\n- `T`: The union type to be filtered.\n- `U`: The type(s) to exclude from `T`.\n\nThe resulting type includes all members of `T` that are not assignable to `U`.\n\n### Example:\n\n```typescript\ntype AllTypes = string | number | boolean;\ntype ExcludedTypes = Exclude<AllTypes, boolean>;\n\n// Result: ExcludedTypes is now string | number\n```\n\nIn this example, the `Exclude` utility removes `boolean` from the union type `AllTypes`, leaving only `string | number`.\n\n### Use Case:\nThe `Exclude` utility is particularly useful when you want to refine or narrow down a type by removing specific members, making it easier to work with subsets of a union type in a type-safe manner.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418496Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "4c2cb8e3-d11f-4e93-a229-8553016ff2f6",
            "question": "How do you create a type-safe API client using TypeScript?",
            "answer": "```markdown\nTo create a type-safe API client using TypeScript, you can follow these steps:\n\n### 1. Define API Endpoints and Types\nStart by defining the structure of your API endpoints and the data they return. Use TypeScript interfaces or types to ensure type safety.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ninterface ApiEndpoints {\n  getUser: {\n    params: { id: number };\n    response: User;\n  };\n  createUser: {\n    params: { name: string; email: string };\n    response: User;\n  };\n}\n```\n\n### 2. Create a Generic API Client\nBuild a reusable API client that uses generics to enforce type safety for requests and responses.\n\n```typescript\nclass ApiClient<T extends Record<string, any>> {\n  constructor(private baseUrl: string) {}\n\n  async request<K extends keyof T>(\n    endpoint: K,\n    params: T[K]['params']\n  ): Promise<T[K]['response']> {\n    const response = await fetch(`${this.baseUrl}/${String(endpoint)}`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(params),\n    });\n\n    if (!response.ok) {\n      throw new Error(`API request failed with status ${response.status}`);\n    }\n\n    return response.json() as Promise<T[K]['response']>;\n  }\n}\n```\n\n### 3. Instantiate the API Client\nPass the API endpoint definitions to the client to enforce type safety.\n\n```typescript\nconst apiClient = new ApiClient<ApiEndpoints>('https://api.example.com');\n```\n\n### 4. Make Type-Safe API Calls\nWhen making API calls, TypeScript will enforce the correct types for parameters and responses.\n\n```typescript\nasync function fetchUser() {\n  const user = await apiClient.request('getUser', { id: 1 });\n  console.log(user.name); // Type-safe access to the `name` field\n}\n\nasync function addUser() {\n  const newUser = await apiClient.request('createUser', {\n    name: 'John Doe',\n    email: 'john.doe@example.com',\n  });\n  console.log(newUser.id); // Type-safe access to the `id` field\n}\n```\n\n### 5. Benefits of Type-Safe API Clients\n- **Compile-Time Safety**: Errors in API calls (e.g., incorrect parameters or response types) are caught during development.\n- **Improved Developer Experience**: Autocompletion and type hints make working with the API easier.\n- **Reduced Runtime Errors**: Type safety ensures that the API client behaves as expected.\n\nBy combining TypeScript's type system with a generic API client, you can create a robust and type-safe interface for interacting with your backend services.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418505Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "f56fcc4d-46f7-4b6e-a606-c73b14837b00",
            "question": "What are discriminated unions in TypeScript, and how do they work?",
            "answer": "```markdown\n### Discriminated Unions in TypeScript\n\nDiscriminated unions, also known as tagged unions or algebraic data types, are a powerful feature in TypeScript that allow you to create a type that can represent multiple distinct types with a common property to differentiate between them. They are particularly useful for modeling scenarios where a value can take on one of several known shapes.\n\n#### How They Work\n\nA discriminated union consists of:\n1. **Union of Types**: A union type that combines multiple object types.\n2. **Discriminant Property**: A shared property (usually a string literal) that acts as a \"tag\" to distinguish between the different types in the union.\n\nTypeScript uses the discriminant property to narrow down the type of a value at compile time, enabling type-safe operations on the specific type.\n\n#### Example\n\n```typescript\n// Define a discriminated union\ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; sideLength: number }\n  | { kind: \"rectangle\"; width: number; height: number };\n\n// Function to calculate the area of a shape\nfunction getArea(shape: Shape): number {\n  switch (shape.kind) {\n    case \"circle\":\n      return Math.PI * shape.radius ** 2;\n    case \"square\":\n      return shape.sideLength ** 2;\n    case \"rectangle\":\n      return shape.width * shape.height;\n    default:\n      // Exhaustiveness checking\n      const _exhaustive: never = shape;\n      throw new Error(`Unhandled shape: ${_exhaustive}`);\n  }\n}\n\n// Example usage\nconst circle: Shape = { kind: \"circle\", radius: 5 };\nconsole.log(getArea(circle)); // Output: 78.53981633974483\n```\n\n#### Key Features\n1. **Type Narrowing**: TypeScript automatically narrows the type based on the `kind` property in control flow constructs like `switch` or `if`.\n2. **Exhaustiveness Checking**: Using the `never` type in the default case ensures all possible cases are handled, making the code more robust.\n\nDiscriminated unions are a clean and type-safe way to handle multiple related types in TypeScript, improving code readability and maintainability.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418514Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "0d484a46-28ff-4ec7-8234-d7aecefd11f3",
            "question": "How do you use the 'Pick' utility type in TypeScript?",
            "answer": "```markdown\nThe `Pick` utility type in TypeScript is used to create a new type by selecting a subset of properties from an existing type. It is particularly useful when you want to work with only specific properties of an object type.\n\n### Syntax:\n```typescript\nPick<Type, Keys>\n```\n\n- `Type`: The existing object type you want to pick properties from.\n- `Keys`: A union of the keys (property names) you want to include in the new type.\n\n### Example:\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  isAdmin: boolean;\n}\n\n// Use Pick to create a new type with only 'id' and 'name'\ntype UserPreview = Pick<User, 'id' | 'name'>;\n\nconst user: UserPreview = {\n  id: 1,\n  name: \"John Doe\",\n};\n```\n\nIn this example:\n- The `UserPreview` type includes only the `id` and `name` properties from the `User` interface.\n- The `Pick` utility ensures that the new type is strongly typed and only allows the specified properties.\n\n### Key Benefits:\n1. Helps in creating more focused and reusable types.\n2. Reduces redundancy by reusing existing type definitions.\n3. Ensures type safety when working with subsets of an object.\n\nThe `Pick` utility type is a powerful tool for managing and manipulating types in TypeScript, especially in large codebases.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418522Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "427a31aa-1832-4fe3-bd4b-dd2bb7c0cd07",
            "question": "How do you define a class in TypeScript, and what are the key features?",
            "answer": "```markdown\nIn TypeScript, a class is defined using the `class` keyword. A class can include properties, constructors, and methods. TypeScript enhances classes with features like type annotations, access modifiers, and support for interfaces and inheritance.\n\n### Example of Defining a Class in TypeScript:\n```typescript\nclass Person {\n  // Properties with type annotations\n  private name: string;\n  public age: number;\n  protected gender: string;\n\n  // Constructor to initialize properties\n  constructor(name: string, age: number, gender: string) {\n    this.name = name;\n    this.age = age;\n    this.gender = gender;\n  }\n\n  // Method\n  public greet(): string {\n    return `Hello, my name is ${this.name}.`;\n  }\n}\n\n// Creating an instance of the class\nconst person = new Person(\"Alice\", 30, \"Female\");\nconsole.log(person.greet());\n```\n\n### Key Features of TypeScript Classes:\n1. **Type Annotations**: You can specify types for properties, method parameters, and return values.\n2. **Access Modifiers**: \n   - `public`: Accessible from anywhere (default).\n   - `private`: Accessible only within the class.\n   - `protected`: Accessible within the class and its subclasses.\n3. **Constructors**: Special methods for initializing class properties.\n4. **Inheritance**: Classes can extend other classes using the `extends` keyword.\n5. **Interfaces**: Classes can implement interfaces to enforce a specific structure.\n6. **Static Members**: Properties and methods can be declared as `static` to belong to the class itself rather than an instance.\n7. **Getters and Setters**: Provide controlled access to properties.\n\nThese features make TypeScript classes more robust and type-safe compared to plain JavaScript classes.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418541Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "1909f3a8-9a80-4a34-af7d-9831e176162f",
            "question": "What is the difference between public, private, and protected access modifiers in TypeScript?",
            "answer": "```markdown\nIn TypeScript, access modifiers are used to control the visibility and accessibility of class members (properties and methods). The three main access modifiers are `public`, `private`, and `protected`.\n\n### 1. `public`\n- Members marked as `public` are accessible from anywhere.\n- This is the default access modifier in TypeScript if no modifier is explicitly specified.\n- Public members can be accessed both inside and outside the class.\n\n```typescript\nclass Example {\n  public name: string;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  public greet(): void {\n    console.log(`Hello, ${this.name}`);\n  }\n}\n\nconst example = new Example(\"Alice\");\nconsole.log(example.name); // Accessible\nexample.greet(); // Accessible\n```\n\n---\n\n### 2. `private`\n- Members marked as `private` are accessible only within the class in which they are defined.\n- They cannot be accessed from outside the class or by subclasses.\n\n```typescript\nclass Example {\n  private secret: string;\n\n  constructor(secret: string) {\n    this.secret = secret;\n  }\n\n  private revealSecret(): void {\n    console.log(this.secret);\n  }\n}\n\nconst example = new Example(\"Top Secret\");\n// console.log(example.secret); // Error: Property 'secret' is private\n// example.revealSecret(); // Error: Method 'revealSecret' is private\n```\n\n---\n\n### 3. `protected`\n- Members marked as `protected` are accessible within the class and its subclasses.\n- They are not accessible from outside the class, even if inherited.\n\n```typescript\nclass Parent {\n  protected data: string;\n\n  constructor(data: string) {\n    this.data = data;\n  }\n\n  protected showData(): void {\n    console.log(this.data);\n  }\n}\n\nclass Child extends Parent {\n  display(): void {\n    console.log(\"Accessing protected member:\");\n    this.showData(); // Accessible in subclass\n  }\n}\n\nconst child = new Child(\"Protected Data\");\nchild.display(); // Works\n// console.log(child.data); // Error: Property 'data' is protected\n```\n\n---\n\n### Summary Table\n\n| Modifier   | Accessible in the Class | Accessible in Subclasses | Accessible Outside the Class |\n|------------|--------------------------|---------------------------|-------------------------------|\n| `public`   | Yes                      | Yes                       | Yes                           |\n| `private`  | Yes                      | No                        | No                            |\n| `protected`| Yes                      | Yes                       | No                            |\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418550Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "31cd22d6-08ca-4742-8f9f-bb44de2ff7cf",
            "question": "How do you use abstract classes in TypeScript?",
            "answer": "```markdown\nIn TypeScript, abstract classes are used as a blueprint for other classes. They cannot be instantiated directly and are designed to define a common structure and behavior that derived classes must implement. Abstract classes can include both abstract methods (methods without implementation) and concrete methods (methods with implementation).\n\n### Key Points:\n1. **Abstract Classes**:\n   - Declared using the `abstract` keyword.\n   - Cannot be instantiated directly.\n   - Can include abstract methods and concrete methods.\n\n2. **Abstract Methods**:\n   - Declared using the `abstract` keyword.\n   - Do not have an implementation in the abstract class.\n   - Must be implemented by any non-abstract subclass.\n\n3. **Concrete Methods**:\n   - Regular methods with implementations.\n   - Can be inherited by subclasses.\n\n### Example:\n\n```typescript\nabstract class Animal {\n  // Abstract method (must be implemented by subclasses)\n  abstract makeSound(): void;\n\n  // Concrete method (can be inherited)\n  move(): void {\n    console.log(\"Moving...\");\n  }\n}\n\nclass Dog extends Animal {\n  // Implementing the abstract method\n  makeSound(): void {\n    console.log(\"Bark!\");\n  }\n}\n\nconst dog = new Dog();\ndog.makeSound(); // Output: Bark!\ndog.move();      // Output: Moving...\n```\n\n### Use Cases:\n- Abstract classes are useful when you want to enforce a consistent structure across multiple derived classes.\n- They are often used in scenarios where you want to provide some shared functionality (via concrete methods) while ensuring that specific behaviors (via abstract methods) are implemented by subclasses.\n\n### Notes:\n- Abstract classes are different from interfaces. While interfaces only define the structure, abstract classes can define both structure and behavior.\n- A class can extend only one abstract class but can implement multiple interfaces.\n```\n",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418559Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "4ab93b2d-8995-48b7-b40d-0bc74cb01124",
            "question": "What are module declarations in TypeScript, and how are they used?",
            "answer": "```markdown\n### Module Declarations in TypeScript\n\nIn TypeScript, module declarations are used to define the shape of external modules that do not have type definitions. They allow developers to describe the types and structure of such modules so they can be safely used within a TypeScript project.\n\n#### Syntax\nA module declaration is written using the `declare module` syntax. For example:\n\n```typescript\ndeclare module 'external-module-name' {\n  export function someFunction(param: string): number;\n  export const someConstant: boolean;\n}\n```\n\n#### Use Cases\n1. **Typing for External Libraries**: When using a third-party library that lacks TypeScript type definitions, you can create a module declaration to define its API.\n2. **Custom Modules**: For custom JavaScript files or modules without type annotations, module declarations provide a way to integrate them into a TypeScript project.\n3. **Augmenting Existing Modules**: You can extend or modify the types of an existing module by declaring the module again and adding additional types.\n\n#### Example\nSuppose you are using a library called `my-library` that does not have type definitions. You can create a `.d.ts` file and declare the module:\n\n```typescript\n// my-library.d.ts\ndeclare module 'my-library' {\n  export function greet(name: string): string;\n  export const version: string;\n}\n```\n\nNow, you can safely use `my-library` in your TypeScript code:\n\n```typescript\nimport { greet, version } from 'my-library';\n\nconsole.log(greet('Alice')); // Type-safe usage\nconsole.log(`Library version: ${version}`);\n```\n\n#### Notes\n- Module declarations are typically placed in `.d.ts` files.\n- For popular libraries, type definitions are often available via the DefinitelyTyped repository (`@types` packages).\n- If the module is a global script (not an ES module), you may need to use a global declaration instead.\n\nBy using module declarations, TypeScript ensures type safety and better developer experience when working with untyped or partially typed modules.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418567Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "12cab893-a9b6-44cb-bf1e-95dbf3e1d075",
            "question": "How do you configure a TypeScript project using tsconfig.json?",
            "answer": "```markdown\nTo configure a TypeScript project using `tsconfig.json`, follow these steps:\n\n1. **Create a `tsconfig.json` file**: In the root of your project, create a file named `tsconfig.json`. This file is used to specify the TypeScript compiler options and project settings.\n\n2. **Initialize the `tsconfig.json` file**: Run the following command in your terminal to generate a basic `tsconfig.json` file:\n   ```bash\n   tsc --init\n   ```\n   This will create a default configuration file with common options.\n\n3. **Customize the configuration**: Open the `tsconfig.json` file and modify it to suit your project's needs. Below is an example of a typical configuration:\n   ```json\n   {\n     \"compilerOptions\": {\n       \"target\": \"ES6\",                // Specify ECMAScript target version\n       \"module\": \"CommonJS\",           // Specify module system\n       \"strict\": true,                 // Enable strict type-checking options\n       \"outDir\": \"./dist\",             // Specify output directory for compiled files\n       \"rootDir\": \"./src\",             // Specify root directory of input files\n       \"esModuleInterop\": true,        // Enable interoperability between CommonJS and ES modules\n       \"skipLibCheck\": true            // Skip type checking of declaration files\n     },\n     \"include\": [\"src/**/*\"],          // Specify files or directories to include\n     \"exclude\": [\"node_modules\"]       // Specify files or directories to exclude\n   }\n   ```\n\n4. **Compile the project**: Run the TypeScript compiler using the `tsc` command. It will use the settings defined in `tsconfig.json`:\n   ```bash\n   tsc\n   ```\n\n5. **Verify the output**: The compiled JavaScript files will be generated in the directory specified by the `outDir` option (e.g., `./dist`).\n\nBy configuring the `tsconfig.json` file, you can control how TypeScript compiles your code and manage your project's structure effectively.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418576Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "d8687e1c-0675-487a-a3a7-4ae4ff21001f",
            "question": "How do you handle type casting in TypeScript?",
            "answer": "```markdown\nIn TypeScript, type casting is used to explicitly tell the compiler to treat a value as a specific type. This can be useful when you have more information about the type of a value than TypeScript can infer. There are two main ways to perform type casting:\n\n### 1. Using the `as` Syntax\nThe `as` keyword is the most common and recommended way to cast a value to a specific type in TypeScript.\n\n```typescript\nlet someValue: unknown = \"Hello, TypeScript!\";\nlet strLength: number = (someValue as string).length;\nconsole.log(strLength); // Output: 17\n```\n\n### 2. Using Angle Bracket Syntax\nYou can also use the angle bracket (`<>`) syntax for type casting. However, this is not recommended in JSX files (e.g., React projects) because it conflicts with JSX syntax.\n\n```typescript\nlet someValue: unknown = \"Hello, TypeScript!\";\nlet strLength: number = (<string>someValue).length;\nconsole.log(strLength); // Output: 17\n```\n\n### Important Notes:\n- **Type Safety**: Type casting does not change the runtime type of a value; it only tells the compiler to treat the value as a specific type. If the actual type does not match the cast type, it may lead to runtime errors.\n- **Avoid Overuse**: Use type casting sparingly and only when you are certain about the type of the value. Overusing type casting can bypass TypeScript's type-checking and lead to bugs.\n- **Non-null Assertion (`!`)**: You can use the non-null assertion operator (`!`) to tell TypeScript that a value is not `null` or `undefined`.\n\n```typescript\nlet someValue: string | null = \"Hello!\";\nlet strLength: number = someValue!.length; // Asserts that someValue is not null\nconsole.log(strLength); // Output: 6\n```\n\nBy using type casting carefully, you can ensure your TypeScript code remains type-safe while accommodating scenarios where the compiler cannot infer the type correctly.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418594Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "f81ce0b0-0ce6-4d11-aed4-85d8252acb44",
            "question": "What is the difference between 'type' and 'interface' when extending in TypeScript?",
            "answer": "```markdown\nIn TypeScript, both `type` and `interface` can be used to define the shape of an object, but there are some differences when it comes to extending them:\n\n### 1. **Extending with `interface`**\n- `interface` supports extending other interfaces using the `extends` keyword.\n- An `interface` can extend one or more interfaces or even a class type.\n- Interfaces are open-ended, meaning you can declare the same interface multiple times, and TypeScript will merge their properties.\n\n```typescript\ninterface A {\n  propA: string;\n}\n\ninterface B extends A {\n  propB: number;\n}\n\nconst obj: B = {\n  propA: \"Hello\",\n  propB: 42,\n};\n```\n\n### 2. **Extending with `type`**\n- `type` uses intersection types (`&`) to combine multiple types.\n- Unlike `interface`, `type` is not open-ended, so you cannot redeclare a type to add new properties.\n- `type` can extend other types, interfaces, or even complex unions.\n\n```typescript\ntype A = {\n  propA: string;\n};\n\ntype B = A & {\n  propB: number;\n};\n\nconst obj: B = {\n  propA: \"Hello\",\n  propB: 42,\n};\n```\n\n### Key Differences\n| Feature                  | `interface`                     | `type`                          |\n|--------------------------|----------------------------------|----------------------------------|\n| Extending                | Uses `extends` keyword          | Uses intersection types (`&`)   |\n| Open-ended               | Yes, can be merged              | No, cannot be redefined         |\n| Extends Classes          | Yes                             | No                              |\n| Union Types              | No                              | Yes                             |\n\n### When to Use\n- Use `interface` when you need to define a contract for objects and want to take advantage of declaration merging.\n- Use `type` when you need to work with union types, intersections, or more complex type compositions.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418603Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "17225516-fb71-4dd3-b605-26023d571ca8",
            "question": "How do you use the 'NonNullable' utility type in TypeScript?",
            "answer": "```markdown\nIn TypeScript, the `NonNullable` utility type is used to construct a type by excluding `null` and `undefined` from a given type. It is particularly useful when you want to ensure that a value cannot be `null` or `undefined`.\n\n### Syntax:\n```typescript\nNonNullable<Type>\n```\n\n### Example:\n```typescript\ntype Example = string | number | null | undefined;\n\n// Using NonNullable to exclude null and undefined\ntype NonNullableExample = NonNullable<Example>;\n\n// Resulting type: string | number\n```\n\n### Use Case:\nThe `NonNullable` utility type is often used in scenarios where you want to enforce stricter type checks, such as when working with APIs or functions that should not accept `null` or `undefined` values.\n\n### Practical Example:\n```typescript\nfunction processValue(value: NonNullable<string | null | undefined>) {\n  // Here, value is guaranteed to be a string and not null or undefined\n  console.log(value.toUpperCase());\n}\n\n// Valid usage\nprocessValue(\"Hello\");\n\n// Invalid usage (will cause a TypeScript error)\n// processValue(null);\n// processValue(undefined);\n```\n\nBy using `NonNullable`, you can ensure that your code is more robust and avoids potential runtime errors caused by `null` or `undefined` values.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418611Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "339a3dc8-3f64-46d5-8579-906b1db06a52",
            "question": "What is the purpose of the 'Awaited' utility type in TypeScript?",
            "answer": "```markdown\nThe `Awaited` utility type in TypeScript is used to infer the resolved type of a `Promise` or a value that is `await`-ed. It is particularly useful when working with asynchronous code, as it helps extract the type of the value that a `Promise` resolves to, or the type returned by an `async` function.\n\n### Purpose:\n1. **Extract Resolved Types**: It allows developers to determine the type of the value that a `Promise` resolves to, simplifying type handling in asynchronous workflows.\n2. **Handle Nested Promises**: It can recursively unwrap nested `Promise` types, ensuring the correct resolved type is inferred.\n3. **Type Safety**: It improves type safety by ensuring that the resolved type is accurately represented in the code.\n\n### Example:\n```typescript\ntype Example = Promise<string>;\n\ntype Resolved = Awaited<Example>; // Resolved is inferred as 'string'\n\nasync function fetchData(): Promise<number> {\n  return 42;\n}\n\ntype Result = Awaited<ReturnType<typeof fetchData>>; // Result is inferred as 'number'\n```\n\n### Key Points:\n- Introduced in TypeScript 4.5.\n- Works with both `Promise` and non-`Promise` values, making it versatile.\n- Simplifies type inference in complex asynchronous scenarios.\n\nThe `Awaited` utility type is a powerful tool for managing asynchronous code and ensuring type correctness in TypeScript.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418620Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "26b2e937-8ebb-425f-aa93-462ac823f3cc",
            "question": "How do you define and use enums in TypeScript?",
            "answer": "```markdown\nIn TypeScript, enums are a way to define a set of named constants, which can be either numeric or string-based. Enums make it easier to work with a group of related values and improve code readability.\n\n### Defining an Enum\nYou can define an enum using the `enum` keyword. Here's an example of a numeric enum:\n\n```typescript\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n```\n\nIn this example:\n- `Up` is explicitly assigned the value `1`.\n- The rest of the members (`Down`, `Left`, `Right`) are auto-incremented, so `Down` will be `2`, `Left` will be `3`, and `Right` will be `4`.\n\nYou can also define string enums:\n\n```typescript\nenum Status {\n  Success = \"SUCCESS\",\n  Failure = \"FAILURE\",\n  Pending = \"PENDING\"\n}\n```\n\nHere, each member is explicitly assigned a string value.\n\n### Using Enums\nYou can use enums to access their members or values:\n\n```typescript\n// Accessing enum members\nconst direction: Direction = Direction.Up;\nconsole.log(direction); // Output: 1\n\n// Accessing enum names using values\nconst directionName: string = Direction[1];\nconsole.log(directionName); // Output: \"Up\"\n\n// Using string enums\nconst status: Status = Status.Success;\nconsole.log(status); // Output: \"SUCCESS\"\n```\n\n### Key Points\n1. Numeric enums can have auto-incremented values.\n2. String enums require explicit assignment of values.\n3. Enums can be used for both type safety and readability in your code.\n\nEnums are particularly useful when you have a fixed set of related constants that you want to use throughout your application.\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418629Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "b586d1ba-11c5-4cf5-9922-783ddf4f9773",
            "question": "What are ambient declarations in TypeScript, and when are they used?",
            "answer": "```markdown\n### Ambient Declarations in TypeScript\n\nAmbient declarations in TypeScript are used to describe the shape or type of code that exists outside of the TypeScript project, typically in JavaScript or other external libraries. These declarations allow TypeScript to understand and type-check code that is not written in TypeScript but is still used in a TypeScript project.\n\nAmbient declarations are written using the `declare` keyword and are typically found in `.d.ts` (declaration) files. These files do not contain any implementation; they only provide type information. This is particularly useful when working with third-party libraries that do not have their own TypeScript type definitions.\n\n### When to Use Ambient Declarations\n\n1. **Interfacing with JavaScript Libraries**: When using a JavaScript library that does not provide TypeScript type definitions, you can write ambient declarations to describe the library's API.\n\n2. **Global Variables or Modules**: When you need to declare global variables, modules, or namespaces that are not explicitly defined in your TypeScript code.\n\n3. **Custom Type Definitions**: When extending or customizing existing type definitions for libraries or frameworks.\n\n4. **Legacy Codebases**: When integrating TypeScript into a legacy JavaScript project, ambient declarations can help describe the existing codebase without rewriting it.\n\n### Example\n\nHere is an example of an ambient declaration for a global variable:\n\n```typescript\n// globals.d.ts\ndeclare const API_URL: string;\n```\n\nThis tells TypeScript that a global variable `API_URL` exists and is of type `string`.\n\nAnother example for a module:\n\n```typescript\n// myLibrary.d.ts\ndeclare module \"myLibrary\" {\n  export function doSomething(param: string): void;\n}\n```\n\nThis allows TypeScript to understand the `myLibrary` module and its `doSomething` function.\n\n### Summary\n\nAmbient declarations are a powerful feature in TypeScript that enable type safety and better tooling support when working with external or legacy code. They bridge the gap between TypeScript and non-TypeScript codebases, ensuring a seamless development experience.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418638Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "a53794f7-4327-4f49-ab50-4ff3eb9568dc",
            "question": "How do you work with third-party libraries that don't have TypeScript definitions?",
            "answer": "```markdown\nWhen working with third-party libraries that don't have TypeScript definitions, you can handle this situation in the following ways:\n\n1. **Install Community-Maintained Type Definitions**:  \n   Many libraries have TypeScript definitions maintained by the community, which are available in the DefinitelyTyped repository. You can install these using the `@types` package. For example:\n   ```bash\n   npm install --save-dev @types/library-name\n   ```\n   Check if the type definitions exist for the library before proceeding.\n\n2. **Use the `any` Type**:  \n   If no type definitions are available and you need a quick solution, you can use the `any` type. However, this approach sacrifices type safety:\n   ```typescript\n   const library: any = require('library-name');\n   ```\n\n3. **Create a Custom Type Declaration File**:  \n   If no type definitions exist, you can create your own `.d.ts` file to define the types for the library. For example, create a `library-name.d.ts` file in your project:\n   ```typescript\n   declare module 'library-name' {\n       export function someFunction(arg: string): number;\n       // Add other type definitions as needed\n   }\n   ```\n\n4. **Use the `declare` Keyword**:  \n   If you only need to use a small part of the library, you can declare the module inline in your code:\n   ```typescript\n   declare module 'library-name';\n   ```\n\n5. **Use `ts-ignore` as a Last Resort**:  \n   If you are unable to define types and need to bypass TypeScript errors temporarily, you can use `// @ts-ignore` to suppress the error. This should only be used sparingly:\n   ```typescript\n   // @ts-ignore\n   import library from 'library-name';\n   ```\n\n6. **Contribute to the Community**:  \n   If you create custom type definitions for a library, consider contributing them to the DefinitelyTyped repository so others can benefit.\n\nBy following these steps, you can effectively work with third-party libraries that lack TypeScript definitions while maintaining as much type safety as possible.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418646Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "a6bdeae7-4b6d-4166-ab4c-12f61e395fe5",
            "question": "What is the purpose of declaration merging in TypeScript?",
            "answer": "```markdown\nDeclaration merging in TypeScript allows multiple declarations with the same name to be combined into a single definition. This feature is particularly useful for extending existing types, interfaces, or modules without modifying their original definitions. It enables developers to:\n\n1. **Extend Interfaces**: Add additional properties or methods to an existing interface.\n2. **Augment Modules**: Add new members to existing modules, such as extending third-party libraries.\n3. **Combine Function Overloads**: Merge multiple function declarations to support different parameter and return type combinations.\n\nThis capability enhances flexibility and reusability in TypeScript, making it easier to work with external libraries and maintain modular code.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418654Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "334d4c34-943a-4982-a73f-0cf8a8f44702",
            "question": "How do you use the 'this' keyword in TypeScript classes?",
            "answer": "```markdown\nIn TypeScript classes, the `this` keyword refers to the current instance of the class. It is used to access the properties and methods of the class within its scope. Here's an example:\n\n```typescript\nclass Person {\n  name: string;\n\n  constructor(name: string) {\n    this.name = name; // Using 'this' to refer to the class property\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`); // Accessing 'name' using 'this'\n  }\n}\n\nconst person = new Person(\"Alice\");\nperson.greet(); // Output: Hello, my name is Alice.\n```\n\n### Key Points:\n1. `this` always refers to the current instance of the class.\n2. It is commonly used in constructors and methods to access or modify class properties.\n3. Be cautious when using `this` in callbacks or event handlers, as the context of `this` may change. To preserve the context, you can use arrow functions or explicitly bind the method.\n\nExample of preserving `this` context with an arrow function:\n\n```typescript\nclass Counter {\n  count: number = 0;\n\n  increment = () => {\n    this.count++;\n    console.log(this.count);\n  };\n}\n\nconst counter = new Counter();\nconst incrementFn = counter.increment;\nincrementFn(); // Output: 1 (context of 'this' is preserved)\n```\n```",
            "level": "Beginner",
            "created_at": "2025-03-28T17:58:41.418663Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "be6b0376-1e85-4660-bf9b-8382157399fd",
            "question": "What are the differences between static and instance members in TypeScript classes?",
            "answer": "```markdown\nIn TypeScript, static and instance members of a class differ in the following ways:\n\n1. **Definition and Access**:\n   - **Static Members**: These are defined using the `static` keyword and belong to the class itself, not to any specific instance. They are accessed directly on the class (e.g., `ClassName.staticMember`).\n   - **Instance Members**: These are defined without the `static` keyword and belong to individual instances of the class. They are accessed through an instance of the class (e.g., `instance.instanceMember`).\n\n2. **Memory Allocation**:\n   - **Static Members**: Only one copy of a static member exists, regardless of the number of instances of the class. It is shared across all instances.\n   - **Instance Members**: Each instance of the class has its own copy of the instance members, meaning they are unique to each object.\n\n3. **Use Cases**:\n   - **Static Members**: Used for properties or methods that are common to all instances and do not depend on instance-specific data. For example, utility functions or constants.\n   - **Instance Members**: Used for properties or methods that are specific to an instance and may vary between instances.\n\n4. **Access Restrictions**:\n   - **Static Members**: Cannot access instance members directly because they do not belong to any specific instance. To access instance members, a static method would need an instance of the class.\n   - **Instance Members**: Can access both static and instance members of the class.\n\n### Example:\n```typescript\nclass Example {\n  static staticProperty: string = \"I am static\";\n  instanceProperty: string;\n\n  constructor(instanceProperty: string) {\n    this.instanceProperty = instanceProperty;\n  }\n\n  static staticMethod() {\n    console.log(\"Static method called\");\n    // Cannot access instanceProperty directly\n    // console.log(this.instanceProperty); // Error\n  }\n\n  instanceMethod() {\n    console.log(\"Instance method called\");\n    console.log(Example.staticProperty); // Can access static members\n  }\n}\n\n// Accessing static members\nconsole.log(Example.staticProperty); // \"I am static\"\nExample.staticMethod(); // \"Static method called\"\n\n// Accessing instance members\nconst instance = new Example(\"I am an instance\");\nconsole.log(instance.instanceProperty); // \"I am an instance\"\ninstance.instanceMethod(); \n// \"Instance method called\"\n// \"I am static\"\n```\n\nIn summary, static members are tied to the class itself, while instance members are tied to individual instances of the class. They serve different purposes and are accessed differently.\n```",
            "level": "Intermediate",
            "created_at": "2025-03-28T17:58:41.418672Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        },
        {
            "id": "2f9029f5-5d4c-45c2-85b0-5198d2644a58",
            "question": "How do you handle circular dependencies in TypeScript?",
            "answer": "```markdown\n### Handling Circular Dependencies in TypeScript\n\nCircular dependencies occur when two or more modules depend on each other, either directly or indirectly. In TypeScript, circular dependencies can lead to runtime errors or unexpected behavior. Here are some strategies to handle them:\n\n1. **Refactor Code to Remove Circular Dependencies**:\n   - Analyze the dependency graph and identify the circular references.\n   - Break the dependency chain by restructuring the code. For example:\n     - Extract shared logic into a separate module.\n     - Use dependency injection to decouple modules.\n\n2. **Use Interfaces or Abstract Classes**:\n   - Instead of importing concrete implementations, use interfaces or abstract classes to define contracts. This reduces direct dependencies between modules.\n\n   ```typescript\n   // Module A\n   import { BInterface } from './B';\n\n   export class A {\n       constructor(private b: BInterface) {}\n   }\n\n   // Module B\n   import { A } from './A';\n\n   export interface BInterface {\n       doSomething(): void;\n   }\n\n   export class B implements BInterface {\n       constructor(private a: A) {}\n       doSomething() {\n           console.log('B is doing something');\n       }\n   }\n   ```\n\n3. **Lazy Imports**:\n   - Use dynamic imports (`import()`) to defer the loading of a module until it's needed. This can break the circular dependency at runtime.\n\n   ```typescript\n   class A {\n       async useB() {\n           const { B } = await import('./B');\n           const b = new B();\n           b.doSomething();\n       }\n   }\n   ```\n\n4. **Re-export Modules**:\n   - Use a central module to re-export dependencies, reducing direct imports between modules.\n\n   ```typescript\n   // index.ts\n   export { A } from './A';\n   export { B } from './B';\n\n   // A.ts and B.ts import from index.ts instead of each other\n   ```\n\n5. **Type-Only Imports**:\n   - Use `import type` to import only types, which avoids runtime circular dependencies.\n\n   ```typescript\n   import type { B } from './B';\n\n   export class A {\n       b!: B;\n   }\n   ```\n\n6. **Enable `esModuleInterop` or `allowSyntheticDefaultImports`**:\n   - In some cases, enabling these compiler options in `tsconfig.json` can help resolve circular dependencies when working with CommonJS modules.\n\n   ```json\n   {\n       \"compilerOptions\": {\n           \"esModuleInterop\": true,\n           \"allowSyntheticDefaultImports\": true\n       }\n   }\n   ```\n\n7. **Use Dependency Injection Frameworks**:\n   - Frameworks like `InversifyJS` or `NestJS` can help manage dependencies and resolve circular references automatically.\n\n8. **Be Aware of Execution Order**:\n   - Circular dependencies can cause issues due to the order in which modules are executed. Ensure that initialization logic does not rely on incomplete module states.\n\nBy carefully analyzing and refactoring your code, you can effectively manage and eliminate circular dependencies in TypeScript.\n```",
            "level": "Advanced",
            "created_at": "2025-03-28T17:58:41.418681Z",
            "topic": "82ef8628-02db-4238-a140-023ad52e3778"
        }
    ]
}