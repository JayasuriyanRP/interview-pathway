[
    {
        "id": "e435ecca-9de6-4f2b-9a2f-316b2d1d632e",
        "question": "What is Angular and how does it differ from AngularJS?",
        "answer": "```markdown **Answer:**\n\nAngular is a modern, open-source front-end web application framework developed by Google. It is used to build dynamic, single-page web applications (SPAs) using TypeScript, a superset of JavaScript.\n\n**Differences between Angular and AngularJS:**\n\n| Feature              | AngularJS (v1.x)             | Angular (v2 and above)         |\n|----------------------|------------------------------|-------------------------------|\n| Language             | JavaScript                   | TypeScript (and ES6+)         |\n| Architecture         | MVC (Model-View-Controller)  | Component-based architecture  |\n| Mobile Support       | Limited                      | Designed for mobile support   |\n| Performance          | Slower, uses two-way binding | Faster, improved change detection |\n| Dependency Injection | Limited                      | Robust and improved           |\n| Directives Syntax    | ng-directives (e.g., ng-model) | Uses [] for property binding and () for event binding |\n| Backward Compatibility | N/A                        | Not backward compatible with AngularJS |\n\n**Summary:**  \nAngular is a complete rewrite of AngularJS, offering better performance, a component-based structure, and modern features like TypeScript support, making it more suitable for large-scale and maintainable applications.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794673Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "66c5fb9e-479f-4b8d-81da-e07da236aa00",
        "question": "Explain the concept of data binding in Angular.",
        "answer": "```markdown **Answer:**\n\nData binding in Angular is a powerful feature that allows you to connect the data in your component (TypeScript code) with the view (HTML template). It ensures that changes in the component’s data are automatically reflected in the view, and vice versa, depending on the type of binding used. Angular supports several types of data binding:\n\n1. **Interpolation (`{{ }}`):**\n   - Used to display component data in the template.\n   - Example: `<h1>{{ title }}</h1>`\n\n2. **Property Binding (`[property]`):**\n   - Binds a property of an HTML element to a component property.\n   - Example: `<img [src]=\"imageUrl\">`\n\n3. **Event Binding (`(event)`):**\n   - Binds an event (like click, input) to a method in the component.\n   - Example: `<button (click)=\"onClick()\">Click Me</button>`\n\n4. **Two-way Binding (`[(ngModel)]`):**\n   - Combines property and event binding to keep the component and view in sync.\n   - Example: `<input [(ngModel)]=\"username\">`\n\n**Summary:**  \nData binding in Angular makes it easy to manage and synchronize data between the component and the view, enhancing interactivity and reducing the need for manual DOM manipulation.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794694Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "c1e1d48a-f9d0-4011-bdea-7d3aebb0d1e5",
        "question": "What are Angular decorators and name a few commonly used ones?",
        "answer": "```markdown **Answer:**\n\nIn Angular, **decorators** are special functions that add metadata to classes, properties, methods, or parameters. This metadata tells Angular how to process and use these elements. Decorators are a core part of Angular and are used to define components, services, modules, and more.\n\nA few commonly used Angular decorators are:\n\n- `@Component` &mdash; Defines a class as an Angular component and provides its metadata (like selector, template, etc.).\n- `@NgModule` &mdash; Declares a class as an Angular module and specifies its components, directives, pipes, and providers.\n- `@Injectable` &mdash; Marks a class as available to be provided and injected as a dependency.\n- `@Input` &mdash; Marks a property as an input property that can receive data from a parent component.\n- `@Output` &mdash; Marks a property as an output property that can emit events to a parent component.\n\nThese decorators help Angular understand how to construct and connect different parts of your application.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794702Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "c8e66565-a7b1-4a9a-90fc-9a5085e6a5b9",
        "question": "What is the purpose of NgModule in Angular?",
        "answer": "```markdown **Answer:**\n\nIn Angular, an `NgModule` is a fundamental building block that helps organize an application into cohesive blocks of functionality. The purpose of `NgModule` is to:\n\n- **Group related components, directives, pipes, and services** together so they can be managed as a single unit.\n- **Declare which components, directives, and pipes** belong to the module using the `declarations` array.\n- **Import other modules** whose exported classes are needed by components in this module using the `imports` array.\n- **Export components, directives, and pipes** so they can be used in other modules using the `exports` array.\n- **Provide services** that should be available application-wide or module-wide using the `providers` array.\n- **Bootstrap the root component** that Angular should load when the application starts (in the root module).\n\nIn summary, `NgModule` helps in structuring an Angular application, making it modular, maintainable, and scalable.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794710Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "de9646a2-57ac-4f6f-a749-5daf7763c373",
        "question": "How does Angular handle dependency injection?",
        "answer": "```markdown\nAngular uses a built-in dependency injection (DI) framework to manage how components and services acquire their dependencies. Instead of creating dependencies manually inside a class, Angular allows you to declare them in the constructor, and the framework automatically provides the required instances.\n\nKey points about Angular's dependency injection:\n\n- **Providers**: Dependencies (like services) are registered with Angular's injector using providers, which can be specified at different levels (root, module, component).\n- **Constructor Injection**: Dependencies are injected into classes via their constructors. Angular inspects the constructor parameters and provides the required instances.\n- **Hierarchical Injectors**: Angular creates a tree of injectors, allowing different parts of the application to have their own instances of dependencies if needed.\n- **@Injectable Decorator**: Services must be decorated with `@Injectable()` to let Angular know they can be injected elsewhere.\n\n**Example:**\n\n```typescript\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  // Service logic\n}\n\n@Component({\n  selector: 'app-example',\n  template: `...`\n})\nexport class ExampleComponent {\n  constructor(private dataService: DataService) {\n    // dataService is automatically injected\n  }\n}\n```\n\n**Summary:**  \nAngular handles dependency injection by using providers, injectors, and decorators to automatically supply classes with their required dependencies, making code modular, testable, and maintainable.\n```\n",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794719Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "869ab3c7-e378-4aa7-9e4e-3b560dc0f670",
        "question": "What are the differences between Angular Elements and standard Angular components?",
        "answer": "```markdown\n**Differences Between Angular Elements and Standard Angular Components**\n\n| Aspect                    | Angular Elements                                            | Standard Angular Components                        |\n|---------------------------|------------------------------------------------------------|----------------------------------------------------|\n| **Definition**            | Angular Elements are Angular components packaged as custom elements (web components) that can be used in any HTML page, regardless of the framework. | Standard Angular components are building blocks of Angular applications and are used within Angular templates. |\n| **Usage Context**         | Can be used outside Angular applications (e.g., in React, Vue, plain HTML). | Used only within Angular applications.             |\n| **Bootstrap Mechanism**   | Bootstrapped as custom elements via browser APIs.           | Bootstrapped by Angular’s component tree and module system. |\n| **Dependency Injection**  | Limited or no Angular dependency injection outside Angular context. | Full Angular dependency injection support.         |\n| **Lifecycle Hooks**       | Only a subset of Angular lifecycle hooks are supported (e.g., ngOnInit, ngOnDestroy). | All Angular lifecycle hooks are available.         |\n| **Change Detection**      | Manual triggering may be required when used outside Angular. | Automatic via Angular’s change detection mechanism.|\n| **Interoperability**      | High—can be used in non-Angular projects as standard web components. | Low—tightly coupled to Angular framework.          |\n| **Packaging**             | Packaged as standalone JavaScript bundles.                  | Part of Angular application bundles.               |\n\n**Summary:**  \nAngular Elements allow Angular components to be used as standard web components, enabling interoperability with other frameworks and plain HTML. Standard Angular components, on the other hand, are tightly integrated with the Angular framework and are not natively usable outside Angular applications.\n```",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795080Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "6657c5e2-cd0c-44dc-ac21-54dcec0b85ce",
        "question": "What is the difference between a component and a directive in Angular?",
        "answer": "```markdown **Answer:**\n\nIn Angular, both components and directives are used to add behavior to the DOM, but they serve different purposes:\n\n| Feature      | Component                                      | Directive                                      |\n|--------------|------------------------------------------------|------------------------------------------------|\n| Definition   | A component is a directive with a template.    | A directive is a class that adds behavior to elements. |\n| Template     | Has its own HTML template.                     | Does not have a template of its own.           |\n| Usage        | Used to create UI views and screens.           | Used to change the appearance or behavior of existing elements. |\n| Selector     | Usually used as an element (`<app-example>`).  | Used as an attribute (`<div appHighlight>`), element, or class. |\n| Example      | `@Component({...})`                            | `@Directive({...})`                            |\n\n**Summary:**  \n- **Components** are the main building blocks for UI in Angular applications and always have a template.\n- **Directives** are used to add custom behavior to elements and do not have their own templates.  \n  - *Structural directives* (like `*ngIf`, `*ngFor`) change the DOM structure.\n  - *Attribute directives* (like `ngClass`, custom highlight directives) change the appearance or behavior of elements.\n\n**In short:**  \n> Every component is a directive with a template, but not every directive is a component.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794726Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "6c29a58e-7337-4ab0-b777-ab00ceb5a6bf",
        "question": "How do you create and use services in Angular?",
        "answer": "```markdown ### How do you create and use services in Angular?\n\nIn Angular, **services** are used to share data, logic, or functions across different components. They help keep your code modular and reusable.\n\n#### 1. Creating a Service\n\nYou can create a service using the Angular CLI:\n\n```bash\nng generate service my-service\n```\n\nThis command creates a file like `my-service.service.ts` with a basic service class:\n\n```typescript\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MyService {\n  constructor() { }\n\n  getData() {\n    return 'Hello from MyService!';\n  }\n}\n```\n\n- The `@Injectable({ providedIn: 'root' })` decorator makes the service available application-wide (singleton).\n\n#### 2. Using a Service in a Component\n\nTo use the service in a component:\n\n1. **Import the service:**\n\n    ```typescript\n    import { MyService } from './my-service.service';\n    ```\n\n2. **Inject the service via the constructor:**\n\n    ```typescript\n    constructor(private myService: MyService) { }\n    ```\n\n3. **Use the service methods:**\n\n    ```typescript\n    ngOnInit() {\n      const message = this.myService.getData();\n      console.log(message); // Output: Hello from MyService!\n    }\n    ```\n\n#### Summary\n\n- Create a service with `ng generate service`.\n- Use `@Injectable` to make it injectable.\n- Inject the service into components or other services via the constructor.\n- Call service methods as needed.\n\nServices are a core concept in Angular for sharing logic and data across your application.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794733Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "bce343a0-30cc-42d2-acaf-69e9f19a29b5",
        "question": "What is the Angular CLI and what are its main benefits?",
        "answer": "```markdown **Answer:**\n\nThe **Angular CLI** (Command Line Interface) is a powerful tool that helps developers create, manage, and build Angular applications directly from the command line.\n\n### Main Benefits of Angular CLI\n\n- **Project Scaffolding:** Quickly generates new Angular projects and boilerplate code for components, services, modules, and more using simple commands.\n- **Efficient Development:** Automates common development tasks like building, testing, linting, and serving the application.\n- **Consistent Structure:** Ensures a consistent project structure and coding standards across teams and projects.\n- **Built-in Best Practices:** Applies Angular best practices and optimizations by default, such as Ahead-of-Time (AOT) compilation and tree-shaking.\n- **Easy Updates:** Simplifies updating Angular and its dependencies with commands like `ng update`.\n- **Testing Support:** Integrates with testing frameworks and makes it easy to run unit and end-to-end tests.\n- **Configuration Management:** Handles complex build configurations for different environments (development, production, etc.) with ease.\n\n**In summary:** The Angular CLI streamlines Angular development, boosts productivity, and enforces best practices, making it an essential tool for Angular developers.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:27:00.794740Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "98e773ef-1a27-400c-b607-51897c251fab",
        "question": "Explain the lifecycle hooks of an Angular component.",
        "answer": "```markdown\n### Angular Component Lifecycle Hooks\n\nAngular components go through a series of lifecycle events from creation to destruction. Angular provides lifecycle hooks—special methods that allow you to tap into these key moments and execute custom logic. Here are the main lifecycle hooks:\n\n1. **ngOnChanges(changes: SimpleChanges)**\n   - Called before `ngOnInit` and whenever one or more data-bound input properties change.\n   - Useful for reacting to changes in `@Input()` properties.\n\n2. **ngOnInit()**\n   - Called once after the first `ngOnChanges`.\n   - Ideal for component initialization logic, such as fetching data.\n\n3. **ngDoCheck()**\n   - Called during every change detection run, immediately after `ngOnChanges` and `ngOnInit`.\n   - Use this for custom change detection.\n\n4. **ngAfterContentInit()**\n   - Called once after Angular projects external content into the component's view (using `<ng-content>`).\n   - Useful for initialization that depends on projected content.\n\n5. **ngAfterContentChecked()**\n   - Called after every check of the projected content.\n   - Use this to respond to changes in the projected content.\n\n6. **ngAfterViewInit()**\n   - Called once after the component's view (and child views) have been initialized.\n   - Good for DOM-dependent initialization.\n\n7. **ngAfterViewChecked()**\n   - Called after every check of the component's view (and child views).\n   - Use this to act on changes in the view.\n\n8. **ngOnDestroy()**\n   - Called just before Angular destroys the component.\n   - Ideal for cleanup logic, such as unsubscribing from observables or detaching event handlers.\n\n#### Lifecycle Hook Order\n\nThe typical sequence is:\n\n1. `ngOnChanges`\n2. `ngOnInit`\n3. `ngDoCheck`\n4. `ngAfterContentInit`\n5. `ngAfterContentChecked`\n6. `ngAfterViewInit`\n7. `ngAfterViewChecked`\n8. `ngOnDestroy` (when the component is destroyed)\n\n#### Example\n\n```typescript\nimport { \n  Component, OnInit, OnChanges, DoCheck, \n  AfterContentInit, AfterContentChecked, \n  AfterViewInit, AfterViewChecked, OnDestroy, Input, SimpleChanges \n} from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<p>Example Component</p>`\n})\nexport class ExampleComponent implements \n  OnInit, OnChanges, DoCheck, \n  AfterContentInit, AfterContentChecked, \n  AfterViewInit, AfterViewChecked, OnDestroy {\n\n  @Input() data: any;\n\n  ngOnChanges(changes: SimpleChanges) { /* ... */ }\n  ngOnInit() { /* ... */ }\n  ngDoCheck() { /* ... */ }\n  ngAfterContentInit() { /* ... */ }\n  ngAfterContentChecked() { /* ... */ }\n  ngAfterViewInit() { /* ... */ }\n  ngAfterViewChecked() { /* ... */ }\n  ngOnDestroy() { /* ... */ }\n}\n```\n\n#### Summary Table\n\n| Hook                    | When Called                                         | Typical Use Case                        |\n|-------------------------|-----------------------------------------------------|-----------------------------------------|\n| ngOnChanges             | On input property changes                           | Respond to input changes                |\n| ngOnInit                | Once after first ngOnChanges                        | Initialization logic                    |\n| ngDoCheck               | Every change detection cycle                        | Custom change detection                 |\n| ngAfterContentInit      | Once after content projected                        | Init after content projection           |\n| ngAfterContentChecked   | After every check of projected content              | Respond to projected content changes    |\n| ngAfterViewInit         | Once after component’s view initialized             | DOM-dependent initialization            |\n| ngAfterViewChecked      | After every check of component’s view               | Respond to view changes                 |\n| ngOnDestroy             | Just before component destroyed                     | Cleanup (unsubscribe, detach handlers)  |\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794748Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "867d3359-dfa6-4d49-ad2d-384098f4c65f",
        "question": "What is change detection in Angular and how does it work?",
        "answer": "```markdown **Change detection in Angular** is the mechanism that Angular uses to keep the view (DOM) in sync with the underlying application data (model). Whenever the state of the application changes (for example, due to user input, HTTP requests, or timers), Angular automatically updates the view to reflect those changes.\n\n### How Change Detection Works\n\n1. **Component Tree Traversal**:  \n   Angular maintains a tree of components. When change detection runs, it traverses this tree from top to bottom, checking each component for changes.\n\n2. **Checking for Changes**:  \n   For each component, Angular compares the current value of data-bound properties (those used in templates) with their previous values. If a change is detected, Angular updates the DOM accordingly.\n\n3. **Change Detection Strategies**:  \n   Angular provides two main strategies:\n   - **Default**: Checks all components in the tree whenever any event occurs (like a click, HTTP response, etc.).\n   - **OnPush**: Only checks the component if its input properties change or an event originates from the component itself. This can improve performance for large applications.\n\n4. **Triggering Change Detection**:  \n   Change detection is triggered by:\n   - Browser events (click, input, etc.)\n   - HTTP responses\n   - Timers (setTimeout, setInterval)\n   - Manually via `ChangeDetectorRef` methods (e.g., `markForCheck()`, `detectChanges()`)\n\n### Example\n\n```typescript\n@Component({\n  selector: 'app-example',\n  template: `<p>{{ counter }}</p>`\n})\nexport class ExampleComponent {\n  counter = 0;\n\n  increment() {\n    this.counter++;\n    // Angular automatically detects the change and updates the view\n  }\n}\n```\n\nWhen `increment()` is called (e.g., by a button click), Angular's change detection will notice that `counter` has changed and update the displayed value in the template.\n\n### Summary Table\n\n| Aspect                | Description                                                                 |\n|-----------------------|-----------------------------------------------------------------------------|\n| Purpose               | Syncs model and view                                                        |\n| Triggered by          | Events, HTTP, timers, manual calls                                          |\n| Strategies            | Default, OnPush                                                             |\n| Manual Control        | Via `ChangeDetectorRef`                                                     |\n\n**In summary:**  \nChange detection is a core feature in Angular that ensures the UI always reflects the current state of the data, using efficient strategies to minimize unnecessary updates.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794755Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "58e6dd6a-7543-4115-844f-ea98d073e3a1",
        "question": "Describe the difference between template-driven and reactive forms in Angular.",
        "answer": "```markdown **Template-driven vs. Reactive Forms in Angular**\n\n| Feature                   | Template-driven Forms                                   | Reactive Forms                                         |\n|---------------------------|--------------------------------------------------------|--------------------------------------------------------|\n| **Form Creation**         | Defined in the template using directives (`ngModel`)    | Defined in the component class using `FormControl`, `FormGroup`, etc. |\n| **Data Flow**             | Two-way data binding (`[(ngModel)]`)                   | Explicit and synchronous; data flows from model to view and vice versa |\n| **Form Model**            | Created by Angular at runtime                          | Created and managed explicitly in the component         |\n| **Validation**            | Declarative in the template with directives            | Imperative in the component class with validator functions |\n| **Scalability**           | Suitable for simple forms                              | Better for complex and dynamic forms                   |\n| **Testing**               | Harder to test due to reliance on the DOM              | Easier to test as logic is in the component class       |\n| **Control**               | Less control over form structure and validation        | More control and flexibility                           |\n| **Example Usage**         | `<input [(ngModel)]=\"user.name\" name=\"name\">`          | `this.form = new FormGroup({ name: new FormControl('') })` |\n\n**Summary:**\n- **Template-driven forms** are easier to use for simple forms and rely heavily on Angular’s directives in the template.\n- **Reactive forms** provide more control, scalability, and testability, making them ideal for complex and dynamic forms. They are defined and managed in the component class.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794763Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "cf59829e-86d4-43a4-9b6d-29732f9574c9",
        "question": "How do you implement lazy loading in Angular?",
        "answer": "```markdown\n### How do you implement lazy loading in Angular?\n\nLazy loading in Angular is a technique that allows you to load feature modules only when they are needed, rather than loading all modules at the start. This improves the application's initial load time and overall performance.\n\n#### Steps to Implement Lazy Loading:\n\n1. **Create a Feature Module**\n   - Use Angular CLI to generate a new module with routing:\n     ```bash\n     ng generate module feature --route feature --module app.module\n     ```\n   - This command creates a `feature` module and sets up routing for lazy loading.\n\n2. **Configure the App Routing Module**\n   - In your `app-routing.module.ts`, set up the route to load the module lazily using the `loadChildren` property:\n     ```typescript\n     const routes: Routes = [\n       {\n         path: 'feature',\n         loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)\n       }\n     ];\n     ```\n\n3. **Set Up Routes in the Feature Module**\n   - In `feature-routing.module.ts`, define the child routes for your feature module:\n     ```typescript\n     const routes: Routes = [\n       { path: '', component: FeatureComponent }\n     ];\n     ```\n\n4. **Navigation**\n   - Use Angular's routerLink to navigate to the lazy-loaded module:\n     ```html\n     <a routerLink=\"/feature\">Go to Feature Module</a>\n     ```\n\n#### Key Points\n\n- **loadChildren** is used for lazy loading modules.\n- The feature module and its components are loaded only when the route is activated.\n- Lazy loading helps reduce the initial bundle size and improves performance.\n\n#### Example Directory Structure\n\n```\nsrc/\n  app/\n    feature/\n      feature.module.ts\n      feature-routing.module.ts\n      feature.component.ts\n    app-routing.module.ts\n    app.module.ts\n```\n\n#### References\n\n- [Angular Docs: Lazy Loading Feature Modules](https://angular.io/guide/lazy-loading-ngmodules)\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794770Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "f7e0b5a1-3545-457f-87c2-9d6d55097545",
        "question": "What is an Angular pipe and how do you create a custom pipe?",
        "answer": "```markdown An Angular pipe is a feature that allows you to transform data in your templates. Pipes are used with the pipe (|) character in template expressions to format data such as dates, currencies, or custom values before displaying them to the user.\n\n### Built-in Pipes Example\n\n```html\n<!-- Using the date pipe -->\n<p>{{ today | date:'longDate' }}</p>\n```\n\n### Creating a Custom Pipe\n\nTo create a custom pipe, you need to:\n\n1. **Create a Pipe Class**: Implement the PipeTransform interface.\n2. **Add the @Pipe Decorator**: Provide a name for your pipe.\n3. **Implement the transform Method**: Define the transformation logic.\n\n#### Example: Custom \"ExponentialStrength\" Pipe\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({ name: 'exponentialStrength' })\nexport class ExponentialStrengthPipe implements PipeTransform {\n  transform(value: number, exponent: number = 1): number {\n    return Math.pow(value, exponent);\n  }\n}\n```\n\n#### Usage in a Template\n\n```html\n<!-- Raises 2 to the power of 10 -->\n<p>{{ 2 | exponentialStrength:10 }}</p>\n```\n\n### Steps to Use a Custom Pipe\n\n1. **Declare the pipe** in your module's declarations array.\n2. **Use the pipe** in your templates with the syntax: `{{ value | pipeName:arg1:arg2 }}`.\n\n### Summary\n\n- **Angular pipes** transform data in templates.\n- **Custom pipes** are created by implementing `PipeTransform` and using the `@Pipe` decorator.\n- **Use custom pipes** by declaring them in a module and referencing them in templates.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794778Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "2f42379c-00e2-40f7-9e7f-fdfd6ff34782",
        "question": "Explain the concept of observables in Angular and how they are used with HTTP requests.",
        "answer": "```markdown ### Observables in Angular and Their Use with HTTP Requests\n\n**Observables** are a core part of Angular's reactive programming model, provided by the [RxJS](https://rxjs.dev/) library. They represent a stream of data that can be observed and acted upon asynchronously.\n\n#### Key Concepts of Observables\n\n- **Asynchronous Data Streams:** Observables can emit multiple values over time, making them ideal for handling asynchronous operations like HTTP requests, user input events, or real-time data feeds.\n- **Lazy Execution:** Observables are not executed until they are subscribed to, allowing for efficient resource usage.\n- **Operators:** RxJS provides powerful operators (e.g., `map`, `filter`, `catchError`) to transform, combine, and handle data streams.\n\n#### Using Observables with HTTP Requests\n\nAngular's `HttpClient` service returns observables when making HTTP requests. This allows you to handle responses asynchronously and take advantage of RxJS operators for further processing.\n\n**Example: Making an HTTP GET Request**\n\n```typescript\nimport { HttpClient } from '@angular/common/http';\nimport { Observable } from 'rxjs';\n\n@Injectable({ providedIn: 'root' })\nexport class DataService {\n  constructor(private http: HttpClient) {}\n\n  getData(): Observable<MyDataType[]> {\n    return this.http.get<MyDataType[]>('https://api.example.com/data');\n  }\n}\n```\n\n**Subscribing to the Observable**\n\n```typescript\n@Component({ /* ... */ })\nexport class MyComponent implements OnInit {\n  constructor(private dataService: DataService) {}\n\n  ngOnInit() {\n    this.dataService.getData().subscribe(\n      data => {\n        // Handle the data received from the API\n      },\n      error => {\n        // Handle error\n      }\n    );\n  }\n}\n```\n\n#### Benefits of Using Observables with HTTP\n\n- **Chaining and Transformation:** Easily chain multiple asynchronous operations and transform data using RxJS operators.\n- **Error Handling:** Use operators like `catchError` for robust error management.\n- **Unsubscription:** Prevent memory leaks by unsubscribing when the component is destroyed (e.g., using `takeUntil` or the `async` pipe).\n\n#### Summary\n\nObservables in Angular provide a powerful, flexible way to handle asynchronous data, especially with HTTP requests. They enable efficient data flow management, transformation, and error handling, making them essential for modern Angular applications.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794785Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "5afda61e-d586-45f1-9aa8-c9accc6c6397",
        "question": "How do you optimize the performance of an Angular application?",
        "answer": "```markdown\nTo optimize the performance of an Angular application, consider the following strategies:\n\n1. **Lazy Loading Modules**  \n   Load feature modules only when needed using Angular’s lazy loading with the router. This reduces the initial bundle size and speeds up the application startup.\n\n2. **Change Detection Strategy**  \n   Use `ChangeDetectionStrategy.OnPush` for components where possible. This tells Angular to check for changes only when input properties change, reducing unnecessary checks.\n\n3. **TrackBy in *ngFor**  \n   Use the `trackBy` function with `*ngFor` to help Angular track items efficiently and avoid re-rendering entire lists when only a few items change.\n\n4. **AOT Compilation**  \n   Use Ahead-of-Time (AOT) compilation to pre-compile your application during the build process, resulting in faster rendering and smaller bundle sizes.\n\n5. **Tree Shaking and Minification**  \n   Ensure unused code is removed during the build process by enabling tree shaking and minification, typically handled by Angular CLI in production builds.\n\n6. **Optimize Template Expressions**  \n   Avoid complex calculations or function calls in templates, as they can be executed frequently during change detection.\n\n7. **Use Pure Pipes**  \n   Prefer pure pipes over impure ones, as pure pipes are only recalculated when their inputs change.\n\n8. **On-Demand Loading of Assets**  \n   Load heavy assets (like images or third-party libraries) only when required, possibly using dynamic imports.\n\n9. **Service Worker and Caching**  \n   Use Angular Service Worker (with Angular PWA) to cache assets and API responses, improving load times and offline capabilities.\n\n10. **Efficient HTTP Requests**  \n    Optimize API calls by debouncing, throttling, or batching requests, and unsubscribe from observables to avoid memory leaks.\n\n11. **Use Web Workers**  \n    Offload heavy computations to Web Workers to keep the UI responsive.\n\n12. **Production Build Optimizations**  \n    Always build your application using `ng build --prod` to enable all Angular and Webpack optimizations.\n\nBy applying these techniques, you can significantly improve the performance and responsiveness of your Angular applications.\n```",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794829Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "f87885ec-4919-495a-b2d5-db7bec38bcfd",
        "question": "What is Ahead-of-Time (AOT) compilation in Angular?",
        "answer": "```markdown **Ahead-of-Time (AOT) Compilation in Angular**\n\nAhead-of-Time (AOT) compilation is a process in Angular where the application’s TypeScript and HTML code are compiled into efficient JavaScript code during the build phase, before the browser downloads and runs the code. This is in contrast to Just-in-Time (JIT) compilation, which compiles the code in the browser at runtime.\n\n### Key Points about AOT Compilation\n\n- **Faster Rendering:** Since the code is already compiled, the browser can render the application immediately, resulting in faster startup times.\n- **Smaller Bundle Size:** AOT removes Angular decorators and unused code, reducing the final bundle size.\n- **Early Error Detection:** Compilation errors are caught during the build process, not at runtime, making applications more robust.\n- **Enhanced Security:** Templates are pre-compiled, reducing the risk of injection attacks.\n\n### How AOT Works\n\n1. **Template Compilation:** Angular templates are converted into JavaScript code.\n2. **Metadata Processing:** Angular processes metadata to generate the necessary code for dependency injection and change detection.\n3. **Code Generation:** The compiler generates optimized JavaScript code that the browser can execute directly.\n\n### Usage\n\nAOT compilation can be enabled using the Angular CLI:\n\n```bash\nng build --aot\n```\n\nIn production builds, AOT is enabled by default.\n\n---\n\n**Summary:**  \nAOT compilation improves performance, security, and reliability by compiling Angular applications during the build process rather than at runtime.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794792Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "d0174863-a12c-4480-a44e-c1243bb88d26",
        "question": "How does Angular handle routing and navigation?",
        "answer": "```markdown Angular handles routing and navigation using its built-in **Angular Router** module. This module enables developers to define routes, navigate between different views or components, and manage browser history seamlessly in single-page applications (SPAs).\n\n### Key Concepts\n\n- **Routes Configuration:**  \n  Routes are defined in a configuration array, mapping URL paths to components.\n  ```typescript\n  const routes: Routes = [\n    { path: 'home', component: HomeComponent },\n    { path: 'about', component: AboutComponent },\n    { path: '', redirectTo: '/home', pathMatch: 'full' }\n  ];\n  ```\n\n- **RouterModule:**  \n  The `RouterModule.forRoot(routes)` method imports the routing configuration into the root module.\n\n- **Router Outlet:**  \n  The `<router-outlet></router-outlet>` directive in templates acts as a placeholder where the routed component is displayed.\n\n- **Navigation:**  \n  Angular provides the `Router` service for programmatic navigation:\n  ```typescript\n  constructor(private router: Router) {}\n  navigateToAbout() {\n    this.router.navigate(['/about']);\n  }\n  ```\n  Alternatively, the `<a [routerLink]=\"['/about']\">About</a>` directive is used in templates for declarative navigation.\n\n- **Route Parameters and Guards:**  \n  Angular supports dynamic route parameters (e.g., `/user/:id`) and route guards (e.g., `CanActivate`) for controlling access.\n\n- **Lazy Loading:**  \n  Modules can be loaded on demand using lazy loading, improving performance for large applications.\n\n### Summary Table\n\n| Feature             | Description                                      |\n|---------------------|--------------------------------------------------|\n| Route Definitions   | Map paths to components                          |\n| RouterModule        | Registers routes in the app                      |\n| Router Outlet       | Displays routed components                       |\n| Navigation          | Programmatic and declarative navigation          |\n| Route Guards        | Control access to routes                         |\n| Lazy Loading        | Loads modules only when needed                   |\n\n**In summary:** Angular’s router provides a robust and flexible way to manage navigation and view rendering in SPAs, supporting features like route parameters, guards, and lazy loading for scalable applications.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794799Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "03075ef5-b4d5-40d4-82fa-6ac02d9c88dd",
        "question": "What are route guards in Angular and how do you use them?",
        "answer": "```markdown\n### What are route guards in Angular and how do you use them?\n\n**Route guards** in Angular are interfaces that allow you to control navigation to and from components in your application. They help you protect routes from unauthorized access, prevent users from leaving a route with unsaved changes, or even control when a module should be loaded.\n\nAngular provides several types of route guards:\n\n- `CanActivate`: Checks if a route can be activated.\n- `CanActivateChild`: Checks if child routes can be activated.\n- `CanDeactivate`: Checks if a user can leave a route.\n- `CanLoad`: Checks if a module can be loaded lazily.\n- `Resolve`: Pre-fetches data before activating a route.\n\n#### How to Use Route Guards\n\n1. **Implement the Guard Interface**\n\n   Create a service and implement the desired guard interface. For example, to create an authentication guard:\n\n   ```typescript\n   import { Injectable } from '@angular/core';\n   import { CanActivate, Router } from '@angular/router';\n\n   @Injectable({\n     providedIn: 'root'\n   })\n   export class AuthGuard implements CanActivate {\n     constructor(private router: Router) {}\n\n     canActivate(): boolean {\n       const isLoggedIn = /* logic to check if user is logged in */;\n       if (!isLoggedIn) {\n         this.router.navigate(['/login']);\n         return false;\n       }\n       return true;\n     }\n   }\n   ```\n\n2. **Register the Guard in Routing Module**\n\n   Apply the guard to routes in your `AppRoutingModule`:\n\n   ```typescript\n   const routes: Routes = [\n     {\n       path: 'dashboard',\n       component: DashboardComponent,\n       canActivate: [AuthGuard]\n     }\n   ];\n   ```\n\n3. **Other Guards**\n\n   - **CanDeactivate** is used for confirming navigation away from a component (e.g., unsaved form changes).\n   - **CanLoad** is used for lazy-loaded modules.\n\n   Example for `CanDeactivate`:\n\n   ```typescript\n   export interface CanComponentDeactivate {\n     canDeactivate: () => boolean | Observable<boolean>;\n   }\n\n   @Injectable({ providedIn: 'root' })\n   export class UnsavedChangesGuard implements CanDeactivate<CanComponentDeactivate> {\n     canDeactivate(component: CanComponentDeactivate) {\n       return component.canDeactivate ? component.canDeactivate() : true;\n     }\n   }\n   ```\n\n   And in your route:\n\n   ```typescript\n   {\n     path: 'edit',\n     component: EditComponent,\n     canDeactivate: [UnsavedChangesGuard]\n   }\n   ```\n\n#### Summary\n\nRoute guards are essential for securing routes, managing navigation flow, and improving user experience in Angular applications. They are implemented as services that return a boolean or an observable/promise resolving to a boolean, and are configured in the routing module.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794807Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "5efa8a2d-667e-40ae-bec7-c663dbc9df04",
        "question": "Explain the difference between @Input and @Output decorators.",
        "answer": "```markdown **@Input vs @Output Decorators in Angular**\n\nIn Angular, `@Input` and `@Output` are decorators used to facilitate communication between parent and child components.\n\n---\n\n### `@Input` Decorator\n\n- **Purpose:** Allows a parent component to bind values to a child component's property.\n- **Usage:** Used to pass data **from parent to child**.\n- **How it works:** The child component declares a property with the `@Input` decorator. The parent component binds to this property using property binding syntax (`[property]=\"value\"`).\n\n**Example:**\n```typescript\n// child.component.ts\n@Input() childProperty: string;\n```\n```html\n<!-- parent.component.html -->\n<app-child [childProperty]=\"parentValue\"></app-child>\n```\n\n---\n\n### `@Output` Decorator\n\n- **Purpose:** Allows a child component to emit events to the parent component.\n- **Usage:** Used to send data **from child to parent**.\n- **How it works:** The child component declares an `EventEmitter` property with the `@Output` decorator. The parent listens for this event using event binding syntax (`(event)=\"handler($event)\"`).\n\n**Example:**\n```typescript\n// child.component.ts\n@Output() notify: EventEmitter<string> = new EventEmitter();\n\nsomeMethod() {\n  this.notify.emit('Message from child');\n}\n```\n```html\n<!-- parent.component.html -->\n<app-child (notify)=\"onNotify($event)\"></app-child>\n```\n\n---\n\n### **Summary Table**\n\n| Decorator   | Direction         | Use Case                    |\n|-------------|-------------------|-----------------------------|\n| `@Input`    | Parent → Child    | Pass data to child          |\n| `@Output`   | Child → Parent    | Emit events to parent       |\n\n---\n\n**In short:**  \n- Use `@Input` to receive data in a child component from its parent.  \n- Use `@Output` to send events or data from a child component to its parent.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794814Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "26fbcd76-3052-4cd3-b4a8-7604ee9737c7",
        "question": "What is the purpose of the async pipe in Angular?",
        "answer": "```markdown The **async pipe** in Angular is used to automatically subscribe to an Observable or Promise and render its latest value in the template. It also handles unsubscribing from the observable when the component is destroyed, helping to prevent memory leaks.\n\n**Key purposes of the async pipe:**\n\n- **Automatic Subscription:** It subscribes to the observable or promise and updates the view whenever a new value is emitted.\n- **Automatic Unsubscription:** It unsubscribes when the component is destroyed, reducing the risk of memory leaks.\n- **Simplifies Code:** Eliminates the need for manual subscription management in the component class.\n\n**Example:**\n\n```html\n<!-- myData$ is an Observable in the component -->\n<div *ngIf=\"myData$ | async as data\">\n  {{ data }}\n</div>\n```\n\n**Summary:**  \nThe async pipe simplifies working with asynchronous data streams in Angular templates by managing subscriptions and unsubscriptions automatically.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794822Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "e25b1062-526d-429a-8077-51dfd698d07f",
        "question": "What is Angular Universal and why would you use it?",
        "answer": "```markdown **Angular Universal** is a technology that enables **server-side rendering (SSR)** for Angular applications. Normally, Angular apps are rendered entirely in the browser (client-side), but with Angular Universal, the initial rendering of the application happens on the server. The server generates static HTML for each route, which is then sent to the client.\n\n### Why Use Angular Universal?\n\n1. **Improved Performance & Faster First Paint**\n   - SSR provides a fully rendered page from the server, so users see content faster, especially on slow networks or devices.\n\n2. **Better SEO (Search Engine Optimization)**\n   - Search engines can easily crawl and index the pre-rendered HTML content, improving discoverability and ranking, which is crucial for public-facing sites.\n\n3. **Social Media Sharing**\n   - Social media platforms can extract meta tags and page content from the server-rendered HTML, resulting in better link previews.\n\n4. **Progressive Enhancement**\n   - Users get a usable page even before the JavaScript bundles are fully loaded and bootstrapped on the client.\n\n### How Does It Work?\n\n- The server (typically Node.js) runs Angular and renders the requested route as HTML.\n- The rendered HTML is sent to the browser, which displays the content immediately.\n- Angular then bootstraps on the client and takes over, making the app fully interactive.\n\n### Use Cases\n\n- Public websites, blogs, e-commerce sites, and landing pages where SEO and fast initial load are critical.\n- Applications targeting users with slow internet connections or low-powered devices.\n\n---\n\n**In summary:**  \nAngular Universal enables server-side rendering for Angular apps, providing better SEO, faster initial load times, and improved user experience, especially for content-heavy or public-facing applications.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794836Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "55af182c-eb2a-4419-9cc0-b9caa71ce090",
        "question": "Explain the difference between ViewChild and ContentChild.",
        "answer": "```markdown **ViewChild vs ContentChild in Angular**\n\nIn Angular, both `@ViewChild` and `@ContentChild` are decorators used to access child components, directives, or DOM elements, but they serve different purposes based on the component's template structure.\n\n---\n\n### `@ViewChild`\n\n- **Purpose:** Accesses a child component, directive, or DOM element **that is declared within the component's own template**.\n- **Use Case:** When you want to interact with elements/components that are part of the view (i.e., directly inside the template of the component).\n- **Example:**\n\n  ```typescript\n  @ViewChild('myInput') inputElement: ElementRef;\n  ```\n\n  ```html\n  <input #myInput>\n  ```\n\n---\n\n### `@ContentChild`\n\n- **Purpose:** Accesses a child component, directive, or DOM element **that is projected into the component using ng-content** (i.e., content projected from a parent component).\n- **Use Case:** When you want to interact with elements/components that are passed into the component via content projection.\n- **Example:**\n\n  ```typescript\n  @ContentChild('projectedContent') content: ElementRef;\n  ```\n\n  ```html\n  <!-- Parent component template -->\n  <my-component>\n    <span #projectedContent>Some content</span>\n  </my-component>\n  ```\n\n---\n\n### Key Differences\n\n| Aspect             | ViewChild                                      | ContentChild                                   |\n|--------------------|------------------------------------------------|------------------------------------------------|\n| **Scope**          | Own template                                   | Projected content (ng-content)                 |\n| **When Queried**   | After view initialization (`ngAfterViewInit`)  | After content initialization (`ngAfterContentInit`) |\n| **Typical Use**    | Accessing template refs, child components      | Accessing projected content                    |\n\n---\n\n### Summary\n\n- Use **`@ViewChild`** for elements/components in the component's own template.\n- Use **`@ContentChild`** for elements/components projected into the component via `<ng-content>`.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794843Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "dba5e470-4fb0-4a97-b95a-ecd35dd7f7d0",
        "question": "What are Angular zones and how do they relate to change detection?",
        "answer": "```markdown ### Angular Zones and Their Relationship to Change Detection\n\n**Angular zones** are a core concept that help Angular automatically detect changes in the application state and update the view accordingly. They are implemented using the [zone.js](https://github.com/angular/zone.js/) library, which patches asynchronous APIs (like setTimeout, Promises, DOM events, etc.) to keep track of when asynchronous operations start and finish.\n\n#### What is a Zone?\n\nA **zone** is an execution context that persists across asynchronous tasks. In Angular, the main zone is called **NgZone**. It allows Angular to know when to run change detection by monitoring all asynchronous activities that might affect the application state.\n\n#### How Zones Relate to Change Detection\n\n- **Automatic Change Detection:**  \n  When you perform an asynchronous operation (e.g., HTTP request, timer, user event), zone.js intercepts it. Once the operation completes, Angular's NgZone triggers change detection to update the view if necessary.\n\n- **NgZone Service:**  \n  Angular provides the `NgZone` service, which you can inject into your components or services. It exposes methods like `run()` and `runOutsideAngular()` to control whether a block of code should trigger change detection.\n\n- **Example:**\n  ```typescript\n  constructor(private ngZone: NgZone) {}\n\n  someAsyncOperation() {\n    this.ngZone.runOutsideAngular(() => {\n      setTimeout(() => {\n        // This code will NOT trigger change detection\n        this.ngZone.run(() => {\n          // This code WILL trigger change detection\n        });\n      }, 1000);\n    });\n  }\n  ```\n\n#### Why Use Zones?\n\n- **Simplicity:**  \n  Developers don't need to manually call change detection after every async operation.\n- **Performance Optimization:**  \n  By using `runOutsideAngular()`, you can prevent unnecessary change detection cycles for operations that don't affect the UI, improving performance.\n\n#### Summary Table\n\n| Concept         | Purpose                                   | Example Use Case                  |\n|-----------------|-------------------------------------------|-----------------------------------|\n| zone.js         | Tracks async operations                   | setTimeout, Promises, HTTP calls  |\n| NgZone.run()    | Executes code inside Angular zone         | Triggers change detection         |\n| NgZone.runOutsideAngular() | Executes code outside Angular zone | Avoids triggering change detection |\n\n---\n\n**In summary:**  \nAngular zones, powered by zone.js, are crucial for Angular's automatic change detection. They allow Angular to know when to check for changes in the application state after asynchronous operations, ensuring the UI stays in sync with the data model. Developers can leverage NgZone to fine-tune when change detection should or should not occur, optimizing application performance.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794851Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "ad8fb9ee-4186-4e19-a656-4aa8f0f7ae70",
        "question": "How do you implement server-side rendering in Angular?",
        "answer": "```markdown\n**Implementing Server-Side Rendering (SSR) in Angular**\n\nServer-side rendering (SSR) in Angular is achieved using Angular Universal. SSR allows your Angular application to be rendered on the server, generating static HTML that is sent to the client, which improves performance, SEO, and the perceived load time.\n\n**Steps to Implement SSR in Angular:**\n\n1. **Add Angular Universal to Your Project**\n   Use the Angular CLI to add Universal support:\n   ```bash\n   ng add @nguniversal/express-engine\n   ```\n   This command:\n   - Installs necessary dependencies.\n   - Creates a server-side app module (`app.server.module.ts`).\n   - Adds server entry point (`main.server.ts`).\n   - Sets up an Express server (`server.ts`).\n\n2. **Update Angular Configuration**\n   The CLI updates your `angular.json` to include a server build target. You can customize the build options as needed.\n\n3. **Build the Application**\n   Build both the browser and server bundles:\n   ```bash\n   npm run build:ssr\n   ```\n   This creates output in the `dist/` folder for both browser and server.\n\n4. **Serve the Application**\n   Start the Express server to serve the SSR app:\n   ```bash\n   npm run serve:ssr\n   ```\n   By default, the server runs on `http://localhost:4000`.\n\n5. **Handle Platform-Specific Code**\n   Since SSR runs on Node.js, avoid using browser-specific APIs (like `window`, `document`) directly. Use Angular's `PLATFORM_ID` and `isPlatformBrowser`/`isPlatformServer` utilities to conditionally execute code.\n\n   ```typescript\n   import { isPlatformBrowser } from '@angular/common';\n   import { Inject, PLATFORM_ID } from '@angular/core';\n\n   constructor(@Inject(PLATFORM_ID) private platformId: Object) {\n     if (isPlatformBrowser(this.platformId)) {\n       // Browser-only code\n     }\n   }\n   ```\n\n6. **Transfer State (Optional)**\n   Use Angular's `TransferState` API to transfer data from the server to the client, avoiding duplicate HTTP requests.\n\n7. **Deploy**\n   Deploy the server bundle (`server.js`) and the browser assets to your Node.js server or a platform that supports Node.js.\n\n**Summary Table**\n\n| Step                        | Command / File                | Description                              |\n|-----------------------------|-------------------------------|------------------------------------------|\n| Add Universal               | `ng add @nguniversal/express-engine` | Sets up SSR scaffolding                  |\n| Build SSR                   | `npm run build:ssr`           | Builds browser and server bundles        |\n| Serve SSR                   | `npm run serve:ssr`           | Starts Express server for SSR            |\n| Platform checks             | `isPlatformBrowser`           | Ensures compatibility with SSR           |\n| Transfer state (optional)   | `TransferState` API           | Shares data between server and client    |\n\n**References:**\n- [Angular Universal Official Docs](https://angular.io/guide/universal)\n- [Angular CLI Universal Schematic](https://angular.io/guide/universal#universal-schematic)\n\n**Best Practices:**\n- Avoid direct DOM manipulation in components.\n- Use Angular’s Dependency Injection to abstract platform-specific code.\n- Optimize data fetching to minimize server response time.\n\nBy following these steps, you can enable server-side rendering in your Angular application, improving SEO and initial load performance.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794858Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "9570fbaf-cd67-4fdb-992a-0877e1c4f777",
        "question": "What is the Renderer2 service and when would you use it?",
        "answer": "```markdown **Answer:**\n\nIn Angular, the `Renderer2` service is an abstraction provided to safely manipulate the DOM elements, attributes, classes, and styles in a platform-independent way. Direct DOM access (e.g., using `document` or `element.nativeElement`) is discouraged in Angular because it can break server-side rendering (Angular Universal), web workers, and other rendering environments.\n\n### Key Points about `Renderer2`:\n\n- **Abstraction Layer:** It abstracts DOM manipulation, so your code remains compatible with different platforms (browser, server, web worker).\n- **Security:** Helps prevent security vulnerabilities like XSS by sanitizing values where appropriate.\n- **Testability:** Makes components easier to test by avoiding direct DOM access.\n\n### Common Use Cases:\n\n- Dynamically adding or removing elements.\n- Setting or removing attributes, classes, or styles.\n- Listening to events on elements.\n- Manipulating the DOM in a way that is compatible with Angular’s rendering engine.\n\n### Example Usage\n\n```typescript\nimport { Component, ElementRef, Renderer2 } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<button (click)=\"changeColor()\">Change Color</button>`\n})\nexport class ExampleComponent {\n  constructor(private el: ElementRef, private renderer: Renderer2) {}\n\n  changeColor() {\n    this.renderer.setStyle(this.el.nativeElement, 'color', 'red');\n  }\n}\n```\n\n### When to Use `Renderer2`:\n\n- When you need to manipulate the DOM directly in your components or directives.\n- When you want your code to be compatible with Angular Universal (server-side rendering).\n- When you need to ensure security and platform agnosticism in DOM operations.\n\n**In summary:**  \nUse `Renderer2` whenever you need to interact with the DOM in Angular, instead of direct DOM access, to ensure your application is secure, portable, and compatible with all Angular rendering environments.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794866Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "d7d1a527-7ea4-4b11-8b5b-b8aa44d09b36",
        "question": "Explain the concept of dynamic component loading in Angular.",
        "answer": "```markdown ### Dynamic Component Loading in Angular\n\nDynamic component loading in Angular refers to the ability to instantiate and insert components into the application view at runtime, rather than declaring them statically in a template. This is particularly useful for scenarios such as:\n\n- Rendering components based on user actions or configuration\n- Building modal dialogs, notifications, or dynamic forms\n- Implementing plugin architectures\n\n#### Key Concepts\n\n1. **ComponentFactoryResolver (Angular < v13)**  \n   Previously, Angular used `ComponentFactoryResolver` to create component factories and instantiate components dynamically.\n\n2. **ViewContainerRef**  \n   This service provides methods to manipulate the view, such as `createComponent()` to insert a component dynamically.\n\n3. **Dynamic Component Creation (Angular v13+)**  \n   From Angular v13 onwards, the process is simplified using the `ViewContainerRef.createComponent()` method, which no longer requires a factory resolver.\n\n#### Basic Steps\n\n1. **Prepare the Host**  \n   Define a container in your template using `ng-template` and access it via `@ViewChild` with `ViewContainerRef`.\n\n   ```typescript\n   @ViewChild('container', { read: ViewContainerRef, static: true })\n   container!: ViewContainerRef;\n   ```\n\n2. **Load the Component Dynamically**  \n   Use the `createComponent` method to instantiate and insert the component.\n\n   ```typescript\n   import { MyDynamicComponent } from './my-dynamic.component';\n\n   this.container.clear(); // Optional: clear previous components\n   const componentRef = this.container.createComponent(MyDynamicComponent);\n   ```\n\n3. **Pass Data to the Component**  \n   You can set input properties on the created component instance.\n\n   ```typescript\n   componentRef.instance.someInput = value;\n   ```\n\n#### Example\n\n```html\n<!-- app.component.html -->\n<ng-template #container></ng-template>\n```\n\n```typescript\n// app.component.ts\nimport { Component, ViewChild, ViewContainerRef } from '@angular/core';\nimport { MyDynamicComponent } from './my-dynamic.component';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html'\n})\nexport class AppComponent {\n  @ViewChild('container', { read: ViewContainerRef, static: true })\n  container!: ViewContainerRef;\n\n  loadComponent() {\n    this.container.clear();\n    const componentRef = this.container.createComponent(MyDynamicComponent);\n    componentRef.instance.someInput = 'Hello, Dynamic!';\n  }\n}\n```\n\n#### Advantages\n\n- **Flexibility:** Components can be loaded based on runtime conditions.\n- **Performance:** Only necessary components are loaded, reducing initial bundle size.\n- **Extensibility:** Enables plugin-like architectures.\n\n#### Considerations\n\n- Dynamically loaded components must be included in the module’s `entryComponents` array (Angular < v9).\n- Proper cleanup is necessary to avoid memory leaks (e.g., destroying component references).\n\n---\n\n**In summary:**  \nDynamic component loading in Angular allows you to create and insert components at runtime, providing flexibility for advanced UI scenarios and modular application architectures.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794874Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "fdb25bb1-d54d-4ca5-be9a-a42d860c13e6",
        "question": "How can you create a custom structural directive?",
        "answer": "```markdown ### How to Create a Custom Structural Directive in Angular\n\nA **structural directive** in Angular modifies the structure of the DOM by adding, removing, or manipulating elements. Examples include `*ngIf` and `*ngFor`. You can create your own custom structural directive by implementing the `Directive` decorator and using the `TemplateRef` and `ViewContainerRef` services.\n\n#### Steps to Create a Custom Structural Directive\n\n1. **Import Required Modules**\n   ```typescript\n   import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';\n   ```\n\n2. **Create the Directive Class**\n   - Use the `@Directive` decorator.\n   - Inject `TemplateRef` and `ViewContainerRef` via the constructor.\n   - Use an `@Input()` property to accept directive input.\n\n   ```typescript\n   @Directive({\n     selector: '[appCustomIf]'\n   })\n   export class CustomIfDirective {\n     constructor(\n       private templateRef: TemplateRef<any>,\n       private viewContainer: ViewContainerRef\n     ) {}\n\n     @Input() set appCustomIf(condition: boolean) {\n       if (condition) {\n         this.viewContainer.createEmbeddedView(this.templateRef);\n       } else {\n         this.viewContainer.clear();\n       }\n     }\n   }\n   ```\n\n3. **Use the Directive in a Template**\n   - Add the directive to your module’s `declarations`.\n   - Use it with the `*` syntax in your template:\n\n   ```html\n   <div *appCustomIf=\"isVisible\">\n     This will only be visible if 'isVisible' is true.\n   </div>\n   ```\n\n#### Explanation\n\n- **TemplateRef**: Represents the template (the element and its children) to be rendered.\n- **ViewContainerRef**: Represents a container where one or more views can be attached.\n- **@Input()**: Allows passing a value to the directive, which can be used to control its behavior.\n\n#### Summary Table\n\n| Step                | Description                                                  |\n|---------------------|-------------------------------------------------------------|\n| Import modules      | Import `Directive`, `TemplateRef`, `ViewContainerRef`, etc. |\n| Decorate class      | Use `@Directive` with a selector.                           |\n| Inject dependencies | Use constructor injection for `TemplateRef` and `ViewContainerRef`. |\n| Handle input        | Use `@Input()` to accept directive input.                   |\n| Manipulate DOM      | Use `createEmbeddedView` and `clear` to control rendering.  |\n\n---\n\n**In summary:**  \nTo create a custom structural directive, use the `@Directive` decorator, inject `TemplateRef` and `ViewContainerRef`, and manipulate the DOM based on input values. This allows you to define custom logic for adding or removing elements from the DOM.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794881Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "27675c58-84bd-4112-8a8d-44446bf9cf36",
        "question": "What are Angular schematics and how can you use them?",
        "answer": "```markdown\n### What are Angular schematics and how can you use them?\n\n**Angular schematics** are powerful code generation tools used to automate tasks and enforce best practices within Angular projects. They are part of the [Angular DevKit](https://angular.io/guide/schematics) and are commonly used by the Angular CLI to scaffold components, services, modules, and even entire applications.\n\n#### Key Concepts\n\n- **Schematics**: Templates and rules that transform a project by creating, modifying, or deleting files.\n- **Collection**: A set of related schematics (e.g., `@schematics/angular`).\n- **Rule**: A function that takes a virtual file system (Tree) and applies transformations.\n\n#### Common Uses\n\n- Generating Angular artifacts (components, services, modules, etc.).\n- Automating repetitive coding tasks.\n- Enforcing coding standards and project structure.\n- Customizing or extending Angular CLI commands.\n\n#### How to Use Schematics\n\n1. **Using Built-in Schematics via Angular CLI:**\n\n   ```bash\n   ng generate component my-component\n   ng generate service my-service\n   ng generate module my-module\n   ```\n\n   These commands invoke schematics from the default collection (`@schematics/angular`).\n\n2. **Creating Custom Schematics:**\n\n   - Install the schematics CLI globally:\n     ```bash\n     npm install -g @angular-devkit/schematics-cli\n     ```\n   - Create a new schematics project:\n     ```bash\n     schematics blank --name=my-schematics\n     ```\n   - Implement your schematic logic in the generated files.\n   - Test your schematic locally:\n     ```bash\n     schematics .:my-schematic\n     ```\n   - Publish your schematic as an npm package for reuse.\n\n3. **Running External Schematics:**\n\n   You can use schematics from third-party libraries:\n   ```bash\n   ng add @angular/material\n   ng generate @ngx-translate/core:translate-pipe\n   ```\n\n#### Example: Custom Schematic to Generate a README\n\nSuppose you want a schematic that generates a `README.md` file:\n\n- Define a rule in `src/my-schematic/index.ts`:\n  ```typescript\n  import { Rule, SchematicContext, Tree } from '@angular-devkit/schematics';\n\n  export function mySchematic(_options: any): Rule {\n    return (tree: Tree, _context: SchematicContext) => {\n      tree.create('README.md', '# My Project\\n\\nGenerated by a schematic!');\n      return tree;\n    };\n  }\n  ```\n\n- Register and run your schematic.\n\n#### Summary\n\nAngular schematics are essential for automating code generation and project transformations. They can be used directly via the Angular CLI or extended with custom logic to fit specific project needs, improving productivity and consistency across Angular applications.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794889Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "75f1415b-0000-45e4-882b-9bdc49bb48eb",
        "question": "Describe the process of creating a library in Angular.",
        "answer": "```markdown ### Creating a Library in Angular\n\nCreating a library in Angular allows you to package reusable components, services, and modules for use across multiple Angular applications or for distribution via npm. Here’s a step-by-step process:\n\n#### 1. **Set Up an Angular Workspace**\nIf you don’t already have an Angular workspace, create one:\n```bash\nng new my-workspace --create-application=false\ncd my-workspace\n```\n\n#### 2. **Generate a Library**\nUse the Angular CLI to generate a new library:\n```bash\nng generate library my-lib\n```\nThis creates a `projects/my-lib` folder with the library’s source code and configuration.\n\n#### 3. **Develop the Library**\n- Add components, services, pipes, etc., inside `projects/my-lib/src/lib/`.\n- Export public APIs in `projects/my-lib/src/public-api.ts`.\n- Update `projects/my-lib/ng-package.json` if you need custom build options.\n\n#### 4. **Build the Library**\nBuild the library using:\n```bash\nng build my-lib\n```\nThe output will be in the `dist/my-lib` folder.\n\n#### 5. **Use the Library Locally**\nTo test the library in an application within the same workspace:\n- Add the library as a dependency in the app’s `package.json` or use Angular CLI’s path mapping.\n- Import the library module in your application’s module.\n\n#### 6. **Package and Publish**\n- Ensure the `package.json` in `dist/my-lib` is configured correctly (name, version, peer dependencies).\n- Publish to npm (optional):\n  ```bash\n  cd dist/my-lib\n  npm publish\n  ```\n\n#### 7. **Consume the Library**\n- Install the library in any Angular project:\n  ```bash\n  npm install my-lib\n  ```\n- Import the library’s module into your application’s module.\n\n---\n\n**Key Points:**\n- Libraries are generated and managed within Angular workspaces.\n- Use `ng-packagr` (handled by Angular CLI) for packaging.\n- Libraries should not contain application-specific code.\n- Use `public-api.ts` to control what is exported.\n\nThis process enables modular, maintainable, and reusable code across Angular projects.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794896Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "16e18439-8b6d-40d2-8562-34f34219fbf3",
        "question": "How do you use the HttpInterceptor in Angular?",
        "answer": "```markdown\n### How do you use the `HttpInterceptor` in Angular?\n\nIn Angular, an `HttpInterceptor` is a powerful mechanism that allows you to intercept and modify HTTP requests and responses globally before they are handled by the application's code. Common use cases include adding authentication tokens, logging, error handling, and modifying request/response data.\n\n#### Steps to Use `HttpInterceptor`:\n\n1. **Create an Interceptor Class**\n\n   Implement the `HttpInterceptor` interface and override the `intercept` method:\n\n   ```typescript\n   import { Injectable } from '@angular/core';\n   import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n   import { Observable } from 'rxjs';\n\n   @Injectable()\n   export class AuthInterceptor implements HttpInterceptor {\n     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n       // Clone the request to add the new header\n       const authReq = req.clone({\n         setHeaders: {\n           Authorization: `Bearer YOUR_AUTH_TOKEN`\n         }\n       });\n       // Pass on the cloned request instead of the original request\n       return next.handle(authReq);\n     }\n   }\n   ```\n\n2. **Provide the Interceptor in Your App Module**\n\n   Register your interceptor in the `providers` array using the `HTTP_INTERCEPTORS` injection token:\n\n   ```typescript\n   import { HTTP_INTERCEPTORS } from '@angular/common/http';\n\n   @NgModule({\n     // ...\n     providers: [\n       {\n         provide: HTTP_INTERCEPTORS,\n         useClass: AuthInterceptor,\n         multi: true\n       }\n     ]\n   })\n   export class AppModule { }\n   ```\n\n   The `multi: true` option allows you to register multiple interceptors.\n\n3. **Chaining Multiple Interceptors**\n\n   If you have more than one interceptor, Angular will execute them in the order they are provided in the `providers` array.\n\n#### Key Points\n\n- The `intercept` method receives the outgoing `HttpRequest` and a `HttpHandler` to continue the chain.\n- Always use `req.clone()` to modify the request, as `HttpRequest` is immutable.\n- You can also intercept responses by using RxJS operators (like `map`, `catchError`) inside the `intercept` method.\n\n#### Example: Handling Errors\n\n```typescript\nimport { catchError } from 'rxjs/operators';\nimport { throwError } from 'rxjs';\n\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n  return next.handle(req).pipe(\n    catchError(error => {\n      // Handle the error\n      console.error('Error intercepted:', error);\n      return throwError(() => error);\n    })\n  );\n}\n```\n\n#### Summary\n\n`HttpInterceptor` is a central place to handle cross-cutting concerns for HTTP requests and responses in Angular, such as authentication, logging, and error handling, making your code cleaner and more maintainable.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794933Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "3c30beb8-7bda-4a5c-85e8-e819058f66fa",
        "question": "How do you handle memory leaks in Angular applications?",
        "answer": "```markdown ### Handling Memory Leaks in Angular Applications\n\nMemory leaks in Angular applications can degrade performance and lead to crashes, especially in long-running or complex apps. Here are advanced strategies to identify and prevent memory leaks:\n\n---\n\n#### 1. **Unsubscribe from Observables**\n\n- **Why:** Subscriptions to Observables (e.g., from services, HTTP calls, or event streams) can persist after a component is destroyed, preventing garbage collection.\n- **How:**\n  - **Manual Unsubscription:**  \n    ```typescript\n    private subscription: Subscription;\n\n    ngOnInit() {\n      this.subscription = this.myService.getData().subscribe(...);\n    }\n\n    ngOnDestroy() {\n      this.subscription.unsubscribe();\n    }\n    ```\n  - **Using `takeUntil`:**  \n    ```typescript\n    private destroy$ = new Subject<void>();\n\n    ngOnInit() {\n      this.myService.getData()\n        .pipe(takeUntil(this.destroy$))\n        .subscribe(...);\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    ```\n  - **Async Pipe:**  \n    Use the `async` pipe in templates to auto-unsubscribe.\n\n---\n\n#### 2. **Detach Event Listeners**\n\n- **Why:** Direct DOM event listeners (added via `addEventListener`) or third-party libraries can retain references to destroyed components.\n- **How:**  \n  Always remove event listeners in `ngOnDestroy`.\n  ```typescript\n  ngOnInit() {\n    window.addEventListener('resize', this.onResize);\n  }\n\n  ngOnDestroy() {\n    window.removeEventListener('resize', this.onResize);\n  }\n  ```\n\n---\n\n#### 3. **Avoid Global State Leaks**\n\n- **Why:** Storing component references in global variables or services can prevent garbage collection.\n- **How:**  \n  Ensure services do not retain references to destroyed components.\n\n---\n\n#### 4. **Use Angular Profiling Tools**\n\n- **How:**  \n  - Use Chrome DevTools’ Memory tab to take heap snapshots and identify detached DOM nodes.\n  - Use Angular DevTools to profile component lifecycles and detect leaks.\n\n---\n\n#### 5. **Clean Up Timers and Intervals**\n\n- **Why:** Active `setTimeout` or `setInterval` can keep components alive.\n- **How:**  \n  Clear all timers in `ngOnDestroy`.\n  ```typescript\n  ngOnDestroy() {\n    clearInterval(this.intervalId);\n  }\n  ```\n\n---\n\n#### 6. **Leverage `trackBy` in `*ngFor`**\n\n- **Why:** Without `trackBy`, Angular may create unnecessary DOM elements, leading to memory bloat.\n- **How:**  \n  ```html\n  <div *ngFor=\"let item of items; trackBy: trackById\"></div>\n  ```\n\n---\n\n#### 7. **Audit Third-Party Libraries**\n\n- **How:**  \n  Ensure libraries clean up after themselves, especially those manipulating the DOM or managing subscriptions.\n\n---\n\n### **Summary Table**\n\n| Source of Leak           | Prevention Method                      |\n|------------------------- |----------------------------------------|\n| Observables              | Unsubscribe, `takeUntil`, async pipe   |\n| Event Listeners          | Remove in `ngOnDestroy`                |\n| Timers/Intervals         | Clear in `ngOnDestroy`                 |\n| Global References        | Avoid storing component references     |\n| DOM Manipulation         | Use Angular APIs, clean up manually    |\n| Third-party Libraries    | Audit and clean up                     |\n\n---\n\n**Best Practice:**  \nAlways implement the `OnDestroy` lifecycle hook for components and services that manage subscriptions, listeners, or resources, and perform necessary cleanup to prevent memory leaks.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794904Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "018763ac-e628-4a9d-b0c6-86a18b89c4db",
        "question": "What is the difference between ChangeDetectionStrategy.Default and ChangeDetectionStrategy.OnPush?",
        "answer": "```markdown\n**ChangeDetectionStrategy.Default vs ChangeDetectionStrategy.OnPush in Angular**\n\nAngular uses change detection to update the view whenever the application state changes. The `ChangeDetectionStrategy` determines how Angular checks for changes in a component and its subtree.\n\n### 1. `ChangeDetectionStrategy.Default`\n- **Behavior:** Angular checks the component and all its children every time any event occurs (e.g., user input, HTTP response, timer, etc.).\n- **How it works:** It uses the \"check always\" strategy. Whenever change detection runs anywhere in the app, all components using `Default` are checked for changes.\n- **Use case:** Suitable for most scenarios, especially when the component's data can change from many sources.\n\n### 2. `ChangeDetectionStrategy.OnPush`\n- **Behavior:** Angular only checks the component and its subtree when:\n  - The component's input property reference changes.\n  - An event is fired inside the component.\n  - You manually trigger change detection (e.g., via `ChangeDetectorRef`).\n- **How it works:** It uses the \"check on push\" strategy. Angular skips checking the component unless it detects a new reference for its inputs or an event inside the component.\n- **Use case:** Ideal for performance optimization, especially when using immutable data structures or when you want fine-grained control over change detection.\n\n### **Summary Table**\n\n| Strategy         | When is component checked?                                        | Performance Impact       |\n|------------------|-------------------------------------------------------------------|-------------------------|\n| Default          | On any change detection cycle (global events, async, etc.)        | Less optimized          |\n| OnPush           | Only on input reference change, internal events, or manually      | More optimized          |\n\n### **Example Usage**\n\n```typescript\nimport { Component, ChangeDetectionStrategy } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `...`,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ExampleComponent { }\n```\n\n### **Key Takeaway**\n- Use `Default` for simplicity and when data changes from multiple sources.\n- Use `OnPush` for better performance when you can control how and when data changes (e.g., with immutable objects).\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794911Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "6ff8ab01-3be6-4e0c-9a07-307840b62ba3",
        "question": "How does Angular handle internationalization (i18n)?",
        "answer": "```markdown ### How does Angular handle internationalization (i18n)?\n\nAngular provides robust support for internationalization (i18n), enabling applications to be easily translated and adapted for different languages and regions. Here’s how Angular handles i18n:\n\n#### 1. **Built-in i18n Module**\nAngular offers a built-in i18n module that allows developers to mark text in templates for translation using the `i18n` attribute or pipe.\n\n```html\n<h1 i18n=\"site header|An introduction header\">Welcome to our site!</h1>\n```\n\n#### 2. **Extraction of Translatable Content**\nAngular CLI provides the `ng extract-i18n` command to extract marked text into an industry-standard XLIFF or XMB translation file.\n\n```bash\nng extract-i18n --output-path src/locale\n```\n\nThis generates a file like `messages.xlf` containing all marked strings.\n\n#### 3. **Translation Files**\nTranslators edit the extracted files, providing translations for each marked string. You can create multiple translation files for different locales (e.g., `messages.fr.xlf` for French).\n\n#### 4. **Building for Different Locales**\nAngular supports building the application for multiple locales using the `--localize` flag:\n\n```bash\nng build --localize\n```\n\nThis produces separate builds for each locale, replacing the original text with the appropriate translations.\n\n#### 5. **Locale Data and Formatting**\nAngular automatically handles locale-specific data formatting (dates, numbers, currencies) based on the active locale. You can register additional locale data using:\n\n```typescript\nimport localeFr from '@angular/common/locales/fr';\nregisterLocaleData(localeFr);\n```\n\n#### 6. **Dynamic vs. Compile-time Translation**\n- **Compile-time (Static) i18n:** Angular’s built-in i18n is primarily compile-time, generating separate bundles for each locale.\n- **Runtime (Dynamic) i18n:** For dynamic language switching at runtime, third-party libraries like [ngx-translate](https://github.com/ngx-translate/core) are commonly used.\n\n#### 7. **Pluralization and Selects**\nAngular’s i18n supports pluralization and gender selection using ICU expressions:\n\n```html\n<p i18n>\n  {count, plural,\n    =0 {No messages}\n    =1 {One message}\n    other {# messages}\n  }\n</p>\n```\n\n#### 8. **Custom Markers and Context**\nYou can add context and descriptions to help translators:\n\n```html\n<span i18n=\"@@welcomeMessage|Greeting on the home page\">Welcome!</span>\n```\n\n---\n\n**Summary:**  \nAngular handles i18n through template markers, extraction and translation files, locale-aware builds, and formatting. For runtime language switching, third-party libraries are recommended. This approach ensures scalable, maintainable, and high-quality internationalized applications.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794918Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "bb3e49b5-4c4c-4809-b9f1-da6ab00479b3",
        "question": "What is the role of ngZone in Angular?",
        "answer": "```markdown\n### What is the role of `NgZone` in Angular?\n\n`NgZone` is a service in Angular that provides a way to execute code inside or outside of Angular's zone, which is crucial for change detection. Angular uses [Zone.js](https://github.com/angular/zone.js/) to intercept asynchronous operations (like events, HTTP requests, timers, etc.) and automatically trigger change detection when these operations complete.\n\n#### Key Roles of `NgZone`:\n\n1. **Change Detection Management**:  \n   By default, Angular runs change detection after every asynchronous event within its zone. `NgZone` allows you to control when change detection should or should not run, which can help optimize performance in complex applications.\n\n2. **Running Code Outside Angular's Zone**:  \n   You can use `ngZone.runOutsideAngular()` to execute code that does not require Angular's change detection. This is useful for performance-intensive tasks (e.g., animations, third-party libraries) that don't affect Angular's state.\n\n   ```typescript\n   this.ngZone.runOutsideAngular(() => {\n     // Code here will not trigger change detection\n   });\n   ```\n\n3. **Re-entering Angular's Zone**:  \n   If you need to update Angular's state after running code outside the zone, you can use `ngZone.run()` to re-enter Angular's zone, ensuring change detection is triggered.\n\n   ```typescript\n   this.ngZone.run(() => {\n     // Code here will trigger change detection\n   });\n   ```\n\n4. **Fine-grained Control**:  \n   `NgZone` provides hooks like `onStable`, `onUnstable`, `onError`, etc., allowing developers to listen to zone events and further control application behavior.\n\n#### Example Use Case\n\nSuppose you have a heavy computation that doesn't affect the UI directly. Running it outside Angular's zone prevents unnecessary change detection cycles:\n\n```typescript\nconstructor(private ngZone: NgZone) {}\n\nstartHeavyComputation() {\n  this.ngZone.runOutsideAngular(() => {\n    heavyComputation();\n    // Once done, update UI inside Angular's zone\n    this.ngZone.run(() => {\n      this.computationDone = true;\n    });\n  });\n}\n```\n\n#### Summary\n\n`NgZone` is a powerful tool for optimizing Angular applications by giving you control over when change detection runs. It helps improve performance, especially in scenarios involving frequent or heavy asynchronous operations.\n```",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794926Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "9c97c067-790d-4a62-8cb0-bcf04a435c2e",
        "question": "Explain the use of multi-provider tokens in Angular dependency injection.",
        "answer": "```markdown ### Multi-Provider Tokens in Angular Dependency Injection\n\nIn Angular, **multi-provider tokens** allow you to associate a single injection token with multiple providers. This means that when you inject the token, you receive an array of all the values provided for that token, rather than a single instance. This is particularly useful for scenarios where you want to collect multiple contributions from different parts of your application, such as registering multiple interceptors, validators, or event handlers.\n\n#### How to Use Multi-Provider Tokens\n\nTo declare a multi-provider, set the `multi: true` property in the provider configuration:\n\n```typescript\nimport { InjectionToken } from '@angular/core';\n\nexport const LOGGER_TOKEN = new InjectionToken<string>('Logger');\n\n@NgModule({\n  providers: [\n    { provide: LOGGER_TOKEN, useValue: 'ConsoleLogger', multi: true },\n    { provide: LOGGER_TOKEN, useValue: 'FileLogger', multi: true }\n  ]\n})\nexport class AppModule {}\n```\n\n#### Injecting Multi-Providers\n\nWhen you inject the token, Angular provides an array of all registered values:\n\n```typescript\nimport { Inject } from '@angular/core';\n\nconstructor(@Inject(LOGGER_TOKEN) private loggers: string[]) {\n  // loggers = ['ConsoleLogger', 'FileLogger']\n}\n```\n\n#### Use Cases\n\n- **HTTP Interceptors**: Angular's HTTP interceptors use multi-provider tokens to allow multiple interceptors to be registered.\n- **Custom Plugins or Extensions**: Applications can define extension points where multiple modules contribute functionality.\n- **Event Handlers**: Collecting multiple event handlers for a particular event.\n\n#### Key Points\n\n- All providers for a multi-provider token must set `multi: true`.\n- The injected value is always an array, even if only one provider is registered.\n- Useful for extensibility and modular design.\n\n---\n\n**Example: Registering Multiple HTTP Interceptors**\n\n```typescript\nproviders: [\n  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },\n  { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }\n]\n```\n\nWhen Angular injects `HTTP_INTERCEPTORS`, it provides an array of all registered interceptors.\n\n---\n\n**Summary:**  \nMulti-provider tokens in Angular enable you to collect multiple values or services under a single injection token, facilitating extensibility and modularity in your application’s architecture.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794941Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "f25e0c91-a09f-4b1b-b2f0-53d055ba4709",
        "question": "What are the best practices for state management in Angular?",
        "answer": "```markdown\n**Best Practices for State Management in Angular**\n\n1. **Single Source of Truth**  \n   Maintain a single, centralized store for application state (using libraries like NgRx, Akita, or NGXS) to ensure consistency and predictability.\n\n2. **Immutable State**  \n   Treat state as immutable. Always create new state objects instead of mutating existing ones, which helps with debugging and change detection.\n\n3. **Use Selectors**  \n   Access state using selectors rather than directly, to encapsulate logic, improve performance, and enable memoization.\n\n4. **Divide State into Feature Stores**  \n   Split state into logical feature stores/modules to keep state management scalable and maintainable.\n\n5. **Keep State Minimal**  \n   Store only essential data in the global state. Avoid storing transient or UI-specific state (like form control states) globally; keep them local to components when possible.\n\n6. **Leverage Observables**  \n   Use RxJS observables to manage asynchronous state changes and side effects, enabling powerful reactive patterns.\n\n7. **Handle Side Effects with Effects/Middleware**  \n   Use NgRx Effects or similar mechanisms to handle side effects (like API calls), keeping reducers pure and focused on state changes.\n\n8. **Strict Typing**  \n   Use TypeScript interfaces and types to define state shape, actions, and selectors for better maintainability and error prevention.\n\n9. **Use Actions for All State Changes**  \n   Dispatch actions for every state change, even for simple updates, to maintain a clear and traceable flow of changes.\n\n10. **Testing**  \n    Write unit tests for reducers, selectors, and effects to ensure state logic is reliable and maintainable.\n\n11. **Performance Optimization**  \n    Use OnPush change detection and memoized selectors to minimize unnecessary re-renders and improve performance.\n\n12. **Documentation and Naming Conventions**  \n    Clearly document state structure, actions, and selectors. Use consistent naming conventions for actions and state slices.\n\n**References:**\n- [NgRx Best Practices](https://ngrx.io/guide/store/best-practices)\n- [Angular State Management Patterns and Best Practices](https://blog.angularindepth.com/angular-state-management-patterns-and-best-practices-9b6c6f4b8f7b)\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.794948Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "e9cf0e89-cdbc-4368-a9a5-2803777b246c",
        "question": "How do you test Angular components and services?",
        "answer": "```markdown ### How do you test Angular components and services?\n\nTesting in Angular is typically done using **Jasmine** (a testing framework) and **Karma** (a test runner). Here’s how you can test components and services:\n\n---\n\n#### 1. **Testing Components**\n\n- **Setup:** Use Angular’s `TestBed` to configure a testing module that declares the component.\n- **Create Fixture:** Use `TestBed.createComponent()` to create a fixture, which provides access to both the component instance and its rendered DOM.\n- **Assertions:** Use Jasmine’s `expect()` to assert component behavior, template rendering, and event handling.\n\n**Example:**\n```typescript\nimport { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { MyComponent } from './my.component';\n\ndescribe('MyComponent', () => {\n  let component: MyComponent;\n  let fixture: ComponentFixture<MyComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [ MyComponent ]\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(MyComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should render title', () => {\n    component.title = 'Test Title';\n    fixture.detectChanges();\n    const compiled = fixture.nativeElement as HTMLElement;\n    expect(compiled.querySelector('h1')?.textContent).toContain('Test Title');\n  });\n});\n```\n\n---\n\n#### 2. **Testing Services**\n\n- **Setup:** Use `TestBed` to provide the service.\n- **Inject Service:** Use `TestBed.inject()` to get an instance of the service.\n- **Mock Dependencies:** If the service depends on other services (like HttpClient), use Angular’s `HttpClientTestingModule` or provide mocks.\n\n**Example:**\n```typescript\nimport { TestBed } from '@angular/core/testing';\nimport { MyService } from './my.service';\n\ndescribe('MyService', () => {\n  let service: MyService;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({});\n    service = TestBed.inject(MyService);\n  });\n\n  it('should be created', () => {\n    expect(service).toBeTruthy();\n  });\n\n  it('should return expected value', () => {\n    expect(service.getValue()).toBe('expectedValue');\n  });\n});\n```\n\n---\n\n#### 3. **Testing with Dependencies (e.g., HTTP)**\n\nUse `HttpClientTestingModule` and `HttpTestingController` to mock HTTP requests in services.\n\n**Example:**\n```typescript\nimport { TestBed } from '@angular/core/testing';\nimport { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';\nimport { DataService } from './data.service';\n\ndescribe('DataService', () => {\n  let service: DataService;\n  let httpMock: HttpTestingController;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({\n      imports: [HttpClientTestingModule],\n      providers: [DataService]\n    });\n    service = TestBed.inject(DataService);\n    httpMock = TestBed.inject(HttpTestingController);\n  });\n\n  it('should fetch data', () => {\n    const mockData = [{ id: 1, name: 'Test' }];\n    service.getData().subscribe(data => {\n      expect(data).toEqual(mockData);\n    });\n\n    const req = httpMock.expectOne('/api/data');\n    expect(req.request.method).toBe('GET');\n    req.flush(mockData);\n  });\n\n  afterEach(() => {\n    httpMock.verify();\n  });\n});\n```\n\n---\n\n### **Summary**\n\n- Use `TestBed` for configuring test modules.\n- Use Jasmine for assertions.\n- Use Angular testing utilities for mocking dependencies and simulating user interactions.\n- Test both logic (services) and UI (components) in isolation.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.794955Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "7242d5be-9b8e-4cb6-aec0-de2f1784c888",
        "question": "What is the purpose of the ngOnDestroy lifecycle hook?",
        "answer": "```markdown\nThe `ngOnDestroy` lifecycle hook in Angular is used to perform cleanup logic just before a component or directive is destroyed. This hook is especially important for:\n\n- **Unsubscribing from Observables:** Prevents memory leaks by unsubscribing from subscriptions.\n- **Detaching event handlers:** Removes event listeners that were manually added.\n- **Releasing resources:** Cleans up timers, intervals, or any resources allocated during the component's lifecycle.\n\n**Example:**\n```typescript\nimport { Component, OnDestroy } from '@angular/core';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-example',\n  template: `...`\n})\nexport class ExampleComponent implements OnDestroy {\n  private subscription: Subscription;\n\n  constructor() {\n    // Assume someObservable is an observable you subscribe to\n    this.subscription = someObservable.subscribe(data => {\n      // handle data\n    });\n  }\n\n  ngOnDestroy() {\n    // Clean up the subscription\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n    // Additional cleanup logic here\n  }\n}\n```\n\n**Summary:**  \n`ngOnDestroy` ensures that when a component or directive is removed from the DOM, all necessary cleanup is performed to avoid memory leaks and unwanted side effects.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.795015Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "3672bf78-14ae-4c86-a2fd-d74c95dc45a4",
        "question": "How can you share data between sibling components?",
        "answer": "```markdown\nTo share data between sibling components in Angular, you typically use a common parent component as an intermediary. Here are common approaches:\n\n### 1. Using a Shared Parent Component\n\n- **Step 1:** The parent component holds the shared data.\n- **Step 2:** The parent passes data to each child via `@Input()` properties.\n- **Step 3:** When a child needs to update the data, it emits an event using `@Output()` and `EventEmitter`.\n- **Step 4:** The parent listens to the event, updates the shared data, and passes the updated data to the siblings.\n\n**Example:**\n\n```typescript\n// parent.component.html\n<app-sibling1 [data]=\"sharedData\" (dataChange)=\"onDataChange($event)\"></app-sibling1>\n<app-sibling2 [data]=\"sharedData\"></app-sibling2>\n```\n\n```typescript\n// sibling1.component.ts\n@Input() data: any;\n@Output() dataChange = new EventEmitter<any>();\n\nsomeMethod() {\n  this.dataChange.emit(updatedData);\n}\n```\n\n```typescript\n// parent.component.ts\nsharedData: any;\n\nonDataChange(newData: any) {\n  this.sharedData = newData;\n}\n```\n\n### 2. Using a Shared Service\n\n- Create an Angular service with a `Subject` or `BehaviorSubject` to hold the shared data.\n- Inject the service into both sibling components.\n- Siblings can subscribe to the data and update it via the service.\n\n**Example:**\n\n```typescript\n// shared.service.ts\n@Injectable({ providedIn: 'root' })\nexport class SharedService {\n  private dataSubject = new BehaviorSubject<any>(initialValue);\n  data$ = this.dataSubject.asObservable();\n\n  updateData(newData: any) {\n    this.dataSubject.next(newData);\n  }\n}\n```\n\n```typescript\n// sibling1.component.ts\nconstructor(private sharedService: SharedService) {}\n\nupdate() {\n  this.sharedService.updateData(newValue);\n}\n```\n\n```typescript\n// sibling2.component.ts\nconstructor(private sharedService: SharedService) {}\n\nngOnInit() {\n  this.sharedService.data$.subscribe(data => {\n    // React to data changes\n  });\n}\n```\n\n---\n\n**Summary:**  \nData sharing between sibling components is most commonly achieved via a shared parent component or a shared service using RxJS observables.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.795023Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "1fc4079b-99c8-4906-a7c5-c48a41a4196b",
        "question": "What is the difference between pure and impure pipes?",
        "answer": "```markdown ### Difference Between Pure and Impure Pipes in Angular\n\nIn Angular, **pipes** are used to transform data in templates. They can be classified as **pure** or **impure** based on how and when they are executed.\n\n| Aspect            | Pure Pipe                                   | Impure Pipe                                  |\n|-------------------|---------------------------------------------|----------------------------------------------|\n| **Definition**    | A pipe that Angular executes only when it detects a pure change to the input value. | A pipe that Angular executes on every change detection cycle, regardless of the change type. |\n| **Default**       | All custom pipes are pure by default.        | Must be explicitly marked as impure (`pure: false`). |\n| **Execution**     | Called only when the input reference changes (e.g., new object/array or primitive value changes). | Called on every change detection run, even if the input value hasn't changed. |\n| **Performance**   | More performant due to fewer executions.     | Less performant due to frequent executions.  |\n| **Use Case**      | Suitable for stateless, deterministic transformations (e.g., formatting dates, numbers). | Suitable for transformations that depend on mutable objects or external states (e.g., filtering arrays, data from services). |\n| **Example**       | `{{ value | uppercase }}`                    | `{{ items | filter:searchTerm }}` (where `filter` is an impure pipe) |\n\n#### Example Declaration\n\n```typescript\n// Pure Pipe (default)\n@Pipe({ name: 'myPurePipe' })\nexport class MyPurePipe implements PipeTransform {\n  transform(value: any): any {\n    // transformation logic\n  }\n}\n\n// Impure Pipe\n@Pipe({ name: 'myImpurePipe', pure: false })\nexport class MyImpurePipe implements PipeTransform {\n  transform(value: any): any {\n    // transformation logic\n  }\n}\n```\n\n#### Summary\n\n- **Pure pipes** are efficient and should be used whenever possible.\n- **Impure pipes** should be used cautiously, as they can negatively impact performance due to frequent executions.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.795031Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "b40f23f0-b6d3-40a5-85a8-14da1b1e98c3",
        "question": "How do you handle errors globally in Angular?",
        "answer": "```markdown\n### How do you handle errors globally in Angular?\n\nIn Angular, global error handling can be achieved by implementing a custom `ErrorHandler`. The `ErrorHandler` is a built-in service that handles uncaught exceptions in your application. By providing your own implementation, you can centralize error logging, user notifications, or integration with external monitoring services.\n\n#### Steps to Handle Errors Globally:\n\n1. **Create a Custom Error Handler**\n\n   ```typescript\n   import { ErrorHandler, Injectable, Injector } from '@angular/core';\n\n   @Injectable()\n   export class GlobalErrorHandler implements ErrorHandler {\n     constructor(private injector: Injector) {}\n\n     handleError(error: any): void {\n       // Custom error handling logic\n       // For example, log to an external server\n       console.error('Global Error:', error);\n\n       // Optionally, use services via injector to avoid cyclic dependency\n       // const notificationService = this.injector.get(NotificationService);\n       // notificationService.showError('An unexpected error occurred.');\n\n       // Optionally, rethrow the error if you want default behavior\n       // throw error;\n     }\n   }\n   ```\n\n2. **Provide the Custom Error Handler**\n\n   Register your error handler in the `providers` array of your root module:\n\n   ```typescript\n   import { NgModule, ErrorHandler } from '@angular/core';\n   import { BrowserModule } from '@angular/platform-browser';\n   import { AppComponent } from './app.component';\n   import { GlobalErrorHandler } from './global-error-handler';\n\n   @NgModule({\n     declarations: [AppComponent],\n     imports: [BrowserModule],\n     providers: [\n       { provide: ErrorHandler, useClass: GlobalErrorHandler }\n     ],\n     bootstrap: [AppComponent]\n   })\n   export class AppModule {}\n   ```\n\n3. **Handle HTTP Errors Separately (Optional)**\n\n   For HTTP errors, use an `HttpInterceptor` to catch and handle errors from HTTP requests:\n\n   ```typescript\n   import { Injectable } from '@angular/core';\n   import { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpErrorResponse } from '@angular/common/http';\n   import { Observable, throwError } from 'rxjs';\n   import { catchError } from 'rxjs/operators';\n\n   @Injectable()\n   export class GlobalHttpInterceptor implements HttpInterceptor {\n     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n       return next.handle(req).pipe(\n         catchError((error: HttpErrorResponse) => {\n           // Handle HTTP error\n           console.error('HTTP Error:', error);\n           // Optionally, show user-friendly message or redirect\n           return throwError(() => error);\n         })\n       );\n     }\n   }\n   ```\n\n   Register the interceptor in your module providers:\n\n   ```typescript\n   import { HTTP_INTERCEPTORS } from '@angular/common/http';\n\n   providers: [\n     { provide: HTTP_INTERCEPTORS, useClass: GlobalHttpInterceptor, multi: true }\n   ]\n   ```\n\n#### Summary\n\n- Implement a custom `ErrorHandler` for global error handling.\n- Use `HttpInterceptor` for HTTP-specific errors.\n- Centralize logging, user notifications, or integration with monitoring tools.\n- Avoid cyclic dependencies by using `Injector` in your error handler.\n\nThis approach ensures that all uncaught errors are handled consistently across your Angular application.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795043Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "9ae948a1-b0fb-4686-ac37-bfdfcc0b68ba",
        "question": "What is the purpose of the APP_INITIALIZER token?",
        "answer": "```markdown The `APP_INITIALIZER` token in Angular is a special dependency injection token that allows you to execute one or more functions during the application’s initialization process, before the app is bootstrapped. This is particularly useful for performing asynchronous operations such as fetching configuration data, initializing services, or setting up global state before the application becomes available to the user.\n\n### Key Points\n\n- **Purpose:** To run custom initialization logic (synchronous or asynchronous) before Angular bootstraps the root module.\n- **Usage:** You provide one or more factory functions via the `APP_INITIALIZER` token in the providers array of your root module.\n- **Return Value:** Each factory function must return either `void` or a `Promise`. Angular will wait for all returned promises to resolve before continuing the bootstrap process.\n- **Common Use Cases:**\n  - Loading configuration files from the server.\n  - Initializing authentication state.\n  - Setting up third-party libraries.\n\n### Example\n\n```typescript\nimport { APP_INITIALIZER, NgModule } from '@angular/core';\n\nexport function loadConfig(configService: ConfigService) {\n  return () => configService.load();\n}\n\n@NgModule({\n  // ...\n  providers: [\n    {\n      provide: APP_INITIALIZER,\n      useFactory: loadConfig,\n      deps: [ConfigService],\n      multi: true\n    }\n  ]\n})\nexport class AppModule {}\n```\n\nIn this example, Angular will call `configService.load()` before bootstrapping the application, ensuring that any necessary configuration is loaded and available throughout the app.\n\n---\n\n**In summary:**  \nThe `APP_INITIALIZER` token is used to delay Angular app initialization until specified initialization logic (often asynchronous) has completed, ensuring that the application starts in a fully prepared state.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795058Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "73ce1af0-febf-419d-ac5a-0149bd8d3c42",
        "question": "How does Angular support progressive web apps (PWAs)?",
        "answer": "```markdown Angular provides robust support for building Progressive Web Apps (PWAs) through its built-in tooling and libraries. Here’s how Angular facilitates PWA development:\n\n### 1. Angular Service Worker\n\nAngular includes the `@angular/service-worker` package, which enables easy integration of service workers into your application. Service workers are essential for PWAs as they allow features like offline support, background sync, and push notifications.\n\n- **Automatic Service Worker Generation:** By running `ng add @angular/pwa`, Angular CLI configures your project for PWA capabilities, adding the necessary service worker files and updating your `angular.json`.\n- **Caching Strategies:** The `ngsw-config.json` file allows you to define caching strategies for assets and data, improving performance and offline capabilities.\n\n### 2. Manifest File\n\nAngular CLI generates a `manifest.webmanifest` file, which describes your app’s metadata (name, icons, theme color, etc.). This enables your app to be installable on devices and appear like a native app.\n\n### 3. HTTPS Requirement\n\nAngular enforces service worker registration only on HTTPS, ensuring security best practices for PWAs.\n\n### 4. App Shell Model\n\nAngular supports the App Shell model, which pre-renders a minimal UI for fast initial loading, enhancing perceived performance.\n\n### 5. Push Notifications & Background Sync\n\nWith service workers, Angular apps can receive push notifications and perform background synchronization, even when the app is not open.\n\n### 6. Angular CLI Integration\n\nThe Angular CLI simplifies PWA setup:\n```bash\nng add @angular/pwa\n```\nThis command:\n- Registers the service worker in `main.ts`\n- Adds the manifest and icons\n- Updates the app to support offline capabilities\n\n### 7. Best Practices and Updates\n\nAngular regularly updates its PWA support to align with the latest web standards, ensuring developers can leverage new PWA features with minimal configuration.\n\n---\n\n**In summary:**  \nAngular supports PWAs by providing built-in service worker integration, manifest generation, CLI tooling, and best practices, enabling developers to easily build reliable, performant, and installable web applications.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795065Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "355000f4-1767-4d68-aa08-23af21525ae1",
        "question": "Explain the concept of module federation in Angular.",
        "answer": "```markdown **Module Federation in Angular**\n\nModule Federation is a feature introduced in Webpack 5 that allows multiple, independently built and deployed applications (micro frontends) to share code and dependencies at runtime. In the context of Angular, module federation enables applications to dynamically load and use modules from other Angular applications without the need for recompilation or redeployment.\n\n### Key Concepts\n\n- **Host and Remote:**  \n  - The **host** application loads modules from one or more **remote** applications.\n  - Remotes expose specific modules or components for sharing.\n\n- **Dynamic Loading:**  \n  - Modules are loaded at runtime, enabling independent deployment and versioning.\n\n- **Shared Dependencies:**  \n  - Common dependencies (like Angular core libraries) can be shared to avoid duplication and reduce bundle size.\n\n### How Module Federation Works in Angular\n\n1. **Configuration:**  \n   - Angular uses the `@angular-architects/module-federation` plugin to simplify setup.\n   - The `webpack.config.js` (or `webpack.config.ts`) file is configured to define which modules are exposed and which are consumed.\n\n2. **Exposing Modules:**  \n   - In the remote app’s webpack config, specify which Angular modules/components to expose.\n\n3. **Consuming Modules:**  \n   - In the host app, use dynamic imports to load exposed modules from remotes.\n\n4. **Shared Libraries:**  \n   - Define shared libraries in the configuration to ensure only a single instance is loaded.\n\n### Example\n\n**Remote App (webpack.config.js):**\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'remoteApp',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './RemoteModule': './src/app/remote/remote.module.ts',\n      },\n      shared: ['@angular/core', '@angular/common', '@angular/router'],\n    }),\n  ],\n};\n```\n\n**Host App (webpack.config.js):**\n```js\nmodule.exports = {\n  // ...\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'hostApp',\n      remotes: {\n        remoteApp: 'remoteApp@http://localhost:4201/remoteEntry.js',\n      },\n      shared: ['@angular/core', '@angular/common', '@angular/router'],\n    }),\n  ],\n};\n```\n\n**Dynamic Import in Host App:**\n```typescript\nloadRemoteModule({\n  remoteEntry: 'http://localhost:4201/remoteEntry.js',\n  remoteName: 'remoteApp',\n  exposedModule: './RemoteModule'\n}).then(m => {\n  // Use the loaded module\n});\n```\n\n### Benefits\n\n- **Independent Deployment:** Teams can deploy micro frontends independently.\n- **Code Sharing:** Share common libraries and components at runtime.\n- **Scalability:** Enables large-scale applications to be split into manageable parts.\n\n### Use Cases\n\n- Micro frontend architectures\n- Large enterprise applications with multiple teams\n- Gradual migration of legacy applications\n\n---\n\n**In summary:**  \nModule Federation in Angular leverages Webpack 5 to enable dynamic, runtime sharing of modules between separately built Angular applications, supporting scalable, maintainable, and independently deployable micro frontend architectures.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795072Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "99b77858-5af8-4e5e-ba52-83c7be13066a",
        "question": "How do you implement custom validators in Angular forms?",
        "answer": "```markdown\nTo implement custom validators in Angular forms, you need to create a function that takes a `FormControl` (or `AbstractControl`) as an argument and returns either `null` (if the value is valid) or an object describing the validation error.\n\n### Steps to Create a Custom Validator\n\n#### 1. Create the Validator Function\n\nFor **Reactive Forms**:\n\n```typescript\nimport { AbstractControl, ValidationErrors } from '@angular/forms';\n\nexport function forbiddenNameValidator(forbiddenName: RegExp) {\n  return (control: AbstractControl): ValidationErrors | null => {\n    const forbidden = forbiddenName.test(control.value);\n    return forbidden ? { forbiddenName: { value: control.value } } : null;\n  };\n}\n```\n\n#### 2. Apply the Validator to a FormControl\n\n```typescript\nimport { FormControl } from '@angular/forms';\n\nname = new FormControl('', [forbiddenNameValidator(/admin/i)]);\n```\n\nOr in a `FormGroup`:\n\n```typescript\nimport { FormBuilder, Validators } from '@angular/forms';\n\nconstructor(private fb: FormBuilder) {}\n\nform = this.fb.group({\n  username: ['', [forbiddenNameValidator(/admin/i)]]\n});\n```\n\n#### 3. Use the Validator in the Template\n\n```html\n<input formControlName=\"username\">\n<div *ngIf=\"form.get('username')?.errors?.forbiddenName\">\n  This name is not allowed.\n</div>\n```\n\n### For Template-driven Forms\n\nYou can create a directive that implements `Validator` interface:\n\n```typescript\nimport { Directive, Input } from '@angular/core';\nimport { NG_VALIDATORS, Validator, AbstractControl, ValidationErrors } from '@angular/forms';\n\n@Directive({\n  selector: '[appForbiddenName]',\n  providers: [{ provide: NG_VALIDATORS, useExisting: ForbiddenNameValidatorDirective, multi: true }]\n})\nexport class ForbiddenNameValidatorDirective implements Validator {\n  @Input('appForbiddenName') forbiddenName!: string;\n\n  validate(control: AbstractControl): ValidationErrors | null {\n    return this.forbiddenName && new RegExp(this.forbiddenName).test(control.value)\n      ? { forbiddenName: { value: control.value } }\n      : null;\n  }\n}\n```\n\nAnd use it in the template:\n\n```html\n<input name=\"username\" ngModel appForbiddenName=\"admin\">\n```\n\n---\n\n**Summary:**  \nCustom validators in Angular are functions (or classes for template-driven forms) that return either `null` (valid) or an error object (invalid). You can apply them to form controls to enforce custom validation logic.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.795087Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "105cec00-8701-44f0-b30e-e9608fc2a7f4",
        "question": "What is the role of the Injector in Angular?",
        "answer": "```markdown\n### What is the role of the Injector in Angular?\n\nIn Angular, the **Injector** is a fundamental part of the dependency injection (DI) system. Its primary role is to **create and manage dependencies** (services, values, factories, etc.) and provide them to components, directives, pipes, or other services as needed.\n\n#### Key Responsibilities of the Injector:\n\n- **Instance Creation:** The Injector is responsible for instantiating classes that are registered as providers.\n- **Dependency Resolution:** When a class declares dependencies (via constructor parameters), the Injector resolves and supplies the required instances.\n- **Hierarchical Injection:** Angular injectors are organized in a hierarchy, allowing for different scopes (root, module, component, etc.), which helps in controlling the lifetime and visibility of services.\n- **Singleton Management:** By default, services provided in the root injector are singletons and shared across the application. However, services can be scoped to specific modules or components.\n- **Lazy Loading Support:** The Injector supports lazy loading by creating new injectors for lazy-loaded modules, enabling isolated service instances.\n\n#### Example\n\n```typescript\n@Injectable()\nexport class MyService {}\n\n@Component({\n  selector: 'my-component',\n  template: `...`\n})\nexport class MyComponent {\n  constructor(private myService: MyService) {}\n}\n```\n\nIn this example, when Angular creates `MyComponent`, it uses the Injector to provide an instance of `MyService` to the component's constructor.\n\n#### Summary Table\n\n| Responsibility            | Description                                                      |\n|---------------------------|------------------------------------------------------------------|\n| Instance Creation         | Creates service/class instances as needed                        |\n| Dependency Resolution     | Resolves and injects dependencies into constructors              |\n| Hierarchical Injection    | Supports injector hierarchies for different scopes               |\n| Singleton Management      | Manages singleton/shared or scoped service instances             |\n| Lazy Loading Support      | Provides isolated injectors for lazy-loaded modules              |\n\n**In summary:** The Injector is the backbone of Angular's DI system, ensuring that dependencies are efficiently created, managed, and injected where needed throughout the application.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795094Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "0840542d-0052-4656-8465-da539a91738e",
        "question": "How do you use the ng-template and ng-container directives?",
        "answer": "```markdown\n**ng-template** and **ng-container** are structural directives in Angular that help you manage and organize your templates more efficiently.\n\n### `ng-template`\n\n- `<ng-template>` is a template element that Angular does not render directly in the DOM. Instead, it acts as a blueprint for creating views dynamically.\n- It is commonly used with structural directives like `*ngIf`, `*ngFor`, or with the `ngTemplateOutlet` directive to render content conditionally or repeatedly.\n\n**Example: Using `ng-template` with `*ngIf`**\n\n```html\n<div *ngIf=\"isLoggedIn; else loginTemplate\">\n  Welcome, user!\n</div>\n<ng-template #loginTemplate>\n  <p>Please log in.</p>\n</ng-template>\n```\n\n**Example: Using `ngTemplateOutlet`**\n\n```html\n<ng-template #greet let-name=\"name\">\n  <p>Hello, {{ name }}!</p>\n</ng-template>\n\n<div [ngTemplateOutlet]=\"greet\" [ngTemplateOutletContext]=\"{ name: 'Alice' }\"></div>\n```\n\n---\n\n### `ng-container`\n\n- `<ng-container>` is a logical container that does **not** get rendered in the DOM. It allows you to group elements or apply structural directives without introducing extra HTML elements.\n- Useful when you want to apply a directive to multiple elements or avoid unnecessary wrappers.\n\n**Example: Using `ng-container` with `*ngIf`**\n\n```html\n<ng-container *ngIf=\"items.length > 0\">\n  <li *ngFor=\"let item of items\">{{ item }}</li>\n</ng-container>\n```\n\nHere, the `<ng-container>` applies the `*ngIf` to all its child elements without adding an extra node to the DOM.\n\n---\n\n### Summary\n\n- **`ng-template`**: Defines a template that can be rendered conditionally or dynamically.\n- **`ng-container`**: Groups elements and applies directives without adding extra DOM nodes.\n\nBoth are powerful tools for advanced template management in Angular applications.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:27:00.795100Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    },
    {
        "id": "fa4e6f7f-dd8d-4072-982c-aa3a39899259",
        "question": "What is the difference between forRoot() and forChild() methods in Angular modules?",
        "answer": "```markdown\n**Difference between `forRoot()` and `forChild()` methods in Angular modules:**\n\nIn Angular, the `forRoot()` and `forChild()` methods are used to configure and provide services when setting up feature modules and routing modules. They help manage singleton services and avoid multiple instances across the application.\n\n### `forRoot()`\n- **Purpose:** Used in the root module (usually `AppModule`) to configure and provide singleton services or routes that should be available application-wide.\n- **Usage:** Typically called once in the application, in the root module.\n- **Example:**  \n  ```typescript\n  imports: [\n    RouterModule.forRoot(routes)\n  ]\n  ```\n- **Effect:** Registers providers and configurations that should be singletons (e.g., services, guards).\n\n### `forChild()`\n- **Purpose:** Used in feature modules to configure additional routes or module-specific providers without re-registering singleton services.\n- **Usage:** Called in feature or lazily loaded modules.\n- **Example:**  \n  ```typescript\n  imports: [\n    RouterModule.forChild(childRoutes)\n  ]\n  ```\n- **Effect:** Adds routes or configurations specific to the feature module, but does **not** re-instantiate singleton services.\n\n### **Key Differences**\n| Aspect                | `forRoot()`                                 | `forChild()`                         |\n|-----------------------|---------------------------------------------|--------------------------------------|\n| Where to use          | Root module                                 | Feature/lazy-loaded modules          |\n| Singleton providers   | Registers singleton providers               | Does **not** register singletons     |\n| Typical use case      | Application-wide configuration              | Module-specific configuration        |\n| Example               | `RouterModule.forRoot(routes)`              | `RouterModule.forChild(childRoutes)` |\n\n**Summary:**  \nUse `forRoot()` in the root module to set up singleton services and global configuration. Use `forChild()` in feature modules to add module-specific configuration without duplicating singleton providers.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:27:00.795107Z",
        "topic": "26402a9d-d27f-4eec-ba01-00c5494de184"
    }
]