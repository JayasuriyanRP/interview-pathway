[
    {
        "id": "97e346ea-92f9-49de-b53b-29c98dbb4e2b",
        "question": "What is the purpose of ngOnInit and ngOnDestroy lifecycle hooks?",
        "answer": "```markdown\n**ngOnInit** and **ngOnDestroy** are two important lifecycle hooks in Angular components and directives.\n\n### ngOnInit\n\n- **Purpose:**  \n  `ngOnInit` is called once after the component’s data-bound properties have been initialized.  \n- **Typical Use Cases:**  \n  - Fetching data from a server\n  - Initializing component state\n  - Setting up subscriptions\n\n**Example:**\n```typescript\nngOnInit(): void {\n  this.loadData();\n}\n```\n\n---\n\n### ngOnDestroy\n\n- **Purpose:**  \n  `ngOnDestroy` is called just before the component or directive is destroyed.  \n- **Typical Use Cases:**  \n  - Cleaning up resources (e.g., unsubscribing from observables)\n  - Detaching event handlers\n  - Stopping timers\n\n**Example:**\n```typescript\nngOnDestroy(): void {\n  this.subscription.unsubscribe();\n}\n```\n\n---\n\n**Summary:**  \n- Use `ngOnInit` for initialization logic.\n- Use `ngOnDestroy` for cleanup logic to prevent memory leaks and unwanted side effects.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656972Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "a5aa4929-b5ac-4b29-b76f-9f4a23f8a54c",
        "question": "What is the role of the package.json file in an Angular project?",
        "answer": "```markdown\nThe `package.json` file in an Angular project serves as the central configuration file for managing the project's dependencies, scripts, and metadata. It lists all the libraries and packages required for the project to run, including Angular itself and other third-party modules. Additionally, it defines scripts for common tasks (like building or testing the app), specifies the project's version, and includes other relevant information such as the project's name and author. This file is essential for installing dependencies using npm and for sharing the project with others.\n```",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.657201Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "329d0651-1d7e-4810-a1f4-d4fd5a0d77a0",
        "question": "What is Angular and how does it differ from AngularJS?",
        "answer": "```markdown **Answer:**\n\nAngular is a modern, open-source front-end web application framework developed and maintained by Google. It is used for building dynamic, single-page web applications (SPAs) using TypeScript, a superset of JavaScript. Angular provides features like two-way data binding, dependency injection, modular architecture, and a powerful CLI for development.\n\n**Differences between Angular and AngularJS:**\n\n| Feature                | AngularJS (v1.x)                    | Angular (v2 and above)            |\n|------------------------|-------------------------------------|-----------------------------------|\n| Language               | JavaScript                          | TypeScript                        |\n| Architecture           | MVC (Model-View-Controller)         | Component-based                   |\n| Mobile Support         | Limited                             | Designed for mobile support       |\n| Performance            | Slower, uses dirty checking         | Faster, uses a hierarchical DI    |\n| Data Binding           | Two-way data binding                | Two-way and one-way data binding  |\n| Dependency Injection   | Limited                             | Improved and more flexible        |\n| Directives             | Different syntax (`ng-`)            | Simplified, uses `[ ]` and `( )`  |\n| Tooling                | Basic                               | Advanced CLI, better tooling      |\n\nIn summary, Angular is a complete rewrite of AngularJS, offering better performance, a more modern architecture, and improved tooling, making it more suitable for large-scale and complex applications.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656774Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "65e8c6c6-986a-4cea-9d12-fbd82f7fdd4d",
        "question": "Explain the concept of data binding in Angular.",
        "answer": "```markdown **Answer:**\n\nData binding in Angular is a technique that allows you to synchronize data between the component (TypeScript code) and the view (HTML template). It helps keep the user interface and the underlying data model in sync automatically. Angular provides several types of data binding:\n\n1. **Interpolation (`{{ }}`):**  \n   Used to display component data in the template.\n   ```html\n   <h1>{{ title }}</h1>\n   ```\n\n2. **Property Binding (`[property]`):**  \n   Binds a property of a DOM element to a field in the component.\n   ```html\n   <img [src]=\"imageUrl\">\n   ```\n\n3. **Event Binding (`(event)`):**  \n   Binds an event (like click) to a method in the component.\n   ```html\n   <button (click)=\"onClick()\">Click me</button>\n   ```\n\n4. **Two-way Binding (`[(ngModel)]`):**  \n   Allows data to flow both ways—updates in the component reflect in the view and vice versa.\n   ```html\n   <input [(ngModel)]=\"username\">\n   ```\n\n**Summary:**  \nData binding in Angular makes it easy to manage and update the UI based on data changes, and vice versa, reducing the need for manual DOM manipulation.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656817Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "94103631-507d-442c-90bc-9ee0527ae71c",
        "question": "What are components in Angular and how are they created?",
        "answer": "```markdown **Answer:**\n\nIn Angular, **components** are the fundamental building blocks of the user interface. Each component controls a part of the screen called a \"view.\" Components are responsible for displaying data, handling user interactions, and managing their own logic.\n\nA component in Angular consists of three main parts:\n\n1. **Template**: Defines the HTML view.\n2. **Class**: Contains the logic and data (written in TypeScript).\n3. **Metadata**: Provides information about the component to Angular (using the `@Component` decorator).\n\n### How to Create a Component\n\nYou can create a component in Angular using the Angular CLI with the following command:\n\n```bash\nng generate component component-name\n```\nor\n```bash\nng g c component-name\n```\n\nThis command generates four files:\n\n- `component-name.component.ts` (TypeScript class)\n- `component-name.component.html` (Template)\n- `component-name.component.css` (Styles)\n- `component-name.component.spec.ts` (Unit test)\n\n#### Example of a Simple Component\n\n```typescript\n// hello.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-hello',\n  template: `<h1>Hello, Angular!</h1>`,\n  styleUrls: ['./hello.component.css']\n})\nexport class HelloComponent { }\n```\n\n- `selector`: The HTML tag used to insert this component into templates.\n- `template`: The HTML content for the component.\n- `styleUrls`: The CSS files for the component.\n\n**Summary:**  \nComponents in Angular are reusable pieces of UI, each with their own template, logic, and styles. They are created using the Angular CLI or manually by defining a class with the `@Component` decorator.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656832Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "68835ae2-bd35-4cd7-935d-8ae705cbd188",
        "question": "What is a module in Angular and why is it important?",
        "answer": "```markdown **Answer:**\n\nIn Angular, a **module** is a logical container for a cohesive block of code dedicated to an application domain, a workflow, or a set of capabilities. Modules help organize an application into smaller, manageable, and reusable pieces.\n\nThe most common type of module is the **NgModule**, defined using the `@NgModule` decorator. An Angular application always has at least one module, the **root module** (usually called `AppModule`).\n\n**Why is it important?**\n\n- **Organization:** Modules help structure your application, making it easier to maintain and scale.\n- **Reusability:** You can group related components, directives, pipes, and services into modules and reuse them across different parts of your application or even in other projects.\n- **Lazy Loading:** Modules enable lazy loading, which improves performance by loading parts of the application only when needed.\n- **Dependency Management:** Modules declare which components and services they use, making dependencies clear and manageable.\n\n**Example:**\n```typescript\nimport { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\n\nIn summary, modules are essential in Angular for organizing code, managing dependencies, and enabling features like lazy loading and reusability.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656847Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "319ad0e0-05ce-496f-b764-e38ecf2e25d6",
        "question": "Describe the purpose of services in Angular.",
        "answer": "```markdown **Answer:**\n\nIn Angular, **services** are used to organize and share code and data across different components of an application. The main purpose of services is to provide a way to encapsulate reusable logic, such as fetching data from an API, handling business logic, or managing application state, so that it can be easily injected and used by multiple components. This helps keep components focused on displaying data and handling user interactions, making the code more modular, maintainable, and testable. Services in Angular are typically created using the `@Injectable()` decorator and are provided to components through Angular's dependency injection system.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656862Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "4244a921-1feb-4eec-a5de-e21cf419eb18",
        "question": "What is dependency injection in Angular?",
        "answer": "```markdown **Dependency injection** in Angular is a design pattern and core feature that allows you to supply a component or service with its dependencies from the outside, rather than creating them inside the component or service itself. This makes your code more modular, reusable, and easier to test.\n\nIn Angular, the framework's injector is responsible for creating and managing dependencies. You typically declare dependencies in a component or service’s constructor, and Angular automatically provides the required instances when the class is instantiated.\n\n**Example:**\n\n```typescript\nimport { Component } from '@angular/core';\nimport { MyService } from './my-service.service';\n\n@Component({\n  selector: 'app-example',\n  template: `<p>Example works!</p>`\n})\nexport class ExampleComponent {\n  constructor(private myService: MyService) {\n    // myService is injected by Angular\n  }\n}\n```\n\n**Benefits of dependency injection:**\n- Promotes loose coupling between classes\n- Makes code easier to maintain and test\n- Simplifies the management of shared resources (like services)\n\nIn summary, dependency injection in Angular is a way to provide components and services with the objects they need, improving code structure and testability.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656875Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "3a660627-3200-463e-9293-5c9187362305",
        "question": "How do you communicate between components in Angular?",
        "answer": "```markdown\n### How do you communicate between components in Angular?\n\nIn Angular, component communication can be achieved in several ways, depending on the relationship between the components:\n\n#### 1. **Parent to Child Communication**\n- **@Input() Decorator:**  \n  The parent component can pass data to the child component using property binding and the `@Input()` decorator in the child.\n\n  ```typescript\n  // child.component.ts\n  @Input() childProperty: string;\n  ```\n\n  ```html\n  <!-- parent.component.html -->\n  <app-child [childProperty]=\"parentValue\"></app-child>\n  ```\n\n#### 2. **Child to Parent Communication**\n- **@Output() Decorator and EventEmitter:**  \n  The child component can send data to the parent using the `@Output()` decorator and `EventEmitter`.\n\n  ```typescript\n  // child.component.ts\n  @Output() notifyParent = new EventEmitter<string>();\n\n  someMethod() {\n    this.notifyParent.emit('Some data');\n  }\n  ```\n\n  ```html\n  <!-- parent.component.html -->\n  <app-child (notifyParent)=\"parentHandler($event)\"></app-child>\n  ```\n\n#### 3. **Sibling Components Communication**\n- **Shared Service with RxJS Subjects:**  \n  Sibling components can communicate via a shared service that uses RxJS `Subject` or `BehaviorSubject` to emit and subscribe to events.\n\n  ```typescript\n  // communication.service.ts\n  private messageSource = new Subject<string>();\n  message$ = this.messageSource.asObservable();\n\n  sendMessage(message: string) {\n    this.messageSource.next(message);\n  }\n  ```\n\n  Components inject the service and use `sendMessage()` and subscribe to `message$`.\n\n#### 4. **Using ViewChild and ContentChild**\n- **@ViewChild() / @ContentChild():**  \n  The parent can directly access child component methods and properties using `@ViewChild()` or `@ContentChild()`.\n\n  ```typescript\n  @ViewChild(ChildComponent) child: ChildComponent;\n\n  ngAfterViewInit() {\n    this.child.childMethod();\n  }\n  ```\n\n#### 5. **Global Event Bus or State Management**\n- For complex applications, libraries like NgRx or services as a global event bus can be used for communication across unrelated components.\n\n---\n\n**Summary:**  \nAngular provides multiple mechanisms for component communication, such as `@Input()`, `@Output()`, shared services with RxJS, and state management solutions, depending on the component relationship and application complexity.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656959Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "18ed78c9-632f-479a-8a82-0fd350836237",
        "question": "How does Angular handle routing?",
        "answer": "```markdown Angular handles routing using its built-in Angular Router module. The Angular Router enables navigation between different views or components in a single-page application (SPA) without reloading the entire page.\n\n**Key Points:**\n\n- **RouterModule:** You import RouterModule and define routes in your application, typically in a separate routing module.\n- **Routes Configuration:** Routes are defined as an array of objects, where each object maps a URL path to a specific component.\n- **RouterOutlet:** The <router-outlet> directive acts as a placeholder in your template where the matched component will be displayed.\n- **Navigation:** You can navigate between routes using routerLink directives in templates or the Router service in TypeScript code.\n\n**Example:**\n\n```typescript\n// app-routing.module.ts\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { HomeComponent } from './home/home.component';\nimport { AboutComponent } from './about/about.component';\n\nconst routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'about', component: AboutComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n```\n\n```html\n<!-- app.component.html -->\n<nav>\n  <a routerLink=\"/\">Home</a>\n  <a routerLink=\"/about\">About</a>\n</nav>\n<router-outlet></router-outlet>\n```\n\n**Summary:**  \nAngular uses the Router module to map URL paths to components, enabling smooth navigation within SPAs without full page reloads.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656889Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "f3096eb5-d20a-4e3d-a8a0-ff619a534a22",
        "question": "What is the difference between template-driven and reactive forms?",
        "answer": "```markdown **Template-driven forms** and **reactive forms** are two approaches to handling user input and form validation in Angular.\n\n### Template-driven Forms\n\n- **Driven by the template:** Most of the logic is written in the HTML template using directives like `ngModel`.\n- **Simplicity:** Easier to use for simple forms.\n- **Automatic form creation:** Angular automatically creates the form model behind the scenes.\n- **Two-way data binding:** Uses `[(ngModel)]` for binding form inputs.\n- **Validation:** Validation is set up in the template using directives like `required`, `minlength`, etc.\n- **Less scalable:** Not ideal for complex or dynamic forms.\n\n**Example:**\n```html\n<form #myForm=\"ngForm\">\n  <input name=\"username\" ngModel required>\n</form>\n```\n\n---\n\n### Reactive Forms\n\n- **Driven by code:** The form model is created and managed in the component class using `FormGroup`, `FormControl`, and `FormBuilder`.\n- **More control:** Offers more flexibility and control, especially for complex forms.\n- **Explicit form creation:** You define the structure and validation rules in the TypeScript code.\n- **No two-way binding:** Uses `formControlName` for binding.\n- **Validation:** Validation is set up in the component class.\n- **Scalable:** Better suited for large, dynamic, or complex forms.\n\n**Example:**\n```typescript\nform = new FormGroup({\n  username: new FormControl('', Validators.required)\n});\n```\n```html\n<form [formGroup]=\"form\">\n  <input formControlName=\"username\">\n</form>\n```\n\n---\n\n### Summary Table\n\n| Feature                | Template-driven Forms      | Reactive Forms          |\n|------------------------|---------------------------|------------------------|\n| Where logic is defined | Template (HTML)           | Component (TypeScript) |\n| Form creation          | Automatic                 | Explicit               |\n| Data binding           | Two-way (`ngModel`)       | One-way (`formControlName`) |\n| Validation             | Template directives       | Component code         |\n| Best for               | Simple forms              | Complex forms          |",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.656903Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "e8ae8e33-e823-4e5d-9dd8-badc78040ca1",
        "question": "Explain the lifecycle hooks of an Angular component.",
        "answer": "```markdown\n### Explain the lifecycle hooks of an Angular component\n\nAngular components go through a series of lifecycle events from creation to destruction. Angular provides lifecycle hooks—special methods that allow you to tap into these key moments and perform custom logic. Here are the main lifecycle hooks:\n\n1. **ngOnChanges(changes: SimpleChanges)**\n   - Called before `ngOnInit` and whenever one or more data-bound input properties change.\n   - Useful for reacting to changes in `@Input()` properties.\n\n2. **ngOnInit()**\n   - Called once after the first `ngOnChanges`.\n   - Ideal for component initialization logic, such as fetching data.\n\n3. **ngDoCheck()**\n   - Called during every change detection run.\n   - Use this to detect and act upon changes that Angular doesn't catch on its own.\n\n4. **ngAfterContentInit()**\n   - Called once after Angular projects external content into the component's view (using `<ng-content>`).\n\n5. **ngAfterContentChecked()**\n   - Called after every check of projected content.\n\n6. **ngAfterViewInit()**\n   - Called once after the component's view (and child views) have been initialized.\n\n7. **ngAfterViewChecked()**\n   - Called after every check of the component's view (and child views).\n\n8. **ngOnDestroy()**\n   - Called just before Angular destroys the component.\n   - Use this for cleanup, such as unsubscribing from observables or detaching event handlers.\n\n#### Example Usage\n\n```typescript\nimport { Component, OnInit, OnDestroy } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<p>Example Component</p>`\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  ngOnInit() {\n    // Initialization logic here\n  }\n\n  ngOnDestroy() {\n    // Cleanup logic here\n  }\n}\n```\n\n#### Summary Table\n\n| Hook                    | When Called                                      |\n|-------------------------|--------------------------------------------------|\n| ngOnChanges             | On input property changes                        |\n| ngOnInit                | Once after first ngOnChanges                     |\n| ngDoCheck               | During every change detection run                |\n| ngAfterContentInit      | After content (ng-content) projected             |\n| ngAfterContentChecked   | After every check of projected content           |\n| ngAfterViewInit         | After component's view initialized               |\n| ngAfterViewChecked      | After every check of component's view            |\n| ngOnDestroy             | Just before the component is destroyed           |\n\nUnderstanding these hooks helps you manage your component's behavior throughout its lifecycle.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656917Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "96265bc1-f5f7-4f8c-be7e-aac058ca9f1c",
        "question": "How do you create and use custom pipes in Angular?",
        "answer": "```markdown\n### How do you create and use custom pipes in Angular?\n\nIn Angular, **pipes** are used to transform data in templates. While Angular provides several built-in pipes (like `date`, `uppercase`, etc.), you can also create your own **custom pipes** to suit specific needs.\n\n#### 1. Creating a Custom Pipe\n\nYou can create a custom pipe using the Angular CLI:\n\n```bash\nng generate pipe my-custom\n```\n\nOr manually, by creating a class that implements the `PipeTransform` interface and decorating it with `@Pipe`.\n\n**Example:** Create a pipe that capitalizes the first letter of a string.\n\n```typescript\nimport { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'capitalize'\n})\nexport class CapitalizePipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) return '';\n    return value.charAt(0).toUpperCase() + value.slice(1);\n  }\n}\n```\n\n#### 2. Registering the Pipe\n\nMake sure to declare your pipe in the `declarations` array of your Angular module (usually `app.module.ts`):\n\n```typescript\nimport { CapitalizePipe } from './capitalize.pipe';\n\n@NgModule({\n  declarations: [\n    // other components and pipes\n    CapitalizePipe\n  ],\n  // ...\n})\nexport class AppModule { }\n```\n\n#### 3. Using the Custom Pipe in Templates\n\nOnce declared, you can use your custom pipe in any template of the module:\n\n```html\n<p>{{ 'hello world' | capitalize }}</p>\n<!-- Output: Hello world -->\n```\n\n#### 4. Pipe Parameters\n\nCustom pipes can also accept parameters:\n\n```typescript\n@Pipe({ name: 'exponential' })\nexport class ExponentialPipe implements PipeTransform {\n  transform(value: number, exponent: number = 1): number {\n    return Math.pow(value, exponent);\n  }\n}\n```\n\nUsage:\n\n```html\n<p>{{ 2 | exponential:3 }}</p>\n<!-- Output: 8 -->\n```\n\n---\n\n**Summary:**  \n- Create a class implementing `PipeTransform` and decorate it with `@Pipe`.\n- Register the pipe in your module's `declarations`.\n- Use the pipe in your templates with the `|` syntax, optionally passing parameters.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656931Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "2380514c-507a-4ea7-95eb-eb8783dc08a6",
        "question": "What are directives in Angular? Name and explain different types.",
        "answer": "```markdown **Directives in Angular**\n\nIn Angular, **directives** are special classes that allow you to manipulate the DOM or modify the behavior and appearance of elements in your application. Directives are one of the core features of Angular, enabling developers to create reusable components and add dynamic behavior to the UI.\n\n### Types of Directives in Angular\n\nAngular provides three main types of directives:\n\n1. **Component Directives**\n   - **Description:** Components are directives with a template. They are the most commonly used directive type and are the building blocks of Angular applications.\n   - **Example:** \n     ```typescript\n     @Component({\n       selector: 'app-example',\n       template: '<h1>Hello World</h1>'\n     })\n     export class ExampleComponent {}\n     ```\n\n2. **Structural Directives**\n   - **Description:** These directives change the structure of the DOM by adding or removing elements. They are usually denoted with a `*` prefix in the template.\n   - **Common Examples:**\n     - `*ngIf`: Adds or removes an element based on a condition.\n     - `*ngFor`: Repeats an element for each item in a collection.\n     - `*ngSwitch`: Conditionally swaps DOM structure.\n   - **Example:**\n     ```html\n     <div *ngIf=\"isVisible\">Visible Content</div>\n     <ul>\n       <li *ngFor=\"let item of items\">{{ item }}</li>\n     </ul>\n     ```\n\n3. **Attribute Directives**\n   - **Description:** These directives change the appearance or behavior of an existing element, component, or another directive by modifying its attributes.\n   - **Common Examples:**\n     - `ngClass`: Adds or removes CSS classes.\n     - `ngStyle`: Adds or removes inline styles.\n     - Custom attribute directives (e.g., to highlight an element).\n   - **Example:**\n     ```html\n     <div [ngClass]=\"{'active': isActive}\">Styled Content</div>\n     <input [ngStyle]=\"{'color': color}\">\n     ```\n\n---\n\n**Summary Table**\n\n| Directive Type         | Purpose                                 | Example         |\n|----------------------- |-----------------------------------------|-----------------|\n| Component Directive    | Has a template, creates UI components   | @Component      |\n| Structural Directive   | Changes DOM structure                   | *ngIf, *ngFor   |\n| Attribute Directive    | Changes appearance/behavior of elements | ngClass, ngStyle|\n\nDirectives are essential for building dynamic, interactive, and reusable UI components in Angular applications.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656945Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "e58868f6-51a4-4e3a-94e1-7133d177a207",
        "question": "How do you implement lazy loading in Angular?",
        "answer": "```markdown\n**How do you implement lazy loading in Angular?**\n\nLazy loading in Angular is a technique that allows you to load feature modules only when they are needed, rather than loading all modules at the application startup. This improves the application's performance by reducing the initial load time.\n\n**Steps to implement lazy loading in Angular:**\n\n1. **Create a Feature Module:**\n   Generate a new module using Angular CLI:\n   ```bash\n   ng generate module feature-module --route feature --module app.module\n   ```\n   This command creates a module and sets up routing for lazy loading.\n\n2. **Set Up Routing for Lazy Loading:**\n   In your `app-routing.module.ts`, use the `loadChildren` property to specify the module to be lazy loaded:\n   ```typescript\n   const routes: Routes = [\n     {\n       path: 'feature',\n       loadChildren: () => import('./feature-module/feature-module.module').then(m => m.FeatureModuleModule)\n     }\n   ];\n   ```\n\n3. **Configure Routes in the Feature Module:**\n   In `feature-module-routing.module.ts`, define the routes for the feature module:\n   ```typescript\n   const routes: Routes = [\n     { path: '', component: FeatureComponent }\n   ];\n   ```\n\n4. **Access the Lazy Loaded Module:**\n   Now, when you navigate to `/feature`, Angular will load the `FeatureModule` only at that time.\n\n**Key Points:**\n- Lazy loading is implemented using the `loadChildren` property in the route configuration.\n- It helps in optimizing the application's load time and performance.\n- Each lazy-loaded module should have its own routing module.\n\n**Example:**\n```typescript\n// app-routing.module.ts\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)\n  }\n];\n```\n\n**Summary:**  \nLazy loading in Angular is achieved by configuring routes with `loadChildren`, which loads feature modules only when their routes are accessed, resulting in better performance and user experience.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656986Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "15af0419-7a1a-4edd-82de-20244e7208ce",
        "question": "What is an Observable in Angular and how is it used?",
        "answer": "```markdown **Answer:**\n\nIn Angular, an **Observable** is a key part of the reactive programming paradigm provided by the RxJS library. An Observable represents a stream of data that can be observed over time. It can emit multiple values asynchronously—such as data from HTTP requests, user inputs, or other events—and allows components or services to subscribe to these data streams and react accordingly.\n\n### How Observables are Used in Angular\n\n1. **HTTP Requests:**  \n   Angular's `HttpClient` methods (like `get`, `post`, etc.) return Observables. This allows you to subscribe to the response and handle data when it arrives.\n\n   ```typescript\n   this.http.get<User[]>('/api/users').subscribe(users => {\n     this.users = users;\n   });\n   ```\n\n2. **Event Handling:**  \n   Observables can be used to handle events such as user input, form changes, or custom events.\n\n   ```typescript\n   fromEvent(button, 'click').subscribe(() => {\n     console.log('Button clicked!');\n   });\n   ```\n\n3. **Reactive Forms:**  \n   Angular's reactive forms use Observables to listen for value and status changes.\n\n   ```typescript\n   this.form.valueChanges.subscribe(value => {\n     console.log('Form changed:', value);\n   });\n   ```\n\n### Key Features\n\n- **Asynchronous:** Observables handle asynchronous data streams.\n- **Multiple Values:** They can emit multiple values over time (unlike Promises, which resolve once).\n- **Operators:** RxJS provides powerful operators (like `map`, `filter`, `mergeMap`) to transform and combine streams.\n- **Unsubscription:** You can unsubscribe from Observables to prevent memory leaks.\n\n### Example\n\n```typescript\nimport { Observable } from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next('Hello');\n  observer.next('World');\n  observer.complete();\n});\n\nobservable.subscribe({\n  next: value => console.log(value),\n  complete: () => console.log('Done')\n});\n// Output: Hello\n//         World\n//         Done\n```\n\n**In summary:**  \nObservables in Angular are used to handle asynchronous data streams efficiently, making it easier to manage data from various sources and events in a reactive way.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.656999Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "a226f24f-9c87-4367-b0ba-b50a7db57843",
        "question": "How do you handle HTTP requests in Angular?",
        "answer": "```markdown\nIn Angular, HTTP requests are handled using the `HttpClient` service, which is part of the `@angular/common/http` package. To use it, you first need to import the `HttpClientModule` in your application's root module (`AppModule`):\n\n```typescript\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  imports: [\n    // other imports\n    HttpClientModule\n  ],\n})\nexport class AppModule { }\n```\n\nThen, you can inject the `HttpClient` service into your components or services:\n\n```typescript\nimport { HttpClient } from '@angular/common/http';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DataService {\n  constructor(private http: HttpClient) {}\n\n  getData() {\n    return this.http.get('https://api.example.com/data');\n  }\n\n  postData(data: any) {\n    return this.http.post('https://api.example.com/data', data);\n  }\n}\n```\n\nThe `HttpClient` methods (`get`, `post`, `put`, `delete`, etc.) return RxJS `Observable`s, allowing you to handle asynchronous data and chain operators for error handling, transformation, and more:\n\n```typescript\nthis.dataService.getData().subscribe(\n  response => {\n    // handle successful response\n  },\n  error => {\n    // handle error\n  }\n);\n```\n\nFor advanced scenarios, you can use HTTP interceptors to modify requests or responses globally (e.g., for adding authentication tokens or handling errors).\n\n**Summary:**  \n- Import `HttpClientModule` in your module.\n- Inject `HttpClient` where needed.\n- Use its methods to make HTTP requests.\n- Handle responses using RxJS `Observable`s.\n- Use interceptors for cross-cutting concerns.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657012Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "b9534deb-336a-4a52-87b1-bfdde08d9b4e",
        "question": "What is the Angular CLI and what are its main features?",
        "answer": "```markdown **Answer:**\n\nThe **Angular CLI (Command Line Interface)** is a powerful tool that helps developers create, manage, and build Angular applications directly from the command line. It streamlines the development process by automating common tasks and enforcing best practices.\n\n### Main Features of Angular CLI\n\n- **Project Creation:** Easily generate a new Angular project with `ng new`, which sets up the basic structure and configuration.\n- **Code Generation:** Quickly generate components, services, modules, directives, and pipes using commands like `ng generate component my-component`.\n- **Development Server:** Start a local development server with live-reload using `ng serve`, allowing you to see changes instantly.\n- **Build Tools:** Build and optimize your application for production with `ng build`.\n- **Testing:** Run unit tests and end-to-end tests with `ng test` and `ng e2e`.\n- **Linting:** Check your code for errors and style issues using `ng lint`.\n- **Configuration Management:** Easily manage different environments and configurations.\n- **Updating Dependencies:** Simplifies updating Angular and its dependencies with `ng update`.\n\nThe Angular CLI helps developers follow Angular’s best practices and speeds up the development workflow.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.657026Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "6ce256bb-6a4a-4a0d-9c71-bc8e44f01df7",
        "question": "How do you optimize the performance of an Angular application?",
        "answer": "```markdown\n### How do you optimize the performance of an Angular application?\n\nOptimizing the performance of an Angular application involves several strategies across code, template, and build processes. Here are some advanced techniques:\n\n#### 1. **Ahead-of-Time (AOT) Compilation**\n- Use AOT compilation to pre-compile templates and components at build time, reducing the amount of work the browser does at runtime.\n- Enable with: `ng build --prod` (AOT is enabled by default in production builds).\n\n#### 2. **Lazy Loading Modules**\n- Split the application into feature modules and load them on demand using Angular’s router.\n- This reduces the initial bundle size and speeds up the initial load.\n\n#### 3. **Change Detection Strategy**\n- Use `ChangeDetectionStrategy.OnPush` for components where possible. This tells Angular to check for changes only when input properties change, reducing unnecessary checks.\n\n#### 4. **TrackBy in *ngFor**\n- Use the `trackBy` function in `*ngFor` directives to optimize DOM rendering, especially for large lists.\n\n#### 5. **Tree Shaking and Bundle Optimization**\n- Remove unused code and dependencies. Angular CLI and modern bundlers perform tree shaking automatically in production builds.\n- Analyze bundle size with tools like `source-map-explorer` or `webpack-bundle-analyzer`.\n\n#### 6. **Service Workers and Caching**\n- Use Angular Service Worker (`@angular/pwa`) for caching assets and API responses, enabling offline support and faster load times.\n\n#### 7. **Efficient Template Usage**\n- Avoid complex expressions and heavy computations in templates.\n- Use pure pipes instead of methods in templates to prevent unnecessary recalculations.\n\n#### 8. **On-Demand Loading of Assets**\n- Load images, scripts, and stylesheets as needed (lazy loading of assets).\n- Use Angular’s built-in support for lazy loading images with the `loading=\"lazy\"` attribute.\n\n#### 9. **Optimize Change Detection with Detach/Attach**\n- For rarely changing components, manually detach change detection using `ChangeDetectorRef.detach()` and reattach when needed.\n\n#### 10. **Minimize Third-party Dependencies**\n- Audit and remove unnecessary third-party libraries.\n- Import only required modules from libraries (e.g., import specific RxJS operators).\n\n#### 11. **Server-Side Rendering (SSR)**\n- Use Angular Universal for SSR to improve perceived performance and SEO.\n\n#### 12. **HTTP Request Optimization**\n- Use RxJS operators like `debounceTime`, `switchMap`, and `shareReplay` to optimize API calls.\n- Cache HTTP responses where appropriate.\n\n#### 13. **Production Build Optimizations**\n- Always use `ng build --prod` for production deployments, which enables minification, AOT, and other optimizations.\n\n---\n\n**Summary:**  \nPerformance optimization in Angular is a combination of architectural decisions (like lazy loading and SSR), efficient coding practices (like OnPush change detection and trackBy), and leveraging Angular CLI’s build optimizations. Regularly profiling and analyzing your app with tools like Chrome DevTools and Angular DevTools can help identify and address bottlenecks.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657041Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "32cad0c1-9698-4a4e-af33-d1d1d83f2a04",
        "question": "What are guards in Angular routing and how do you implement them?",
        "answer": "```markdown\n**Guards in Angular Routing**\n\nGuards in Angular are interfaces that allow you to control navigation to and from routes. They help protect routes from unauthorized access, prevent users from accidentally leaving a page with unsaved changes, or control the loading of feature modules.\n\nAngular provides several types of guards:\n\n- `CanActivate`: Checks if a route can be activated.\n- `CanActivateChild`: Checks if child routes can be activated.\n- `CanDeactivate`: Checks if a route can be deactivated.\n- `CanLoad`: Checks if a module can be loaded lazily.\n- `Resolve`: Pre-fetches data before route activation.\n\n**Implementation Example: CanActivate Guard**\n\n1. **Create the Guard Service**\n\nGenerate a guard using Angular CLI:\n\n```bash\nng generate guard auth\n```\n\nImplement the logic in the generated service:\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { CanActivate, Router } from '@angular/router';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  constructor(private router: Router) {}\n\n  canActivate(): boolean {\n    const isLoggedIn = /* logic to check if user is authenticated */;\n    if (isLoggedIn) {\n      return true;\n    } else {\n      this.router.navigate(['/login']);\n      return false;\n    }\n  }\n}\n```\n\n2. **Apply the Guard to Routes**\n\nIn your routing module:\n\n```typescript\nimport { AuthGuard } from './auth.guard';\n\nconst routes: Routes = [\n  {\n    path: 'dashboard',\n    component: DashboardComponent,\n    canActivate: [AuthGuard]\n  }\n];\n```\n\n**Summary**\n\nGuards are essential for securing routes and controlling navigation flow in Angular applications. You implement them by creating a guard service that implements the appropriate interface, then applying the guard to routes in your routing configuration.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657054Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "968d25b8-7f98-44ef-aa98-a4cfb47ae7a8",
        "question": "Explain the difference between @Input and @Output decorators.",
        "answer": "```markdown\n**@Input vs @Output Decorators in Angular**\n\nIn Angular, `@Input` and `@Output` are decorators used to facilitate communication between components, specifically between a parent and its child component.\n\n### @Input\n- **Purpose:** Allows a parent component to bind values and pass data into a child component.\n- **Usage:** Decorate a property in the child component with `@Input()`.\n- **Direction:** Data flows **from parent to child**.\n- **Example:**\n  ```typescript\n  // child.component.ts\n  @Input() childProperty: string;\n  ```\n  ```html\n  <!-- parent.component.html -->\n  <app-child [childProperty]=\"parentValue\"></app-child>\n  ```\n\n### @Output\n- **Purpose:** Allows a child component to emit events or data to its parent component.\n- **Usage:** Decorate an `EventEmitter` property in the child component with `@Output()`.\n- **Direction:** Data flows **from child to parent**.\n- **Example:**\n  ```typescript\n  // child.component.ts\n  @Output() notifyParent: EventEmitter<string> = new EventEmitter();\n\n  someMethod() {\n    this.notifyParent.emit('Some data');\n  }\n  ```\n  ```html\n  <!-- parent.component.html -->\n  <app-child (notifyParent)=\"handleNotification($event)\"></app-child>\n  ```\n\n### Summary Table\n\n| Decorator | Direction         | Use Case                      |\n|-----------|-------------------|-------------------------------|\n| @Input    | Parent → Child    | Pass data to child component  |\n| @Output   | Child → Parent    | Send events/data to parent    |\n\n**In summary:**  \n- Use `@Input` to receive data from a parent component.\n- Use `@Output` with `EventEmitter` to send data or events to a parent component.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657068Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "2a85f48e-1241-47fe-9c8b-7f5e5db4434d",
        "question": "What is Change Detection in Angular and how does it work?",
        "answer": "```markdown **Change Detection in Angular**\n\nChange Detection is a core mechanism in Angular that ensures the view (DOM) is always in sync with the underlying component data (model). Whenever the state of the application changes—such as user input, HTTP responses, or timer events—Angular needs to update the view to reflect these changes.\n\n### How Change Detection Works\n\n1. **Component Tree Traversal:**  \n   Angular maintains a tree of components. When change detection runs, it traverses this tree from the root (usually `AppComponent`) down to all child components.\n\n2. **Checking for Changes:**  \n   For each component, Angular compares the current values of data-bound properties (e.g., those used in templates with interpolation `{{ }}` or property bindings `[property]=\"value\"`) with their previous values.\n\n3. **Updating the View:**  \n   If Angular detects a change in any property, it updates the corresponding part of the DOM to reflect the new value.\n\n4. **Change Detection Strategies:**  \n   - **Default:** Angular checks every component in the tree whenever any event occurs (e.g., user input, HTTP response).\n   - **OnPush:** Angular only checks the component when its input properties change or an event is triggered inside the component. This can improve performance for large applications.\n\n### Triggers for Change Detection\n\n- **Events:** User interactions like clicks, input, etc.\n- **Async Operations:** HTTP requests, timers, etc.\n- **Manual Triggers:** Using `ChangeDetectorRef` to manually mark a component for check.\n\n### Example\n\n```typescript\n@Component({\n  selector: 'app-example',\n  template: `<p>{{ counter }}</p>`\n})\nexport class ExampleComponent {\n  counter = 0;\n\n  increment() {\n    this.counter++;\n    // Angular automatically detects this change and updates the view\n  }\n}\n```\n\nWhen `increment()` is called (e.g., via a button click), Angular's change detection will update the displayed `counter` value.\n\n### Summary Table\n\n| Aspect                  | Description                                  |\n|-------------------------|----------------------------------------------|\n| Purpose                 | Syncs view with component data               |\n| How it works            | Traverses component tree, checks bindings    |\n| Strategies              | Default, OnPush                             |\n| Triggers                | Events, async ops, manual triggers           |\n\n---\n\n**In summary:**  \nChange Detection in Angular is the process that keeps the view and model in sync by checking for changes in data and updating the DOM accordingly. It is highly configurable and can be optimized using strategies like `OnPush` for better performance.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657081Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "75424b88-9be5-492f-b9b9-7562fbed09b2",
        "question": "How do you implement unit testing in Angular?",
        "answer": "```markdown\n**How do you implement unit testing in Angular?**\n\nIn Angular, unit testing is typically performed using the Jasmine testing framework along with the Karma test runner. Here’s how you can implement unit testing in an Angular application:\n\n1. **Setup**:  \n   When you create a new Angular project using the Angular CLI (`ng new`), it comes pre-configured with Jasmine and Karma.\n\n2. **Writing Tests**:  \n   - Test files are usually named with the `.spec.ts` suffix.\n   - You write test cases using Jasmine’s `describe`, `it`, `beforeEach`, and assertion functions like `expect`.\n   - For example, to test a component:\n     ```typescript\n     import { ComponentFixture, TestBed } from '@angular/core/testing';\n     import { MyComponent } from './my.component';\n\n     describe('MyComponent', () => {\n       let component: MyComponent;\n       let fixture: ComponentFixture<MyComponent>;\n\n       beforeEach(async () => {\n         await TestBed.configureTestingModule({\n           declarations: [ MyComponent ]\n         })\n         .compileComponents();\n       });\n\n       beforeEach(() => {\n         fixture = TestBed.createComponent(MyComponent);\n         component = fixture.componentInstance;\n         fixture.detectChanges();\n       });\n\n       it('should create', () => {\n         expect(component).toBeTruthy();\n       });\n     });\n     ```\n\n3. **Testing Services**:  \n   - You can inject services using Angular’s dependency injection in your tests.\n   - Use `TestBed.inject()` to get service instances.\n\n4. **Mocking Dependencies**:  \n   - Use Jasmine spies or Angular’s testing utilities to mock dependencies like services or HTTP calls.\n\n5. **Running Tests**:  \n   - Use the Angular CLI command:  \n     ```\n     ng test\n     ```\n   - This will launch Karma, run your tests, and display the results.\n\n6. **Code Coverage**:  \n   - To check code coverage, run:  \n     ```\n     ng test --code-coverage\n     ```\n   - This generates a coverage report in the `/coverage` folder.\n\n**Summary:**  \nAngular provides a robust testing environment out-of-the-box. You write unit tests using Jasmine, configure and run them with Karma, and use Angular’s testing utilities (`TestBed`, `ComponentFixture`, etc.) to create and test components and services in isolation.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657094Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "6bcf4485-a8ca-444b-8a71-277b2b529b92",
        "question": "What is Ahead-of-Time (AOT) compilation in Angular?",
        "answer": "```markdown **Ahead-of-Time (AOT) Compilation in Angular**\n\nAhead-of-Time (AOT) compilation is a process in Angular where the Angular HTML templates and TypeScript code are compiled into efficient JavaScript code during the build phase, before the browser downloads and runs the application.\n\n### Key Points:\n\n- **Compilation at Build Time:** With AOT, Angular compiles your application and libraries at build time, rather than at runtime (which is known as Just-in-Time or JIT compilation).\n- **Faster Rendering:** Since the browser receives pre-compiled code, the application loads and renders faster.\n- **Smaller Bundle Size:** AOT removes unnecessary code and reduces the size of the application bundle.\n- **Early Error Detection:** Errors in templates and code are detected during the build process, leading to fewer runtime errors.\n- **Enhanced Security:** AOT compiles templates into JavaScript, preventing injection attacks that can occur if templates are interpreted at runtime.\n\n### How it works:\n\n1. **Template Compilation:** Angular’s compiler converts HTML templates and Angular decorators into JavaScript code.\n2. **Type Checking:** The compiler checks for errors in templates and code.\n3. **Bundle Generation:** The compiled code is bundled and shipped to the browser.\n\n### Usage:\n\nAOT compilation can be enabled by default in Angular CLI production builds:\n\n```bash\nng build --prod\n```\n\nOr explicitly:\n\n```bash\nng build --aot\n```\n\n### Summary Table\n\n| Feature                | AOT Compilation           | JIT Compilation           |\n|------------------------|---------------------------|---------------------------|\n| Compilation Time       | Build time                | Runtime                   |\n| App Load Time          | Faster                    | Slower                    |\n| Error Detection        | Build time                | Runtime                   |\n| Bundle Size            | Smaller                   | Larger                    |\n| Security               | More secure               | Less secure               |\n\n**In summary:**  \nAOT compilation in Angular improves application performance, security, and reliability by compiling code and templates during the build process, resulting in faster and safer applications.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657108Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "92d022b1-d6d9-4ea9-99a8-19692cf8f631",
        "question": "Explain the concept of Angular Zones.",
        "answer": "```markdown ### Angular Zones Explained\n\nAngular Zones are a core concept that help Angular detect and respond to asynchronous operations, enabling its powerful change detection mechanism.\n\n#### What is a Zone?\n\nA **Zone** is an execution context that persists across asynchronous tasks. In Angular, zones are implemented using the [zone.js](https://github.com/angular/zone.js/) library. They allow Angular to know when to trigger change detection by tracking asynchronous activities like:\n\n- HTTP requests\n- Timers (`setTimeout`, `setInterval`)\n- User events (clicks, keypresses)\n- Promises\n\n#### How do Angular Zones Work?\n\n1. **Zone Creation:** When your Angular app starts, it runs inside a special zone called `NgZone`.\n2. **Task Tracking:** Any asynchronous task initiated within this zone is tracked.\n3. **Change Detection Trigger:** When an async task completes (e.g., an HTTP request returns), zone.js notifies Angular, which then runs change detection to update the UI if necessary.\n\n#### Example\n\n```typescript\nimport { Component, NgZone } from '@angular/core';\n\n@Component({\n  selector: 'app-zone-demo',\n  template: `<p>{{message}}</p>`\n})\nexport class ZoneDemoComponent {\n  message = 'Waiting...';\n\n  constructor(private ngZone: NgZone) {\n    setTimeout(() => {\n      this.message = 'Updated inside Angular Zone!';\n      // Angular automatically detects this change\n    }, 1000);\n  }\n}\n```\n\n#### Running Code Outside Angular Zone\n\nSometimes, you want to run code outside Angular's zone to avoid unnecessary change detection cycles (for performance optimization):\n\n```typescript\nthis.ngZone.runOutsideAngular(() => {\n  // Code here will not trigger change detection\n  setTimeout(() => {\n    // If you want to update the UI, re-enter the Angular zone:\n    this.ngZone.run(() => {\n      this.message = 'Updated after running outside Angular Zone!';\n    });\n  }, 1000);\n});\n```\n\n#### Key Points\n\n- **Zones** enable Angular to automatically detect and respond to async operations.\n- **NgZone** service allows you to control when code runs inside or outside Angular’s zone.\n- **Performance Optimization:** Running heavy or frequent async tasks outside the Angular zone can improve performance by reducing unnecessary change detection cycles.\n\n#### References\n\n- [Angular Docs: NgZone](https://angular.io/api/core/NgZone)\n- [zone.js GitHub](https://github.com/angular/zone.js/)\n\n---\n\n**In summary:** Angular Zones are essential for automatic change detection in response to asynchronous events, making Angular apps reactive and efficient.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657121Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "306675e0-9836-4fb7-81ca-7f6ae873aeb0",
        "question": "How do you handle errors in Angular applications?",
        "answer": "```markdown\nIn Angular applications, error handling can be managed at various levels to ensure a robust and user-friendly experience. Here are some common approaches:\n\n### 1. **Using `try-catch` Blocks**\nFor synchronous code or specific operations, you can use standard JavaScript `try-catch` blocks to handle errors:\n\n```typescript\ntry {\n  // risky operation\n} catch (error) {\n  // handle error\n}\n```\n\n### 2. **Handling HTTP Errors with `HttpClient`**\nWhen making HTTP requests, Angular's `HttpClient` returns Observables, which can emit errors. You can use the `catchError` operator from RxJS to handle these:\n\n```typescript\nimport { catchError } from 'rxjs/operators';\nimport { throwError } from 'rxjs';\n\nthis.http.get('api/data').pipe(\n  catchError(error => {\n    // handle the error\n    return throwError(() => error);\n  })\n).subscribe({\n  next: data => { /* handle data */ },\n  error: err => { /* handle error */ }\n});\n```\n\n### 3. **Global Error Handling with `ErrorHandler`**\nAngular provides a built-in `ErrorHandler` class. You can create a custom error handler by extending this class and providing it in your app module:\n\n```typescript\nimport { ErrorHandler, Injectable } from '@angular/core';\n\n@Injectable()\nexport class GlobalErrorHandler implements ErrorHandler {\n  handleError(error: any): void {\n    // Log the error or show a user-friendly message\n    console.error('An error occurred:', error);\n  }\n}\n\n// In app.module.ts\nproviders: [{ provide: ErrorHandler, useClass: GlobalErrorHandler }]\n```\n\n### 4. **Route Guards and Resolver Error Handling**\nFor navigation errors, you can handle them in route guards or resolvers and redirect users as needed.\n\n### 5. **User Feedback**\nAlways provide meaningful feedback to users when errors occur, such as displaying error messages or notifications.\n\n---\n\n**Summary:**  \nError handling in Angular involves using `try-catch` for synchronous code, `catchError` for Observables (especially HTTP requests), implementing a global error handler with `ErrorHandler`, and providing user feedback. This layered approach ensures errors are managed gracefully throughout the application.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657135Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "9a43d86d-1170-43ac-b1a8-46d5df085496",
        "question": "What is the difference between ngIf and ngFor directives?",
        "answer": "```markdown **Answer:**\n\nIn Angular, both `*ngIf` and `*ngFor` are structural directives, but they serve different purposes:\n\n- **`*ngIf` Directive:**\n  - Used to conditionally include or remove an element from the DOM based on a boolean expression.\n  - If the expression evaluates to `true`, the element is rendered; if `false`, it is not.\n\n  ```html\n  <div *ngIf=\"isVisible\">This will be shown if isVisible is true.</div>\n  ```\n\n- **`*ngFor` Directive:**\n  - Used to repeat an element for each item in a collection (like an array).\n  - It creates a template for each item in the list.\n\n  ```html\n  <ul>\n    <li *ngFor=\"let item of items\">{{ item }}</li>\n  </ul>\n  ```\n\n**Summary Table:**\n\n| Directive | Purpose                                    | Example Usage                              |\n|-----------|--------------------------------------------|--------------------------------------------|\n| `*ngIf`   | Conditionally adds/removes elements        | `<div *ngIf=\"show\">Content</div>`          |\n| `*ngFor`  | Repeats elements for each item in a list   | `<li *ngFor=\"let x of list\">{{ x }}</li>`  |\n\n**In short:**  \n- Use `*ngIf` for conditional rendering.\n- Use `*ngFor` for looping through collections.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.657148Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "e557133a-b21e-4b36-981f-efc74e59bd01",
        "question": "How do you share data between unrelated components?",
        "answer": "```markdown\nTo share data between unrelated components in Angular (components that do not have a direct parent-child relationship), you typically use a shared service. Here’s how it works:\n\n1. **Create a Shared Service**  \n   Create an Angular service using the CLI or manually. This service will act as a central hub for the data you want to share.\n\n   ```typescript\n   import { Injectable } from '@angular/core';\n   import { BehaviorSubject } from 'rxjs';\n\n   @Injectable({\n     providedIn: 'root'\n   })\n   export class DataService {\n     private dataSource = new BehaviorSubject<any>(null);\n     currentData = this.dataSource.asObservable();\n\n     changeData(data: any) {\n       this.dataSource.next(data);\n     }\n   }\n   ```\n\n2. **Inject the Service in Both Components**  \n   Inject the shared service into the constructors of the components that need to share data.\n\n   ```typescript\n   constructor(private dataService: DataService) { }\n   ```\n\n3. **Send Data from One Component**  \n   Use the service method to update the data.\n\n   ```typescript\n   this.dataService.changeData('New Data');\n   ```\n\n4. **Receive Data in Another Component**  \n   Subscribe to the observable in the other component to receive updates.\n\n   ```typescript\n   this.dataService.currentData.subscribe(data => {\n     this.sharedData = data;\n   });\n   ```\n\n**Summary:**  \nBy using a shared service with RxJS subjects or observables, you can efficiently share and synchronize data between unrelated components in Angular.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657161Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "127c1edd-6064-45e1-ad3c-7bb133ebd882",
        "question": "What is the purpose of the async pipe in Angular?",
        "answer": "```markdown The **async pipe** in Angular is used to automatically subscribe to observables or promises and render their emitted values in the template. It also handles unsubscribing when the component is destroyed, which helps prevent memory leaks.\n\n**Key purposes of the async pipe:**\n\n- **Automatic Subscription:** Subscribes to an observable or promise and returns the latest value emitted.\n- **Automatic Unsubscription:** Unsubscribes when the component is destroyed, reducing the risk of memory leaks.\n- **Simplifies Code:** Eliminates the need for manual subscription and unsubscription in the component class.\n\n**Example:**\n\n```html\n<!-- Assume 'data$' is an Observable in the component -->\n<div *ngIf=\"data$ | async as data\">\n  {{ data }}\n</div>\n```\n\nIn this example, the async pipe subscribes to `data$`, assigns the emitted value to `data`, and updates the view automatically when new values are emitted.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657174Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "e0048254-5731-4c81-b76e-997152005473",
        "question": "How do you secure an Angular application?",
        "answer": "```markdown ### How do you secure an Angular application?\n\nSecuring an Angular application involves multiple layers, as Angular is a client-side framework and cannot provide complete security on its own. Here are key strategies to secure an Angular application:\n\n#### 1. **Authentication and Authorization**\n- **Use strong authentication:** Integrate with secure authentication providers (OAuth, OpenID Connect, JWT, etc.).\n- **Route Guards:** Use Angular’s `CanActivate`, `CanLoad`, and other guards to restrict access to routes based on user roles or authentication status.\n- **Never trust client-side checks:** Always enforce authorization on the backend as well.\n\n#### 2. **Protect Against Cross-Site Scripting (XSS)**\n- **Angular’s built-in sanitization:** Angular automatically escapes data binding expressions, reducing XSS risks.\n- **Avoid bypassing sanitization:** Do not use `innerHTML` or Angular’s `DomSanitizer.bypassSecurityTrust...` methods unless absolutely necessary and safe.\n- **Content Security Policy (CSP):** Implement CSP headers on the server to prevent injection of malicious scripts.\n\n#### 3. **Prevent Cross-Site Request Forgery (CSRF)**\n- **Use tokens:** For state-changing operations, use anti-CSRF tokens provided by your backend.\n- **SameSite cookies:** Configure cookies with the `SameSite` attribute to restrict cross-origin requests.\n\n#### 4. **Secure API Communication**\n- **HTTPS only:** Always use HTTPS to encrypt data in transit.\n- **Token storage:** Store authentication tokens in memory or in secure, HttpOnly cookies. Avoid localStorage/sessionStorage for sensitive data.\n- **CORS:** Configure Cross-Origin Resource Sharing (CORS) on the backend to allow only trusted domains.\n\n#### 5. **Avoid Sensitive Data Exposure**\n- **No secrets in source code:** Never store API keys, secrets, or credentials in the Angular codebase.\n- **Environment files:** Use Angular’s environment files for configuration, but remember these are still part of the client bundle.\n\n#### 6. **Keep Dependencies Updated**\n- **Regularly update Angular and dependencies:** Use tools like `npm audit` to detect vulnerabilities.\n- **Remove unused packages:** Minimize the attack surface by removing unnecessary dependencies.\n\n#### 7. **Other Best Practices**\n- **Disable debug tools in production:** Ensure Angular’s debug tools and error messages are disabled in production builds.\n- **Minimize information leakage:** Avoid exposing stack traces or internal error details to users.\n- **Input validation:** Validate and sanitize all user inputs both on the client and server sides.\n\n---\n\n> **Note:** While Angular provides many security features, true security must be enforced on the server-side. The client-side can be manipulated by users, so never rely solely on Angular for critical security controls.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657188Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "cb5df084-415c-4d63-ab3e-d0fad208a3d1",
        "question": "How do you use interceptors in Angular?",
        "answer": "```markdown\n### How do you use interceptors in Angular?\n\nIn Angular, **interceptors** are used to intercept and modify HTTP requests and responses globally before they are handled by the application's code. They are commonly used for tasks such as adding authentication tokens, logging, error handling, or modifying request/response data.\n\n#### Steps to Use Interceptors in Angular\n\n1. **Create an Interceptor Service**\n\n   Implement the `HttpInterceptor` interface by creating a service:\n\n   ```typescript\n   import { Injectable } from '@angular/core';\n   import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';\n   import { Observable } from 'rxjs';\n\n   @Injectable()\n   export class AuthInterceptor implements HttpInterceptor {\n     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n       // Clone the request to add the new header\n       const authReq = req.clone({\n         setHeaders: { Authorization: `Bearer YOUR_TOKEN_HERE` }\n       });\n       // Pass the cloned request instead of the original request to the next handle\n       return next.handle(authReq);\n     }\n   }\n   ```\n\n2. **Provide the Interceptor**\n\n   Register the interceptor in your module's `providers` array using the `HTTP_INTERCEPTORS` injection token:\n\n   ```typescript\n   import { HTTP_INTERCEPTORS } from '@angular/common/http';\n\n   @NgModule({\n     // ...\n     providers: [\n       {\n         provide: HTTP_INTERCEPTORS,\n         useClass: AuthInterceptor,\n         multi: true\n       }\n     ]\n   })\n   export class AppModule { }\n   ```\n\n   The `multi: true` option allows you to register multiple interceptors.\n\n3. **Chaining Multiple Interceptors**\n\n   If you have more than one interceptor, Angular will call them in the order they are provided. Each interceptor can modify the request or response as needed.\n\n#### Key Points\n\n- Interceptors are singletons and should be stateless.\n- They can be used for authentication, logging, error handling, and more.\n- Always return `next.handle()` to pass the request to the next interceptor or to the backend.\n- You can handle errors globally by using RxJS operators like `catchError` inside the interceptor.\n\n#### Example: Error Handling Interceptor\n\n```typescript\nimport { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\n@Injectable()\nexport class ErrorInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req).pipe(\n      catchError((error: HttpErrorResponse) => {\n        // Handle error\n        console.error('Error intercepted:', error);\n        return throwError(() => error);\n      })\n    );\n  }\n}\n```\n\n**Summary:**  \nInterceptors in Angular are powerful tools for handling cross-cutting concerns related to HTTP requests and responses, such as authentication, logging, and error handling, in a centralized and reusable way.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657229Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "e21dbd8b-0d64-41d1-ba31-e758b9f5b93a",
        "question": "What is the difference between pure and impure pipes?",
        "answer": "```markdown **Difference Between Pure and Impure Pipes in Angular**\n\nIn Angular, pipes are used to transform data in templates. Pipes can be either **pure** or **impure**, and understanding the difference is important for performance and correctness.\n\n| Aspect         | Pure Pipe                                   | Impure Pipe                                   |\n|----------------|---------------------------------------------|-----------------------------------------------|\n| **Definition** | A pipe that Angular executes only when it detects a pure change to the input value (primitive change or object reference change). | A pipe that Angular executes on every change detection cycle, regardless of whether the input value has changed. |\n| **Declaration**| Default behavior; just use `@Pipe({ name: 'pipeName' })` | Explicitly set with `@Pipe({ name: 'pipeName', pure: false })` |\n| **Performance**| More efficient, as it runs less frequently.  | Less efficient, as it runs very often.        |\n| **Use Case**   | Suitable for stateless, deterministic transformations (e.g., formatting dates, numbers, strings). | Used when the pipe depends on mutable objects or external state (e.g., filtering arrays, updating based on user input). |\n| **Example**    | `{{ birthday | date }}`                     | `{{ items | filter:searchTerm }}`             |\n\n**Summary:**  \n- **Pure pipes** are ideal for most use cases and are the default.  \n- **Impure pipes** should be used sparingly, only when you need to react to changes within objects or arrays themselves, not just their references.\n\n**Example Declaration:**\n\n```typescript\n@Pipe({\n  name: 'myPipe',\n  pure: false // This makes it an impure pipe\n})\nexport class MyPipe implements PipeTransform {\n  transform(value: any, ...args: any[]): any {\n    // transformation logic\n  }\n}\n```\n\n**Recommendation:**  \nUse pure pipes whenever possible for better performance. Use impure pipes only when necessary.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657242Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "1ee189af-90c1-43e9-a699-969b0181baf1",
        "question": "How do you implement internationalization (i18n) in Angular?",
        "answer": "```markdown\n### How do you implement internationalization (i18n) in Angular?\n\nAngular provides built-in support for internationalization (i18n) to help you translate your application into different languages and locales. Here’s how you can implement i18n in Angular:\n\n#### 1. **Mark Text for Translation**\nUse the `i18n` attribute in your templates to mark text for translation:\n```html\n<h1 i18n>Welcome to our application!</h1>\n```\n\n#### 2. **Extract Translation Strings**\nUse the Angular CLI to extract marked text into a source translation file (usually in XLIFF format):\n```bash\nng extract-i18n --output-path src/locale\n```\nThis generates a file like `messages.xlf` containing all marked strings.\n\n#### 3. **Translate the Strings**\nCreate copies of the source translation file for each target language (e.g., `messages.fr.xlf` for French) and provide translations for each string.\n\n#### 4. **Configure the Application for Each Locale**\nUpdate the `angular.json` file to define build configurations for each locale:\n```json\n\"configurations\": {\n  \"fr\": {\n    \"localize\": [\"fr\"],\n    \"outputPath\": \"dist/my-app-fr\"\n  },\n  \"es\": {\n    \"localize\": [\"es\"],\n    \"outputPath\": \"dist/my-app-es\"\n  }\n}\n```\n\n#### 5. **Build the Application for Each Locale**\nBuild the app for a specific locale using:\n```bash\nng build --localize\n```\nThis will generate separate builds for each configured locale.\n\n#### 6. **Set the Locale at Runtime (Optional)**\nFor advanced use-cases (like runtime language switching), you might use third-party libraries such as [ngx-translate](https://github.com/ngx-translate/core), as Angular’s built-in i18n is compile-time only.\n\n#### 7. **Format Data According to Locale**\nAngular pipes such as `DatePipe`, `CurrencyPipe`, and `DecimalPipe` automatically format data based on the current locale.\n\n---\n\n**Summary Table**\n\n| Step                       | Description                                      |\n|----------------------------|--------------------------------------------------|\n| Mark text                  | Use `i18n` attribute in templates                |\n| Extract translations       | `ng extract-i18n` to generate XLIFF file         |\n| Translate                  | Create and edit translation files per language   |\n| Configure builds           | Update `angular.json` for each locale            |\n| Build localized versions   | `ng build --localize`                            |\n| (Optional) Runtime i18n    | Use libraries like `ngx-translate`               |\n\n**References:**\n- [Angular i18n Guide](https://angular.io/guide/i18n-overview)\n- [ngx-translate](https://github.com/ngx-translate/core)\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657255Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "96833952-d63e-408b-affc-9ff3253c2164",
        "question": "What is the Renderer2 service in Angular?",
        "answer": "```markdown **Renderer2 Service in Angular**\n\nThe `Renderer2` service in Angular is an abstraction provided by Angular to safely and efficiently manipulate the DOM (Document Object Model) elements, attributes, properties, and classes. It is part of Angular's platform-browser package and is typically injected into components or directives.\n\n### Why Use Renderer2?\n\nDirect DOM manipulation (e.g., using `document` or `element.nativeElement`) can make your application less secure, less portable, and harder to test. `Renderer2` provides a platform-independent way to interact with the DOM, supporting server-side rendering (Angular Universal), Web Workers, and future rendering environments.\n\n### Key Features\n\n- **Platform Agnostic:** Works across different platforms (browser, server, web worker).\n- **Security:** Helps prevent XSS attacks by sanitizing inputs.\n- **Testability:** Easier to mock and test compared to direct DOM access.\n\n### Common Methods\n\n- `createElement(name: string, namespace?: string): any`\n- `createText(value: string): any`\n- `appendChild(parent: any, newChild: any): void`\n- `removeChild(parent: any, oldChild: any, isHostElement?: boolean): void`\n- `setAttribute(el: any, name: string, value: string, namespace?: string): void`\n- `removeAttribute(el: any, name: string, namespace?: string): void`\n- `addClass(el: any, name: string): void`\n- `removeClass(el: any, name: string): void`\n- `setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void`\n- `removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void`\n- `listen(target: any, eventName: string, callback: (event: any) => boolean | void): () => void`\n\n### Example Usage\n\n```typescript\nimport { Component, ElementRef, Renderer2 } from '@angular/core';\n\n@Component({\n  selector: 'app-example',\n  template: `<button (click)=\"changeColor()\">Change Color</button>`\n})\nexport class ExampleComponent {\n  constructor(private renderer: Renderer2, private el: ElementRef) {}\n\n  changeColor() {\n    this.renderer.setStyle(this.el.nativeElement, 'color', 'red');\n  }\n}\n```\n\n### Summary\n\n`Renderer2` is a powerful service in Angular that provides a safe, consistent, and platform-independent API for DOM manipulation, making your applications more robust and maintainable.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657269Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "69420808-6f50-4170-a74a-19d6be8975ac",
        "question": "How does Angular handle forms validation?",
        "answer": "```markdown Angular provides robust form validation mechanisms through two main approaches: **template-driven forms** and **reactive forms**.\n\n### 1. Template-driven Forms\n\n- **Validation Directives:** Angular offers built-in directives such as `required`, `minlength`, `maxlength`, `pattern`, etc., which can be added directly to form controls in the template.\n- **NgModel:** The `ngModel` directive binds form inputs to model properties and tracks their state and validity.\n- **Form State:** Angular automatically tracks the validity and state (touched, dirty, pristine, etc.) of each form control.\n- **Error Display:** You can use the form control’s error properties (e.g., `formControl.errors`) to display validation messages in the template.\n\n**Example:**\n```html\n<input name=\"email\" ngModel required email>\n<div *ngIf=\"email.invalid && email.touched\">\n  Email is invalid.\n</div>\n```\n\n### 2. Reactive Forms\n\n- **FormControl and FormGroup:** You define form controls and groups in the component class, allowing for more explicit and programmatic control.\n- **Validators:** Angular provides a set of built-in validators (e.g., `Validators.required`, `Validators.minLength`) that can be applied when creating form controls.\n- **Custom Validators:** You can also write custom synchronous or asynchronous validators.\n- **Validation Status:** The validity and state of each control are available via properties like `formControl.valid`, `formControl.errors`, etc.\n\n**Example:**\n```typescript\nform = new FormGroup({\n  email: new FormControl('', [Validators.required, Validators.email])\n});\n```\n```html\n<input [formControl]=\"form.get('email')\">\n<div *ngIf=\"form.get('email').invalid && form.get('email').touched\">\n  Email is invalid.\n</div>\n```\n\n### Summary Table\n\n| Feature                | Template-driven Forms         | Reactive Forms           |\n|------------------------|------------------------------|--------------------------|\n| Setup                  | In template                  | In component class       |\n| Validators             | Directives in template       | Functions in code        |\n| Custom Validators      | Limited                      | Fully supported          |\n| Form State Tracking    | Automatic                    | Explicit                 |\n\n**In summary:**  \nAngular handles form validation by providing built-in validators, state tracking, and error reporting for both template-driven and reactive forms, allowing developers to ensure data integrity and provide user feedback efficiently.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657282Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "ebf8bdf1-1d06-4086-9b13-af86157a89eb",
        "question": "What is the difference between ViewChild and ContentChild?",
        "answer": "```markdown **ViewChild vs. ContentChild in Angular**\n\nIn Angular, both `ViewChild` and `ContentChild` are decorators used to access child components, directives, or DOM elements, but they serve different purposes and are used in different contexts.\n\n---\n\n### `@ViewChild`\n\n- **Purpose:** Accesses a child component, directive, or DOM element from the component’s own template (view).\n- **When to use:** When you want to interact with elements that are declared *inside the component’s template*.\n- **Example:**\n\n  ```typescript\n  @ViewChild('myInput') inputElement: ElementRef;\n\n  // In template:\n  // <input #myInput>\n  ```\n\n---\n\n### `@ContentChild`\n\n- **Purpose:** Accesses a child component, directive, or DOM element that is *projected* into the component using `<ng-content>`.\n- **When to use:** When you want to interact with elements that are passed from a parent component and projected into the child via content projection.\n- **Example:**\n\n  ```typescript\n  @ContentChild('projectedContent') content: ElementRef;\n\n  // In parent template:\n  // <app-child>\n  //   <span #projectedContent>Projected!</span>\n  // </app-child>\n  ```\n\n---\n\n### **Summary Table**\n\n| Decorator     | Accesses elements from...         | Typical Use Case                        |\n|---------------|----------------------------------|-----------------------------------------|\n| `@ViewChild`  | Component’s own template (view)  | Accessing template refs, child components|\n| `@ContentChild`| Projected content via `<ng-content>` | Accessing projected content             |\n\n---\n\n### **Key Difference**\n\n- **`ViewChild`** is for elements *inside* the component’s template.\n- **`ContentChild`** is for elements *projected* into the component from its parent.\n\n---\n\n**In short:**  \n- Use `ViewChild` for direct children in the view.  \n- Use `ContentChild` for content projected from outside via `<ng-content>`.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657296Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "9f96167b-3d4e-4665-97ca-245fea02d5ff",
        "question": "How do you use Angular animations?",
        "answer": "```markdown\nTo use Angular animations, you need to leverage the `@angular/animations` package. Here’s how you can implement animations in Angular:\n\n1. **Import the Animations Module:**\n   Add `BrowserAnimationsModule` to your app module imports:\n   ```typescript\n   import { BrowserAnimationsModule } from '@angular/platform-browser/animations';\n\n   @NgModule({\n     imports: [\n       BrowserAnimationsModule,\n       // other imports\n     ]\n   })\n   export class AppModule { }\n   ```\n\n2. **Import Animation Functions:**\n   Import animation functions such as `trigger`, `state`, `style`, `transition`, and `animate` from `@angular/animations` in your component:\n   ```typescript\n   import { trigger, state, style, transition, animate } from '@angular/animations';\n   ```\n\n3. **Define Animations in the Component:**\n   Use the `animations` property in your component decorator:\n   ```typescript\n   @Component({\n     selector: 'app-example',\n     templateUrl: './example.component.html',\n     animations: [\n       trigger('openClose', [\n         state('open', style({\n           height: '200px',\n           opacity: 1,\n           backgroundColor: 'yellow'\n         })),\n         state('closed', style({\n           height: '100px',\n           opacity: 0.5,\n           backgroundColor: 'green'\n         })),\n         transition('open <=> closed', [\n           animate('0.5s')\n         ]),\n       ])\n     ]\n   })\n   export class ExampleComponent {\n     isOpen = true;\n     toggle() {\n       this.isOpen = !this.isOpen;\n     }\n   }\n   ```\n\n4. **Bind the Animation in the Template:**\n   Use the animation trigger in your template:\n   ```html\n   <div [@openClose]=\"isOpen ? 'open' : 'closed'\">\n     The box is {{ isOpen ? 'Open' : 'Closed' }}!\n   </div>\n   <button (click)=\"toggle()\">Toggle</button>\n   ```\n\n**Summary:**  \nAngular animations are defined using triggers and states in the component’s metadata, and bound to elements in the template. You can animate properties such as style, position, and opacity, and control transitions between states using the `@angular/animations` API.\n```",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657309Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "c98a3f48-d787-4213-8748-f553f72da960",
        "question": "What is the purpose of the ng-content directive?",
        "answer": "```markdown **Answer:**\n\nThe `ng-content` directive in Angular is used for content projection. It allows you to insert, or \"project,\" external content into a component's template. This is especially useful when creating reusable components, such as modals, cards, or tabs, where you want the parent component to provide custom content to be displayed inside the child component.\n\n**Example:**\n\n```typescript\n// card.component.html\n<div class=\"card\">\n  <ng-content></ng-content>\n</div>\n```\n\n```html\n<!-- parent.component.html -->\n<app-card>\n  <h2>Title</h2>\n  <p>This is projected content!</p>\n</app-card>\n```\n\n**Purpose:**\n\n- Enables flexible and reusable components.\n- Allows parent components to pass in custom HTML or Angular components to child components.\n- Supports advanced scenarios like multi-slot content projection using selectors.\n\n**In summary:**  \n`ng-content` is Angular’s way of implementing content projection, making it possible to build highly customizable and reusable UI components.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657322Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "b1cfb8e8-dd76-49e7-9fad-cbae5d1501e7",
        "question": "How do you implement server-side rendering in Angular?",
        "answer": "```markdown\n**Implementing Server-Side Rendering (SSR) in Angular**\n\nServer-Side Rendering (SSR) in Angular is achieved using Angular Universal. SSR allows you to render your Angular application on the server, which improves performance, SEO, and the initial load time.\n\n**Steps to Implement SSR in Angular:**\n\n1. **Add Angular Universal to Your Project**\n   Use the Angular CLI to add Universal support:\n   ```bash\n   ng add @nguniversal/express-engine\n   ```\n   This command:\n   - Installs necessary dependencies.\n   - Updates your `angular.json`.\n   - Creates a server-side app module (`app.server.module.ts`).\n   - Generates a server entry point (`main.server.ts`).\n   - Sets up an Express server (`server.ts`).\n\n2. **Build the Application for SSR**\n   Build both the browser and server bundles:\n   ```bash\n   npm run build:ssr\n   ```\n   This generates the `dist/` folder with both browser and server outputs.\n\n3. **Serve the Application Using Node.js**\n   Start the Express server to serve the SSR app:\n   ```bash\n   npm run serve:ssr\n   ```\n   The server will render your Angular app on the server and send the pre-rendered HTML to the client.\n\n4. **Update Application Logic (if needed)**\n   - Use Angular’s `isPlatformBrowser` and `isPlatformServer` utilities to differentiate between server and browser environments.\n   - Avoid using browser-specific APIs (like `window`, `document`) directly in your code. Use Angular’s `PLATFORM_ID` injection token for platform checks.\n\n5. **SEO and Performance Benefits**\n   - SSR improves SEO by providing fully rendered pages to search engines.\n   - Faster first contentful paint for users.\n\n**Example: Platform Detection**\n```typescript\nimport { isPlatformBrowser } from '@angular/common';\nimport { Inject, PLATFORM_ID } from '@angular/core';\n\nconstructor(@Inject(PLATFORM_ID) private platformId: Object) {\n  if (isPlatformBrowser(this.platformId)) {\n    // Code that runs only in the browser\n  }\n}\n```\n\n**Summary Table**\n\n| Step                        | Command/Action                                   |\n|-----------------------------|--------------------------------------------------|\n| Add Universal               | `ng add @nguniversal/express-engine`             |\n| Build SSR                   | `npm run build:ssr`                              |\n| Serve SSR                   | `npm run serve:ssr`                              |\n| Platform-specific code      | Use `isPlatformBrowser`/`isPlatformServer`       |\n\n**References:**\n- [Angular Universal Official Guide](https://angular.io/guide/universal)\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657335Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "66c7861e-b153-40e7-97ce-c135adb6ea82",
        "question": "What are the main differences between Angular and React?",
        "answer": "```markdown **Answer:**\n\nThe main differences between Angular and React are:\n\n| Feature          | Angular                                      | React                                  |\n|------------------|----------------------------------------------|----------------------------------------|\n| **Type**         | Full-fledged framework                       | Library for building UI                |\n| **Language**     | TypeScript (primarily)                       | JavaScript (JSX)                       |\n| **Data Binding** | Two-way data binding                         | One-way data binding                   |\n| **DOM**          | Real DOM                                     | Virtual DOM                            |\n| **Learning Curve** | Steeper (more concepts to learn)           | Gentler (focuses mainly on UI)         |\n| **Architecture** | Opinionated, includes routing, state, etc.   | Unopinionated, needs extra libraries   |\n| **Templates**    | HTML templates with Angular directives       | JSX (JavaScript + HTML)                |\n| **Community**    | Backed by Google, large enterprise support   | Backed by Facebook, huge open-source   |\n\n**Summary:**  \nAngular is a comprehensive framework with built-in solutions for routing, state management, and more, using TypeScript and two-way data binding. React is a flexible library focused on building UI components, using JSX and one-way data flow, and relies on additional libraries for advanced features.",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.657349Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "82a7f866-5bc1-404c-87a9-121114bcbfd7",
        "question": "How do you debug an Angular application?",
        "answer": "```markdown ### How do you debug an Angular application?\n\nDebugging an Angular application involves several strategies and tools to identify and fix issues efficiently:\n\n1. **Browser Developer Tools**\n   - Use Chrome DevTools or similar browser tools to inspect elements, view console logs, set breakpoints, and monitor network requests.\n   - The **Sources** tab allows you to set breakpoints in TypeScript files (with source maps enabled).\n\n2. **Angular CLI Debugging**\n   - Run your app with `ng serve --source-map` to enable source maps, making it easier to debug TypeScript code directly in the browser.\n\n3. **Console Logging**\n   - Use `console.log()`, `console.warn()`, and `console.error()` to output variable values and track code execution flow.\n\n4. **Augury Extension**\n   - Install the [Augury](https://augury.rangle.io/) Chrome extension to inspect Angular component trees, routes, and state.\n\n5. **Debugger Statement**\n   - Insert the `debugger;` statement in your TypeScript code to pause execution at a specific line when DevTools are open.\n\n6. **Error Messages and Stack Traces**\n   - Pay attention to Angular’s error messages and stack traces in the console, which often provide hints about the source of the problem.\n\n7. **Unit and Integration Tests**\n   - Write and run tests using Jasmine and Karma to catch bugs early and ensure code behaves as expected.\n\n8. **Change Detection Debugging**\n   - Use `ChangeDetectionStrategy` and `ngOnChanges` hooks to track how and when data changes in your components.\n\n9. **Network Tab**\n   - Monitor HTTP requests and responses to ensure APIs are called correctly and data is received as expected.\n\n10. **Hot Module Replacement (HMR)**\n    - Enable HMR with Angular CLI to see changes instantly without losing application state, making iterative debugging faster.\n\nBy combining these tools and techniques, you can systematically identify and resolve issues in your Angular applications.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657362Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "fb5a5347-cdc7-4451-84df-ef8a6b7f7c80",
        "question": "What is the Ivy renderer in Angular?",
        "answer": "```markdown **Ivy Renderer in Angular**\n\nIvy is the next-generation rendering engine and compilation pipeline introduced in Angular version 9. It replaces the older View Engine and brings significant improvements to how Angular applications are built and run.\n\n### Key Features of Ivy\n\n- **Smaller Bundle Sizes:** Ivy generates more efficient code, resulting in smaller JavaScript bundles and faster load times.\n- **Faster Compilation:** The build and rebuild times are improved, making development more productive.\n- **Better Debugging:** Ivy provides more helpful error messages and improved stack traces, making it easier to debug applications.\n- **Improved Type Checking:** Enhanced type checking at build time helps catch more errors early.\n- **Lazy Loading of Components:** Ivy enables lazy loading of individual components, not just modules, allowing for more granular code splitting.\n- **Backward Compatibility:** Applications built with View Engine can be upgraded to Ivy with minimal changes.\n\n### How Ivy Works\n\n- **Incremental DOM:** Ivy uses an incremental DOM approach, where the framework generates instructions for creating and updating the DOM, rather than using a virtual DOM.\n- **Tree-Shakable Code:** Ivy generates code that is more tree-shakable, meaning unused parts of Angular can be removed during the build process.\n- **Locality Principle:** Each component is compiled independently, which improves build times and makes it easier to ship and share components.\n\n### Summary Table\n\n| Feature                | View Engine         | Ivy Renderer        |\n|------------------------|--------------------|---------------------|\n| Bundle Size            | Larger             | Smaller             |\n| Compilation Speed      | Slower             | Faster              |\n| Debugging              | Limited            | Improved            |\n| Lazy Loading           | Modules only       | Modules & Components|\n| Tree Shaking           | Limited            | Advanced            |\n\n**In summary:**  \nIvy is Angular’s modern rendering engine that offers better performance, smaller bundles, improved debugging, and new features like component-level lazy loading, making Angular applications faster and easier to maintain.",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657377Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "39fda6a5-2a47-4d78-89d4-14fd3e5a0ba9",
        "question": "How do you handle state management in Angular?",
        "answer": "```markdown\nState management in Angular can be approached in several ways, depending on the complexity of the application:\n\n1. **Service-based State Management**  \n   For small to medium applications, Angular services are commonly used to manage state. Services can hold data and business logic, and components can inject these services to access or modify the state. To enable reactivity, `RxJS` subjects or observables (like `BehaviorSubject`) are often used within services to emit and subscribe to state changes.\n\n   ```typescript\n   @Injectable({ providedIn: 'root' })\n   export class StateService {\n     private userSubject = new BehaviorSubject<User | null>(null);\n     user$ = this.userSubject.asObservable();\n\n     setUser(user: User) {\n       this.userSubject.next(user);\n     }\n   }\n   ```\n\n2. **NgRx (Redux-inspired State Management)**  \n   For larger or more complex applications, libraries like [NgRx](https://ngrx.io/) are used. NgRx provides a Redux-like store, actions, reducers, selectors, and effects for managing global state in a predictable and scalable way. It leverages RxJS for reactive state updates.\n\n   - **Store**: Holds the application state.\n   - **Actions**: Describe state changes.\n   - **Reducers**: Handle state transitions.\n   - **Selectors**: Retrieve slices of state.\n   - **Effects**: Handle side effects (e.g., API calls).\n\n   Example usage:\n   ```typescript\n   // actions.ts\n   export const loadUsers = createAction('[User] Load Users');\n\n   // reducer.ts\n   const userReducer = createReducer(initialState,\n     on(loadUsers, state => ({ ...state, loading: true }))\n   );\n\n   // selector.ts\n   export const selectUsers = createSelector(\n     selectUserState,\n     (state) => state.users\n   );\n   ```\n\n3. **Other Libraries**  \n   Alternatives like [Akita](https://datorama.github.io/akita/), [NGXS](https://www.ngxs.io/), or even simple local state management with `ComponentStore` from NgRx can also be used, depending on project needs.\n\n4. **Best Practices**  \n   - Use services for shared state between a few components.\n   - Use a state management library for complex, large-scale applications.\n   - Keep state immutable where possible.\n   - Use selectors and observables to decouple components from direct state manipulation.\n\n**Summary:**  \nAngular provides flexibility in state management, from simple service-based approaches to robust libraries like NgRx. The choice depends on the application's size, complexity, and scalability requirements.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657389Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "f80487ed-e735-4776-9963-5ea6baef900f",
        "question": "What are structural and attribute directives?",
        "answer": "```markdown **Structural and Attribute Directives in Angular**\n\nIn Angular, **directives** are classes that add behavior to elements in your Angular applications. There are mainly three types of directives, but two of the most important are **structural** and **attribute** directives.\n\n---\n\n### Structural Directives\n\n- **Definition:** Structural directives change the structure of the DOM by adding or removing elements.\n- **Examples:** `*ngIf`, `*ngFor`, `*ngSwitch`\n- **Usage:** They are prefixed with an asterisk (`*`) when used in templates.\n\n**Example:**\n```html\n<div *ngIf=\"isVisible\">This will only be shown if isVisible is true.</div>\n<ul>\n  <li *ngFor=\"let item of items\">{{ item }}</li>\n</ul>\n```\n\n---\n\n### Attribute Directives\n\n- **Definition:** Attribute directives change the appearance or behavior of an element, component, or another directive.\n- **Examples:** `ngClass`, `ngStyle`, `appHighlight` (custom directive)\n- **Usage:** They are used as attributes without the asterisk.\n\n**Example:**\n```html\n<button [ngClass]=\"{'active': isActive}\">Click Me</button>\n<p [ngStyle]=\"{'color': textColor}\">Styled Text</p>\n```\n\n---\n\n### Summary Table\n\n| Directive Type      | Purpose                                 | Example Usage         |\n|---------------------|-----------------------------------------|----------------------|\n| Structural          | Change DOM structure (add/remove nodes) | `*ngIf`, `*ngFor`    |\n| Attribute           | Change element appearance/behavior      | `[ngClass]`, `[ngStyle]` |\n\n---\n\n**In summary:**  \n- **Structural directives** modify the DOM layout by adding or removing elements.\n- **Attribute directives** modify the appearance or behavior of existing elements.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657403Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "5757b3ee-4b47-44d1-8ae6-7eed9c73f785",
        "question": "How do you use environment variables in Angular?",
        "answer": "```markdown\nIn Angular, environment variables are managed using the `src/environments` directory, which typically contains files like `environment.ts` (for development) and `environment.prod.ts` (for production). These files export an `environment` object where you can define your variables.\n\n**Usage Steps:**\n\n1. **Define Variables:**\n   ```typescript\n   // src/environments/environment.ts\n   export const environment = {\n     production: false,\n     apiUrl: 'http://localhost:3000/api'\n   };\n   ```\n\n   ```typescript\n   // src/environments/environment.prod.ts\n   export const environment = {\n     production: true,\n     apiUrl: 'https://api.myapp.com'\n   };\n   ```\n\n2. **Access Variables in Code:**\n   Import the environment object wherever you need to use the variables:\n   ```typescript\n   import { environment } from '../environments/environment';\n\n   console.log(environment.apiUrl); // Outputs the correct URL based on the build\n   ```\n\n3. **Build with Specific Environment:**\n   Angular CLI automatically replaces `environment.ts` with `environment.prod.ts` when you build for production:\n   ```\n   ng build --prod\n   ```\n\n**Note:**  \nYou can create additional environment files (e.g., `environment.staging.ts`) and configure file replacements in `angular.json` for custom environments.\n\n**Summary:**  \nEnvironment variables in Angular are managed via environment files and accessed through the imported `environment` object, allowing you to easily switch configurations based on the build environment.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657416Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "9461276b-1032-4a23-8f47-3d7032e0a550",
        "question": "What is the purpose of the ng-template directive?",
        "answer": "```markdown The `ng-template` directive in Angular is used to define template fragments that are not rendered directly in the DOM. Instead, these templates act as blueprints that Angular can instantiate and insert into the view dynamically, based on certain conditions or logic.\n\n**Purpose of `ng-template`:**\n\n- **Deferred Rendering:** Content inside an `ng-template` is not rendered unless explicitly instructed (e.g., via structural directives like `*ngIf`, `*ngFor`, or using `ngTemplateOutlet`).\n- **Reusable Templates:** Allows you to define a chunk of HTML that can be reused in different places, improving code maintainability and readability.\n- **Custom Structural Directives:** Enables the creation of custom structural directives that control when and how the template content is rendered.\n\n**Example:**\n\n```html\n<ng-template #loading>\n  <p>Loading...</p>\n</ng-template>\n\n<div *ngIf=\"isLoading; else loading\">\n  <p>Data loaded!</p>\n</div>\n```\n\nIn this example, the content inside `<ng-template #loading>` is only rendered if `isLoading` is false, thanks to the `else` clause in `*ngIf`.\n\n**Summary Table:**\n\n| Feature                | Description                                                      |\n|------------------------|------------------------------------------------------------------|\n| Not rendered by default| Content is not in the DOM unless explicitly used                 |\n| Template reference     | Can be referenced and rendered dynamically                       |\n| Used with directives   | Commonly used with `*ngIf`, `*ngFor`, and `ngTemplateOutlet`     |\n\n**In short:**  \n`ng-template` is a powerful tool in Angular for controlling when and how parts of your template are rendered, enabling dynamic and efficient UI development.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657429Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "27882cda-714e-4a14-be37-10dd61f8bf28",
        "question": "How do you create a singleton service in Angular?",
        "answer": "```markdown To create a singleton service in Angular, you use the @Injectable() decorator with the providedIn property set to 'root'. This ensures that Angular provides a single instance of the service throughout the application.\n\n```typescript\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class MySingletonService {\n  constructor() { }\n}\n```\n\n**Explanation:**\n\n- The providedIn: 'root' option tells Angular to register the service at the root level injector, making it a singleton.\n- This means the same instance of MySingletonService is shared across all components and modules in the application.\n- You can inject this service into any component or other service via Angular’s dependency injection.\n\n**Alternative (Older) Approach:**\n\nYou could also provide the service in the AppModule’s providers array, but using providedIn: 'root' is the recommended and more concise method in modern Angular.\n\n```typescript\n@NgModule({\n  providers: [MySingletonService]\n})\nexport class AppModule { }\n```\n\n**Summary:**  \nUse @Injectable({ providedIn: 'root' }) to create a singleton service in Angular.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657443Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "d2312fa2-e17e-4906-ac15-554b040ec651",
        "question": "What is the difference between ActivatedRoute and Router in Angular?",
        "answer": "```markdown **ActivatedRoute vs Router in Angular**\n\nIn Angular, both `ActivatedRoute` and `Router` are services provided by the Angular Router module, but they serve different purposes:\n\n| Feature                | ActivatedRoute                                         | Router                                      |\n|------------------------|-------------------------------------------------------|---------------------------------------------|\n| **Purpose**            | Provides access to information about a route associated with a component loaded in an outlet. | Used for navigation and manipulating the router state. |\n| **Usage**              | Access route parameters, query parameters, static data, and route configuration for the current route. | Navigate to different routes, create links, and listen to route events. |\n| **Common Methods/Properties** | `params`, `queryParams`, `snapshot`, `data`, `url` | `navigate()`, `navigateByUrl()`, `events`, `createUrlTree()` |\n| **Typical Injection**  | Injected into components to get info about the current route. | Injected into components/services to perform navigation. |\n| **Example**            | `constructor(private route: ActivatedRoute) {}`       | `constructor(private router: Router) {}`    |\n\n**Example Usage:**\n\n```typescript\n// Using ActivatedRoute to get route parameters\nconstructor(private route: ActivatedRoute) {\n  this.route.params.subscribe(params => {\n    console.log(params['id']);\n  });\n}\n\n// Using Router to navigate\nconstructor(private router: Router) {}\n\ngoToHome() {\n  this.router.navigate(['/home']);\n}\n```\n\n**Summary:**  \n- Use **ActivatedRoute** to access information about the current route.\n- Use **Router** to perform navigation and interact with the router as a whole.",
        "level": "Intermediate",
        "created_at": "2025-04-20T10:26:48.657464Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "9d70044a-759d-49c8-a636-180ade90bc71",
        "question": "How do you use trackBy with ngFor and why is it important?",
        "answer": "```markdown\n### How do you use `trackBy` with `ngFor` and why is it important?\n\nIn Angular, the `ngFor` directive is used to iterate over a list and render a template for each item. By default, Angular tracks list items by their object references. This can lead to performance issues, especially when dealing with large lists or when the data changes frequently, because Angular may re-render all items even if only one has changed.\n\n#### Using `trackBy` with `ngFor`\n\nThe `trackBy` function allows you to specify a unique identifier for each item in the list. This helps Angular optimize DOM updates by only re-rendering items that have actually changed.\n\n**Syntax:**\n```html\n<div *ngFor=\"let item of items; trackBy: trackByFn\">\n  {{ item.name }}\n</div>\n```\n\n**Component code:**\n```typescript\ntrackByFn(index: number, item: any): any {\n  return item.id; // or any unique property\n}\n```\n\n#### Why is `trackBy` important?\n\n- **Performance Optimization:** Prevents unnecessary DOM manipulations by only updating the items that have changed, rather than re-rendering the entire list.\n- **Preserves State:** Helps maintain the state of DOM elements (like form inputs) when the list changes.\n- **Efficient Change Detection:** Reduces the workload on Angular’s change detection mechanism, leading to smoother UI updates.\n\n#### Example\n\nSuppose you have a list of users:\n```typescript\nusers = [\n  { id: 1, name: 'Alice' },\n  { id: 2, name: 'Bob' },\n  { id: 3, name: 'Charlie' }\n];\n```\n\n**Template:**\n```html\n<li *ngFor=\"let user of users; trackBy: trackByUserId\">\n  {{ user.name }}\n</li>\n```\n\n**Component:**\n```typescript\ntrackByUserId(index: number, user: any): number {\n  return user.id;\n}\n```\n\n**Summary:**  \nUsing `trackBy` with `ngFor` is a best practice for improving performance and ensuring efficient DOM updates, especially when working with large or frequently changing lists.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T10:26:48.657477Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    },
    {
        "id": "ed2dacac-d74e-47d0-ad82-1f753e20607a",
        "question": "What is the role of the main.ts file in an Angular application?",
        "answer": "```markdown\nThe `main.ts` file in an Angular application serves as the entry point for the app. Its main role is to bootstrap the root module (usually `AppModule`) and start the Angular application in the browser. It does this by calling the `platformBrowserDynamic().bootstrapModule(AppModule)` method, which initializes the app and renders it in the browser.\n\nIn summary, `main.ts` is responsible for:\n- Launching the Angular application.\n- Bootstrapping the root module.\n- Setting up the environment for the app to run.\n\nWithout `main.ts`, the Angular application would not start.\n```",
        "level": "Beginner",
        "created_at": "2025-04-20T10:26:48.657490Z",
        "topic": "37f2769c-5490-4fa6-be99-89ca378819b2"
    }
]