[
    {
        "id": "67b34ca8-ad5b-47bc-a727-b856142fda94",
        "question": "How do you handle the response of an asynchronous API call in AngularJS?",
        "answer": "```markdown\nIn AngularJS, you handle the response of an asynchronous API call using promises, typically with the `$http` service. When you make an API call, `$http` returns a promise object. You can use the `.then()` method to handle the response when the call succeeds, and `.catch()` (or the second parameter of `.then()`) to handle errors.\n\n**Example:**\n\n```javascript\n// Inject $http into your controller or service\n$http.get('https://api.example.com/data')\n  .then(function(response) {\n    // Success: handle the response data\n    $scope.data = response.data;\n  })\n  .catch(function(error) {\n    // Error: handle the error\n    console.error('API call failed:', error);\n  });\n```\n\n**Key Points:**\n- Use `$http` for making API calls.\n- Handle successful responses in the `.then()` callback.\n- Handle errors in the `.catch()` callback.\n- Update your scope or component variables with the response data as needed.\n```\n",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396060Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "482960c3-87dd-48e6-a693-7729dde8b516",
        "question": "How do you cancel an ongoing HTTP request in AngularJS?",
        "answer": "```markdown\nTo cancel an ongoing HTTP request in AngularJS, you can use the `timeout` property of the `$http` service. This property can be set to a promise; when the promise is resolved, the HTTP request is aborted.\n\n**Example:**\n\n```javascript\nvar canceler = $q.defer();\n\n$http({\n  method: 'GET',\n  url: '/api/data',\n  timeout: canceler.promise\n}).then(function(response) {\n  // Handle success\n}, function(error) {\n  if (error.status === -1) {\n    // Request was canceled\n  } else {\n    // Handle other errors\n  }\n});\n\n// To cancel the request:\ncanceler.resolve();\n```\n\n**Explanation:**\n- Create a deferred object using `$q.defer()`.\n- Pass `canceler.promise` to the `timeout` property of the `$http` config.\n- When you want to cancel the request, call `canceler.resolve()`.\n- If the request is canceled, the error callback will be invoked with `status: -1`.\n\nThis approach is useful for scenarios like aborting previous requests when a user initiates a new search or navigates away from a view.\n```",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396157Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "bcf7bcbd-ae5f-4645-99b4-9e79dc67bff2",
        "question": "What are the common HTTP methods supported by AngularJS $http service?",
        "answer": "```markdown **Answer:**\n\nAngularJS’s `$http` service supports the following common HTTP methods:\n\n- **GET**: Retrieves data from the server.\n- **POST**: Sends data to the server to create a new resource.\n- **PUT**: Updates an existing resource on the server.\n- **DELETE**: Removes a resource from the server.\n- **HEAD**: Retrieves metadata (headers) for a resource.\n- **PATCH**: Partially updates an existing resource.\n\n**Example usage:**\n\n```javascript\n// GET request\n$http.get('/api/items');\n\n// POST request\n$http.post('/api/items', { name: 'New Item' });\n\n// PUT request\n$http.put('/api/items/1', { name: 'Updated Item' });\n\n// DELETE request\n$http.delete('/api/items/1');\n```\n\nThese methods allow AngularJS applications to interact with RESTful APIs and perform CRUD (Create, Read, Update, Delete) operations.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396169Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b7f6eeb7-6b99-45a2-9b75-1c8844a662c4",
        "question": "What is an asynchronous operation in AngularJS?",
        "answer": "```markdown An **asynchronous operation** in AngularJS refers to any process that runs independently of the main application flow, allowing the application to continue executing other tasks while waiting for the operation to complete. Common examples include fetching data from a server using HTTP requests, timers, or reading files.\n\nIn AngularJS, asynchronous operations are typically handled using **promises** (via the $q service) or **callbacks**. For instance, when you use the `$http` service to make an API call, it returns a promise that resolves when the data is received, without blocking the rest of your application.\n\n**Example:**\n\n```js\n$http.get('https://api.example.com/data')\n  .then(function(response) {\n    // This code runs after the data is fetched\n    $scope.data = response.data;\n  });\n```\n\n**Key Points:**\n- Asynchronous operations do not block the main thread.\n- They improve user experience by keeping the app responsive.\n- AngularJS uses promises to handle async operations cleanly.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396005Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "33e5aa2a-ad2a-4ae4-a9c0-e6a8729f6d35",
        "question": "How does AngularJS handle asynchronous operations?",
        "answer": "```markdown AngularJS handles asynchronous operations primarily using promises, which are provided by its $q service. When you perform actions like making HTTP requests with the $http service, AngularJS returns a promise object. This allows you to handle the result of the operation once it completes, without blocking the rest of your application.\n\n**Key Points:**\n\n- **Promises:** AngularJS uses promises to manage asynchronous operations. A promise represents a value that may be available now, later, or never.\n- **$q Service:** This is AngularJS’s implementation of promises, allowing you to create, resolve, or reject promises.\n- **$http Service:** Used for API integration, it returns a promise that resolves when the HTTP request completes.\n\n**Example:**\n\n```javascript\n$http.get('/api/data')\n  .then(function(response) {\n    // Success: handle the data\n    $scope.data = response.data;\n  })\n  .catch(function(error) {\n    // Error: handle the error\n    console.error('Error:', error);\n  });\n```\n\n**Summary:**  \nAngularJS handles asynchronous operations using promises, enabling smooth API integration and non-blocking code execution.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396023Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "5bd93ef3-eec3-4b26-aa9b-53c6583a6f63",
        "question": "What is the $http service in AngularJS used for?",
        "answer": "```markdown The `$http` service in AngularJS is used to make asynchronous HTTP requests to remote servers. It allows your AngularJS application to communicate with backend APIs, fetch or send data, and handle responses. Common operations include GET, POST, PUT, and DELETE requests.\n\n**Example Usage:**\n\n```javascript\n$http.get('https://api.example.com/data')\n  .then(function(response) {\n    // Handle successful response\n    console.log(response.data);\n  }, function(error) {\n    // Handle error\n    console.error(error);\n  });\n```\n\n**Key Points:**\n- Enables communication with RESTful APIs.\n- Returns a promise, making it easy to handle asynchronous operations.\n- Supports configuration options for headers, parameters, and more.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396032Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "433c8336-92bd-4689-9ac0-fa3140447250",
        "question": "How do you make a GET request to an API using AngularJS?",
        "answer": "```markdown To make a GET request to an API using AngularJS, you can use the `$http` service. Here’s a simple example:\n\n```javascript\nangular.module('myApp', [])\n  .controller('MyController', function($scope, $http) {\n    $http.get('https://api.example.com/data')\n      .then(function(response) {\n        // Success callback\n        $scope.apiData = response.data;\n      }, function(error) {\n        // Error callback\n        console.error('Error fetching data:', error);\n      });\n  });\n```\n\n**Explanation:**\n- Inject the `$http` service into your controller.\n- Use `$http.get('API_URL')` to make the GET request.\n- Handle the response in the `.then()` method.\n- On success, the data is available in `response.data`.\n\n**Note:** Replace `'https://api.example.com/data'` with your actual API endpoint.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396040Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "8171744e-b090-41b3-8223-46621831e88c",
        "question": "What is a promise in AngularJS?",
        "answer": "```markdown A **promise** in AngularJS is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. Promises are commonly used for handling asynchronous tasks such as API calls, timers, or reading files.\n\n### Key Points:\n- A promise can be in one of three states: **pending**, **resolved** (fulfilled), or **rejected**.\n- In AngularJS, promises are typically created and managed using the `$q` service.\n- Promises allow you to attach callbacks using `.then()` for success and `.catch()` for errors, making asynchronous code easier to read and maintain.\n\n### Example:\n```javascript\n// Using $http service which returns a promise\n$http.get('/api/data')\n  .then(function(response) {\n    // Success: handle response data\n    console.log(response.data);\n  })\n  .catch(function(error) {\n    // Error: handle error\n    console.error(error);\n  });\n```\n\n### Benefits:\n- Simplifies handling of asynchronous operations.\n- Avoids \"callback hell\" by chaining `.then()` methods.\n- Makes code more readable and maintainable.\n\n**In summary:**  \nA promise in AngularJS is a way to handle asynchronous operations, allowing you to write cleaner and more manageable code when dealing with things like API integrations.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396048Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "ad3110e8-023b-4c51-ba7c-627294dfc203",
        "question": "What is the difference between $http.get and $http.post in AngularJS?",
        "answer": "```markdown **Answer:**\n\nIn AngularJS, both `$http.get` and `$http.post` are methods used to make HTTP requests to a server, but they are used for different purposes:\n\n| Method         | Purpose                                  | Data Sent To Server          |\n|----------------|------------------------------------------|------------------------------|\n| `$http.get`    | Retrieves data from the server (read)     | Data is sent as URL params   |\n| `$http.post`   | Sends data to the server (create/update)  | Data is sent in the request body |\n\n**Key Differences:**\n\n- **$http.get**  \n  - Used to fetch or retrieve data from the server.\n  - Parameters are sent as part of the URL.\n  - Example:\n    ```js\n    $http.get('/api/users?role=admin')\n      .then(function(response) {\n        // handle success\n      });\n    ```\n\n- **$http.post**  \n  - Used to send data to the server, often to create or update resources.\n  - Data is sent in the body of the HTTP request.\n  - Example:\n    ```js\n    $http.post('/api/users', { name: 'John', role: 'admin' })\n      .then(function(response) {\n        // handle success\n      });\n    ```\n\n**Summary:**  \nUse `$http.get` for retrieving data, and `$http.post` for sending data to the server.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396069Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "946416c4-cb89-4fdc-b808-631a1a91d6bc",
        "question": "How do you handle errors in API calls using AngularJS?",
        "answer": "```markdown\nIn AngularJS, you typically handle errors in API calls by using the `.catch()` method (or the error callback) when working with promises returned by the `$http` service. Here’s a simple example:\n\n```javascript\n$http.get('/api/data')\n  .then(function(response) {\n    // Success: handle the response data\n    $scope.data = response.data;\n  })\n  .catch(function(error) {\n    // Error: handle the error\n    console.error('API call failed:', error);\n    $scope.errorMessage = 'Failed to load data from the server.';\n  });\n```\n\n**Key Points:**\n- Use `.catch()` to handle any errors that occur during the API call.\n- You can also use the second argument of `.then(success, error)` to handle errors.\n- Always provide user feedback or log errors for debugging.\n\n**Example with `.then(success, error)` syntax:**\n\n```javascript\n$http.get('/api/data')\n  .then(\n    function(response) {\n      // Success handler\n      $scope.data = response.data;\n    },\n    function(error) {\n      // Error handler\n      console.error('API call failed:', error);\n      $scope.errorMessage = 'Failed to load data.';\n    }\n  );\n```\n\nBy handling errors this way, you can ensure your application responds gracefully to failed API calls.\n```\n",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396077Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "299ff5c7-4489-4736-9dfc-e74aad5d24ec",
        "question": "What is the $q service in AngularJS?",
        "answer": "```markdown The `$q` service in AngularJS is a built-in service that helps you work with asynchronous operations using promises. It allows you to execute functions asynchronously and handle the results (success or failure) in a clean and manageable way.\n\n### Key Points about `$q`:\n\n- **Promise Creation:** `$q` lets you create and return promise objects, which represent a value that may be available now, later, or never.\n- **Chaining:** You can chain `.then()`, `.catch()`, and `.finally()` methods to handle the result or error of an asynchronous operation.\n- **Integration:** It is commonly used for API calls, timeouts, and any other async tasks in AngularJS.\n\n### Example Usage\n\n```javascript\napp.controller('MyController', function($scope, $q, $timeout) {\n  function asyncOperation() {\n    var deferred = $q.defer();\n\n    $timeout(function() {\n      if (Math.random() > 0.5) {\n        deferred.resolve('Success!');\n      } else {\n        deferred.reject('Error!');\n      }\n    }, 1000);\n\n    return deferred.promise;\n  }\n\n  asyncOperation().then(function(result) {\n    $scope.message = result;\n  }).catch(function(error) {\n    $scope.message = error;\n  });\n});\n```\n\n### Summary\n\n- `$q` is AngularJS’s promise implementation for handling asynchronous operations.\n- It helps you write cleaner, more maintainable code when dealing with API calls and other async tasks.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396085Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "987501f1-eb7d-49c7-82e1-06846d59003c",
        "question": "How can you use $q to create custom promises in AngularJS?",
        "answer": "```markdown\nIn AngularJS, the `$q` service is used to create and manage promises for asynchronous operations. To create a custom promise using `$q`, you typically use the `$q.defer()` method, which gives you a deferred object. This object has a `promise` property and methods like `resolve`, `reject`, and `notify` to control the promise's state.\n\n**Example: Creating a Custom Promise with `$q`**\n\n```javascript\napp.controller('MyController', function($scope, $q, $timeout) {\n  function asyncOperation() {\n    var deferred = $q.defer();\n\n    // Simulate an async task (e.g., API call)\n    $timeout(function() {\n      var success = true; // Simulate success/failure\n      if (success) {\n        deferred.resolve('Operation successful!');\n      } else {\n        deferred.reject('Operation failed.');\n      }\n    }, 2000);\n\n    return deferred.promise;\n  }\n\n  asyncOperation().then(function(result) {\n    $scope.message = result;\n  }, function(error) {\n    $scope.message = error;\n  });\n});\n```\n\n**Key Points:**\n- Use `$q.defer()` to create a deferred object.\n- Perform your async operation, then call `deferred.resolve(data)` on success or `deferred.reject(error)` on failure.\n- Return `deferred.promise` so callers can use `.then()` and `.catch()` to handle results.\n- You can also use `$q(function(resolve, reject) { ... })` for a more modern style (similar to native Promises).\n\n**Alternative with `$q` Constructor:**\n\n```javascript\nfunction asyncOperation() {\n  return $q(function(resolve, reject) {\n    $timeout(function() {\n      var success = true;\n      if (success) {\n        resolve('Operation successful!');\n      } else {\n        reject('Operation failed.');\n      }\n    }, 2000);\n  });\n}\n```\n\n**Summary:**  \nUse `$q` to wrap asynchronous logic and return a promise, allowing you to handle async results in a clean, promise-based way in AngularJS.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396093Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "251414ba-b61c-427b-8028-bfaaa56ca511",
        "question": "What is the role of callbacks in asynchronous operations in AngularJS?",
        "answer": "```markdown **Answer:**\n\nIn AngularJS, callbacks play a crucial role in handling asynchronous operations, such as API calls or timers. When you perform an asynchronous task (like fetching data from a server), you don't get the result immediately. Instead, you provide a callback function that will be executed once the operation is complete.\n\n**Role of Callbacks:**\n\n- **Non-blocking:** Callbacks allow the application to continue running other code while waiting for the asynchronous operation to finish.\n- **Handling Results:** The callback function receives the result (data or error) of the asynchronous operation and processes it accordingly.\n- **API Integration:** When making HTTP requests (using `$http` service), you pass callback functions to handle the response.\n\n**Example:**\n\n```javascript\n$http.get('/api/data').then(function(response) {\n  // This is the callback function\n  $scope.data = response.data;\n}, function(error) {\n  // This is the error callback\n  console.error('Error:', error);\n});\n```\n\n**Summary:**  \nCallbacks in AngularJS are essential for managing the flow of code after asynchronous operations, ensuring that the application responds to events like API responses without blocking the user interface.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396100Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "150e6ca6-22d8-489b-9694-ccef8086f9df",
        "question": "How do you chain multiple asynchronous operations in AngularJS?",
        "answer": "```markdown To chain multiple asynchronous operations in AngularJS, you typically use the $q service, which implements promises. Chaining allows you to perform a sequence of async tasks where each step depends on the result of the previous one.\n\nHere's how you can do it:\n\n```javascript\n// Assume myService.getData1(), myService.getData2(), and myService.getData3() return promises\n\nmyService.getData1()\n  .then(function(result1) {\n    // Use result1 to get data2\n    return myService.getData2(result1.id);\n  })\n  .then(function(result2) {\n    // Use result2 to get data3\n    return myService.getData3(result2.value);\n  })\n  .then(function(result3) {\n    // All operations completed, handle final result\n    console.log('Final result:', result3);\n  })\n  .catch(function(error) {\n    // Handle any error that occurred in the chain\n    console.error('An error occurred:', error);\n  });\n```\n\n**Key Points:**\n\n- Each `.then()` returns a new promise, allowing chaining.\n- Each step can return a value or a promise; if a promise is returned, the next `.then()` waits for it to resolve.\n- Use `.catch()` at the end to handle errors from any step in the chain.\n\n**Example with $http:**\n\n```javascript\n$http.get('/api/user')\n  .then(function(response) {\n    var userId = response.data.id;\n    return $http.get('/api/orders/' + userId);\n  })\n  .then(function(response) {\n    var orders = response.data;\n    // Do something with orders\n  })\n  .catch(function(error) {\n    // Handle error\n  });\n```\n\nThis pattern keeps your asynchronous logic clean and readable.",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396108Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "93d28ab8-c68d-41db-8069-e70a3d6ff783",
        "question": "What is the difference between synchronous and asynchronous operations?",
        "answer": "```markdown **Synchronous vs. Asynchronous Operations in AngularJS**\n\n| Synchronous Operations                        | Asynchronous Operations                          |\n|-----------------------------------------------|--------------------------------------------------|\n| Tasks are performed one after another.        | Tasks can be started and completed independently.|\n| Each operation waits for the previous one to finish. | Operations don’t block the execution of others.  |\n| The program execution is paused until the task completes. | The program continues running while the task completes in the background. |\n| Example: Reading a file line by line and waiting for each line to be read before moving to the next. | Example: Making an API call and continuing with other tasks while waiting for the response. |\n\n**In AngularJS:**\n- Synchronous code executes step by step.\n- Asynchronous code (like HTTP requests) uses callbacks, promises, or observables to handle results when they are ready, without blocking the rest of the code.\n\n**Example:**\n```js\n// Synchronous\nvar result = calculateSum(1, 2); // Waits for calculateSum to finish\n\n// Asynchronous (using $http in AngularJS)\n$http.get('/api/data').then(function(response) {\n  // This runs when the data is received, without blocking other code\n});\n```\n\n**Summary:**  \nSynchronous operations block further execution until they finish, while asynchronous operations allow the program to continue running and handle results when they are ready. This is especially useful for API integration in AngularJS, where waiting for server responses should not freeze the user interface.",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396116Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "1e7edb66-8c1a-404a-a140-615b86828a21",
        "question": "How do you send data to an API using $http.post in AngularJS?",
        "answer": "```markdown\nTo send data to an API using `$http.post` in AngularJS, you use the `$http` service and call its `.post()` method. The `.post()` method takes two main arguments: the API endpoint URL and the data object you want to send.\n\n**Example:**\n\n```javascript\n// Inject $http into your controller or service\napp.controller('MyController', function($scope, $http) {\n  $scope.sendData = function() {\n    var data = {\n      name: 'John Doe',\n      email: 'john@example.com'\n    };\n\n    $http.post('https://api.example.com/users', data)\n      .then(function(response) {\n        // Success callback\n        console.log('Data sent successfully:', response.data);\n      }, function(error) {\n        // Error callback\n        console.error('Error sending data:', error);\n      });\n  };\n});\n```\n\n**Explanation:**\n\n- `$http.post(url, data)` sends a POST request to the specified `url` with the `data` object as the request body.\n- The `.then()` method handles the response: the first function is called on success, and the second on error.\n\n**Note:**  \nYou may also send additional configuration (like headers) as a third argument if needed.\n\n```javascript\n$http.post(url, data, { headers: { 'Content-Type': 'application/json' } });\n```\n```",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396124Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "150da359-0181-4564-a0cd-e917ccfb4d2f",
        "question": "How can you intercept HTTP requests and responses in AngularJS?",
        "answer": "```markdown\nIn AngularJS, you can intercept HTTP requests and responses using **$http interceptors**. Interceptors allow you to globally modify or handle HTTP requests and responses before they are processed by your application.\n\n### How to Create an HTTP Interceptor\n\n1. **Define the Interceptor as a Factory:**\n\n```javascript\napp.factory('myHttpInterceptor', function($q) {\n  return {\n    // Intercept outgoing requests\n    request: function(config) {\n      // Modify request config if needed\n      // e.g., add authorization headers\n      config.headers = config.headers || {};\n      config.headers.Authorization = 'Bearer YOUR_TOKEN';\n      return config;\n    },\n\n    // Intercept request errors\n    requestError: function(rejection) {\n      // Handle request error\n      return $q.reject(rejection);\n    },\n\n    // Intercept incoming responses\n    response: function(response) {\n      // Modify response if needed\n      return response;\n    },\n\n    // Intercept response errors\n    responseError: function(rejection) {\n      // Handle response error\n      return $q.reject(rejection);\n    }\n  };\n});\n```\n\n2. **Register the Interceptor with $httpProvider:**\n\n```javascript\napp.config(function($httpProvider) {\n  $httpProvider.interceptors.push('myHttpInterceptor');\n});\n```\n\n### Use Cases\n\n- **Add authentication tokens to headers**\n- **Log requests and responses**\n- **Handle global errors**\n- **Modify response data**\n\n### Example: Adding a Token to Every Request\n\n```javascript\napp.factory('authInterceptor', function() {\n  return {\n    request: function(config) {\n      config.headers = config.headers || {};\n      config.headers.Authorization = 'Bearer ' + localStorage.getItem('token');\n      return config;\n    }\n  };\n});\n\napp.config(function($httpProvider) {\n  $httpProvider.interceptors.push('authInterceptor');\n});\n```\n\n### Summary\n\n- Use `$httpProvider.interceptors` to register interceptors.\n- Interceptors can modify requests, responses, and handle errors globally.\n- They are useful for cross-cutting concerns like authentication, logging, and error handling.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396132Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "646e8027-0469-4a1d-aa12-1e39a13489d9",
        "question": "What is $resource in AngularJS and how is it used for API integration?",
        "answer": "```markdown\n### What is `$resource` in AngularJS and how is it used for API integration?\n\nIn AngularJS, `$resource` is a service provided by the `ngResource` module that simplifies interaction with RESTful APIs. It provides a higher-level abstraction over the lower-level `$http` service, making it easier to perform CRUD (Create, Read, Update, Delete) operations on server-side data.\n\n#### Key Features of `$resource`:\n- Maps RESTful endpoints to client-side objects.\n- Provides methods like `.get()`, `.save()`, `.query()`, `.remove()`, and `.delete()`.\n- Handles URL parameterization and data serialization automatically.\n- Returns resource instances that can be manipulated and synchronized with the server.\n\n#### How to Use `$resource` for API Integration\n\n1. **Include the `ngResource` Module:**\n   ```javascript\n   angular.module('myApp', ['ngResource']);\n   ```\n\n2. **Inject and Define a Resource:**\n   ```javascript\n   angular.module('myApp')\n     .factory('User', function($resource) {\n       return $resource('/api/users/:userId', {userId: '@id'});\n     });\n   ```\n\n3. **Perform API Operations:**\n   ```javascript\n   // Fetch a user with ID 123\n   User.get({userId: 123}, function(user) {\n     console.log(user);\n   });\n\n   // Get all users\n   User.query(function(users) {\n     console.log(users);\n   });\n\n   // Create a new user\n   var newUser = new User({name: 'Alice'});\n   newUser.$save();\n\n   // Update an existing user\n   User.save({userId: 123}, {name: 'Bob'});\n\n   // Delete a user\n   User.delete({userId: 123});\n   ```\n\n#### Summary Table\n\n| Method     | HTTP Verb | Description                  |\n|------------|-----------|------------------------------|\n| `.get()`   | GET       | Fetch a single resource      |\n| `.query()` | GET       | Fetch an array of resources  |\n| `.save()`  | POST/PUT  | Create or update a resource  |\n| `.remove()`| DELETE    | Delete a resource            |\n| `.delete()`| DELETE    | Delete a resource            |\n\n#### When to Use `$resource`\n- When working with RESTful APIs.\n- When you want to reduce boilerplate code for common API operations.\n- When you need easy mapping between client objects and server data.\n\n> **Note:** `$resource` is specific to AngularJS (1.x) and is not available in Angular (2+). For newer Angular versions, use `HttpClient`.\n\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396144Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "9b34b04a-42dd-4ed2-b971-a5f08c49a7ea",
        "question": "How do you handle multiple concurrent API calls in AngularJS?",
        "answer": "```markdown\nTo handle multiple concurrent API calls in AngularJS, you can use the `$q` service, which provides promise-based utilities. The most common approach is to use `$q.all()`, which allows you to execute multiple asynchronous operations in parallel and wait until all of them are completed.\n\n**Example:**\n\n```javascript\napp.controller('MyController', function($scope, $http, $q) {\n  var apiCall1 = $http.get('/api/resource1');\n  var apiCall2 = $http.get('/api/resource2');\n  var apiCall3 = $http.get('/api/resource3');\n\n  $q.all([apiCall1, apiCall2, apiCall3]).then(function(responses) {\n    // responses is an array with the results in order\n    $scope.data1 = responses[0].data;\n    $scope.data2 = responses[1].data;\n    $scope.data3 = responses[2].data;\n  }, function(error) {\n    // Handle error from any of the API calls\n    console.error('One or more API calls failed:', error);\n  });\n});\n```\n\n**Key Points:**\n- `$q.all()` takes an array of promises and returns a new promise.\n- The `.then()` callback receives an array of responses, corresponding to the order of the promises.\n- If any of the API calls fail, the `.catch()` or error callback is triggered.\n- This approach is useful for fetching data from multiple endpoints simultaneously and proceeding only when all data is available.\n\n**Alternative:**  \nIf you need to handle results as soon as each call completes (rather than waiting for all), you can handle each promise individually and update your scope accordingly.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396180Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "441bd556-a616-4044-ab13-9402d76e50d8",
        "question": "What is the purpose of $httpProvider in AngularJS?",
        "answer": "```markdown\nThe `$httpProvider` in AngularJS is a configuration provider that allows you to customize the behavior of the `$http` service, which is used for making asynchronous HTTP requests (such as API calls). It is typically configured during the application's configuration phase using the `.config()` method.\n\n**Key purposes of `$httpProvider` include:**\n\n- **Setting Default Headers:** You can define default headers (like authentication tokens) that will be sent with every HTTP request.\n- **Configuring Interceptors:** You can add interceptors to globally handle or modify requests and responses (e.g., for logging, error handling, or modifying requests).\n- **Changing Default Settings:** You can adjust default settings such as timeout, withCredentials, or how data is transformed before sending or after receiving.\n\n**Example:**\n```js\nangular.module('myApp', [])\n  .config(function($httpProvider) {\n    // Add a default header\n    $httpProvider.defaults.headers.common['Authorization'] = 'Bearer TOKEN';\n\n    // Add an interceptor\n    $httpProvider.interceptors.push('myHttpInterceptor');\n  });\n```\n\n**Summary:**  \n`$httpProvider` is essential for configuring the global behavior of HTTP requests in AngularJS applications, making it easier to manage API integration and asynchronous operations.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396193Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b911b90e-c43f-48fb-a9d0-141bd885e9bf",
        "question": "How do you configure default headers for all API requests in AngularJS?",
        "answer": "```markdown\nTo configure default headers for all API requests in AngularJS, you can use the `$httpProvider` service during the configuration phase of your AngularJS module. This allows you to set default headers that will be included with every `$http` request made by your application.\n\nHere's how you can do it:\n\n```javascript\nangular.module('myApp', [])\n  .config(['$httpProvider', function($httpProvider) {\n    // Set default headers for all requests\n    $httpProvider.defaults.headers.common['Authorization'] = 'Bearer YOUR_TOKEN_HERE';\n    $httpProvider.defaults.headers.common['Custom-Header'] = 'CustomValue';\n    // You can also set headers for specific methods:\n    $httpProvider.defaults.headers.post['Content-Type'] = 'application/json';\n  }]);\n```\n\n**Explanation:**\n- `$httpProvider.defaults.headers.common` sets headers for all HTTP methods (GET, POST, PUT, etc.).\n- `$httpProvider.defaults.headers.post` (or `.get`, `.put`, etc.) sets headers for specific HTTP methods.\n- Place this configuration inside your module's `.config()` block to ensure it runs during the configuration phase.\n\n**Note:**  \nIf you need to set dynamic headers (e.g., tokens that change at runtime), consider using an `$http` interceptor instead.\n```",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396205Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "beff5241-add3-4493-b13a-1ab14ae9881a",
        "question": "What is JSONP and how does AngularJS support it?",
        "answer": "```markdown **JSONP (JSON with Padding)** is a technique used to overcome the limitations of the same-origin policy in web browsers, which restricts making AJAX requests to a domain different from the one that served the web page. JSONP allows web pages to request data from servers in different domains by exploiting the fact that `<script>` tags are not subject to the same-origin policy.\n\n### How JSONP Works\n\n- The client adds a `<script>` tag to the page with a `src` attribute pointing to the API endpoint.\n- The server responds with JavaScript code that calls a callback function (specified by the client) with the data as its argument.\n- The browser executes the script, and the callback function processes the data.\n\n**Example:**\n```html\n<script src=\"https://api.example.com/data?callback=myCallback\"></script>\n```\nThe server responds with:\n```js\nmyCallback({ \"key\": \"value\" });\n```\n\n### AngularJS Support for JSONP\n\nAngularJS provides built-in support for JSONP through its `$http` service. To make a JSONP request, you use the `$http.jsonp()` method or specify the `method: 'JSONP'` in the `$http` configuration.\n\n**Usage Example:**\n```js\n$http.jsonp('https://api.example.com/data?callback=JSON_CALLBACK')\n  .then(function(response) {\n    // Handle success\n    console.log(response.data);\n  }, function(error) {\n    // Handle error\n    console.log(error);\n  });\n```\n\n**Key Points:**\n- The URL must include the string `JSON_CALLBACK` as a placeholder for the callback function name.\n- AngularJS replaces `JSON_CALLBACK` with an auto-generated function name to handle the response.\n\n**Summary Table:**\n\n| Feature         | Description                                         |\n|-----------------|-----------------------------------------------------|\n| Purpose         | Cross-domain requests for data retrieval            |\n| AngularJS Method| `$http.jsonp()`                                     |\n| Callback Marker | `JSON_CALLBACK` in the URL                          |\n| Limitation      | Only supports HTTP GET requests                     |\n\n**Note:** JSONP is less secure than CORS and should be used only when CORS is not available and with trusted APIs.",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396212Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "90491bf6-5dc1-49c3-8988-2386f04f1c2a",
        "question": "How do you use $http.jsonp in AngularJS?",
        "answer": "```markdown\nTo use `$http.jsonp` in AngularJS for making cross-domain requests (where CORS is not available), you can follow these steps:\n\n### 1. JSONP Endpoint Requirement\nThe API endpoint must support JSONP by accepting a `callback` parameter and wrapping the response in a function call.\n\n### 2. Syntax\n\n```javascript\n$http.jsonp(url, [config])\n```\n\n- `url`: The API endpoint, **must** include `JSON_CALLBACK` as the callback placeholder.\n- `config`: (Optional) Additional configuration.\n\n### 3. Example\n\nSuppose you want to fetch data from `https://api.example.com/data` using JSONP:\n\n```javascript\nangular.module('myApp', [])\n  .controller('MyController', function($scope, $http) {\n    var url = 'https://api.example.com/data?callback=JSON_CALLBACK';\n\n    $http.jsonp(url)\n      .then(function(response) {\n        // Success callback\n        $scope.data = response.data;\n      }, function(error) {\n        // Error callback\n        console.error('Error:', error);\n      });\n  });\n```\n\n### 4. Notes\n\n- Always use `JSON_CALLBACK` in the URL; AngularJS will replace it with an auto-generated function name.\n- JSONP only supports HTTP GET requests.\n- Use JSONP only when CORS is not available and the API supports JSONP.\n\n### 5. Security Consideration\n\nJSONP can expose your application to XSS attacks if the API is not trusted. Use it only with trusted sources.\n\n---\n\n**Summary:**  \nUse `$http.jsonp('API_URL?callback=JSON_CALLBACK')` to make cross-domain GET requests to APIs that support JSONP in AngularJS.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396221Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "8305051d-f148-407e-96b8-768cf8308c76",
        "question": "What is CORS and how does it affect API integration in AngularJS?",
        "answer": "```markdown **CORS (Cross-Origin Resource Sharing)** is a security feature implemented by web browsers to restrict web applications running on one origin (domain, protocol, and port) from making requests to a different origin. This is important for protecting users from malicious websites trying to access sensitive data from another site.\n\n### How CORS Works\n\nWhen your AngularJS application tries to make an HTTP request (e.g., using `$http` or `$resource`) to an API hosted on a different domain, the browser checks if the target server allows such cross-origin requests. The server must include specific HTTP headers (like `Access-Control-Allow-Origin`) in its response to permit the request.\n\n### Impact on AngularJS API Integration\n\n- **Blocked Requests:** If the API server does not send the appropriate CORS headers, the browser will block the request, and your AngularJS app will not receive the response.\n- **Preflight Requests:** For certain types of requests (e.g., those with custom headers or methods like `PUT` or `DELETE`), the browser sends a preflight `OPTIONS` request to check if the actual request is safe to send.\n- **No Effect in Backend:** CORS is enforced by browsers, not by AngularJS or the server. Server-to-server requests (like from Node.js) are not affected.\n\n### Handling CORS in AngularJS\n\n- **Server-Side Solution:** The best way to resolve CORS issues is to configure the API server to include the correct CORS headers, such as:\n  ```\n  Access-Control-Allow-Origin: *\n  ```\n  or restrict to specific origins as needed.\n\n- **Proxy Approach:** During development, you can use a proxy server to route API requests through the same origin as your AngularJS app, bypassing CORS restrictions.\n\n### Example Error\n\nIf CORS is not configured, you might see an error like:\n```\nNo 'Access-Control-Allow-Origin' header is present on the requested resource.\n```\n\n### Summary Table\n\n| Aspect         | Description                                                                 |\n|----------------|-----------------------------------------------------------------------------|\n| What is CORS?  | Browser security feature restricting cross-origin HTTP requests              |\n| Affects        | AngularJS API calls to different domains                                    |\n| Solution       | Configure server to send appropriate CORS headers                           |\n| Workarounds    | Use proxy during development, or enable CORS on the server                  |\n\n**In summary:**  \nCORS is a browser-enforced security mechanism that can block your AngularJS app from accessing APIs on different domains unless the server explicitly allows it. Always configure your API server to handle CORS properly for smooth integration.",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396233Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b321a2b4-c354-411c-9fd8-607f09dc8898",
        "question": "How do you handle API authentication in AngularJS?",
        "answer": "```markdown\nTo handle API authentication in AngularJS, you typically use HTTP interceptors to attach authentication tokens (like JWTs) to outgoing API requests and manage authentication state. Here’s a step-by-step approach:\n\n1. **Obtain the Token:**  \n   After a successful login, the server returns an authentication token (e.g., JWT). Store this token securely, usually in `localStorage` or `sessionStorage`.\n\n   ```js\n   // Example: Save token after login\n   localStorage.setItem('authToken', response.data.token);\n   ```\n\n2. **Attach Token to Requests:**  \n   Use an `$http` interceptor to automatically add the token to the `Authorization` header of each outgoing request.\n\n   ```js\n   app.factory('AuthInterceptor', function($q) {\n     return {\n       request: function(config) {\n         var token = localStorage.getItem('authToken');\n         if (token) {\n           config.headers.Authorization = 'Bearer ' + token;\n         }\n         return config;\n       },\n       responseError: function(response) {\n         // Handle 401 Unauthorized responses\n         if (response.status === 401) {\n           // Redirect to login or show an error\n         }\n         return $q.reject(response);\n       }\n     };\n   });\n\n   app.config(function($httpProvider) {\n     $httpProvider.interceptors.push('AuthInterceptor');\n   });\n   ```\n\n3. **Handle Authentication Errors:**  \n   In the interceptor’s `responseError`, handle cases like expired or invalid tokens (e.g., redirect to login).\n\n4. **Logout:**  \n   Remove the token from storage when the user logs out.\n\n   ```js\n   localStorage.removeItem('authToken');\n   ```\n\n**Summary:**  \n- Store the authentication token after login.\n- Use an `$http` interceptor to attach the token to API requests.\n- Handle authentication errors globally.\n- Remove the token on logout.\n\nThis approach ensures secure and consistent API authentication in AngularJS applications.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396241Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "d9a18ecf-e175-478b-ac73-d9b1de63bbce",
        "question": "How can you retry a failed API request in AngularJS?",
        "answer": "```markdown\nTo retry a failed API request in AngularJS, you can use the `$q` service to create a retry mechanism. Here’s a common approach:\n\n### Example: Retrying a Failed API Request\n\nSuppose you have a service method that makes an HTTP request using `$http`. You can wrap the request in a function that attempts the request and retries it a specified number of times if it fails.\n\n```javascript\napp.factory('ApiService', function($http, $q, $timeout) {\n  function retryRequest(httpConfig, retries, delay) {\n    return $http(httpConfig).catch(function(error) {\n      if (retries > 0) {\n        // Wait for 'delay' milliseconds before retrying\n        return $timeout(function() {\n          return retryRequest(httpConfig, retries - 1, delay);\n        }, delay);\n      } else {\n        // No retries left, reject the promise\n        return $q.reject(error);\n      }\n    });\n  }\n\n  return {\n    getDataWithRetry: function(url) {\n      var httpConfig = {\n        method: 'GET',\n        url: url\n      };\n      // Retry up to 3 times with a 1000ms delay between attempts\n      return retryRequest(httpConfig, 3, 1000);\n    }\n  };\n});\n```\n\n### Usage in Controller\n\n```javascript\napp.controller('MainCtrl', function($scope, ApiService) {\n  ApiService.getDataWithRetry('/api/data')\n    .then(function(response) {\n      $scope.data = response.data;\n    })\n    .catch(function(error) {\n      $scope.error = 'Failed to load data after retries.';\n    });\n});\n```\n\n### Key Points\n\n- The `retryRequest` function recursively retries the HTTP request if it fails.\n- `$timeout` is used to add a delay between retries.\n- The number of retries and delay can be configured as needed.\n- If all retries fail, the promise is rejected and can be handled in the controller.\n\nThis pattern helps make your API integration more robust against temporary network or server issues.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396248Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b8577847-a319-414f-b488-cf229cdc137e",
        "question": "What are interceptors in AngularJS and how do you use them?",
        "answer": "```markdown ### What are Interceptors in AngularJS?\n\n**Interceptors** in AngularJS are a feature of the `$http` service that allow you to globally intercept and modify HTTP requests and responses. They are commonly used for tasks such as:\n\n- Adding authentication tokens to headers\n- Logging requests and responses\n- Handling errors globally\n- Modifying request or response data\n\nInterceptors are implemented as services that expose specific methods and are registered with the `$httpProvider`.\n\n---\n\n### How to Use Interceptors in AngularJS\n\n#### 1. Create an Interceptor Service\n\nAn interceptor is simply a factory that returns an object with one or more of the following methods:\n\n- `request(config)`\n- `requestError(rejection)`\n- `response(response)`\n- `responseError(rejection)`\n\n```js\napp.factory('myHttpInterceptor', function($q) {\n  return {\n    // Intercept outgoing requests\n    request: function(config) {\n      // Example: Add an auth token to headers\n      config.headers = config.headers || {};\n      config.headers.Authorization = 'Bearer my-token';\n      return config;\n    },\n\n    // Intercept request errors\n    requestError: function(rejection) {\n      // Handle request error\n      return $q.reject(rejection);\n    },\n\n    // Intercept incoming responses\n    response: function(response) {\n      // Modify or log the response\n      return response;\n    },\n\n    // Intercept response errors\n    responseError: function(rejection) {\n      // Handle response errors globally\n      if (rejection.status === 401) {\n        // Redirect to login, for example\n      }\n      return $q.reject(rejection);\n    }\n  };\n});\n```\n\n---\n\n#### 2. Register the Interceptor\n\nYou need to register your interceptor with the `$httpProvider` in your app's config block:\n\n```js\napp.config(function($httpProvider) {\n  $httpProvider.interceptors.push('myHttpInterceptor');\n});\n```\n\n---\n\n#### 3. How It Works\n\n- Every `$http` request and response will pass through your interceptor.\n- You can chain multiple interceptors; they will be called in the order they are added.\n\n---\n\n### Example Use Cases\n\n- **Authentication:** Automatically attach JWT tokens to every request.\n- **Error Handling:** Show a global error message for certain HTTP status codes.\n- **Logging:** Log every request and response for debugging.\n\n---\n\n### Summary Table\n\n| Method           | Purpose                                 |\n|------------------|-----------------------------------------|\n| request          | Modify outgoing request config           |\n| requestError     | Handle request errors                    |\n| response         | Modify incoming response                 |\n| responseError    | Handle response errors                   |\n\n---\n\n**In summary:**  \nInterceptors in AngularJS are powerful tools for handling cross-cutting concerns in HTTP communication, making your code cleaner and more maintainable.",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396255Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "c7496bd9-ddbb-4f55-b4eb-02af7ecf99a8",
        "question": "How do you transform requests and responses in AngularJS $http?",
        "answer": "```markdown In AngularJS, the $http service allows you to transform requests before they are sent to the server and responses after they are received. This is achieved using the transformRequest and transformResponse properties.\n\n### Transforming Requests\n\n- **transformRequest** is used to modify the request data before it is sent to the server.\n- It can be a single function or an array of functions.\n- Each function receives the data and headersGetter as arguments and must return the transformed data.\n\n**Example:**\n\n```javascript\n$http({\n  method: 'POST',\n  url: '/api/data',\n  data: { name: 'AngularJS' },\n  transformRequest: function(data, headersGetter) {\n    // Convert data object to a URL-encoded string\n    var str = [];\n    for (var p in data)\n      str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(data[p]));\n    return str.join(\"&\");\n  },\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n});\n```\n\n### Transforming Responses\n\n- **transformResponse** is used to modify the response data before it is passed to your application.\n- It can also be a single function or an array of functions.\n- Each function receives the data and headersGetter as arguments and must return the transformed data.\n\n**Example:**\n\n```javascript\n$http({\n  method: 'GET',\n  url: '/api/data',\n  transformResponse: function(data, headersGetter) {\n    // Parse JSON and extract a specific property\n    var jsonData = angular.fromJson(data);\n    return jsonData.result;\n  }\n});\n```\n\n### Using Defaults\n\nYou can also set default transformations for all $http requests:\n\n```javascript\n// Add a default response transformer\n$http.defaults.transformResponse.push(function(data) {\n  // Custom transformation logic\n  return data;\n});\n```\n\n### Chaining Multiple Transformers\n\nBoth transformRequest and transformResponse can be arrays. Each function in the array is called in sequence, passing the result to the next.\n\n```javascript\n$http({\n  url: '/api/data',\n  transformResponse: [\n    function(data) {\n      // First transformation\n      return angular.fromJson(data);\n    },\n    function(data) {\n      // Second transformation\n      return data.items;\n    }\n  ]\n});\n```\n\n### Summary Table\n\n| Property            | Purpose                                 | Type                |\n|---------------------|-----------------------------------------|---------------------|\n| transformRequest    | Modify request data before sending       | Function/Array      |\n| transformResponse   | Modify response data after receiving     | Function/Array      |\n\n---\n\n**In summary:**  \nUse `transformRequest` to preprocess outgoing data and `transformResponse` to postprocess incoming data in AngularJS $http operations, either globally or per-request, using functions or arrays of functions for flexible data transformation.",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396263Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b68a67a8-59b0-4bf3-baab-3d9d517c8b65",
        "question": "What is the difference between $q.all and $q.when in AngularJS?",
        "answer": "```markdown\n### Difference between `$q.all` and `$q.when` in AngularJS\n\n#### `$q.all`\n- **Purpose:** Used to wait for multiple promises to resolve.\n- **Input:** Takes an array (or object) of promises.\n- **Behavior:** Returns a single promise that resolves when *all* of the input promises are resolved. If any promise is rejected, the returned promise is rejected immediately.\n- **Use Case:** When you need to perform actions after several asynchronous operations have all completed.\n\n**Example:**\n```javascript\n$q.all([promise1, promise2, promise3]).then(function(results) {\n  // All promises resolved, results is an array of values\n});\n```\n\n#### `$q.when`\n- **Purpose:** Normalizes a value or a promise into a promise.\n- **Input:** Takes a value or a promise.\n- **Behavior:** If the input is already a promise, it is returned as-is. If the input is a non-promise value, it returns a promise that is immediately resolved with that value.\n- **Use Case:** When you want to ensure you always have a promise, regardless of whether the input is already a promise or just a value.\n\n**Example:**\n```javascript\n$q.when(someValueOrPromise).then(function(result) {\n  // result is the resolved value\n});\n```\n\n---\n\n**Summary Table**\n\n| Feature      | `$q.all`                        | `$q.when`                           |\n|--------------|---------------------------------|-------------------------------------|\n| Input        | Array/Object of promises        | Value or promise                    |\n| Output       | Single promise                  | Single promise                      |\n| Resolves     | When all input promises resolve | When input value/promise resolves   |\n| Use Case     | Wait for multiple async ops     | Normalize value to a promise        |\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396270Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "f0164e0c-12bc-4553-abe2-054abdf35c9e",
        "question": "How do you manage loading indicators during async operations in AngularJS?",
        "answer": "```markdown\nTo manage loading indicators during asynchronous operations in AngularJS, you typically use a combination of scope variables and conditional rendering in your templates. Here’s a common approach:\n\n1. **Define a Loading Variable**  \n   In your controller, create a variable (e.g., `$scope.isLoading`) to track the loading state.\n\n   ```javascript\n   app.controller('MyController', function($scope, $http) {\n     $scope.isLoading = false;\n\n     $scope.loadData = function() {\n       $scope.isLoading = true;\n       $http.get('/api/data')\n         .then(function(response) {\n           $scope.data = response.data;\n         })\n         .finally(function() {\n           $scope.isLoading = false;\n         });\n     };\n   });\n   ```\n\n2. **Show/Hide the Loading Indicator in the Template**  \n   Use `ng-show` or `ng-if` to display a loading spinner or message when the async operation is in progress.\n\n   ```html\n   <button ng-click=\"loadData()\">Load Data</button>\n\n   <div ng-show=\"isLoading\">\n     <p>Loading...</p>\n     <!-- You can use a spinner icon here -->\n   </div>\n\n   <div ng-if=\"!isLoading\">\n     <!-- Display your data here -->\n     <pre>{{ data | json }}</pre>\n   </div>\n   ```\n\n3. **Best Practices**\n   - Use `.finally()` to ensure the loading indicator is hidden regardless of success or error.\n   - For multiple concurrent requests, consider using a counter or a service to manage loading states globally.\n\n**Summary:**  \nBy toggling a scope variable before and after your async operation, and binding it to your template, you can easily manage loading indicators in AngularJS applications.\n```",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396277Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "76f983df-566a-4522-b18a-7885c1674d4f",
        "question": "How do you handle API rate limiting in AngularJS applications?",
        "answer": "```markdown\n### Handling API Rate Limiting in AngularJS Applications\n\nAPI rate limiting restricts the number of requests a client can make to a server within a specific timeframe. Exceeding these limits can result in errors or temporary bans. In AngularJS applications, handling rate limiting involves both proactive and reactive strategies:\n\n---\n\n#### **1. Throttling and Debouncing Requests**\n\n- **Throttling**: Ensures that a function (e.g., an API call) is only executed once in a specified period.\n- **Debouncing**: Delays the function execution until a certain period has passed since the last invocation (useful for search/autocomplete).\n\n**Example using lodash:**\n```javascript\n$scope.search = _.debounce(function(query) {\n  // API call here\n}, 300);\n```\n\n---\n\n#### **2. Queueing Requests**\n\nImplement a request queue to ensure that only a certain number of requests are sent per time window.\n\n**Example:**\n```javascript\nvar requestQueue = [];\nvar isProcessing = false;\n\nfunction processQueue() {\n  if (requestQueue.length === 0 || isProcessing) return;\n  isProcessing = true;\n  var req = requestQueue.shift();\n  $http(req.config).then(req.resolve, req.reject).finally(function() {\n    isProcessing = false;\n    setTimeout(processQueue, 1000); // 1 request per second\n  });\n}\n\nfunction rateLimitedHttp(config) {\n  return $q(function(resolve, reject) {\n    requestQueue.push({ config: config, resolve: resolve, reject: reject });\n    processQueue();\n  });\n}\n```\n\n---\n\n#### **3. Handling 429 Too Many Requests Responses**\n\nAPIs often respond with HTTP 429 when rate limits are exceeded. Handle these in a global `$http` interceptor.\n\n**Example:**\n```javascript\napp.factory('rateLimitInterceptor', function($q, $timeout) {\n  return {\n    responseError: function(rejection) {\n      if (rejection.status === 429) {\n        var retryAfter = rejection.headers('Retry-After') || 1;\n        return $timeout(function() {\n          return $http(rejection.config);\n        }, retryAfter * 1000);\n      }\n      return $q.reject(rejection);\n    }\n  };\n});\n\napp.config(function($httpProvider) {\n  $httpProvider.interceptors.push('rateLimitInterceptor');\n});\n```\n\n---\n\n#### **4. Respecting Server Rate Limit Headers**\n\nSome APIs return headers like `X-RateLimit-Remaining` and `X-RateLimit-Reset`. Monitor these headers and adjust request logic accordingly.\n\n**Example:**\n```javascript\n$http.get('/api/data').then(function(response) {\n  var remaining = response.headers('X-RateLimit-Remaining');\n  var reset = response.headers('X-RateLimit-Reset');\n  // Use this info to adjust request frequency\n});\n```\n\n---\n\n#### **5. Using Third-Party Libraries**\n\nConsider libraries like [angular-rate-limit](https://github.com/krispo/angular-rate-limit) or integrating with RxJS for more advanced rate limiting and retry strategies.\n\n---\n\n### **Summary Table**\n\n| Strategy                | Description                                      |\n|-------------------------|--------------------------------------------------|\n| Throttling/Debouncing   | Limit frequency of API calls                     |\n| Queueing                | Serialize requests to avoid bursts               |\n| Interceptors            | Handle 429 errors and implement retries          |\n| Header Monitoring       | Adjust logic based on rate limit headers         |\n| Libraries               | Use existing solutions for complex scenarios     |\n\n---\n\n**Best Practice:**  \nCombine these strategies as needed, depending on your API's rate limiting policy and your application's requirements.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396283Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "edc0275a-cac7-4336-ba09-050e10ff0682",
        "question": "How do you cache API responses in AngularJS?",
        "answer": "```markdown\n### How to Cache API Responses in AngularJS\n\nCaching API responses in AngularJS can improve performance by reducing unnecessary network requests. Here are common approaches to caching API responses:\n\n#### 1. Using `$http` with Caching\n\nAngularJS's `$http` service supports built-in caching for GET requests. You can enable it by setting the `cache` option to `true`:\n\n```javascript\n$http.get('/api/data', { cache: true })\n  .then(function(response) {\n    // Use response.data\n  });\n```\n\n- **How it works:** The response is cached in the default `$cacheFactory` cache. Subsequent requests to the same URL will return the cached response.\n\n#### 2. Custom Cache with `$cacheFactory`\n\nFor more control, create a custom cache using `$cacheFactory`:\n\n```javascript\nangular.module('myApp').factory('myCache', function($cacheFactory) {\n  return $cacheFactory('myCache');\n});\n\nangular.module('myApp').service('ApiService', function($http, myCache) {\n  this.getData = function() {\n    var cachedData = myCache.get('data');\n    if (cachedData) {\n      return Promise.resolve(cachedData);\n    } else {\n      return $http.get('/api/data').then(function(response) {\n        myCache.put('data', response.data);\n        return response.data;\n      });\n    }\n  };\n});\n```\n\n- **How it works:** The service checks the cache before making an API call. If data is cached, it returns it; otherwise, it fetches from the API and stores the result.\n\n#### 3. Using Third-Party Libraries\n\nLibraries like [`angular-cache`](https://github.com/jmdobry/angular-cache) provide advanced caching features, such as expiration and persistence.\n\n#### 4. Manual Caching in Services\n\nYou can also manually cache responses in a service variable:\n\n```javascript\nangular.module('myApp').service('ApiService', function($http) {\n  var cachedData = null;\n\n  this.getData = function() {\n    if (cachedData) {\n      return Promise.resolve(cachedData);\n    } else {\n      return $http.get('/api/data').then(function(response) {\n        cachedData = response.data;\n        return cachedData;\n      });\n    }\n  };\n});\n```\n\n---\n\n**Summary:**  \nAngularJS offers built-in and customizable ways to cache API responses, primarily through the `$http` service's `cache` option, `$cacheFactory`, or manual caching in services. Choose the approach that best fits your application's needs.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396291Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "048cb597-910a-4b05-a5f6-1db5fce83081",
        "question": "What are the best practices for error handling in async operations in AngularJS?",
        "answer": "```markdown\n### Best Practices for Error Handling in Async Operations in AngularJS\n\nHandling errors effectively in asynchronous operations (such as HTTP requests or promises) is crucial for building robust AngularJS applications. Here are some best practices:\n\n---\n\n#### 1. **Use `.catch()` or `.then(null, errorCallback)` with Promises**\nAlways attach error handlers to your promises to catch and process errors.\n\n```javascript\n$http.get('/api/data')\n  .then(function(response) {\n    // Success logic\n  })\n  .catch(function(error) {\n    // Error handling logic\n  });\n```\n\n---\n\n#### 2. **Centralize Error Handling with Interceptors**\nAngularJS allows you to define `$http` interceptors to handle errors globally.\n\n```javascript\napp.factory('httpErrorInterceptor', function($q, $injector) {\n  return {\n    responseError: function(rejection) {\n      // Handle error (e.g., show notification)\n      return $q.reject(rejection);\n    }\n  };\n});\n\napp.config(function($httpProvider) {\n  $httpProvider.interceptors.push('httpErrorInterceptor');\n});\n```\n\n---\n\n#### 3. **Provide User Feedback**\nDisplay meaningful error messages to users, but avoid exposing sensitive information.\n\n```javascript\n.catch(function(error) {\n  $scope.errorMessage = \"An error occurred. Please try again later.\";\n});\n```\n\n---\n\n#### 4. **Log Errors for Debugging**\nUse AngularJS’s `$log` service or a custom logging service to record errors for debugging.\n\n```javascript\n.catch(function(error) {\n  $log.error('API error:', error);\n});\n```\n\n---\n\n#### 5. **Graceful Degradation**\nEnsure your application can continue to function (at least partially) even if some async operations fail.\n\n---\n\n#### 6. **Retry Failed Requests (When Appropriate)**\nImplement retry logic for transient errors (e.g., network issues).\n\n```javascript\nfunction retryHttpRequest(requestFn, retries) {\n  return requestFn().catch(function(error) {\n    if (retries > 0) {\n      return retryHttpRequest(requestFn, retries - 1);\n    }\n    return $q.reject(error);\n  });\n}\n```\n\n---\n\n#### 7. **Handle Specific Error Codes**\nDifferentiate error handling based on HTTP status codes (e.g., 401 Unauthorized, 404 Not Found).\n\n```javascript\n.catch(function(error) {\n  if (error.status === 401) {\n    // Redirect to login\n  } else if (error.status === 404) {\n    // Show not found message\n  }\n});\n```\n\n---\n\n#### 8. **Clean Up Resources**\nOn error, ensure any resources (like loading indicators or subscriptions) are properly cleaned up.\n\n---\n\n#### 9. **Use `$q.reject()` for Custom Errors**\nWhen creating custom promises, use `$q.reject()` to propagate errors.\n\n```javascript\nreturn $q.reject('Custom error message');\n```\n\n---\n\n#### 10. **Document and Test Error Scenarios**\nDocument possible error cases and write unit tests to ensure your error handling works as expected.\n\n---\n\n**Summary Table**\n\n| Practice                        | Benefit                              |\n|----------------------------------|--------------------------------------|\n| Use `.catch()`                   | Catches and handles promise errors   |\n| Centralize with interceptors     | DRY, consistent error handling       |\n| Provide user feedback            | Better user experience               |\n| Log errors                       | Easier debugging                     |\n| Graceful degradation             | App remains usable                   |\n| Retry logic                      | Handles transient failures           |\n| Handle specific error codes      | Appropriate responses per error type |\n| Clean up resources               | Prevents memory leaks, UI issues     |\n| Use `$q.reject()`                | Proper promise error propagation     |\n| Document & test                  | Reliable, maintainable code          |\n\n---\n```",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396298Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "ada7d714-0b0b-490c-b008-7d0c02fef4f1",
        "question": "How do you test asynchronous API calls in AngularJS?",
        "answer": "```markdown\n### Testing Asynchronous API Calls in AngularJS\n\nTesting asynchronous API calls in AngularJS typically involves using the built-in `$httpBackend` service provided by the `ngMock` module. This allows you to mock HTTP requests and control their responses, enabling you to test how your code handles asynchronous operations without making real API calls.\n\n#### Steps to Test Asynchronous API Calls\n\n1. **Include the `ngMock` Module**  \n   Make sure to include `angular-mocks.js` in your test environment.\n\n2. **Inject Dependencies**  \n   Inject the service under test and `$httpBackend` into your test.\n\n   ```javascript\n   beforeEach(module('myApp'));\n\n   var $httpBackend, myService;\n   beforeEach(inject(function(_$httpBackend_, _myService_) {\n     $httpBackend = _$httpBackend_;\n     myService = _myService_;\n   }));\n   ```\n\n3. **Set Up Mock HTTP Expectations**  \n   Use `$httpBackend.expectGET()`, `.expectPOST()`, etc., to specify expected API calls and their mock responses.\n\n   ```javascript\n   $httpBackend.expectGET('/api/data').respond(200, { result: 'success' });\n   ```\n\n4. **Trigger the API Call**  \n   Call the method in your service or controller that makes the HTTP request.\n\n   ```javascript\n   var response;\n   myService.getData().then(function(res) {\n     response = res.data;\n   });\n   ```\n\n5. **Flush the Backend**  \n   Use `$httpBackend.flush()` to simulate the asynchronous response.\n\n   ```javascript\n   $httpBackend.flush();\n   ```\n\n6. **Assert the Results**  \n   Check that your code handled the response as expected.\n\n   ```javascript\n   expect(response).toEqual({ result: 'success' });\n   ```\n\n7. **Verify No Outstanding Requests**  \n   Ensure there are no unexpected HTTP requests left.\n\n   ```javascript\n   afterEach(function() {\n     $httpBackend.verifyNoOutstandingExpectation();\n     $httpBackend.verifyNoOutstandingRequest();\n   });\n   ```\n\n#### Example Test\n\n```javascript\ndescribe('myService', function() {\n  beforeEach(module('myApp'));\n\n  var $httpBackend, myService;\n\n  beforeEach(inject(function(_$httpBackend_, _myService_) {\n    $httpBackend = _$httpBackend_;\n    myService = _myService_;\n  }));\n\n  it('should fetch data asynchronously', function() {\n    $httpBackend.expectGET('/api/data').respond(200, { result: 'success' });\n\n    var result;\n    myService.getData().then(function(response) {\n      result = response.data;\n    });\n\n    $httpBackend.flush();\n    expect(result).toEqual({ result: 'success' });\n  });\n\n  afterEach(function() {\n    $httpBackend.verifyNoOutstandingExpectation();\n    $httpBackend.verifyNoOutstandingRequest();\n  });\n});\n```\n\n#### Key Points\n\n- Use `$httpBackend` to mock and control HTTP requests.\n- Always flush the backend to resolve promises.\n- Clean up with `verifyNoOutstandingExpectation()` and `verifyNoOutstandingRequest()`.\n\nThis approach allows you to reliably test asynchronous API integration in AngularJS applications.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396305Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "a70e62f8-f31c-49d1-82e6-72fa00bfc2e0",
        "question": "How do you mock HTTP requests in AngularJS unit tests?",
        "answer": "```markdown To mock HTTP requests in AngularJS unit tests, you use the $httpBackend service provided by the ngMock module. This allows you to simulate backend API responses without making real HTTP calls. Here’s how you can do it:\n\n```javascript\ndescribe('MyService', function() {\n  var $httpBackend, MyService;\n\n  beforeEach(module('myApp'));\n\n  beforeEach(inject(function(_$httpBackend_, _MyService_) {\n    $httpBackend = _$httpBackend_;\n    MyService = _MyService_;\n  }));\n\n  afterEach(function() {\n    // Ensure that all expects set on the $httpBackend were actually called\n    $httpBackend.verifyNoOutstandingExpectation();\n    $httpBackend.verifyNoOutstandingRequest();\n  });\n\n  it('should fetch data from API', function() {\n    var mockResponse = { data: 'test' };\n\n    // Set up the expected HTTP request and response\n    $httpBackend.expectGET('/api/data').respond(200, mockResponse);\n\n    var result;\n    MyService.getData().then(function(response) {\n      result = response.data;\n    });\n\n    // Flush pending HTTP requests\n    $httpBackend.flush();\n\n    expect(result).toEqual('test');\n  });\n});\n```\n\n**Key Points:**\n\n- Inject $httpBackend in your test.\n- Use $httpBackend.expectGET(), expectPOST(), etc., to define expected requests and mock responses.\n- Call $httpBackend.flush() to simulate the asynchronous response.\n- Use $httpBackend.verifyNoOutstandingExpectation() and $httpBackend.verifyNoOutstandingRequest() to ensure all requests are handled.\n- This approach isolates your unit tests from real backend services, making them fast and reliable.\n\n**References:**\n- [AngularJS $httpBackend documentation](https://docs.angularjs.org/api/ngMock/service/$httpBackend)\n- [Testing AngularJS Applications (Official Guide)](https://docs.angularjs.org/guide/unit-testing)",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396312Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "7f8698c8-66f9-4970-bc8b-3aa0c9fef3d7",
        "question": "What is the digest cycle and how does it relate to async operations in AngularJS?",
        "answer": "```markdown\n### What is the Digest Cycle and How Does it Relate to Async Operations in AngularJS?\n\n#### The Digest Cycle\n\nIn AngularJS, the **digest cycle** is the core mechanism that keeps the view (DOM) in sync with the model (JavaScript objects). It is a loop that checks all the watched expressions (using `$watch`) on the `$scope` for changes. If a change is detected, AngularJS updates the DOM accordingly.\n\n- The digest cycle is triggered automatically by AngularJS when certain events occur, such as user interactions (ng-click), HTTP responses, or timers (like `$timeout`).\n- Internally, the digest cycle repeatedly checks all watchers until no more changes are detected (this is called \"dirty checking\").\n\n#### Relation to Async Operations\n\nAsync operations—such as HTTP requests, timeouts, and custom asynchronous code—often update the model outside of AngularJS's direct control. AngularJS needs to be notified to run the digest cycle so that changes are reflected in the view.\n\n- **$http, $timeout, $interval**: These AngularJS services automatically trigger the digest cycle after their callbacks execute. For example, when an `$http` request completes, AngularJS runs `$digest` to update the view with new data.\n- **Third-party async code (e.g., setTimeout, Promises not using $q)**: If you use native JavaScript async APIs, AngularJS is unaware of the changes. You must manually trigger a digest cycle using `$scope.$apply()` to update the view.\n\n#### Example\n\n```javascript\n// Using $http (digest cycle triggered automatically)\n$http.get('/api/data').then(function(response) {\n  $scope.data = response.data;\n  // No need to call $scope.$apply()\n});\n\n// Using native setTimeout (digest cycle NOT triggered automatically)\nsetTimeout(function() {\n  $scope.value = 42;\n  $scope.$apply(); // Manually trigger digest cycle\n}, 1000);\n```\n\n#### Summary Table\n\n| Async Source         | Digest Cycle Triggered Automatically? | Manual Action Needed?      |\n|----------------------|:-------------------------------------:|:-------------------------:|\n| `$http`, `$timeout`  | Yes                                   | No                        |\n| Native `setTimeout`  | No                                    | Yes, use `$scope.$apply()`|\n| Custom async code    | No                                    | Yes, use `$scope.$apply()`|\n\n#### Key Takeaway\n\nThe digest cycle is essential for AngularJS's two-way data binding. For async operations, ensure that the digest cycle runs after your model changes—either automatically (with AngularJS services) or manually (with `$scope.$apply()` for external async code)—to keep your view and model in sync.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396319Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "53bc3b4b-a162-40e4-a358-3b58f33c8582",
        "question": "How do you prevent memory leaks in AngularJS when dealing with async operations?",
        "answer": "```markdown\n### Preventing Memory Leaks in AngularJS with Async Operations\n\nMemory leaks in AngularJS often occur when asynchronous operations (such as `$http`, `$timeout`, `$interval`, or custom event listeners) are not properly cleaned up, especially when controllers or scopes are destroyed. Here are best practices to prevent such leaks:\n\n---\n\n#### 1. **Unsubscribe from Events and Observables**\n\n- **$scope.$on**: When registering event listeners, always deregister them on scope destruction.\n\n  ```javascript\n  var deregister = $scope.$on('someEvent', function() { ... });\n  $scope.$on('$destroy', deregister);\n  ```\n\n- **Custom Event Listeners**: Remove any listeners you add to DOM or services.\n\n---\n\n#### 2. **Cancel Pending $timeout and $interval**\n\n- Always store the promise returned by `$timeout` or `$interval` and cancel it on `$destroy`.\n\n  ```javascript\n  var timeoutPromise = $timeout(function() { ... }, 1000);\n  $scope.$on('$destroy', function() {\n    $timeout.cancel(timeoutPromise);\n  });\n  ```\n\n---\n\n#### 3. **Abort Pending $http Requests**\n\n- Use the `timeout` property in `$http` to cancel requests when the scope is destroyed.\n\n  ```javascript\n  var canceler = $q.defer();\n  $http.get('/api/data', { timeout: canceler.promise });\n\n  $scope.$on('$destroy', function() {\n    canceler.resolve(); // Aborts the request\n  });\n  ```\n\n---\n\n#### 4. **Clean Up Third-Party Subscriptions**\n\n- If using libraries like RxJS, always unsubscribe on `$destroy`.\n\n  ```javascript\n  var subscription = observable.subscribe(...);\n  $scope.$on('$destroy', function() {\n    subscription.unsubscribe();\n  });\n  ```\n\n---\n\n#### 5. **Avoid Global State Pollution**\n\n- Do not attach data or listeners to `$rootScope` unless necessary, and always clean up if you do.\n\n---\n\n#### 6. **Use One-Time Bindings Where Possible**\n\n- Use `::` one-time bindings to avoid unnecessary watchers.\n\n  ```html\n  <span>{{::someValue}}</span>\n  ```\n\n---\n\n#### **Summary Table**\n\n| Async Operation      | Prevention Technique                        |\n|---------------------|---------------------------------------------|\n| $scope.$on          | Deregister on `$destroy`                    |\n| $timeout/$interval  | Cancel on `$destroy`                        |\n| $http               | Use `timeout` and resolve on `$destroy`     |\n| RxJS/Observables    | Unsubscribe on `$destroy`                   |\n| DOM/Event Listeners | Remove on `$destroy`                        |\n\n---\n\n**In summary:**  \nAlways clean up any asynchronous operation or event listener when the associated scope or component is destroyed. This ensures that no references are kept, preventing memory leaks in AngularJS applications.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396326Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "950e45d9-8e7d-4100-be8d-1d7283077730",
        "question": "How do you update the UI after an async operation completes in AngularJS?",
        "answer": "```markdown\nIn AngularJS, when you perform an asynchronous operation (such as an API call using `$http` or `$q`), Angular's digest cycle automatically updates the UI when the operation completes, as long as the async code runs within Angular's context.\n\n**Example:**\n\n```javascript\napp.controller('MyController', function($scope, $http) {\n  $scope.data = null;\n\n  $http.get('/api/data').then(function(response) {\n    $scope.data = response.data;\n    // The UI will automatically update to reflect the new value of $scope.data\n  });\n});\n```\n\n**Key Points:**\n- Use AngularJS services like `$http` or `$q` for async operations.\n- Update `$scope` variables inside the `.then()` or `.success()` callback.\n- AngularJS will detect the change and update the UI automatically.\n\n**Note:**  \nIf you use non-AngularJS async code (like plain JavaScript `setTimeout` or third-party libraries), you may need to manually trigger a digest cycle using `$scope.$apply()`:\n\n```javascript\nsetTimeout(function() {\n  $scope.$apply(function() {\n    $scope.data = 'Updated!';\n  });\n}, 1000);\n```\n```\n",
        "level": "Beginner",
        "created_at": "2025-04-20T11:04:10.396333Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "75534b73-badd-4de8-b47d-d053d667c7f7",
        "question": "How do you handle file uploads to an API in AngularJS?",
        "answer": "```markdown\nTo handle file uploads to an API in AngularJS, you typically use the following approach:\n\n### 1. Use a File Input in Your HTML\n\n```html\n<form ng-submit=\"uploadFile()\">\n  <input type=\"file\" file-model=\"myFile\" />\n  <button type=\"submit\">Upload</button>\n</form>\n```\n\n### 2. Create a Custom Directive to Bind the File Input\n\nAngularJS does not natively bind file inputs to models, so you need a directive:\n\n```javascript\napp.directive('fileModel', ['$parse', function ($parse) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      var model = $parse(attrs.fileModel);\n      var modelSetter = model.assign;\n\n      element.bind('change', function(){\n        scope.$apply(function(){\n          modelSetter(scope, element[0].files[0]);\n        });\n      });\n    }\n  };\n}]);\n```\n\n### 3. Use FormData and `$http` to Send the File\n\nIn your controller:\n\n```javascript\napp.controller('MyCtrl', ['$scope', '$http', function($scope, $http) {\n  $scope.uploadFile = function() {\n    var file = $scope.myFile;\n    var formData = new FormData();\n    formData.append('file', file);\n\n    $http.post('/api/upload', formData, {\n      transformRequest: angular.identity,\n      headers: { 'Content-Type': undefined }\n    }).then(function(response) {\n      // Handle success\n      console.log('File uploaded successfully', response.data);\n    }, function(error) {\n      // Handle error\n      console.error('Error uploading file', error);\n    });\n  };\n}]);\n```\n\n### 4. Key Points\n\n- Use `FormData` to send files as multipart/form-data.\n- Set `Content-Type` to `undefined` so the browser sets the correct boundary.\n- Use `angular.identity` for `transformRequest` to prevent Angular from serializing the data.\n\n### 5. Optional: Use Third-Party Libraries\n\nFor more advanced use cases (progress bars, drag-and-drop, etc.), consider libraries like [ng-file-upload](https://github.com/danialfarid/ng-file-upload).\n\n---\n\n**Summary:**  \nFile uploads in AngularJS require a custom directive for file input binding, use of `FormData` for payload, and proper configuration of `$http` to send the file to your API endpoint.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396345Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "a3943ca7-8a4c-499c-9b69-2b47f9a785e0",
        "question": "How do you handle long polling or server-sent events in AngularJS?",
        "answer": "```markdown\nTo handle **long polling** or **server-sent events (SSE)** in AngularJS, you need to manage asynchronous communication with the server, often outside the standard `$http` service. Here’s how you can approach each:\n\n---\n\n### 1. Long Polling\n\nLong polling involves repeatedly making HTTP requests to the server, where the server holds the request open until new data is available or a timeout occurs.\n\n**Implementation Steps:**\n\n- Use `$http` or `$resource` to make the initial request.\n- On response, process the data and immediately issue another request.\n- Handle errors and implement retry logic as needed.\n\n**Example:**\n\n```javascript\napp.factory('LongPollingService', function($http, $timeout, $rootScope) {\n  var poll = function() {\n    $http.get('/api/updates').then(function(response) {\n      // Process new data\n      $rootScope.$broadcast('newData', response.data);\n      // Immediately poll again\n      poll();\n    }, function(error) {\n      // Retry after a delay on error\n      $timeout(poll, 5000);\n    });\n  };\n\n  return {\n    start: poll\n  };\n});\n```\n\n**Usage:**\n\n```javascript\napp.controller('MainCtrl', function(LongPollingService) {\n  LongPollingService.start();\n});\n```\n\n---\n\n### 2. Server-Sent Events (SSE)\n\nSSE uses the `EventSource` API to receive automatic updates from the server via a persistent HTTP connection.\n\n**Implementation Steps:**\n\n- Use the native `EventSource` API (not available in `$http`).\n- Listen for messages and update the AngularJS scope accordingly.\n- Use `$scope.$apply()` or `$timeout` to trigger digest cycles when updating scope variables.\n\n**Example:**\n\n```javascript\napp.factory('SSEService', function($rootScope, $timeout) {\n  var source = new EventSource('/api/stream');\n\n  source.onmessage = function(event) {\n    // Use $timeout to safely update scope\n    $timeout(function() {\n      $rootScope.$broadcast('newData', JSON.parse(event.data));\n    });\n  };\n\n  source.onerror = function(error) {\n    // Handle errors (e.g., reconnect logic)\n    console.error('SSE error:', error);\n  };\n\n  return source;\n});\n```\n\n**Usage:**\n\n```javascript\napp.controller('MainCtrl', function($scope, SSEService) {\n  $scope.data = [];\n\n  $scope.$on('newData', function(event, data) {\n    $scope.data.push(data);\n  });\n});\n```\n\n---\n\n### **Best Practices**\n\n- Always clean up event listeners or polling intervals when the controller/scope is destroyed to prevent memory leaks.\n- Use `$timeout` or `$scope.$apply()` when updating scope variables from outside AngularJS (e.g., native EventSource callbacks).\n- Handle network errors and implement reconnection logic as needed.\n\n---\n\n**Summary Table**\n\n| Technique         | API Used      | AngularJS Integration      | Use Case                |\n|-------------------|--------------|----------------------------|-------------------------|\n| Long Polling      | `$http`      | Recursively call on success| Broad compatibility     |\n| Server-Sent Events| `EventSource`| Use `$timeout` for digest  | Real-time updates, SSE  |\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396358Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "3297078e-ec3e-49db-b17e-f5f4ff5dd66c",
        "question": "How do you implement request throttling or debouncing in AngularJS API calls?",
        "answer": "```markdown\n### Implementing Request Throttling or Debouncing in AngularJS API Calls\n\nIn AngularJS, to prevent excessive API calls (such as those triggered by rapid user input), you can implement **throttling** or **debouncing**. These techniques help optimize performance and reduce server load.\n\n#### 1. Debouncing API Calls\n\n**Debouncing** ensures that the API call is made only after a specified period of inactivity. This is useful for scenarios like search inputs.\n\n**Example using `$timeout`:**\n\n```javascript\napp.controller('SearchController', function($scope, $http, $timeout) {\n  let debounceTimeout;\n\n  $scope.search = function(query) {\n    if (debounceTimeout) {\n      $timeout.cancel(debounceTimeout);\n    }\n    debounceTimeout = $timeout(function() {\n      $http.get('/api/search', { params: { q: query } })\n        .then(function(response) {\n          $scope.results = response.data;\n        });\n    }, 300); // 300ms debounce\n  };\n});\n```\n\n**Usage in template:**\n```html\n<input ng-model=\"searchQuery\" ng-change=\"search(searchQuery)\">\n```\n\n#### 2. Throttling API Calls\n\n**Throttling** ensures that the API call is made at most once in a specified interval, regardless of how many times the event is triggered.\n\n**Example using a custom throttle function:**\n\n```javascript\napp.factory('throttle', function($timeout) {\n  return function(fn, threshhold) {\n    let last, promise;\n    return function() {\n      let context = this, args = arguments;\n      let now = Date.now();\n      if (last && now < last + threshhold) {\n        $timeout.cancel(promise);\n        promise = $timeout(function() {\n          last = now;\n          fn.apply(context, args);\n        }, threshhold);\n      } else {\n        last = now;\n        fn.apply(context, args);\n      }\n    };\n  };\n});\n\napp.controller('SearchController', function($scope, $http, throttle) {\n  $scope.throttledSearch = throttle(function(query) {\n    $http.get('/api/search', { params: { q: query } })\n      .then(function(response) {\n        $scope.results = response.data;\n      });\n  }, 500); // 500ms throttle\n});\n```\n\n**Usage in template:**\n```html\n<input ng-model=\"searchQuery\" ng-change=\"throttledSearch(searchQuery)\">\n```\n\n---\n\n### Summary Table\n\n| Technique   | When to Use                      | AngularJS Tooling      |\n|-------------|----------------------------------|------------------------|\n| Debouncing  | Wait for user to stop typing     | `$timeout`             |\n| Throttling  | Limit calls to fixed intervals   | Custom/throttle factory|\n\n---\n\n**Tip:** For more advanced use-cases, consider integrating lodash's `_.debounce` or `_.throttle` functions with AngularJS.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396369Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b07c5586-0140-4af4-ad26-352b90518e98",
        "question": "How do you secure sensitive data in API requests made from AngularJS?",
        "answer": "```markdown\nSecuring sensitive data in API requests from AngularJS involves several best practices, as client-side code is inherently exposed to users. Here are key strategies:\n\n### 1. **Never Store Sensitive Data in the Frontend**\n- Do **not** store secrets (API keys, passwords, tokens) in AngularJS code or configuration files.\n- Use environment variables and server-side logic to handle sensitive data.\n\n### 2. **Use HTTPS**\n- Always serve your AngularJS application and make API requests over HTTPS to encrypt data in transit and prevent man-in-the-middle attacks.\n\n### 3. **Authentication & Authorization**\n- Implement secure authentication mechanisms (e.g., OAuth 2.0, JWT).\n- Store tokens securely (preferably in `HttpOnly` cookies to mitigate XSS attacks).\n- Never expose authentication credentials in the frontend.\n\n### 4. **Backend as a Proxy**\n- Route API requests through your backend server. The frontend communicates with your backend, which then securely interacts with third-party APIs using sensitive credentials.\n\n### 5. **Input Validation & Sanitization**\n- Validate and sanitize all user input on both client and server sides to prevent injection attacks.\n\n### 6. **CORS Configuration**\n- Restrict API access using CORS policies to only allow trusted origins.\n\n### 7. **Use CSRF Protection**\n- Implement CSRF tokens for state-changing requests to prevent cross-site request forgery.\n\n### 8. **Minimal Data Exposure**\n- Only send necessary data in API requests and responses. Avoid sending sensitive information unless absolutely required.\n\n### 9. **Monitor and Log**\n- Monitor API usage and log suspicious activities for auditing and incident response.\n\n---\n\n**Example: Using Backend Proxy for API Integration**\n\n```javascript\n// AngularJS frontend makes a request to your backend\n$http.post('/api/secure-action', { data: userInput })\n  .then(function(response) {\n    // handle response\n  });\n```\n\n```js\n// Node.js backend securely interacts with the third-party API\napp.post('/api/secure-action', (req, res) => {\n  // Use server-stored API keys/secrets\n  // Make request to third-party API\n  // Return result to frontend\n});\n```\n\n---\n\n**Summary Table**\n\n| Practice                  | Where to Implement | Purpose                                   |\n|---------------------------|-------------------|-------------------------------------------|\n| No secrets in frontend    | Frontend          | Prevent exposure of sensitive data        |\n| HTTPS                     | Both              | Encrypt data in transit                   |\n| Auth & tokens             | Both              | Secure user authentication                |\n| Backend proxy             | Backend           | Hide credentials from client              |\n| Input validation          | Both              | Prevent injection attacks                 |\n| CORS                      | Backend           | Restrict API access                       |\n| CSRF protection           | Backend           | Prevent CSRF attacks                      |\n| Minimal data exposure     | Both              | Reduce risk of data leakage               |\n| Monitoring                | Backend           | Detect and respond to threats             |\n\n---\n\n**In summary:**  \nSensitive data should never be exposed or handled directly in AngularJS code. Always use secure, server-side mechanisms for authentication, authorization, and API integration, and follow security best practices to protect your application and users.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396381Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "802407ce-373c-432f-be1a-40f1797070d2",
        "question": "How do you handle API versioning in AngularJS applications?",
        "answer": "```markdown\n### Handling API Versioning in AngularJS Applications\n\nAPI versioning is crucial for maintaining backward compatibility and enabling smooth upgrades in your AngularJS applications. Here’s how you can effectively handle API versioning:\n\n#### 1. **URL-Based Versioning**\nThe most common approach is to include the version number in the API endpoint URL.\n\n**Example:**\n```javascript\n// Service definition\nangular.module('myApp').service('UserService', function($http) {\n  const API_BASE = 'https://api.example.com/v2'; // v2 indicates the API version\n\n  this.getUser = function(id) {\n    return $http.get(`${API_BASE}/users/${id}`);\n  };\n});\n```\n- **Pros:** Easy to manage multiple versions.\n- **Cons:** Requires updating all endpoints when changing versions.\n\n#### 2. **Header-Based Versioning**\nSpecify the API version in the HTTP headers.\n\n**Example:**\n```javascript\nangular.module('myApp').service('UserService', function($http) {\n  const API_BASE = 'https://api.example.com';\n\n  this.getUser = function(id) {\n    return $http.get(`${API_BASE}/users/${id}`, {\n      headers: { 'Accept-Version': 'v2' }\n    });\n  };\n});\n```\n- **Pros:** Clean URLs, versioning is abstracted from the endpoint.\n- **Cons:** Requires server support for header parsing.\n\n#### 3. **Centralized Configuration**\nUse AngularJS constants or configuration blocks to manage API versions centrally.\n\n**Example:**\n```javascript\nangular.module('myApp')\n  .constant('API_CONFIG', {\n    baseUrl: 'https://api.example.com',\n    version: 'v2'\n  })\n  .service('UserService', function($http, API_CONFIG) {\n    this.getUser = function(id) {\n      return $http.get(`${API_CONFIG.baseUrl}/${API_CONFIG.version}/users/${id}`);\n    };\n  });\n```\n- **Pros:** Easy to update the version in one place.\n\n#### 4. **Interceptors for Dynamic Versioning**\nUse `$httpInterceptor` to automatically append version info to all requests.\n\n**Example:**\n```javascript\nangular.module('myApp')\n  .factory('apiVersionInterceptor', function(API_CONFIG) {\n    return {\n      request: function(config) {\n        if (config.url.startsWith(API_CONFIG.baseUrl)) {\n          config.url = config.url.replace(API_CONFIG.baseUrl, `${API_CONFIG.baseUrl}/${API_CONFIG.version}`);\n        }\n        return config;\n      }\n    };\n  })\n  .config(function($httpProvider) {\n    $httpProvider.interceptors.push('apiVersionInterceptor');\n  });\n```\n- **Pros:** Centralizes versioning logic, reduces code duplication.\n\n#### 5. **Best Practices**\n- **Document** which API version each service uses.\n- **Gracefully handle** deprecated endpoints and errors.\n- **Test** thoroughly when upgrading API versions.\n\n---\n\n**Summary:**  \nAPI versioning in AngularJS can be managed via URL paths, headers, centralized configs, or interceptors. Choose the method that best fits your backend and team workflow, and always keep versioning logic maintainable and well-documented.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396388Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "a601e228-b850-4e4f-817e-4f64dbd9b063",
        "question": "How do you use $timeout and $interval for async operations in AngularJS?",
        "answer": "```markdown\nIn AngularJS, `$timeout` and `$interval` are services used to handle asynchronous operations related to timing.\n\n### `$timeout`\n- Similar to JavaScript's `setTimeout`.\n- Executes a function after a specified delay (in milliseconds).\n- Returns a promise, allowing you to handle completion or cancellation.\n\n**Example:**\n```javascript\napp.controller('MyCtrl', function($scope, $timeout) {\n  $scope.message = \"Waiting...\";\n\n  $timeout(function() {\n    $scope.message = \"Timeout executed!\";\n  }, 2000); // Executes after 2 seconds\n});\n```\n\n### `$interval`\n- Similar to JavaScript's `setInterval`.\n- Repeatedly executes a function at specified intervals.\n- Returns a promise-like object that can be cancelled.\n\n**Example:**\n```javascript\napp.controller('MyCtrl', function($scope, $interval) {\n  $scope.counter = 0;\n\n  var stop = $interval(function() {\n    $scope.counter++;\n    if ($scope.counter === 5) {\n      $interval.cancel(stop); // Stop after 5 increments\n    }\n  }, 1000); // Executes every 1 second\n});\n```\n\n### Key Points\n- Both services automatically trigger AngularJS's digest cycle, updating the view when the model changes.\n- Always cancel intervals/timeouts in `$destroy` event to prevent memory leaks:\n  ```javascript\n  $scope.$on('$destroy', function() {\n    $interval.cancel(stop);\n  });\n  ```\n\n### Use Cases\n- `$timeout`: Delayed actions (e.g., showing messages, debouncing input).\n- `$interval`: Polling APIs, updating clocks, or periodic tasks.\n\nThese services help manage async operations in a way that's integrated with AngularJS's scope and digest cycle.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396395Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "454e2944-76fe-48c7-a033-7e6b19094ec9",
        "question": "What are the limitations of AngularJS $http service for API integration?",
        "answer": "```markdown\n### Limitations of AngularJS `$http` Service for API Integration\n\nWhile AngularJS's `$http` service provides a convenient way to make HTTP requests, it has several limitations when used for API integration, especially in advanced or large-scale applications:\n\n1. **Limited Interceptors and Middleware Support**\n   - `$http` supports request and response interceptors, but the mechanism is less flexible compared to modern alternatives (like Angular's `HttpClient` or libraries such as Axios).\n   - Complex middleware chains or advanced request/response transformations can be cumbersome to implement.\n\n2. **No Built-in Retry or Advanced Error Handling**\n   - `$http` does not provide built-in support for retrying failed requests, exponential backoff, or circuit breaker patterns.\n   - Developers must manually implement such logic, increasing code complexity.\n\n3. **Lack of Observable Support**\n   - `$http` uses promises (`$q`), not Observables, limiting its ability to handle complex asynchronous flows, cancellations, or streams of data.\n   - This makes it less suitable for real-time or event-driven API integrations.\n\n4. **No Automatic JSON Transformation for Non-Standard APIs**\n   - `$http` automatically serializes and deserializes JSON, but if an API uses a different content type or requires custom serialization, extra configuration is needed.\n\n5. **CORS and Security Limitations**\n   - `$http` cannot bypass browser-enforced CORS restrictions. If the API does not support CORS, integration is not possible from the browser.\n   - Handling authentication tokens (e.g., JWT) and secure storage must be managed manually.\n\n6. **Limited Progress Event Support**\n   - `$http` does not natively support progress events for uploads/downloads, making it harder to provide user feedback during large file transfers.\n\n7. **No Built-in Request Cancellation**\n   - While `$http` allows request cancellation via the `timeout` property, it is less intuitive and flexible compared to modern APIs that use `AbortController` or Observable cancellation.\n\n8. **Verbose Configuration for Advanced Scenarios**\n   - Advanced configurations (e.g., custom headers, credentials, response types) require verbose and sometimes repetitive code.\n\n9. **No Built-in Support for Modern Features**\n   - Lacks built-in support for features like HTTP/2, WebSockets, or GraphQL, which are increasingly common in modern APIs.\n\n10. **Deprecation and Lack of Updates**\n    - AngularJS (and thus `$http`) is no longer actively maintained, meaning no new features, security updates, or bug fixes.\n\n---\n\n**Summary:**  \nWhile AngularJS’s `$http` service is sufficient for basic API integration, it falls short in terms of flexibility, advanced features, and modern best practices required for robust, scalable, and secure API interactions in contemporary web applications.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396402Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "df71cfb2-cc04-4505-8412-626de6749755",
        "question": "How do you handle cross-domain requests in AngularJS?",
        "answer": "```markdown\n### Handling Cross-Domain Requests in AngularJS\n\nIn AngularJS, cross-domain (CORS) requests are typically handled using the `$http` service, which supports AJAX calls to external APIs. However, browsers enforce the Same-Origin Policy, so the server you are requesting data from must explicitly allow cross-origin requests.\n\n#### Steps to Handle Cross-Domain Requests:\n\n1. **Enable CORS on the Server:**\n   - The server must include appropriate CORS headers, such as:\n     ```\n     Access-Control-Allow-Origin: *\n     ```\n   - This allows browsers to accept responses from different origins.\n\n2. **Making a Cross-Domain Request in AngularJS:**\n   ```javascript\n   $http.get('https://api.example.com/data')\n     .then(function(response) {\n       // Success: handle response.data\n     }, function(error) {\n       // Error: handle error\n     });\n   ```\n\n3. **Custom Headers and Credentials:**\n   - If you need to send credentials (cookies, HTTP authentication), set `withCredentials: true`:\n     ```javascript\n     $http({\n       method: 'GET',\n       url: 'https://api.example.com/data',\n       withCredentials: true\n     });\n     ```\n   - The server must also allow credentials:\n     ```\n     Access-Control-Allow-Credentials: true\n     ```\n\n4. **Using JSONP as a Fallback:**\n   - If the server does not support CORS, you can use JSONP for GET requests:\n     ```javascript\n     $http.jsonp('https://api.example.com/data?callback=JSON_CALLBACK')\n       .then(function(response) {\n         // Handle response\n       });\n     ```\n   - Note: JSONP only supports GET requests and requires the server to support JSONP.\n\n#### Summary Table\n\n| Method         | Server Requirement           | AngularJS Usage                      |\n|----------------|-----------------------------|--------------------------------------|\n| CORS           | CORS headers                | `$http.get/post/put/delete`          |\n| JSONP          | JSONP endpoint              | `$http.jsonp`                        |\n\n#### Best Practices\n\n- Always prefer CORS over JSONP for security and flexibility.\n- Ensure the server is configured correctly for CORS.\n- Avoid using JSONP for sensitive data.\n\n**References:**\n- [AngularJS $http Documentation](https://docs.angularjs.org/api/ng/service/$http)\n- [MDN CORS Guide](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396410Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "08e29fe9-d2fa-440d-9498-105d2b6fd850",
        "question": "How do you use third-party libraries like Restangular for API integration in AngularJS?",
        "answer": "```markdown\nTo use third-party libraries like **Restangular** for API integration in AngularJS, follow these steps:\n\n### 1. Install Restangular and Dependencies\n\nYou need to include both `restangular.js` and its dependency, `lodash.js` (or `underscore.js`):\n\n- Using npm:\n  ```bash\n  npm install restangular lodash\n  ```\n- Or include via CDN in your HTML:\n  ```html\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js\"></script>\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/restangular/1.6.1/restangular.min.js\"></script>\n  ```\n\n### 2. Add Restangular as a Dependency\n\nWhen defining your AngularJS module, add `restangular` as a dependency:\n\n```javascript\nangular.module('myApp', ['restangular']);\n```\n\n### 3. Configure Restangular (Optional)\n\nYou can configure the base URL or default headers in a `.config` block:\n\n```javascript\nangular.module('myApp')\n  .config(function(RestangularProvider) {\n    RestangularProvider.setBaseUrl('https://api.example.com');\n    // Optional: set default headers\n    RestangularProvider.setDefaultHeaders({'Authorization': 'Bearer TOKEN'});\n  });\n```\n\n### 4. Inject and Use Restangular in Controllers/Services\n\nInject `Restangular` where you need to make API calls:\n\n```javascript\nangular.module('myApp')\n  .controller('MainCtrl', function($scope, Restangular) {\n    // GET request to /users\n    Restangular.all('users').getList().then(function(users) {\n      $scope.users = users;\n    });\n\n    // GET request to /users/1\n    Restangular.one('users', 1).get().then(function(user) {\n      $scope.user = user;\n    });\n\n    // POST request to /users\n    Restangular.all('users').post({name: 'John Doe'}).then(function(newUser) {\n      $scope.newUser = newUser;\n    });\n  });\n```\n\n### 5. Handling Async Operations\n\nRestangular methods return **promises**, so you can use `.then()` for handling responses and errors:\n\n```javascript\nRestangular.all('posts').getList()\n  .then(function(posts) {\n    // Success\n    $scope.posts = posts;\n  })\n  .catch(function(error) {\n    // Error handling\n    console.error(error);\n  });\n```\n\n---\n\n**Summary:**  \nRestangular simplifies API integration in AngularJS by providing a clean, promise-based interface for RESTful operations. Install it, add it as a dependency, configure as needed, and use its methods to perform async API calls in your application.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396417Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "ccb5c77c-9223-409a-907f-5c50ec240f14",
        "question": "How do you manage API endpoints and environment variables in AngularJS?",
        "answer": "```markdown\n### Managing API Endpoints and Environment Variables in AngularJS\n\nIn AngularJS (version 1.x), managing API endpoints and environment variables typically involves separating configuration from your application logic. Here’s how you can do it:\n\n#### 1. Use AngularJS Constants or Values\n\nDefine your API endpoints and environment-specific variables using `.constant` or `.value` in a dedicated configuration module.\n\n```javascript\n// app.config.js\nangular.module('app.config', [])\n  .constant('API_ENDPOINTS', {\n    BASE_URL: 'https://api.example.com',\n    USERS: '/users',\n    POSTS: '/posts'\n  })\n  .constant('ENV', {\n    name: 'development'\n  });\n```\n\n#### 2. Inject Configuration into Services\n\nInject these constants into your services or controllers to use them for API calls.\n\n```javascript\nangular.module('app')\n  .service('UserService', function($http, API_ENDPOINTS) {\n    this.getUsers = function() {\n      return $http.get(API_ENDPOINTS.BASE_URL + API_ENDPOINTS.USERS);\n    };\n  });\n```\n\n#### 3. Environment-Specific Files\n\nMaintain separate configuration files for each environment (e.g., `config.dev.js`, `config.prod.js`). During your build or deployment process, include the appropriate config file.\n\n- **config.dev.js**\n  ```javascript\n  angular.module('app.config', [])\n    .constant('API_ENDPOINTS', {\n      BASE_URL: 'http://localhost:3000',\n      USERS: '/users'\n    });\n  ```\n\n- **config.prod.js**\n  ```javascript\n  angular.module('app.config', [])\n    .constant('API_ENDPOINTS', {\n      BASE_URL: 'https://api.production.com',\n      USERS: '/users'\n    });\n  ```\n\n#### 4. Automate Environment Selection\n\nUse build tools (like Grunt, Gulp, or Webpack) or scripts to include the correct config file based on the environment.\n\n#### 5. Avoid Hardcoding in Source Files\n\nNever hardcode sensitive or environment-specific values directly in your controllers or services. Always use injected constants or values.\n\n---\n\n**Summary:**  \nTo manage API endpoints and environment variables in AngularJS, define them as constants or values in a separate module, inject them where needed, and maintain separate config files for different environments. Use build tools to automate the selection of the correct configuration during deployment.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396424Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "b9d5d073-3cea-4d72-8064-8efbcb9e9440",
        "question": "How do you handle large data sets from APIs efficiently in AngularJS?",
        "answer": "```markdown\nHandling large data sets from APIs efficiently in AngularJS involves several strategies to optimize performance, user experience, and resource usage:\n\n### 1. **Pagination (Server-side)**\n- **Request only a subset of data** (e.g., 20–50 items per page) from the API.\n- Update the UI as users navigate between pages.\n- Example:\n  ```javascript\n  $http.get('/api/items?page=' + page + '&size=' + pageSize)\n    .then(function(response) {\n      $scope.items = response.data.items;\n    });\n  ```\n\n### 2. **Infinite Scrolling / Lazy Loading**\n- Load more data as the user scrolls, instead of fetching all at once.\n- Useful for lists and feeds.\n- Use libraries like [ngInfiniteScroll](https://sroze.github.io/ngInfiniteScroll/).\n\n### 3. **Filtering and Searching on the Server**\n- Send filter/search parameters to the API so only relevant data is returned.\n- Reduces payload size and client-side processing.\n\n### 4. **Debouncing API Requests**\n- When implementing search or filter features, debounce user input to avoid excessive API calls.\n- Example using `$timeout`:\n  ```javascript\n  var timeout;\n  $scope.search = function(query) {\n    if (timeout) $timeout.cancel(timeout);\n    timeout = $timeout(function() {\n      $http.get('/api/items?search=' + query)\n        .then(function(response) {\n          $scope.items = response.data.items;\n        });\n    }, 300);\n  };\n  ```\n\n### 5. **Virtual Scrolling**\n- Render only the visible portion of a large list in the DOM.\n- Use libraries like [angular-ui-scroll](https://github.com/angular-ui/ui-scroll).\n\n### 6. **Efficient Data Binding**\n- Use `track by` in `ng-repeat` to optimize DOM updates:\n  ```html\n  <div ng-repeat=\"item in items track by item.id\">{{item.name}}</div>\n  ```\n- Avoid deep watches on large objects.\n\n### 7. **Caching**\n- Cache API responses where appropriate to avoid redundant requests.\n- Use AngularJS’s `$cacheFactory` or HTTP cache.\n\n### 8. **Web Workers (Advanced)**\n- For heavy client-side processing, offload work to Web Workers to keep the UI responsive.\n\n---\n\n**Summary Table**\n\n| Technique                | Benefit                                 |\n|--------------------------|-----------------------------------------|\n| Pagination               | Reduces data per request                |\n| Infinite Scrolling       | Loads data as needed                    |\n| Server-side Filtering    | Minimizes unnecessary data transfer     |\n| Debouncing               | Prevents excessive API calls            |\n| Virtual Scrolling        | Optimizes DOM rendering                 |\n| Efficient Data Binding   | Reduces digest cycle workload           |\n| Caching                  | Avoids redundant API calls              |\n| Web Workers              | Offloads heavy processing from UI thread|\n\n**Best Practice:**  \nCombine multiple strategies (e.g., server-side pagination + virtual scrolling) for optimal results when dealing with very large data sets in AngularJS.\n```\n",
        "level": "Advanced",
        "created_at": "2025-04-20T11:04:10.396431Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    },
    {
        "id": "56ef223e-2a7a-439e-a3b0-cc0c4999ccb0",
        "question": "How do you implement pagination with API data in AngularJS?",
        "answer": "```markdown\nTo implement pagination with API data in AngularJS, follow these steps:\n\n1. **API Design**  \n   Ensure your API supports pagination, typically via query parameters like `page` and `pageSize` (or `limit` and `offset`).\n\n2. **Controller Logic**  \n   In your AngularJS controller, manage the current page, page size, and total items. Fetch data from the API whenever the page changes.\n\n   ```javascript\n   app.controller('PaginationCtrl', function($scope, $http) {\n     $scope.currentPage = 1;\n     $scope.pageSize = 10;\n     $scope.totalItems = 0;\n     $scope.items = [];\n\n     $scope.getData = function() {\n       $http.get('/api/items', {\n         params: {\n           page: $scope.currentPage,\n           pageSize: $scope.pageSize\n         }\n       }).then(function(response) {\n         $scope.items = response.data.items;\n         $scope.totalItems = response.data.total; // assuming API returns total count\n       });\n     };\n\n     $scope.pageChanged = function(newPage) {\n       $scope.currentPage = newPage;\n       $scope.getData();\n     };\n\n     // Initial load\n     $scope.getData();\n   });\n   ```\n\n3. **View (HTML)**\n   Use AngularJS directives like `ng-repeat` to display items and create pagination controls.\n\n   ```html\n   <div ng-controller=\"PaginationCtrl\">\n     <ul>\n       <li ng-repeat=\"item in items\">{{ item.name }}</li>\n     </ul>\n\n     <button ng-disabled=\"currentPage === 1\" ng-click=\"pageChanged(currentPage - 1)\">\n       Previous\n     </button>\n     Page {{currentPage}}\n     <button ng-disabled=\"items.length < pageSize\" ng-click=\"pageChanged(currentPage + 1)\">\n       Next\n     </button>\n   </div>\n   ```\n\n4. **Optional: Pagination Libraries**  \n   For more advanced pagination (page numbers, first/last, etc.), consider using AngularJS pagination directives like [angular-ui-bootstrap's pagination](https://angular-ui.github.io/bootstrap/).\n\n**Summary:**  \nPagination in AngularJS with API data involves tracking the current page, requesting the correct data from the API, and updating the view when the page changes. Always ensure your API supports pagination parameters and returns the total item count for accurate navigation.\n```\n",
        "level": "Intermediate",
        "created_at": "2025-04-20T11:04:10.396439Z",
        "topic": "4ed9fb15-da0c-4e22-8b5e-fd58305a1615"
    }
]