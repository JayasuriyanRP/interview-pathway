[
    {
        "id": "b78f9c82-11a6-4ac9-9379-f686a4bf7331",
        "question": "What is the correct syntax to declare a variable in Go?",
        "answer": "```go\nvar variableName type\n```\n\n**Example:**\n```go\nvar age int\n```\n\nYou can also declare and initialize a variable in one line:\n```go\nvar name string = \"Alice\"\n```\n\nOr use shorthand inside functions:\n```go\nage := 25\n```",
        "level": "Beginner"
    },
    {
        "id": "4bbda388-6d00-4a1e-b7fd-70ce09a73d4b",
        "question": "How do you declare and initialize a constant in Go?",
        "answer": "```markdown You can declare and initialize a constant in Go using the const keyword, followed by the name, optional type, and value. Here’s the syntax:\n\n```go\nconst name type = value\n```\n\nThe type is optional if it can be inferred from the value.\n\n**Examples:**\n\n```go\nconst Pi = 3.14           // type inferred as float64\nconst Greeting string = \"Hello, Go!\" // explicit type\n```\n\nConstants must be assigned a value at compile time and cannot be changed later.",
        "level": "Beginner"
    },
    {
        "id": "d134e6a8-9b3d-440f-9ed2-07c621c2ba81",
        "question": "What is the syntax for creating a function in Go?",
        "answer": "```go\nfunc functionName(parameters) returnType {\n    // function body\n}\n```\n\n**Example:**\n\n```go\nfunc add(a int, b int) int {\n    return a + b\n}\n```\n\n- func: Keyword to declare a function.\n- functionName: Name of the function.\n- parameters: List of input parameters with their types.\n- returnType: (Optional) The type of value the function returns.\n- Function body: Code to be executed when the function is called.",
        "level": "Beginner"
    },
    {
        "id": "adcf14bc-0aa7-4a0c-b727-51afa72ddb3d",
        "question": "How do you import a package in Go?",
        "answer": "```markdown To import a package in Go, use the import keyword followed by the package name in quotes. For example, to import the fmt package:\n\n```go\nimport \"fmt\"\n```\n\nYou can also import multiple packages using parentheses:\n\n```go\nimport (\n    \"fmt\"\n    \"math\"\n)\n```",
        "level": "Beginner"
    },
    {
        "id": "c125de64-9a1c-4cbd-9bd5-44f5610b89c0",
        "question": "What is the short variable declaration syntax in Go?",
        "answer": "```markdown In Go, the short variable declaration syntax uses := to declare and initialize variables in one step. It is typically used inside functions.\n\n```go\nname := \"Alice\"\nage := 30\n```\n\nThis is equivalent to:\n\n```go\nvar name string = \"Alice\"\nvar age int = 30\n```\n\n**Note:** The short variable declaration (:=) can only be used inside functions, not at the package level.",
        "level": "Beginner"
    },
    {
        "id": "7622de82-2da4-4fde-8db5-15ffa3376cf9",
        "question": "How do you write a for loop in Go?",
        "answer": "```go\n// Basic for loop in Go\nfor i := 0; i < 5; i++ {\n    fmt.Println(i)\n}\n```\n\n**Explanation:**\n- `i := 0` initializes the loop variable.\n- `i < 5` is the loop condition.\n- `i++` increments the variable after each iteration.\n\nGo's `for` loop is similar to other C-style languages, but it's the only looping construct in Go. You can also use it in different forms, such as:\n\n```go\n// Like a while loop\ni := 0\nfor i < 5 {\n    fmt.Println(i)\n    i++\n}\n```\n\n```go\n// Infinite loop\nfor {\n    // your code here\n}\n```",
        "level": "Beginner"
    },
    {
        "id": "a0490475-6f78-41bb-ad23-ce1d0a2c1ded",
        "question": "What is the syntax for an if-else statement in Go?",
        "answer": "```go\nif condition {\n    // code to execute if condition is true\n} else {\n    // code to execute if condition is false\n}\n```\n\n**Example:**\n```go\nx := 10\nif x > 5 {\n    fmt.Println(\"x is greater than 5\")\n} else {\n    fmt.Println(\"x is 5 or less\")\n}\n```",
        "level": "Beginner"
    },
    {
        "id": "dbb73bff-cf60-41bd-b0b5-ea56ba768fe2",
        "question": "How do you define a struct in Go?",
        "answer": "```markdown You can define a struct in Go using the type and struct keywords. Here’s the basic syntax:\n\n```go\ntype StructName struct {\n    FieldName1 FieldType1\n    FieldName2 FieldType2\n    // Add more fields as needed\n}\n```\n\n**Example:**\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n```\n\nThis defines a struct named Person with two fields: Name (a string) and Age (an int).",
        "level": "Beginner"
    },
    {
        "id": "de3f5d0c-ab6d-41fe-aa10-93d613f1870b",
        "question": "How do you create an array in Go?",
        "answer": "```markdown You can create an array in Go by specifying the length and the type of its elements. Here’s the basic syntax:\n\n```go\nvar arrayName [length]elementType\n```\n\n**Example:**\n\n```go\nvar numbers [5]int // An array of 5 integers\n```\n\nYou can also initialize the array with values:\n\n```go\nnumbers := [5]int{1, 2, 3, 4, 5}\n```\n\nIf you want Go to determine the length automatically, use `...`:\n\n```go\nnumbers := [...]int{1, 2, 3, 4, 5}\n```\n\n**Summary:**  \n- Use `[length]type` to declare an array.\n- Use `{}` to initialize with values.",
        "level": "Beginner"
    },
    {
        "id": "d2cafe79-102b-4361-8578-5bf2740504e1",
        "question": "What is the syntax for declaring a slice in Go?",
        "answer": "```go\n// Declaring a slice of integers\nvar numbers []int\n\n// Declaring and initializing a slice of strings\nfruits := []string{\"apple\", \"banana\", \"cherry\"}\n```\n\n- Use var sliceName []Type to declare a slice.\n- Use sliceName := []Type{values} to declare and initialize a slice.",
        "level": "Beginner"
    },
    {
        "id": "d24c6646-6d1c-4661-91ec-e604f0f654f7",
        "question": "How do you append an element to a slice in Go?",
        "answer": "```markdown You can append an element to a slice in Go using the built-in append function. Here’s the syntax:\n\n```go\nslice = append(slice, element)\n```\n\n**Example:**\n\n```go\nnumbers := []int{1, 2, 3}\nnumbers = append(numbers, 4)\n// numbers now contains: [1, 2, 3, 4]\n```\n\nYou can also append multiple elements at once:\n\n```go\nnumbers = append(numbers, 5, 6)\n// numbers now contains: [1, 2, 3, 4, 5, 6]\n```",
        "level": "Beginner"
    },
    {
        "id": "4cf7afc5-0760-44c0-bf90-beab614d8a8f",
        "question": "What is the syntax for a switch statement in Go?",
        "answer": "```go\nswitch expression {\ncase value1:\n    // code to execute if expression == value1\ncase value2:\n    // code to execute if expression == value2\ndefault:\n    // code to execute if no case matches\n}\n```\n\n**Example:**\n```go\nnum := 2\nswitch num {\ncase 1:\n    fmt.Println(\"One\")\ncase 2:\n    fmt.Println(\"Two\")\ndefault:\n    fmt.Println(\"Other number\")\n}\n```\n\n**Notes:**\n- The switch expression is evaluated once.\n- The first matching case is executed.\n- The default case is optional and runs if no other case matches.\n- You can omit the expression to create a switch that acts like a series of if-else statements.",
        "level": "Beginner"
    },
    {
        "id": "0a2bddc1-6247-4af9-b851-26a05d03057c",
        "question": "How do you declare a map in Go?",
        "answer": "```markdown You can declare a map in Go using the following syntax:\n\n```go\nvar myMap map[keyType]valueType\n```\n\nFor example, to declare a map with string keys and int values:\n\n```go\nvar ages map[string]int\n```\n\nTo create and initialize a map, you can use the make function:\n\n```go\nages := make(map[string]int)\n```\n\nOr, you can use a map literal:\n\n```go\nages := map[string]int{\n    \"Alice\": 30,\n    \"Bob\":   25,\n}\n```\n\n**Summary:**  \n- Use map[keyType]valueType to declare a map type.\n- Use make or a map literal to initialize a map.",
        "level": "Beginner"
    },
    {
        "id": "720f4c17-5c84-4cc2-af6f-eae2f84425fb",
        "question": "What is the syntax for a range loop in Go?",
        "answer": "```go\nfor index, value := range collection {\n    // code to use index and value\n}\n```\n\n- collection can be an array, slice, string, map, or channel.\n- index is the current index/key (for maps, it's the key).\n- value is the element at that index/key.\n- If you only need the value, use _ for the index: for _, value := range collection { ... }\n- If you only need the index/key, use _ for the value: for index := range collection { ... }",
        "level": "Beginner"
    },
    {
        "id": "8e385e55-d0c8-4e16-81bd-6383bad7ffde",
        "question": "How do you define a pointer in Go?",
        "answer": "```markdown In Go, you define a pointer by using the * (asterisk) symbol before a type. A pointer holds the memory address of a variable.\n\nHere's how you define and use a pointer:\n\n```go\nvar a int = 10     // a is an integer variable\nvar p *int         // p is a pointer to an int\np = &a             // p now holds the address of a\n\nfmt.Println(p)     // prints the memory address of a\nfmt.Println(*p)    // prints the value stored at that address (10)\n```\n\n- &a gives the address of variable a.\n- *p gives the value stored at the address p points to.",
        "level": "Beginner"
    },
    {
        "id": "c77edc0c-d820-42e8-aea5-abd505f4c878",
        "question": "How do you dereference a pointer in Go?",
        "answer": "```markdown To dereference a pointer in Go, use the * (asterisk) operator before the pointer variable. This gives you access to the value stored at the memory address the pointer refers to.\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 10\n    p := &x        // p is a pointer to x\n    fmt.Println(*p) // Dereference p to get the value of x (prints 10)\n}\n```\n\nIn this example, *p gives you the value stored at the address p points to.",
        "level": "Beginner"
    },
    {
        "id": "613eba49-d294-4333-838d-cf5136f312b3",
        "question": "What is the syntax for creating a new instance of a struct?",
        "answer": "```markdown To create a new instance of a struct in Go, you can use one of the following syntaxes:\n\n```go\n// Define a struct type\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// 1. Using a struct literal\np1 := Person{Name: \"Alice\", Age: 30}\n\n// 2. Using the new keyword (returns a pointer)\np2 := new(Person)\np2.Name = \"Bob\"\np2.Age = 25\n\n// 3. Using the address-of operator with a struct literal (pointer)\np3 := &Person{Name: \"Charlie\", Age: 40}\n```\n\n- p1 is a value of type Person.\n- p2 and p3 are pointers to Person structs.",
        "level": "Beginner"
    },
    {
        "id": "ce62799f-1ed6-4761-9b1e-f28de6e6f16b",
        "question": "How do you access struct fields in Go?",
        "answer": "```markdown You access struct fields in Go using the dot (.) notation. Here’s a simple example:\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 30}\n    fmt.Println(p.Name) // Accesses the Name field\n    fmt.Println(p.Age)  // Accesses the Age field\n}\n```\n\nIn this example, `p.Name` and `p.Age` access the `Name` and `Age` fields of the `Person` struct instance `p`.",
        "level": "Beginner"
    },
    {
        "id": "b3f20ee6-359d-41eb-8801-cc3b9c876c30",
        "question": "How do you define a method for a struct in Go?",
        "answer": "```markdown To define a method for a struct in Go, you use a receiver argument in the function definition. The receiver specifies which struct the method belongs to. Here’s the syntax:\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Method with value receiver\nfunc (p Person) Greet() {\n    fmt.Printf(\"Hello, my name is %s.\\n\", p.Name)\n}\n\n// Method with pointer receiver (allows modification)\nfunc (p *Person) HaveBirthday() {\n    p.Age++\n}\n```\n\n**Key Points:**\n- The receiver appears between the func keyword and the method name.\n- Use a value receiver (e.g., p Person) if the method does not modify the struct.\n- Use a pointer receiver (e.g., p *Person) if the method modifies the struct or for efficiency with large structs.\n\n**Example Usage:**\n\n```go\np := Person{Name: \"Alice\", Age: 30}\np.Greet()           // Output: Hello, my name is Alice.\np.HaveBirthday()\nfmt.Println(p.Age)  // Output: 31\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "100253d2-1757-4832-ae02-868083cef64c",
        "question": "What is the syntax for an interface in Go?",
        "answer": "```go\ntype InterfaceName interface {\n    MethodName1(param1 type1, param2 type2) returnType1\n    MethodName2(param1 type1) (returnType2, returnType3)\n    // ... more method signatures\n}\n```\n\n**Example:**\n```go\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n```\n\n- Use the type keyword followed by the interface name and the interface keyword.\n- List method signatures inside curly braces.\n- No method bodies are provided in the interface.",
        "level": "Intermediate"
    },
    {
        "id": "ece7478f-20c8-4200-bdcb-d502b2fca71e",
        "question": "How do you implement an interface in Go?",
        "answer": "```markdown To implement an interface in Go, you define a type (usually a struct) and then provide method definitions with the exact signatures specified in the interface. Go uses implicit implementation, so you don't need to declare that a type implements an interface—if the methods match, it does.\n\n**Example:**\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Define the interface\ntype Speaker interface {\n    Speak() string\n}\n\n// Define a struct\ntype Person struct {\n    Name string\n}\n\n// Implement the interface method for the struct\nfunc (p Person) Speak() string {\n    return \"Hello, my name is \" + p.Name\n}\n\nfunc main() {\n    var s Speaker\n    s = Person{Name: \"Alice\"}\n    fmt.Println(s.Speak())\n}\n```\n\n**Key Points:**\n- The `Person` struct implements the `Speaker` interface by defining a `Speak()` method.\n- No explicit declaration is needed; implementation is automatic if the method set matches.\n- You can assign a `Person` value to a variable of type `Speaker` because it satisfies the interface.",
        "level": "Intermediate"
    },
    {
        "id": "975e8e6a-4398-4f20-9328-5a37386f3ec6",
        "question": "How do you use type assertion in Go?",
        "answer": "```markdown Type assertion in Go is used to retrieve the dynamic value of an interface variable and convert it to a specified type. The syntax is:\n\n```go\nvalue := interfaceVariable.(Type)\n```\n\nIf the interface holds the specified type, the assertion succeeds and value is assigned. If not, the program panics.\n\n**Example:**\n\n```go\nvar i interface{} = \"hello\"\n\ns := i.(string) // s is now \"hello\"\nfmt.Println(s)\n```\n\nTo avoid a panic, you can use the \"comma, ok\" idiom:\n\n```go\ns, ok := i.(string)\nif ok {\n    fmt.Println(\"String value:\", s)\n} else {\n    fmt.Println(\"Not a string\")\n}\n```\n\n**Summary Table:**\n\n| Syntax                   | Description                                 |\n|--------------------------|---------------------------------------------|\n| `v := x.(T)`             | Asserts x holds type T, panics if not       |\n| `v, ok := x.(T)`         | ok is true if x holds type T, false otherwise |\n\nType assertion is commonly used when working with interfaces, especially the empty interface (interface{}).",
        "level": "Intermediate"
    },
    {
        "id": "e832b25b-e9fc-49f3-b489-1fe8e6794587",
        "question": "What is the syntax for a goroutine in Go?",
        "answer": "```go\ngo functionName(arguments)\n```\n\n**Example:**\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc sayHello() {\n    fmt.Println(\"Hello from goroutine!\")\n}\n\nfunc main() {\n    go sayHello() // Starts sayHello in a new goroutine\n\n    time.Sleep(time.Second) // Wait for goroutine to finish\n}\n```\n\n**Explanation:**\n- The go keyword starts a new goroutine, which runs concurrently with the main function.\n- You can use go with any function or anonymous function:\n  ```go\n  go func() {\n      fmt.Println(\"Anonymous goroutine\")\n  }()\n  ```\n- Goroutines are lightweight threads managed by the Go runtime.",
        "level": "Intermediate"
    },
    {
        "id": "aeba2971-3e1b-49fc-b260-1fb603ecc969",
        "question": "How do you create and use a channel in Go?",
        "answer": "```markdown To create and use a channel in Go, you use the make function and the chan keyword. Channels are used to communicate between goroutines.\n\nHere's a step-by-step example:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    // Create a channel of type int\n    ch := make(chan int)\n\n    // Start a goroutine that sends a value into the channel\n    go func() {\n        ch <- 42 // Send the value 42 to the channel\n    }()\n\n    // Receive the value from the channel\n    value := <-ch\n    fmt.Println(value) // Output: 42\n}\n```\n\n**Explanation:**\n\n- `ch := make(chan int)` creates a channel that can transport int values.\n- `ch <- 42` sends the value 42 into the channel.\n- `<-ch` receives a value from the channel.\n- Channels are often used to synchronize and communicate between goroutines.\n\n**Note:** Channels can also be buffered (e.g., `make(chan int, 2)`) to allow sending without immediate receiving.",
        "level": "Intermediate"
    },
    {
        "id": "98575b91-da2b-4aa6-a334-a82dc1543cea",
        "question": "What is the select statement syntax in Go?",
        "answer": "```go\nselect {\ncase <-chan1:\n    // code to execute when chan1 receives a value\ncase val := <-chan2:\n    // code to execute when chan2 receives a value, with val assigned\ncase chan3 <- value:\n    // code to execute when value is sent to chan3\ndefault:\n    // code to execute if no other case is ready\n}\n```\n\n**Explanation:**\n\n- The `select` statement lets a goroutine wait on multiple communication operations (channels).\n- Each `case` must be a channel operation (receive or send).\n- The `default` case (optional) runs if no channels are ready.\n- Only one case is chosen at random if multiple are ready.\n- `select` blocks until one case can proceed, unless there is a `default` case.\n\n**Example:**\n```go\nselect {\ncase msg := <-messages:\n    fmt.Println(\"Received\", msg)\ncase sig := <-signals:\n    fmt.Println(\"Signal received\", sig)\ndefault:\n    fmt.Println(\"No communication\")\n}\n```",
        "level": "Intermediate"
    },
    {
        "id": "90ed6aff-8bda-47d0-a11d-fe2a56b285a8",
        "question": "How do you define a variadic function in Go?",
        "answer": "```markdown In Go, a variadic function is defined by using an ellipsis (...) before the type of the last parameter. This allows the function to accept zero or more arguments of that type.\n\nHere's the syntax:\n\n```go\nfunc functionName(paramName ...Type) {\n    // function body\n}\n```\n\n**Example:**\n\n```go\nfunc sum(numbers ...int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n\nresult := sum(1, 2, 3, 4) // result is 10\n```\n\n**Key Points:**\n\n- The variadic parameter must be the last parameter in the function signature.\n- Inside the function, the variadic parameter behaves like a slice of the specified type.\n- You can call the function with any number of arguments (including zero).",
        "level": "Intermediate"
    },
    {
        "id": "ca34083f-89c8-419e-9a9a-600487dfd0d2",
        "question": "What is the syntax for defer statements in Go?",
        "answer": "```go\ndefer functionName(arguments)\n```\n\n**Explanation:**\n- The defer statement in Go is used to ensure that a function call is performed later in a program’s execution, usually for purposes of cleanup.\n- Deferred functions are executed in LIFO (Last In, First Out) order just before the surrounding function returns.\n\n**Example:**\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    defer fmt.Println(\"World\")\n    fmt.Println(\"Hello\")\n}\n```\n**Output:**\n```\nHello\nWorld\n```\n\n**Note:** You can also defer anonymous functions or methods:\n```go\ndefer func() {\n    fmt.Println(\"Deferred call\")\n}()\n```",
        "level": "Intermediate"
    },
    {
        "id": "1de62b18-685d-4a42-8f8c-9ee06429e25f",
        "question": "How do you handle errors in Go?",
        "answer": "```markdown In Go, error handling is typically done by returning an error value as the last return value from a function. You check if the error is not nil to determine if something went wrong. Here’s a common pattern:\n\n```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"cannot divide by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    result, err := divide(10, 0)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Result:\", result)\n}\n```\n\n**Key Points:**\n- Functions that can fail usually return an error as the last return value.\n- The error type is an interface; you can use errors.New or fmt.Errorf to create errors.\n- Always check if err != nil before using the other return values.\n- You can define custom error types by implementing the Error() string method.\n\n**Example with custom error:**\n\n```go\ntype MyError struct {\n    Msg string\n}\n\nfunc (e *MyError) Error() string {\n    return e.Msg\n}\n\nfunc doSomething() error {\n    return &MyError{\"something went wrong\"}\n}\n```\n\n**Summary:**  \nGo does not use exceptions for error handling. Instead, it uses explicit error values, making error handling straightforward and explicit.",
        "level": "Intermediate"
    },
    {
        "id": "7e96d020-028f-4c5d-9adc-14a9ea11e182",
        "question": "What is the blank identifier and how is it used in Go?",
        "answer": "```markdown The **blank identifier** in Go is represented by an underscore (`_`). It acts as an anonymous placeholder that can be assigned any value, but the value is discarded and not stored anywhere. The blank identifier is useful in situations where a variable is required syntactically, but its value is not needed.\n\n### Common Uses of the Blank Identifier\n\n1. **Ignoring Return Values**\n\n   Many Go functions return multiple values. If you only care about some of them, you can use `_` to ignore the rest:\n\n   ```go\n   value, _ := someFunction() // Ignore the second return value\n   ```\n\n2. **Importing Packages for Side Effects**\n\n   Sometimes you want to import a package only for its side effects (like initialization):\n\n   ```go\n   import _ \"net/http/pprof\"\n   ```\n\n3. **Ignoring Values in Range Loops**\n\n   When iterating over a slice or map, you might not need both the index and the value:\n\n   ```go\n   for _, value := range mySlice {\n       fmt.Println(value)\n   }\n   ```\n\n   Or, if you only need the index:\n\n   ```go\n   for index, _ := range mySlice {\n       fmt.Println(index)\n   }\n   ```\n\n4. **Satisfying Interface Requirements**\n\n   If a function requires you to implement an interface method that you don't use, you can use `_` to ignore parameters:\n\n   ```go\n   func (t myType) UnusedMethod(_ int) {\n       // Do nothing\n   }\n   ```\n\n### Key Points\n\n- The blank identifier cannot be used as a variable; it cannot be read from.\n- It is a write-only variable.\n- It helps avoid compiler errors about unused variables or imports.\n\n### Example\n\n```go\nfunc divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, fmt.Errorf(\"division by zero\")\n    }\n    return a / b, nil\n}\n\nresult, _ := divide(10, 2) // Ignore the error for simplicity\nfmt.Println(result)\n```\n\n**Summary:**  \nThe blank identifier `_` is a powerful feature in Go that allows you to ignore values you don't need, making your code cleaner and avoiding compiler warnings about unused variables.",
        "level": "Intermediate"
    },
    {
        "id": "ee4ce31e-f582-40f8-ba4b-4e958a91655a",
        "question": "How do you use the init function in Go?",
        "answer": "```markdown\nIn Go, the `init` function is a special function that is automatically executed when a package is initialized, before the main function runs. You can use `init` to set up initial state, initialize variables, or perform setup tasks.\n\n**Key points about `init`:**\n- You can have multiple `init` functions in a single package (even in different files).\n- `init` functions cannot take arguments or return values.\n- They are executed in the order they appear within a file, and files are initialized in the order determined by the Go compiler.\n\n**Example:**\n\n```go\npackage main\n\nimport \"fmt\"\n\nvar message string\n\nfunc init() {\n    message = \"Hello from init!\"\n    fmt.Println(\"Init function executed\")\n}\n\nfunc main() {\n    fmt.Println(message)\n}\n```\n\n**Output:**\n```\nInit function executed\nHello from init!\n```\n\n**Usage scenarios:**\n- Initializing package-level variables\n- Registering types or plugins\n- Setting up configuration or logging\n\n**Note:** Use `init` sparingly, as excessive use can make code harder to understand and test.\n```\n",
        "level": "Intermediate"
    },
    {
        "id": "184e4a8f-bd33-417e-a7f8-4e804274f8ea",
        "question": "What is the syntax for embedding structs in Go?",
        "answer": "```go\n// Embedding a struct in Go\n\ntype Address struct {\n    City    string\n    ZipCode string\n}\n\ntype Person struct {\n    Name string\n    Age  int\n    Address // Embedded struct\n}\n```\n\n**Explanation:**\n\n- To embed a struct, simply declare the struct type (e.g., Address) as a field in another struct (e.g., Person) without a field name.\n- The fields of the embedded struct become accessible directly on the outer struct.\n\n**Usage Example:**\n\n```go\np := Person{\n    Name: \"Alice\",\n    Age:  30,\n    Address: Address{\n        City:    \"New York\",\n        ZipCode: \"10001\",\n    },\n}\n\nfmt.Println(p.City)    // Output: New York\nfmt.Println(p.ZipCode) // Output: 10001\n```\n**Note:** Embedded structs allow for composition and promote code reuse in Go.",
        "level": "Intermediate"
    },
    {
        "id": "21d77654-1b4e-4a7d-8084-26d7396f3ebf",
        "question": "How do you use anonymous structs in Go?",
        "answer": "```markdown You can use **anonymous structs** in Go when you need a struct type only once or for a short-lived purpose, without declaring a named type. Anonymous structs are defined and instantiated inline.\n\nHere’s how you use anonymous structs in Go:\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // Define and instantiate an anonymous struct\n    person := struct {\n        Name string\n        Age  int\n    }{\n        Name: \"Alice\",\n        Age:  30,\n    }\n\n    fmt.Println(person.Name) // Output: Alice\n    fmt.Println(person.Age)  // Output: 30\n\n    // You can also use anonymous structs in slices or maps\n    people := []struct {\n        Name string\n        Age  int\n    }{\n        {Name: \"Bob\", Age: 25},\n        {Name: \"Carol\", Age: 28},\n    }\n\n    for _, p := range people {\n        fmt.Printf(\"%s is %d years old\\n\", p.Name, p.Age)\n    }\n}\n```\n\n**Key Points:**\n\n- Anonymous structs are useful for short-lived data structures.\n- They are defined inline using the struct keyword without a type name.\n- You can use them in variables, slices, maps, or as function parameters/returns.\n\n**Example Usage:**\n\n```go\nfunc printPerson(p struct{ Name string; Age int }) {\n    fmt.Printf(\"%s is %d years old\\n\", p.Name, p.Age)\n}\n```\n\nThis allows for quick, concise struct definitions without polluting your code with extra type names.",
        "level": "Intermediate"
    },
    {
        "id": "230c89eb-d39e-4de9-9c45-85060932704f",
        "question": "How do you create a slice from an array in Go?",
        "answer": "```markdown To create a slice from an array in Go, you use the slicing syntax: `array[start:end]`. This creates a new slice that references elements from index `start` up to, but not including, index `end` of the array.\n\nHere's an example:\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    arr := [5]int{10, 20, 30, 40, 50}\n    // Create a slice from index 1 to 3 (elements 20, 30, 40)\n    slice := arr[1:4]\n    fmt.Println(slice) // Output: [20 30 40]\n}\n```\n\n**Notes:**\n- The original array is not copied; the slice references the same underlying array.\n- Omitting `start` defaults to 0, and omitting `end` defaults to the array's length. For example, `arr[:3]` is equivalent to `arr[0:3]`.",
        "level": "Intermediate"
    },
    {
        "id": "8d7de37e-79eb-4e78-a4cc-2d6a5ac1da59",
        "question": "What is the syntax for a type alias in Go?",
        "answer": "```go\ntype NewName = ExistingType\n```\n\n**Example:**\n```go\ntype MyInt = int\n```\n\nThis creates a type alias `MyInt` for the built-in type `int`. Both names refer to the exact same type.",
        "level": "Intermediate"
    },
    {
        "id": "60a6b6ba-040a-42d5-998a-17c0e2582267",
        "question": "How do you use the make function in Go?",
        "answer": "```markdown\nThe `make` function in Go is used to initialize and allocate memory for slices, maps, and channels. Unlike the `new` function, which only allocates memory and returns a pointer to a zeroed value, `make` returns an initialized (not zeroed) value of the specified type.\n\n### Syntax\n\n```go\nmake(type, length)\nmake(type, length, capacity)\n```\n\n- **type**: The type of the slice, map, or channel.\n- **length**: For slices, the number of elements; for channels, the buffer size.\n- **capacity** (optional): For slices, the total allocated capacity.\n\n### Examples\n\n#### Slices\n\n```go\ns := make([]int, 5)           // Creates a slice of int with length 5 and capacity 5\ns2 := make([]int, 3, 10)      // Creates a slice of int with length 3 and capacity 10\n```\n\n#### Maps\n\n```go\nm := make(map[string]int)     // Creates an empty map\nm2 := make(map[string]int, 10) // Creates a map with space for 10 elements (hint)\n```\n\n#### Channels\n\n```go\nch := make(chan int)          // Creates an unbuffered channel\nch2 := make(chan int, 5)      // Creates a buffered channel with capacity 5\n```\n\n### Key Points\n\n- `make` can only be used with slices, maps, and channels.\n- It returns an initialized (ready-to-use) value, not a pointer.\n- For slices, you can specify both length and capacity.\n- For maps, the second argument is a hint for initial capacity (optional).\n- For channels, the second argument specifies the buffer size (optional).\n\n**Example Usage:**\n\n```go\nnumbers := make([]int, 0, 100) // Slice with length 0 and capacity 100\nmyMap := make(map[string]bool) // Empty map\nqueue := make(chan string, 10) // Buffered channel\n```\n```",
        "level": "Intermediate"
    },
    {
        "id": "a4bf05f3-5d91-4ddf-9cb5-6e549007acd4",
        "question": "How do you use the new function in Go?",
        "answer": "```markdown In Go, the new function is used to allocate memory for a variable of a specified type and returns a pointer to it. The allocated memory is zeroed.\n\n**Syntax:**\n\n```go\nptr := new(Type)\n```\n\n- Type is the type of the variable you want to allocate.\n- ptr is a pointer to a newly allocated zero value of Type.\n\n**Example:**\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    numPtr := new(int)      // Allocates memory for an int, sets it to 0\n    fmt.Println(*numPtr)    // Output: 0\n\n    *numPtr = 42\n    fmt.Println(*numPtr)    // Output: 42\n\n    strPtr := new(string)   // Allocates memory for a string, sets it to \"\"\n    fmt.Println(*strPtr)    // Output: (empty string)\n}\n```\n\n**Key Points:**\n\n- new(Type) returns a pointer to a zero-initialized value of Type.\n- It is commonly used for allocating basic types or structs.\n- For slices, maps, and channels, use the make function instead.\n\n**When to use new:**\n\n- When you need a pointer to a newly allocated zero value of a type.\n- When you want to avoid using explicit variable declarations and referencing their address.\n\n**When not to use new:**\n\n- When working with slices, maps, or channels (use make).\n- When you do not need a pointer.",
        "level": "Intermediate"
    },
    {
        "id": "2e14f63a-948e-445c-96e0-3519c6c25f45",
        "question": "What is the syntax for a closure in Go?",
        "answer": "```markdown In Go, a closure is an anonymous function that captures variables from its surrounding scope. The syntax for a closure is as follows:\n\n```go\nfunc(parameterList) returnType {\n    // function body\n}\n```\n\nYou can assign a closure to a variable or use it directly. Here’s an example:\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // Closure that captures variable 'x'\n    x := 10\n    add := func(y int) int {\n        return x + y\n    }\n\n    fmt.Println(add(5)) // Output: 15\n}\n```\n\nIn this example, the anonymous function assigned to add forms a closure over the variable x from the enclosing scope. Closures in Go can access and modify variables defined outside their body.",
        "level": "Advanced"
    },
    {
        "id": "05aff3fd-c77e-47a5-8ef7-633d025d02f6",
        "question": "How do you use recover and panic in Go?",
        "answer": "```markdown\nIn Go, `panic` and `recover` are built-in functions used for handling unexpected errors and controlling the flow of execution during exceptional situations.\n\n### `panic`\n\n- The `panic` function is used to stop the normal execution of a goroutine. When `panic` is called, the program begins to unwind the stack, running any deferred functions along the way.\n- After all deferred functions have executed, the program crashes and prints the panic value and stack trace.\n\n**Example:**\n```go\nfunc mayPanic() {\n    panic(\"something went wrong\")\n}\n```\n\n### `recover`\n\n- The `recover` function regains control of a panicking goroutine. It only works if called within a deferred function.\n- If called during a normal execution, `recover` returns `nil`. If called during a panic, it captures the panic value and stops the panic.\n\n**Example:**\n```go\nfunc safeCall() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered from panic:\", r)\n        }\n    }()\n    mayPanic()\n    fmt.Println(\"After mayPanic\") // This line will not be executed if mayPanic panics\n}\n```\n\n### Usage Pattern\n\nA common pattern is to use `defer` with an anonymous function containing `recover` to handle panics gracefully:\n\n```go\nfunc main() {\n    safeCall()\n    fmt.Println(\"Program continues after recovery\")\n}\n```\n\n**Output:**\n```\nRecovered from panic: something went wrong\nProgram continues after recovery\n```\n\n### Key Points\n\n- Use `panic` for unrecoverable errors or programmer mistakes.\n- Use `recover` to regain control after a panic, typically for logging or cleanup.\n- Only deferred functions can call `recover` successfully during a panic.\n- Overusing `panic` and `recover` is discouraged; idiomatic Go prefers error returns.\n\n**References:**\n- [Go Blog: Defer, Panic, and Recover](https://blog.golang.org/defer-panic-and-recover)\n- [Official Go Documentation](https://golang.org/pkg/builtin/#panic)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "56cc2e6c-13c9-482b-aabc-042b345fd961",
        "question": "How do you define and use custom error types in Go?",
        "answer": "```markdown\n### Defining and Using Custom Error Types in Go\n\nIn Go, you can define custom error types by creating a type that implements the `error` interface. The `error` interface requires a single method:\n\n```go\ntype error interface {\n    Error() string\n}\n```\n\n#### 1. Define a Custom Error Type\n\nYou typically define a struct to hold additional error information:\n\n```go\ntype MyError struct {\n    Code    int\n    Message string\n}\n```\n\n#### 2. Implement the `Error()` Method\n\nImplement the `Error()` method for your custom type:\n\n```go\nfunc (e *MyError) Error() string {\n    return fmt.Sprintf(\"Error %d: %s\", e.Code, e.Message)\n}\n```\n\n#### 3. Create and Use the Custom Error\n\nYou can now create and return your custom error from functions:\n\n```go\nfunc doSomething(flag bool) error {\n    if !flag {\n        return &MyError{Code: 123, Message: \"Something went wrong\"}\n    }\n    return nil\n}\n```\n\n#### 4. Type Assertion or Errors.As for Handling\n\nWhen handling errors, you can use type assertion or the `errors.As` function to check for your custom error type:\n\n```go\nerr := doSomething(false)\nif err != nil {\n    if myErr, ok := err.(*MyError); ok {\n        fmt.Println(\"Custom error occurred:\", myErr.Code, myErr.Message)\n    } else {\n        fmt.Println(\"Other error:\", err)\n    }\n}\n```\n\nOr, using `errors.As` (Go 1.13+):\n\n```go\nvar myErr *MyError\nif errors.As(err, &myErr) {\n    fmt.Println(\"Custom error occurred:\", myErr.Code, myErr.Message)\n}\n```\n\n---\n\n#### **Summary Table**\n\n| Step                       | Example Code Snippet                                    |\n|----------------------------|--------------------------------------------------------|\n| Define struct              | `type MyError struct { Code int; Message string }`     |\n| Implement `Error()`        | `func (e *MyError) Error() string { ... }`             |\n| Return custom error        | `return &MyError{Code: 123, Message: \"msg\"}`           |\n| Check error type           | `if myErr, ok := err.(*MyError); ok { ... }`           |\n\n---\n\n**References:**\n- [Go Blog: Error handling and Go](https://blog.golang.org/error-handling-and-go)\n- [GoDoc: errors package](https://pkg.go.dev/errors)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "47207b22-8415-4f71-9a19-1f791994b014",
        "question": "What is the syntax for embedding interfaces in Go?",
        "answer": "```go\n// Embedding interfaces in Go\n\n// Define base interfaces\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\n// Embed interfaces to create a new interface\ntype ReadWriter interface {\n    Reader  // Embedded interface\n    Writer  // Embedded interface\n}\n```\n\n**Explanation:**\n\n- In Go, you embed interfaces by listing their names inside a new interface type.\n- The new interface (`ReadWriter`) will require all methods from the embedded interfaces (`Reader` and `Writer`).\n- No additional keywords are needed—just the interface names.\n\n**Usage Example:**\n\n```go\nfunc UseReadWriter(rw ReadWriter) {\n    // rw has both Read and Write methods\n}\n```\n",
        "level": "Advanced"
    },
    {
        "id": "ecebb0a6-0aae-44b1-90c6-b17b172e83ac",
        "question": "How do you use type switches in Go?",
        "answer": "```markdown\n### Using Type Switches in Go\n\nA **type switch** in Go is a special form of the `switch` statement that allows you to compare the dynamic type of an interface variable against multiple types. This is particularly useful when you have a value of interface type and want to handle it differently based on its underlying concrete type.\n\n#### Syntax\n\n```go\nswitch v := x.(type) {\ncase T1:\n    // v has type T1\ncase T2:\n    // v has type T2\ndefault:\n    // v has type other than T1 or T2\n}\n```\n\n- `x` must be of interface type.\n- `v` is a variable of the type in each case clause.\n- Each `case` specifies a type, not a value.\n\n#### Example\n\n```go\nfunc describe(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf(\"Twice %v is %v\\n\", v, v*2)\n    case string:\n        fmt.Printf(\"%q is %d bytes long\\n\", v, len(v))\n    default:\n        fmt.Printf(\"I don't know about type %T!\\n\", v)\n    }\n}\n\nfunc main() {\n    describe(21)\n    describe(\"hello\")\n    describe(true)\n}\n```\n\n**Output:**\n```\nTwice 21 is 42\n\"hello\" is 5 bytes long\nI don't know about type bool!\n```\n\n#### Key Points\n\n- Type switches let you perform different actions based on the actual type stored in an interface.\n- The variable declared (`v` in the example) is of the type matched in the case.\n- The `default` case handles all types not explicitly listed.\n\n#### References\n\n- [Go Tour: Type Switches](https://tour.golang.org/methods/16)\n- [Go Blog: Type Switches](https://blog.golang.org/laws-of-reflection#TOC_7.)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "342a54df-ec3d-41d0-8ed9-83a78bbae657",
        "question": "How do you use reflection in Go?",
        "answer": "```markdown\n## Using Reflection in Go\n\nReflection in Go is provided by the `reflect` package, which allows you to inspect the type and value of variables at runtime. This is useful for writing generic code, serialization, or frameworks.\n\n### Basic Concepts\n\n- **reflect.Type**: Represents the type of a Go variable.\n- **reflect.Value**: Represents the value of a Go variable.\n\n### Example: Inspecting Type and Value\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    var x float64 = 3.4\n\n    fmt.Println(\"type:\", reflect.TypeOf(x))   // type: float64\n    fmt.Println(\"value:\", reflect.ValueOf(x)) // value: 3.4\n}\n```\n\n### Modifying Values\n\nTo modify a value using reflection, the value must be addressable (usually a pointer):\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    x := 3.4\n    v := reflect.ValueOf(&x).Elem()\n    fmt.Println(\"Before:\", x)\n    v.SetFloat(7.1)\n    fmt.Println(\"After:\", x)\n}\n```\n\n### Inspecting Struct Fields\n\n```go\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{\"Alice\", 30}\n    v := reflect.ValueOf(p)\n    t := reflect.TypeOf(p)\n\n    for i := 0; i < v.NumField(); i++ {\n        fmt.Printf(\"Field %d: %s = %v\\n\", i, t.Field(i).Name, v.Field(i).Interface())\n    }\n}\n```\n\n### Key Functions in `reflect` Package\n\n- `reflect.TypeOf(i interface{}) reflect.Type`\n- `reflect.ValueOf(i interface{}) reflect.Value`\n- `reflect.Value.Kind()` returns the specific kind (e.g., reflect.Struct, reflect.Int)\n- `reflect.Value.Interface()` returns the value as an interface{}\n- `reflect.Value.SetXxx()` sets the value (if addressable)\n\n### Cautions\n\n- Reflection can be slower and more complex than regular code.\n- Type safety is lost; errors may occur at runtime.\n- Use reflection only when necessary.\n\n**References:**\n- [reflect package documentation](https://pkg.go.dev/reflect)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "ce02fdaf-9a66-40e0-8c5d-2043cf526a29",
        "question": "What is the syntax for generic functions in Go 1.18+?",
        "answer": "```go\n// Syntax for a generic function in Go 1.18+\nfunc FunctionName[T any](param T) T {\n    // function body using param of type T\n    return param\n}\n```\n\n**Explanation:**\n- `T` is a type parameter, declared in square brackets `[T any]` after the function name.\n- `any` is a constraint (in this case, any type).\n- You can specify multiple type parameters and more complex constraints.\n\n**Example:**\n```go\nfunc PrintSlice[T any](s []T) {\n    for _, v := range s {\n        fmt.Println(v)\n    }\n}\n```\n\n**Usage:**\n```go\nPrintSlice([]int{1, 2, 3})\nPrintSlice([]string{\"a\", \"b\", \"c\"})\n```\nGenerics allow functions to operate on different types while maintaining type safety.",
        "level": "Advanced"
    },
    {
        "id": "01bba472-b2f2-453a-93eb-b8d5c57138ea",
        "question": "How do you define and use generic types in Go?",
        "answer": "```markdown\n## Defining and Using Generic Types in Go\n\nGo introduced support for generics in version 1.18. Generics allow you to write functions, types, and methods that can operate on different types without sacrificing type safety.\n\n### 1. Defining a Generic Function\n\nYou define type parameters in square brackets `[]` after the function name:\n\n```go\nfunc PrintSlice[T any](s []T) {\n    for _, v := range s {\n        fmt.Println(v)\n    }\n}\n```\n- `T` is a type parameter.\n- `any` is a built-in constraint (alias for `interface{}`), meaning `T` can be any type.\n\n### 2. Calling a Generic Function\n\nYou can call the function with any slice type:\n\n```go\nPrintSlice([]int{1, 2, 3})\nPrintSlice([]string{\"a\", \"b\", \"c\"})\n```\n\n### 3. Defining a Generic Type\n\nYou can also define generic types, such as structs:\n\n```go\ntype Pair[A, B any] struct {\n    First  A\n    Second B\n}\n```\n\n### 4. Using a Generic Type\n\n```go\np1 := Pair[int, string]{First: 1, Second: \"one\"}\np2 := Pair[float64, bool]{First: 3.14, Second: true}\n```\n\n### 5. Adding Constraints\n\nYou can restrict type parameters using constraints:\n\n```go\ntype Adder[T int | float64] interface {\n    Add(a, b T) T\n}\n\nfunc Sum[T int | float64](a, b T) T {\n    return a + b\n}\n```\n\n### 6. Example: Generic Map Function\n\n```go\nfunc Map[T any, U any](s []T, f func(T) U) []U {\n    result := make([]U, len(s))\n    for i, v := range s {\n        result[i] = f(v)\n    }\n    return result\n}\n```\n\n**Usage:**\n```go\ndoubled := Map([]int{1, 2, 3}, func(x int) int { return x * 2 })\n```\n\n---\n\n**Summary:**  \n- Use `[T any]` (or other constraints) to define type parameters.\n- Apply generics to functions, types, and methods.\n- Use constraints to restrict permissible types for type parameters.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "431b26ca-ed61-4d1f-bef6-ea697eedce95",
        "question": "How do you use constraints with generics in Go?",
        "answer": "```markdown\nIn Go, constraints are used with generics to restrict the types that can be used as type parameters. Constraints are typically defined using interfaces, and the `constraints` package in the standard library provides some common ones (like `constraints.Ordered`).\n\n### Defining a Constraint\n\nYou can define your own constraint as an interface. For example, to constrain a type parameter to types that support the `+` operator (like `int` and `float64`):\n\n```go\ntype Adder interface {\n    ~int | ~float64\n}\n```\n\nThe `~` allows types whose underlying type matches.\n\n### Using Constraints in Generic Functions\n\nYou specify constraints in the type parameter list:\n\n```go\nfunc Add[T Adder](a, b T) T {\n    return a + b\n}\n```\n\nHere, `T` is constrained by `Adder`, so only types that satisfy `Adder` can be used.\n\n### Using Standard Library Constraints\n\nGo 1.18+ includes the `constraints` package:\n\n```go\nimport \"golang.org/x/exp/constraints\"\n\nfunc Max[T constraints.Ordered](a, b T) T {\n    if a > b {\n        return a\n    }\n    return b\n}\n```\n\n`constraints.Ordered` allows any type that supports `<`, `>`, etc.\n\n### Example: Generic Map Function with Constraint\n\n```go\ntype Stringer interface {\n    String() string\n}\n\nfunc PrintAll[T Stringer](items []T) {\n    for _, item := range items {\n        fmt.Println(item.String())\n    }\n}\n```\n\nOnly types that implement the `String()` method can be used.\n\n---\n\n**Summary:**  \nConstraints in Go generics are specified using interfaces, either custom or from the standard library, to restrict the set of types that can be used as type parameters in generic functions, types, or methods.\n```\n",
        "level": "Advanced"
    },
    {
        "id": "2e823e6d-a7f2-46b8-92d4-f6a682ecf150",
        "question": "How do you implement custom marshaling and unmarshaling for JSON in Go?",
        "answer": "```markdown To implement custom marshaling and unmarshaling for JSON in Go, you need to define the `MarshalJSON()` and `UnmarshalJSON()` methods for your type. These methods allow you to control how your type is encoded to and decoded from JSON.\n\nHere's an example:\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\n// Custom type\ntype Person struct {\n    Name string\n    Age  int\n}\n\n// Custom marshaling\nfunc (p Person) MarshalJSON() ([]byte, error) {\n    // Custom structure for JSON output\n    type Alias Person\n    return json.Marshal(&struct {\n        Alias\n        IsAdult bool `json:\"is_adult\"`\n    }{\n        Alias:   (Alias)(p),\n        IsAdult: p.Age >= 18,\n    })\n}\n\n// Custom unmarshaling\nfunc (p *Person) UnmarshalJSON(data []byte) error {\n    // Custom structure for JSON input\n    type Alias Person\n    aux := &struct {\n        Alias\n    }{\n        Alias: (Alias)(*p),\n    }\n    if err := json.Unmarshal(data, &aux); err != nil {\n        return err\n    }\n    *p = Person(aux.Alias)\n    return nil\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 30}\n    b, _ := json.Marshal(p)\n    fmt.Println(string(b)) // Output includes \"is_adult\":true\n\n    var p2 Person\n    json.Unmarshal(b, &p2)\n    fmt.Printf(\"%+v\\n\", p2) // Output: {Name:Alice Age:30}\n}\n```\n\n**Key Points:**\n- Implement `MarshalJSON() ([]byte, error)` for custom encoding.\n- Implement `UnmarshalJSON([]byte) error` for custom decoding.\n- Use an alias type to avoid infinite recursion.\n- You can add or omit fields, transform data, or validate during marshaling/unmarshaling.\n\n**References:**\n- [encoding/json documentation](https://pkg.go.dev/encoding/json#Marshaler)\n- [Go Blog: JSON and Go](https://blog.golang.org/json-and-go)",
        "level": "Advanced"
    },
    {
        "id": "351b6cc8-4f33-4063-96b3-afdcbe84b2b6",
        "question": "How do you use build tags in Go source files?",
        "answer": "```markdown\n## Using Build Tags in Go Source Files\n\nIn Go, **build tags** (also known as build constraints) allow you to include or exclude files from a build based on certain conditions, such as the target operating system, architecture, or custom tags. Build tags are specified as comments at the top of a Go source file.\n\n### Syntax\n\nA build tag is a line comment that starts with `//go:build` (preferred since Go 1.17) or the legacy `// +build` (deprecated but still supported):\n\n```go\n//go:build <expression>\n// +build <expression>\n```\n\n- The build tag **must appear before the package declaration and after the copyright or license comments** (if any).\n- The `//go:build` line should come before any `// +build` lines if both are present.\n\n### Examples\n\n#### 1. OS-Specific File\n\nTo include a file only when building for Linux:\n\n```go\n//go:build linux\n// +build linux\n\npackage mypackage\n\n// Linux-specific code here\n```\n\n#### 2. Multiple Conditions\n\nTo include a file for either Linux or Darwin (macOS):\n\n```go\n//go:build linux || darwin\n// +build linux darwin\n\npackage mypackage\n\n// Code for Linux or macOS\n```\n\n#### 3. Custom Build Tags\n\nYou can define custom tags when building:\n\n```go\n//go:build mytag\n// +build mytag\n\npackage mypackage\n\n// Code included only when built with -tags mytag\n```\n\nBuild with:\n\n```sh\ngo build -tags mytag\n```\n\n#### 4. Excluding a File\n\nTo exclude a file from builds with a certain tag:\n\n```go\n//go:build !integration\n// +build !integration\n\npackage mypackage\n\n// Code excluded when built with -tags integration\n```\n\n### Notes\n\n- Prefer `//go:build` syntax for new code.\n- Tags are evaluated per file, not per package.\n- Common tags: `linux`, `darwin`, `windows`, `amd64`, `arm64`, `cgo`, and any custom tag.\n\n### References\n\n- [Go Build Constraints Documentation](https://pkg.go.dev/cmd/go#hdr-Build_constraints)\n```\n",
        "level": "Advanced"
    },
    {
        "id": "60b9765f-74be-408f-b2e2-9ca27b7ef6a4",
        "question": "What is the syntax for embedding files using the //go:embed directive?",
        "answer": "```go\n//go:embed <pattern>\nvar <variable> <type>\n```\n\n**Explanation:**\n\n- The `//go:embed` directive is placed immediately above a variable declaration.\n- `<pattern>` is a string or list of strings specifying the file(s) or directory to embed (supports glob patterns).\n- `<variable>` is the name of the variable that will hold the embedded data.\n- `<type>` must be one of: `string`, `[]byte`, or `embed.FS`.\n\n**Examples:**\n\nEmbed a single file as a string:\n```go\nimport _ \"embed\"\n\n//go:embed hello.txt\nvar hello string\n```\n\nEmbed a single file as bytes:\n```go\nimport _ \"embed\"\n\n//go:embed image.png\nvar imageData []byte\n```\n\nEmbed multiple files or directories using embed.FS:\n```go\nimport \"embed\"\n\n//go:embed templates/*.html static/\nvar content embed.FS\n```\n\n**Note:**  \n- The `embed` package must be imported (even as `_` if not directly used).\n- The directive must be directly above the variable declaration with no intervening lines.",
        "level": "Advanced"
    },
    {
        "id": "bdea179d-12aa-4933-967c-7bc81efb3102",
        "question": "How do you use the unsafe package in Go?",
        "answer": "```markdown\n### Using the `unsafe` Package in Go\n\nThe `unsafe` package in Go provides low-level memory manipulation capabilities that break some of Go's type safety guarantees. It is typically used for advanced operations such as interfacing with hardware, implementing memory-efficient data structures, or interoperating with C code.\n\n#### Importing the Package\n\n```go\nimport \"unsafe\"\n```\n\n#### Common Uses\n\n1. **Obtaining the Size of a Type**\n\n   ```go\n   var x int64\n   size := unsafe.Sizeof(x) // returns 8 on most systems\n   ```\n\n2. **Pointer Arithmetic**\n\n   ```go\n   arr := [4]int{1, 2, 3, 4}\n   ptr := &arr[0]\n   secondElemPtr := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + unsafe.Sizeof(arr[0])))\n   fmt.Println(*secondElemPtr) // Output: 2\n   ```\n\n3. **Converting Between Types**\n\n   ```go\n   var f float64 = 3.14\n   p := (*uint64)(unsafe.Pointer(&f))\n   fmt.Printf(\"%x\\n\", *p) // Prints the IEEE 754 representation of 3.14\n   ```\n\n#### Important Types and Functions\n\n- `unsafe.Pointer`: A special pointer type that can be converted to and from any pointer type.\n- `uintptr`: An integer type that can hold any pointer value.\n- `unsafe.Sizeof(x)`: Returns the size in bytes of the value `x`.\n- `unsafe.Alignof(x)`: Returns the alignment of the type of `x`.\n- `unsafe.Offsetof(x)`: Returns the offset of a struct field within its struct.\n\n#### Example: Accessing a Private Struct Field\n\n```go\ntype secret struct {\n    public  int\n    private int\n}\n\ns := secret{public: 1, private: 42}\nprivatePtr := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.private)))\nfmt.Println(*privatePtr) // Output: 42\n```\n\n#### **Cautions**\n\n- Code using `unsafe` is not portable and may break with future Go versions or on different architectures.\n- Misuse can lead to memory corruption, crashes, or security vulnerabilities.\n- Use `unsafe` only when absolutely necessary and after exhausting all safe alternatives.\n\n**References:**\n- [Official documentation](https://pkg.go.dev/unsafe)\n```\n",
        "level": "Advanced"
    }
]